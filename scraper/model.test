__label__Tree __label__Data-Structures You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function. Input Format You are given a function, Node * insert (Node * root ,int data) {  }  Constraints No. of nodes in the  tree  500 Output Format Return the root of the binary search tree after inserting the value into the tree. Sample Input         4        / \       2   7      / \     1   3  The value to be inserted is 6. Sample Output          4        /   \       2     7      / \   /     1   3 6
__label__Tree __label__Data-Structures Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit.  If they are on the left side of the tree, they will be a 0 (zero).  If on the right, they'll be a 1 (one).  Only the leaves will contain a letter and its frequency count.  All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters. For instance, consider the string ABRACADABRA.  There are a total of  characters in the string.  This number should match the count in the ultimately determined root of the tree.  Our frequencies are  and .  The two smallest frequencies are for  and , both equal to , so we'll create a tree with them.  The root node will contain the sum of the counts of its descendants, in this case .  The left node will be the first character encountered, , and the right will contain .  Next we have  items with a character count of :  the tree we just created, the character  and the character .  The tree came first, so it will go on the left of our new root node.   will go on the right.  Repeat until the tree is complete, then fill in the 's and 's for the edges.  The finished graph looks like:    Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL).  We can determine that our values for characters are:   A - 0 B - 111 C - 1100 D - 1101 R - 10  Our Huffman encoded string is: A B    R  A C     A D     A B    R  A 0 111 10 0 1100 0 1101 0 111 10 0 or 01111001100011010111100  To avoid ambiguity, Huffman encoding is a prefix free encoding technique.  No codeword appears as a prefix of any other codeword.   To decode the encoded string, follow the zeros and ones to a leaf and return the character there.   You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string. Function Description Complete the function decode_huff in the editor below.  It must return the decoded string. decode_huff has the following parameters:   root: a reference to the root node of the Huffman tree s: a Huffman encoded string Input Format There is one line of input containing the plain string, .  Background code creates the Huffman tree then passes the head node and the encoded string to the function. Constraints  Output Format Output the decoded string on a single line. Sample Input   s="1001011"  Sample Output ABACA  Explanation S="1001011" Processing the string from left to right. S[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[1]='0' : we move to the left child.  S[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string. We move back to the root.  S[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[4]='0' : we move to the left child.  S[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string. We move back to the root.   S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  Decoded String = "ABACA"
__label__Tree __label__Data-Structures You are given pointer to the root of the binary search tree and two values  and . You need to return the lowest common ancestor (LCA) of  and  in the binary search tree.     In the diagram above, the lowest common ancestor of the nodes  and  is the node .  Node  is the lowest node which has nodes  and  as descendants. Function Description  Complete the function lca in the editor below.  It should return a pointer to the lowest common ancestor node of the two values given.   lca has the following parameters:  -  root: a pointer to the root node of a binary search tree  -  v1: a node.data value  -  v2: a node.data value   Input Format The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers representing  values.  The third line contains two space-separated integers,  and .   To use the test data, you will have to create the binary search tree yourself.  Here on the platform, the tree will be created for you. Constraints       The tree will contain nodes with data equal to  and .   Output Format Return the a pointer to the node that is the lowest common ancestor of  and . Sample Input 6 4 2 3 1 7 6 1 7     and . Sample Output [reference to node 4] Explanation LCA of  and  is , the root in this case.  Return a pointer to the node.
__label__Tree __label__Data-Structures A binary tree is a tree which is characterized by one of the following properties: It can be empty (null). It contains a root node only. It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees. In-order traversal is performed as Traverse the left subtree. Visit root. Traverse the right subtree. For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true: it is the first node visited, the first time visited  it is a leaf, should only be visited once   all of its subtrees have been explored, should only be visited once while this is true   it is the root of the tree, the first time visited   Swapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L. L R R L For example, in the following tree, we swap children of node 1. 1                                 Depth     1               1            [1]    / \             / \   2   3     ->    3   2          [2]    \   \           \   \     4   5           5   4        [3]  In-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4. 2 4 1 3 5 3 5 1 2 4 Swap operation:  We define depth of a node as follows: The root node is at depth 1. If the depth of the parent node is d, then the depth of current node will be d+1. d d+1 Given a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h ∈ [k, 2k, 3k,...].  In other words, if h is a multiple of k, swap the left and right subtrees of that level. k h h ∈ [k, 2k, 3k,...] h k You are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree. n [1..n] 1 t Function Description Complete the swapNodes function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation. swapNodes has the following parameter(s):  - indexes: an array of integers representing index values of each , beginning with , the first element, as the root.  - queries: an array of integers, each representing a  value. Input Format  The first line contains n, number of nodes in the tree.    n Each of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.    n a b a b Note: -1 is used to represent a null node.    -1 The next line contains an integer, t, the size of .  Each of the next t lines contains an integer , each being a value .   t t Output Format  For each k, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.   k Constraints        Either  or   Either  or   The index of a non-null child will always be greater than that of its parent.   Sample Input 0  3 2 3 -1 -1 -1 -1 2 1 1  Sample Output 0  3 1 2 2 1 3  Explanation 0 As nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.     1   [s]       1    [s]       1       / \      ->   / \        ->  / \     2   3 [s]     3   2  [s]     2   3  Note: [s] indicates that a swap operation is done at this depth. [s] Sample Input 1  5 2 3 -1 4 -1 5 -1 -1 -1 -1 1 2  Sample Output 1  4 2 1 5 3  Explanation 1 Swapping child nodes of node 2 and 3 we get     1                  1      / \                / \    2   3   [s]  ->    2   3    \   \            /   /      4   5          4   5    Sample Input 2  11 2 3 4 -1 5 -1 6 -1 7 8 -1 9 -1 -1 10 11 -1 -1 -1 -1 -1 -1 2 2 4  Sample Output 2  2 9 6 4 1 3 7 5 11 8 10 2 6 9 4 1 3 7 5 10 8 11  Explanation 2  Here we perform swap operations at the nodes whose depth is either 2 or 4 for  and then at nodes whose depth is 4 for .          1                     1                          1                      / \                   / \                        / \                    /   \                 /   \                      /   \                  2     3    [s]        2     3                    2     3                /      /                \     \                    \     \              /      /                  \     \                    \     \            4      5          ->        4     5          ->        4     5          /      / \                  /     / \                  /     / \        /      /   \                /     /   \                /     /   \      6      7     8   [s]        6     7     8   [s]        6     7     8  \          / \            /           / \              \         / \      \        /   \          /           /   \              \       /   \      9      10   11        9           11   10              9     10   11
__label__Tree __label__Data-Structures Kitty has a tree, , consisting of  nodes where each node is uniquely labeled from  to . Her friend Alex gave her  sets, where each set contains  distinct nodes. Kitty needs to calculate the following expression on each set:   where:  denotes an unordered pair of nodes belonging to the set.  denotes the number of edges on the unique path between nodes  and . Given  and  sets of  distinct nodes, can you help her calculate the expression for each set? For each set of nodes, print the value of the expression modulo  on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes in tree ) and  (the number of sets).  Each of the  subsequent lines contains two space-separated integers,  and , describing an undirected edge between nodes  and .  The  subsequent lines define each set over two lines in the following format: The first line contains an integer, , denoting the size of the set.  The second line contains  space-separated integers describing the set's elements. Constraints        The sum of  over all  does not exceed .  All elements in each set are distinct.  Subtasks  for  of the maximum score.   for  of the maximum score.  for  of the maximum score. Output Format Print  lines of output where each line  contains the expression for the  query, modulo . Sample Input 0 Sample Output 0 Explanation 0 Tree  looks like this:  We perform the following calculations for  sets: Set : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:   Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line: Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:
__label__Tree __label__Data-Structures For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements: The  value of every node in a node's left subtree is less than the data value of that node. The  value of every node in a node's right subtree is greater than the data value of that node. Given the root node of a binary tree, can you determine if it's also a binary search tree?  Complete the function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge. Input Format You are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument. Constraints  Output Format You are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line. Sample Input  Sample Output No
__label__Tree __label__Data-Structures The square-ten tree decomposition of an array is defined as follows: The lowest () level of the square-ten tree consists of single array elements in their natural order. The  level (starting from ) of the square-ten tree consists of subsequent array subsegments of length  in their natural order. Thus, the  level contains subsegments of length , the  level contains subsegments of length , the  level contains subsegments of length , etc. In other words, every  level (for every ) of square-ten tree consists of array subsegments indexed as:    The image below depicts the bottom-left corner (i.e., the first  array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:  Task  Given the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence  such as  for every , , , where every  belongs to any of the square-ten tree levels and  is minimal amongst all such variants. Input Format The first line contains a single integer denoting .  The second line contains a single integer denoting . Constraints  The numbers in input do not contain leading zeroes. Output Format As soon as array indices are too large, you should find a sequence of  square-ten tree level numbers, , meaning that subsegment  belongs to the  level of the square-ten tree.  Print this sequence in the following compressed format:  On the first line, print the value of  (i.e., the compressed sequence block count).  For each of the  subsequent lines, print  space-separated integers,  and  (, ), meaning that the number  appears consequently  times in sequence . Blocks should be listed in the order they appear in the sequence. In other words,  should be equal to ,  should be equal to , etc. Thus  must be true and  must be true for every . All numbers should be printed without leading zeroes. Sample Input 0 Sample Output 0 Explanation 0 Segment  belongs to level  of the square-ten tree.
__label__Tree __label__Data-Structures Greg has a tree of nodes containing integer data.  He wants to insert a node with some non-zero integer value somewhere into the tree.  His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount.  This is called a balanced forest.  Being frugal, the data value he inserts should be minimal.  Determine the minimal amount that a new node can have to allow creation of a balanced forest.  If it's not possible to create a balanced forest, return -1. For example, you are given node values  and .  It is the following tree:     The blue node is root, the first number in a node is node number and the second is its value.  Cuts can be made between nodes  and  and nodes  and  to have three trees with sums ,  and .  Adding a new node  of  to the third tree completes the solution.   Function Description Complete the balancedForest function in the editor below.  It must return an integer representing the minimum value of  that can be added to allow creation of a balanced forest, or  if it is not possible.   balancedForest has the following parameter(s): c: an array of integers, the data values for each node   edges: an array of 2 element arrays, the node pairs per edge   Input Format The first line contains a single integer, , the number of queries.   Each of the following  sets of lines is as follows:   The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers describing the respective values of , where each  denotes the value at node . Each of the following  lines contains two space-separated integers,  and , describing edge  connecting nodes  and . Constraints       Each query forms a valid undirected tree.   Subtasks For  of the maximum score:   For  of the maximum score:   Output Format For each query, return the minimum value of the integer .  If no such value exists, return  instead.  Sample Input 2 5 1 2 2 1 1 1 2 1 3 3 5 1 4 3 1 3 5 1 3 1 2  Sample Output 2 -1  Explanation We perform the following two queries: The tree initially looks like this:         Greg can add a new node  with  and create a new edge connecting nodes  and . Then he cuts the edge connecting nodes  and  and the edge connecting nodes  and . We now have a three-tree balanced forest where each tree has a sum of .       In the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .
__label__Tree __label__Data-Structures Jenny loves experimenting with trees. Her favorite tree has  nodes connected by  edges, and each edge is  unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius  from this tree by performing the following two steps: Choose a node, , from the tree. Cut a subtree consisting of all nodes which are not further than  units from node .  For example, the blue nodes in the diagram below depict a subtree centered at  that has radius :  Given , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not  isomorphic. Input Format The first line contains two space-separated integers denoting the respective values of  and .  Each of the next  subsequent lines contains two space-separated integers,  and , describing a bidirectional edge in Jenny's tree having length . Constraints      Subtasks For  of the max score:     Output Format Print the total number of different possible subtrees. Sample Input 0 Sample Output 0 Explanation 0 In the diagram below, blue nodes denote the possible subtrees:  The last  subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 In the diagram below, blue nodes denote the possible subtrees:  Here, we have four possible different subtrees.
__label__Tree __label__Data-Structures We consider metric space to be a pair, , where  is a set and  such that the following conditions hold:     where  is the distance between points  and . Let's define the product of two metric spaces, , to be  such that:  , where , . So, it follows logically that  is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: . For example, , where  is a metric space. , where . In this challenge, we need a tree-space. You're given a tree, , where  is the set of vertices and  is the set of edges. Let the function  be the distance between two vertices in tree  (i.e.,  is the number of edges on the path between vertices  and ). Note that  is a metric space. You are given a tree, , with  vertices, as well as  points in . Find and print the distance between the two furthest points in this metric space! Input Format The first line contains two space-separated positive integers describing the respective values of  (the number of vertices in ) and  (the number of given points).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing edge  in .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for point . Constraints     Scoring This challenge uses binary scoring, so you must pass all test cases to earn a positive score. Output Format Print a single non-negative integer denoting the maximum distance between two of the given points in metric space . Sample Input 0 Sample Output 0 Explanation 0 The distance between points  and  is . Sample Input 1 Sample Output 1 Explanation 1 The best points are  and , which gives us a distance of .
__label__Tree __label__Data-Structures An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree.  In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. We define balance factor for each node as : balanceFactor = height(left subtree) - height(right subtree)  The balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.  (https://en.wikipedia.org/wiki/AVL_tree)         You are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.  Input Format  You are given a function, node *insert(node * root,int new_val) {   }  'node' is defined as : struct node { int val;            //value struct node* left;  //left child struct node* right; //right child int ht;             //height of the node } node;  You only need to complete the function.      Note: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.  Output Format  Insert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced. Sample Input      3   /  \  2    4        \         5  The value to be inserted is 6. Sample Output     3   /  \  2    5      / \     4   6  Explanation After inserting 6 in the tree. the tree becomes:     3 (Balance Factor = -2)   /  \  2    4 (Balance Factor = -2)        \         5 (Balance Factor = -1)          \           6 (Balance Factor = 0)  Balance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree. After performing the rotation, the tree becomes :                                3 (Balance Factor = -1)                             /   \       (Balance Factor = 0) 2     5 (Balance Factor = 0)                                 / \            (Balance Factor = 0)4   6 (Balance Factor = 0)
__label__Data-Structures Given two numbers  and .  indicates the number of elements in the array  and  indicates number of queries. You need to perform two types of queries on the array .   You are given  queries. Queries can be of two types, type 1 and type 2.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   1 i j Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   2 i j Your task is to simply print  of the resulting array after the execution of  queries followed by the resulting array.   Note While adding at back or front the order of elements is preserved.   Input Format First line consists of two space-separated integers,  and .  Second line contains  integers, which represent the elements of the array.   queries follow. Each line contains a query of either type 1 or type 2 in the form   Constraints       Output Format Print the absolute value i.e.  in the first line.  Print elements of the resulting array in the second line. Each element should be seperated by a single space. Sample Input 8 4 1 2 3 4 5 6 7 8 1 2 4 2 3 5 1 4 7 2 1 4  Sample Output 1 2 3 6 5 7 8 4 1  Explanation Given array is .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  Now  is  i.e.  and the array is
__label__Search __label__Tree __label__Data-Structures The median of  numbers is defined as the middle number after sorting them in order if  is odd. Or it is the average of the middle two numbers if  is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median. Example:  For a set of  numbers  the median is the third number in the sorted set , which is . Similarly, for a set of  numbers, , the median is the average of the second and the third element in the sorted set , which is .   Input:  The first line is an integer, , that indicates the number of operations. Each of the next  lines is either a x or r x. a x indicates that  is added to the set, and r x indicates that  is removed from the set. Output:  For each operation: If the operation is add, output the median after adding  in a single line. If the operation is remove and the number  is not in the list, output Wrong! in a single line. If the operation is remove and the number  is in the list, output the median after deleting  in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.) Note  If your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong! Constraints:    For each a x or r x,  will always be a signed integer (which will fit in 32 bits). Sample Input:  7   r 1   a 1   a 2   a 1   r 1   r 2   r 1    Sample Output:  Wrong!   1   1.5   1   1.5   1   Wrong!  Note: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!.
__label__Data-Structures People connect with each other in a social network. A connection between Person  and Person  is represented as . When two persons belonging to different communities connect, the net effect is the merger of both communities which  and  belongs to.  At the beginning, there are  people representing  communities. Suppose person  and  connected and later  and  connected, then ,, and  will belong to the same community. There are two type of queries:  communities containing person  and  merged (if they belong to different communities).  communities containing person  and  merged (if they belong to different communities).  print the size of the community to which person  belongs.   print the size of the community to which person  belongs.  Input Format The first line of input will contain integers  and , i.e. the number of people and the number of queries. The next  lines will contain the queries. Constraints :   Output Format The output of the queries. Sample Input 3 6 Q 1 M 1 2 Q 2 M 2 3 Q 3 Q 2  Sample Output 1 2 3 3  Explanation Initial size of each of the community is .
__label__Data-Structures This question is designed to help you get a better understanding of basic heap operations.  You will be given queries of  types: " "  - Add an element  to the heap.   " "  - Delete the element  from the heap.   "" - Print the minimum of all the elements in the heap. NOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap. Input Format The first line contains the number of queries, .  Each of the next  lines contains a single query of any one of the  above mentioned types.    Constraints     Output Format For each query of type , print the minimum value on a single line.   Sample Input 5   1 4   1 9   3   2 4   3    Sample Output 4   9   Explanation After the first  queries, the heap contains {}. Printing the minimum gives  as the output. Then, the  query deletes  from the heap, and the  query gives  as the output.
__label__Data-Structures You have an empty sequence, and you will be given  queries. Each query is one of these three types: 1 x  -Push the element x into the stack. 2    -Delete the element present at the top of the stack. 3    -Print the maximum element in the stack.  Input Format The first line of input contains an integer, . The next  lines each contain an above mentioned query. (It is guaranteed that each query is valid.) Constraints       Output Format For each type  query, print the maximum element in the stack on a new line. Sample Input 10 1 97 2 1 20 2 1 26 1 20 2 3 1 91 3  Sample Output 26 91
__label__Data-Structures A queue is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed. A basic queue has the following operations: Enqueue: add a new element to the end of the queue. Dequeue: remove the element from the front of the queue and return it. In this challenge, you must first implement a queue using two stacks. Then process  queries, where each query is one of the following  types:  1 x: Enqueue element  into the end of the queue. 1 x 2: Dequeue the element at the front of the queue. 2 3: Print the element at the front of the queue. 3 Input Format The first line contains a single integer, , denoting the number of queries.  Each line  of the  subsequent lines contains a single query in the form described in the problem statement above. All three queries start with an integer denoting the query , but only query  is followed by an additional space-separated value, , denoting the value to be enqueued. Constraints       It is guaranteed that a valid answer always exists for each query of type . Output Format For each query of type , print the value of the element at the front of the queue on a new line.  Sample Input 10 1 42 2 1 14 3 1 28 3 1 60 1 78 2 2  Sample Output 14 14  Explanation We perform the following sequence of actions: Enqueue ; . Dequeue the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Enqueue ; . Dequeue the value at the head of the queue, ; . Dequeue the value at the head of the queue, ; .
__label__Data-Structures There are  values to represent nodes in a graph. They are divided into two sets  and . Each set has exactly  values. Set  is represent by .  can contain any value between  to (inclusive). Set  is represented by .  can contain any value between  to (inclusive). Same value can be chosen any number of times.   Here  represents the edges of the graph.   Your task is to print the number of vertices in the smallest and the largest connected components of the graph.   Note Single nodes should not be considered in the answer.  For more clarity look at the following figure.    For the above graph smallest connected component is 7 and largest connected component is 17.   Input Format First line contains an integer .  Each of the next  lines contain two space-separated integers,  line contains  and .   Constraints       Output Format Print two space separated integers, the number of vertices in the smallest and the largest components. Sample Input 5 1 6  2 7 3 8 4 9 2 6  Sample Output 2 4  Explanation The number of vertices in the smallest connected component in the graph is  i.e. either  or .  The number of vertices in the largest connected component in the graph is  i.e. .
__label__Data-Structures A bracket is considered to be any one of the following characters: (, ), {, }, [, or ].  ( ) { } [ ] Two brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and (). ( [ { ) ] } [] {} () A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ]. {[(])} { } ( ] By this logic, we say a sequence of brackets is balanced if the following conditions are met: It contains no unmatched brackets. The subset of brackets enclosed within the confines of a matched pair of brackets  is also a matched pair of brackets. Given  strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return YES.  Otherwise, return NO.   YES NO Function Description  Complete the function isBalanced in the editor below.  It must return a string: YES if the sequence is balanced or NO if it is not.   YES NO isBalanced has the following parameter(s): s: a string of brackets Input Format The first line contains a single integer , the number of strings.  Each of the next  lines contains a single string , a sequence of brackets. Constraints   , where  is the length of the sequence.   All chracters in the sequences ∈ { {, }, (, ), [, ] }. Output Format For each string, return YES or NO. YES NO Sample Input 3 {[()]} {[(])} {{[[(())]]}}  Sample Output YES NO YES  Explanation The string {[()]} meets both criteria for being a balanced string, so we print YES on a new line.     {[()]} YES The string {[(])} is not balanced because the brackets enclosed by the matched pair { and } are not balanced: [(]).       {[(])} { } [(]) The string {{[[(())]]}} meets both criteria for being a balanced string, so we print YES on a new line.   {{[[(())]]}} YES
__label__Data-Structures You are given a square grid with some cells open (.) and some blocked (X).  Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell.  Given a grid, a start and an end position, determine the number of moves it will take to get to the end position.   For example, you are given a grid with sides  described as follows: ... .X. ...  Your starting position  so you start in the top left corner.  The ending position is .  The path is .  It takes  moves to get to the goal. Function Description  Complete the minimumMoves function in the editor.  It must print an integer denoting the minimum moves required to get from the starting position to the goal. minimumMoves has the following parameter(s): grid: an array of strings representing the rows of the grid   startX: an integer   startY: an integer   goalX: an integer   goalY: an integer   Input Format The first line contains an integer , the size of the array grid.  Each of the next  lines contains a string of length .  The last line contains four space-separated integers,   Constraints   Output Format Print an integer denoting the minimum number of steps required to move the castle to the goal position. Sample Input 3 .X. .X. ... 0 0 0 2  Sample Output 3  Explanation Here is a path that one could follow in order to reach the destination in  steps: .
__label__Data-Structures Jesse loves cookies. He wants the sweetness of all his cookies to be greater than value . To do this, Jesse repeatedly mixes two cookies with the least sweetness. He creates a special combined cookie with: sweetness  Least sweet cookie   2nd least sweet cookie). He repeats this procedure until all the cookies in his collection have a sweetness  .  You are given Jesse's cookies. Print the number of operations required to give the cookies a sweetness  . Print   if this isn't possible.  Input Format The first line consists of integers , the number of cookies and , the minimum required sweetness, separated by a space.  The next line contains  integers describing the array  where  is the sweetness of the  cookie in Jesse's collection. Constraints       Output Format Output the number of operations that are needed to increase the cookie's sweetness .  Output  if this isn't possible.  Sample Input 6 7 1 2 3 9 10 12  Sample Output 2  Explanation Combine the first two cookies to create a cookie with sweetness  =   After this operation, the cookies are .  Then, combine the cookies with sweetness  and sweetness , to create a cookie with resulting sweetness  =   Now, the cookies are .  All the cookies have a sweetness .   Thus,  operations are required to increase the sweetness.
__label__Data-Structures Kundu is true tree lover. Tree is a connected graph having N vertices and N-1  edges. Today when he got a tree, he colored each edge with one of either red(r) or black(b) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex a to b, vertex b to c and vertex c to a . Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet.  r b If the answer is greater than 109 + 7, print the answer modulo (%) 109 + 7. Input Format  The first line contains an integer N, i.e., the number of vertices in tree.  The next N-1 lines represent edges:  2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(r) or black(b).   r b Output Format  Print a single number i.e. the number of triplets.   Constraints  1 ≤ N ≤ 105  A node is numbered between 1 to N.   Sample Input  5 1 2 b 2 3 r 3 4 r 4 5 b  Sample Output  4  Explanation Given tree is something like this.  (2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color. (2,3,5), (1,3,4) and (1,3,5) are other such triplets.  Note that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.
__label__Data-Structures The median of a set of integers is the midpoint value of the data set for which an equal number of integers are less than and greater than the value. To find the median, you must first sort your set of integers in non-decreasing order, then: If your set contains an odd number of elements, the median is the middle element of the sorted sample. In the sorted set ,  is the median. If your set contains an even number of elements, the median is the average of the two middle elements of the sorted sample. In the sorted set ,  is the median. Given an input stream of  integers, you must perform the following task for each  integer: Add the  integer to a running list of integers. Find the median of the updated list (i.e., for the first element through the  element). Print the list's updated median on a new line. The printed value must be a double-precision number scaled to  decimal place (i.e.,  format). Input Format The first line contains a single integer, , denoting the number of integers in the data stream.  Each line  of the  subsequent lines contains an integer, , to be added to your list. Constraints    Output Format After each new integer is added to the list, print the list's updated median on a new line as a single double-precision number scaled to  decimal place (i.e.,  format). Sample Input 6 12 4 5 3 8 7  Sample Output 12.0 8.0 5.0 4.5 5.0 6.0  Explanation There are  integers, so we must print the new median on a new line as each integer is added to the list:
__label__Data-Structures You are given  queries. Each query consists of a single number . You can perform any of the  operations on  in each move: 1: If we take 2 integers  and  where , , then we can change  2: Decrease the value of  by .  Determine the minimum number of moves required to reduce the value of  to . Input Format The first line contains the integer .  The next  lines each contain an integer, .   Constraints     Output Format Output  lines. Each line containing the minimum number of moves required to reduce the value of  to . Sample Input 2 3 4  Sample Output 3 3  Explanation For test case 1, We only have one option that gives the minimum number of moves.  Follow  ->  ->  -> . Hence,  moves. For the case 2, we can either go  ->  ->  ->  ->  or  ->  ->  -> . The 2nd option is more optimal. Hence,  moves.
__label__Data-Structures __label__Greedy-Algorithms You have three stacks of cylinders where each cylinder has the same diameter, but they may vary in height. You can change the height of a stack by removing and discarding its topmost cylinder any number of times.  Find the maximum possible height of the stacks such that all of the stacks are exactly the same height. This means you must remove zero or more cylinders from the top of zero or more of the three stacks until they're all the same height, then print the height. The removals must be performed in such a way as to maximize the height.  Note: An empty stack is still a stack. Input Format The first line contains three space-separated integers, , , and , describing the respective number of cylinders in stacks , , and . The subsequent lines describe the respective heights of each cylinder in a stack from top to bottom:       The second line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   The third line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.    The fourth line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   Constraints   Output Format Print a single integer denoting the maximum height at which all stacks will be of equal height. Sample Input 5 3 4 3 2 1 1 1 4 3 2 1 1 4 1  Sample Output 5  Explanation Initially, the stacks look like this:  Observe that the three stacks are not all the same height. To make all stacks of equal height, we remove the first cylinder from stacks  and , and then remove the top two cylinders from stack  (shown below).  As a result, the stacks undergo the following change in height:    All three stacks now have . Thus, we print  as our answer.
__label__Data-Structures Tieu owns a pizza restaurant and he manages it in his own way.  While in a normal restaurant, a customer is served by following the first-come, first-served rule, Tieu simply minimizes the average waiting time of his customers. So he gets to decide who is served first, regardless of how sooner or later a person comes.  Different kinds of pizzas take different amounts of time to cook. Also, once he starts cooking a pizza, he cannot cook another pizza until the first pizza is completely cooked. Let's say we have three customers who come at time t=0, t=1, & t=2 respectively, and the time needed to cook their pizzas is 3, 9, & 6 respectively. If Tieu applies first-come, first-served rule, then the waiting time of three customers is 3, 11, & 16  respectively. The average waiting time in this case is (3 + 11 + 16) / 3 = 10. This is not an optimized solution. After serving the first customer at time t=3, Tieu can choose to serve the third customer. In that case, the waiting time will be 3, 7, & 17 respectively. Hence the average waiting time is (3 + 7 + 17) / 3 = 9. Help Tieu achieve the minimum average waiting time. For the sake of simplicity, just find the integer part of the minimum average waiting time. Input Format The first line contains an integer N, which is the number of customers.  In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   The  customer is not the customer arriving at the  arrival time.  The  customer is not the customer arriving at the  arrival time.  Output Format Display the integer part of the minimum average waiting time. Constraints 1 ≤ N ≤ 105 0 ≤ Ti ≤ 109 1 ≤ Li ≤ 109 Note The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. Cook does not know about the future orders. Cook does not know about the future orders. Sample Input #00 3 0 3 1 9 2 6  Sample Output #00 9  Sample Input #01 3 0 3 1 9 2 5  Sample Output #01 8  Explanation #01 Let's call the person ordering at time = 0 as A, time = 1 as B and time = 2 as C. By delivering pizza for A, C and B we get the minimum average wait time to be  (3 + 6 + 16)/3 = 25/3 = 8.33   the integer part is 8 and hence the answer.  8
__label__Data-Structures Suppose there is a circle. There are  petrol pumps on that circle. Petrol pumps are numbered  to  (both inclusive). You have two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give, and (2) the distance from that petrol pump to the next petrol pump.  Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps. The truck will move one kilometer for each litre of the petrol. Input Format The first line will contain the value of . The next  lines will contain a pair of integers each, i.e. the amount of petrol that petrol pump will give and the distance between that petrol pump and the next petrol pump. Constraints:   Output Format An integer which will be the smallest index of the petrol pump from which we can start the tour. Sample Input 3 1 5 10 3 3 4  Sample Output 1  Explanation We can start the tour from the second petrol pump.
__label__Data-Structures Alexa has two stacks of non-negative integers, stack  and stack  where index  denotes the top of the stack. Alexa challenges Nick to play the following game: In each move, Nick can remove one integer from the top of either stack  or stack . Nick keeps a running sum of the integers he removes from the two stacks. Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer  given at the beginning of the game. Nick's final score is the total number of integers he has removed from the two stacks. Given , , and  for  games, find the maximum possible score Nick can achieve (i.e., the maximum number of integers he can remove without being disqualified) during each game and print it on a new line. Input Format The first line contains an integer,  (the number of games). The  subsequent lines describe each game in the following format: The first line contains three space-separated integers describing the respective values of  (the number of integers in stack ),  (the number of integers in stack ), and  (the number that the sum of the integers removed from the two stacks cannot exceed). The second line contains  space-separated integers describing the respective values of . The third line contains  space-separated integers describing the respective values of . Constraints     Subtasks  for  of the maximum score. Output Format For each of the  games, print an integer on a new line denoting the maximum possible score Nick can achieve without being disqualified. Sample Input 0 Sample Output 0 Explanation 0 The two stacks initially look like this:  The image below depicts the integers Nick should choose to remove from the stacks. We print  as our answer, because that is the maximum number of integers that can be removed from the two stacks without the sum exceeding .  (There can be multiple ways to remove the integers from the stack, the image shows just one of them.)
__label__Data-Structures Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed. There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by . If you join  adjacent buildings, they will form a solid rectangle of area .   For example, the heights array .  A rectangle of height  and length  can be constructed within the boundaries.  The area formed is .   Function Description Complete the function largestRectangle int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.   largestRectangle largestRectangle has the following parameter(s): h: an array of integers representing building heights Input Format The first line contains , the number of buildings.  The second line contains  space-separated integers, each representing the height of a building.    Constraints    Output Format Print a long integer representing the maximum area of rectangle formed. Sample Input 5 1 2 3 4 5  Sample Output 9  Explanation An illustration of the test case follows.
__label__Data-Structures Consider an -integer sequence, . We perform a query on  by using an integer, , to calculate the result of the following expression:   In other words, if we let , then you need to calculate .   Given  and  queries (each query consists of an integer, ), print the result of each query on a new line. Input Format The first line consists of two space-separated integers describing the respective values of  and .  The second line consists of  space-separated integers describing the respective values of .  Each of the  subsequent lines contains a single integer denoting the value of  for that query.  Constraints     Output Format For each query, print an integer denoting the query's answer on a new line. After completing all the queries, you should have printed  lines. Sample Input 0 Sample Output 0 Explanation 0 For , the answer is   Sample Input 1 Sample Output 1 Explanation 1 For each query, the "prefix" has the least maximum value among the consecutive subsequences of the same size.
__label__Data-Structures Victoria has a tree, , consisting of  nodes numbered from  to . Each edge from node  to  in tree  has an integer weight, . Let's define the cost, , of a path from some node  to some other node  as the maximum weight () for any edge in the unique path from node  to node . Victoria wants your help processing  queries on tree , where each query contains  integers,  and , such that . For each query, she wants to print the number of different paths in  that have a cost, , in the inclusive range . It should be noted that path from some node  to some other node  is considered same as path from node  to  i.e  is same as .  Input Format The first line contains  space-separated integers,  (the number of nodes) and  (the number of queries), respectively.  Each of the  subsequent lines contain  space-separated integers, , , and , respectively, describing a bidirectional road between nodes  and  which has weight .  The  subsequent lines each contain  space-separated integers denoting  and . Constraints         Scoring  for  of the test data.    for  of the test data. Output Format For each of the  queries, print the number of paths in  having cost  in the inclusive range  on a new line. Sample Input 5 5 1 2 3 1 4 2 2 5 6 3 4 1 1 1 1 2 2 3 2 5 1 6  Sample Output 1 3 5 5 10  Explanation :   :   :   :   ...etc.
__label__Data-Structures In this challenge, you must implement a simple text editor. Initially, your editor contains an empty string, . You must perform  operations of the following  types: append  - Append string  to the end of . delete   - Delete the last  characters of . print     - Print the  character of . undo     - Undo the last (not previously undone) operation of type  or , reverting  to the state it was in prior to that operation.  Input Format The first line contains an integer, , denoting the number of operations.  Each line  of the  subsequent lines (where ) defines an operation to be performed. Each operation starts with a single integer,  (where ), denoting a type of operation as defined in the Problem Statement above. If the operation requires an argument,  is followed by its space-separated argument. For example, if  and , line  will be 1 abcd.  1 abcd Constraints     The sum of the lengths of all  in the input .   The sum of  over all delete operations .   All input characters are lowercase English letters.   It is guaranteed that the sequence of operations given as input is possible to perform. Output Format Each operation of type  must print the  character on a new line. Sample Input 8 1 abc 3 3 2 3 1 xy 3 2 4  4  3 1  Sample Output c y a  Explanation Initially,  is empty. The following sequence of  operations are described below: . We append  to , so .  Print the  character on a new line. Currently, the  character is c. c Delete the last  characters in  (), so .  Append  to , so .  Print the  character on a new line. Currently, the  character is y. y Undo the last update to , making  empty again (i.e., ). Undo the next to last update to  (the deletion of the last  characters), making . Print the  character on a new line. Currently, the  character is a. a
__label__Data-Structures There are a number of plants in a garden. Each of these plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.   You are given the initial values of the pesticide in each of the plants. Print the number of days after which no plant dies, i.e. the time after which there are no plants with more pesticide content than the plant to their left.   For example, pesticide levels .  Using a -indexed array, day  plants  and  die leaving .  On day , plant  of the current array dies leaving .  As there is no plant with a higher concentration of pesticide than the one to its left, plants stop dying after day .   Function Description  Complete the function poisonousPlants in the editor below.  It must return an integer representing the number of days until plants no longer die from pesticide. poisonousPlants has the following parameter(s): p: an array of integers representing pesticide levels in each plant Input Format The first line contains an integer , the size of the array .  The next line contains  space-separated integers .   Constraints    Output Format Output an integer equal to the number of days after which no plants die. Sample Input 7 6 5 8 4 7 10 9  Sample Output 2  Explanation Initially all plants are alive.   Plants = {(6,1), (5,2), (8,3), (4,4), (7,5), (10,6), (9,7)}    Plants[k] = (i,j) => jth plant has pesticide amount = i.   After the 1st day, 4 plants remain as plants 3, 5, and 6 die.   Plants = {(6,1), (5,2), (4,4), (9,7)}   After the 2nd day, 3 plants survive as plant 7 dies. Plants = {(6,1), (5,2), (4,4)}   After the 2nd day the plants stop dying.
__label__Data-Structures Given an array  of  distinct elements. Let  and  be the smallest and the next smallest element in the interval  where .   .   where , are the bitwise operators ,  and  respectively.  Your task is to find the maximum possible value of . Input Format First line contains integer .  Second line contains  integers, representing elements of the array .   Constraints      Output Format Print the value of maximum possible value of .    Sample Input 5 9 6 3 5 2  Sample Output 15  Explanation Consider the interval  the result will be maximum.
__label__Data-Structures You are a waiter at a party. There are  stacked plates on pile . Each plate has a number written on it. Then there will be  iterations. In -th iteration, you start picking up the plates in  from the top one by one and check whether the number written on the plate is divisible by the -th prime. If the number is divisible, you stack that plate on pile . Otherwise, you stack that plate on pile . After  iterations, plates can only be on pile , . Output numbers on these plates from top to bottom of each piles in order of , . Input Format The first line contains two space separated integers,  and .  The next line contains  space separated integers representing the initial pile of plates, i.e., . The leftmost value represents the bottom plate of the pile. Constraints        Output Format Output  lines. Each line contains a number written on the plate. Printing should be done in the order defined above. Sample Input 0 Sample Output 0 Explanation 0 Initially:  = [3, 4, 7, 6, 5]<-TOP After 1 iteration:  = []<-TOP  = [6, 4]<-TOP  = [5, 7, 3]<-TOP We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom. Sample Input 1 Sample Output 1 Explanation 1 Initially:  = [3, 3, 4, 4, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<-TOP  = [3, 3, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<- TOP  = [3, 3, 9]<-TOP  We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom.
__label__Data-Structures We're going to make our own Contacts application! The application must perform two types of operations: add name, where  is a string denoting a contact name. This must store  as a new contact in the application.   add name find partial, where  is a string denoting a partial name to search the application for. It must count the number of contacts starting with  and print the count on a new line. find partial Given  sequential add and find operations, perform each operation in order. Input Format The first line contains a single integer, , denoting the number of operations to perform.  Each line  of the  subsequent lines contains an operation in one of the two forms defined above.   Constraints       It is guaranteed that  and  contain lowercase English letters only. The input doesn't have any duplicate  for the  operation. Output Format For each find partial operation, print the number of contact names starting with  on a new line. find partial Sample Input 4 add hack add hackerrank find hac find hak  Sample Output 2 0  Explanation We perform the following sequence of operations: Add a contact named hack. hack Add a contact named hackerrank. hackerrank Find and print the number of contact names beginning with hac. There are currently two contact names in the application and both of them start with hac, so we print  on a new line. hac hac Find and print the number of contact names beginning with hak. There are currently two contact names in the application but neither of them start with hak, so we print  on a new line. hak hak
__label__Data-Structures __label__Data-Structures Given  strings. Each string contains only lowercase letters from (both inclusive). The set of  strings is said to be GOOD SET if no string is prefix of another string else, it is BAD SET. (If two strings are identical, they are considered prefixes of each other.) For example, aab, abcde, aabcd is BAD SET because aab is prefix of aabcd.   Print GOOD SET if it satisfies the problem requirement.  Else, print BAD SET and the first string for which the condition fails.   Input Format  First line contains , the number of strings in the set.  Then next  lines follow, where  line contains  string.   Constraints     Length of the string   Output Format  Output GOOD SET if the set is valid.  Else, output BAD SET followed by the first string for which the condition fails.   GOOD SET BAD SET Sample Input00  7 aab defgab abcde aabcde cedaaa bbbbbbbbbb jabjjjad  Sample Output00  BAD SET aabcde  Sample Input01 4 aab aac aacghgh aabghgh  Sample Output01  BAD SET aacghgh  Explanation  aab is prefix of aabcde. So set is BAD SET and it fails at string aabcde.
__label__Data-Structures Meera teaches a class of  students, and every day in her classroom is an adventure. Today is drawing day! The students are sitting around a round table, and they are numbered from  to  in the clockwise direction. This means that the students are numbered , and students  and  are sitting next to each other. After letting the students draw for a certain period of time, Meera starts collecting their work to ensure she has time to review all the drawings before the end of the day. However, some of her students aren't finished drawing! Each student  needs  extra minutes to complete their drawing.  Meera collects the drawings sequentially in the clockwise direction, starting with student ID , and it takes her exactly  minute to review each drawing. This means that student  gets  extra minutes to complete their drawing, student  gets  extra minute, student  gets  extra minutes, and so on. Note that Meera will still spend  minute for each student even if the drawing isn't ready.  Given the values of , help Meera choose the best possible  to start collecting drawings from, such that the number of students able to complete their drawings is maximal. Then print  on a new line. If there are multiple such IDs, select the smallest one. Input Format The first line contains a single positive integer, , denoting the number of students in the class.  The second line contains  space-separated integers describing the respective amounts of time that each student needs to finish their drawings (i.e., ). Constraints   Subtasks  for  of the maximum score. Output Format Print an integer denoting the ID number, , where Meera should start collecting the drawings such that a maximal number of students can complete their drawings. If there are multiple such IDs, select the smallest one.
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a 3-D Matrix in which each block contains 0 initially. The first block is defined by the coordinate (1,1,1) and the last block is defined by the coordinate (N,N,N). There are two types of queries. UPDATE x y z W  updates the value of block (x,y,z) to W. QUERY x1 y1 z1 x2 y2 z2  calculates the sum of the value of blocks whose x coordinate is between x1 and x2 (inclusive), y coordinate between y1 and y2 (inclusive) and z coordinate between z1 and z2 (inclusive).  Input Format  The first line contains an integer T, the number of test-cases. T testcases follow.  For each test case, the first line will contain two integers N and M separated by a single space.  N defines the N * N * N matrix.  M defines the number of operations.  The next M lines will contain either    1. UPDATE x y z W  2. QUERY  x1 y1 z1 x2 y2 z2   Output Format  Print the result for each QUERY. Constrains  1 <= T <= 50  1 <= N <= 100  1 <= M <= 1000  1 <= x1 <= x2 <= N  1 <= y1 <= y2 <= N  1 <= z1 <= z2 <= N  1 <= x,y,z <= N  -109 <= W <= 109  Sample Input 2 4 5 UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3 2 4 UPDATE 2 2 2 1 QUERY 1 1 1 1 1 1 QUERY 1 1 1 2 2 2 QUERY 2 2 2 2 2 2  Sample Output 4 4 27 0 1 1  Explanation  First test case, we are given a cube of 4 * 4 * 4 and 5 queries.  Initially all the cells (1,1,1) to (4,4,4) are 0.  UPDATE 2 2 2 4 makes the cell (2,2,2) = 4  QUERY 1 1 1 3 3 3. As (2,2,2) is updated to 4 and the rest are all 0. The answer to this query is 4.  UPDATE 1 1 1 23. updates the cell (1,1,1) to 23.  QUERY 2 2 2 4 4 4. Only the cell (1,1,1) and (2,2,2) are non-zero and (1,1,1) is not between (2,2,2) and (4,4,4). So, the answer is 4.  QUERY 1 1 1 3 3 3. 2 cells are non-zero and their sum is 23+4 = 27.  UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3
__label__Data-Structures __label__Advanced-Data-Structures A cricket match is going to be held. The field is represented by a 1D plane. A cricketer, Mr. X has  favorite shots. Each shot has a particular range. The range of the   shot is from i to i. That means his favorite shot can be anywhere in this range. Each player on the opposite team  can field only in a particular range. Player  can field from i to i. You are given the  favorite shots of Mr. X and the range of  players.  represents the strength of each player i.e. the number of shots player  can stop.  Your task is to find: . Game Rules: A player can stop the  shot if the range overlaps with the player's fielding range. For more clarity about overlapping, study the following figure:    Input Format The first line consists of two space separated integers,  and . Each of the next  lines contains two space separated integers. The  line contains  and . Each of the next  lines contains two integers. The  line contains integers  and . Output Format You need to print the sum of the strengths of all the players: . Constraints:    Sample Input 4 4                 1 2  2 3 4 5 6 7 1 5 2 3 4 7 5 7     Sample Output 9  Explanation Player 1 can stop the 1st, 2nd and 3rd shot so the strength is . Player 2 can stop the 1st and 2nd shot so the strength is . Player 3 can stop the 3rd and 4th shot so the strength is . Player 4 can stop the 3rd and 4th shot so the strength is . The sum of the strengths of all the players is .
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Enter-View  is a linear, street-like country. By linear, we mean all the cities of the country are placed on a single straight line - the -axis. Thus every city's position can be defined by a single coordinate, , the distance from the left borderline of the country. You can treat all cities as single points. Unfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if  people are living in city , there must be at least  cables from city  to every other city of EV - this way he can guarantee no congestion will ever occur! Mr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population.  Note that The connections between the cities can be shared. Look at the example for the detailed explanation. Input Format  A number  is given in the first line and then comes  blocks, each representing a scenario. Each scenario consists of three lines. The first line indicates the number of cities (N). The second line indicates the coordinates of the N cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input. Output Format  For each scenario of the input, write the length of cable needed in a single line modulo . Constraints        Border to border length of the country  Sample Input  2   3   1 3 6   10 20 30   5   5 55 555 55555 555555   3333 333 333 33 35  Sample Output  280   463055586  Explanation For the first test case, having  cities requires  sets of cable connections. Between city  and , which has a population of  and , respectively, Mr. Treat believes at least  cables should come out of city 1 for this connection, and at least 20 cables should come out of city  for this connection. Thus, the connection between city  and city  will require  cables, each crossing a distance of  km. Applying this absurd logic to connection 2,3 and 1,3, we have  =>  connections   km of cable  =>  connections   km of cable  =>  connections   km of cable For a total of  , Output is  km of cable
__label__Mathematics __label__Tree __label__Data-Structures __label__Advanced-Data-Structures A subsequence of a sequence is a sequence which is obtained by deleting zero or more elements from the sequence.  You are given a sequence A in which every element is a pair of integers  i.e  A = [(a1, w1), (a2, w2),..., (aN, wN)]. A A For a subseqence B = [(b1, v1), (b2, v2), ...., (bM, vM)] of the given sequence :  B We call it increasing if for every i (1 <= i < M ) , bi < bi+1. Weight(B) = v1 + v2 + ... + vM.   Task:  Given a sequence, output the maximum weight formed by an increasing subsequence. Input:  The first line of input contains a single integer T. T test-cases follow. The first line of each test-case contains an integer N. The next line contains a1, a2 ,... , aN separated by a single space. The next line contains w1, w2, ..., wN separated by a single space. Output:  For each test-case output a single integer: The maximum weight of increasing subsequences of the given sequence.   Constraints:  1 <= T <= 5  1 <= N <= 150000  1 <= ai <= 109, where i ∈ [1..N]  1 <= wi <= 109, where i ∈ [1..N]  Sample Input: 2   4   1 2 3 4   10 20 30 40   8   1 2 3 4 1 2 3 4   10 20 30 40 15 15 15 50  Sample Output: 100   110  Explanation:  In the first sequence, the maximum size increasing subsequence is 4, and there's only one of them. We choose B = [(1, 10), (2, 20), (3, 30), (4, 40)], and we have Weight(B) = 100. B = [(1, 10), (2, 20), (3, 30), (4, 40)] Weight(B) = 100 In the second sequence, the maximum size increasing subsequence is still 4, but there are now 5 possible subsequences: 1 2 3 4   10 20 30 40  1 2 3 4   10 20 30 50  1 2 3 4   10 20 15 50  1 2 3 4   10 15 15 50  1 2 3 4   15 15 15 50  Of those, the one with the greatest weight is B = [(1, 10), (2, 20), (3, 30), (4, 50)], with Weight(B) = 110. B = [(1, 10), (2, 20), (3, 30), (4, 50)] Weight(B) = 110 Please note that this is not the maximum weight generated from picking the highest value element of each index. That value, 115, comes from [(1, 15), (2, 20), (3, 30), (4, 50)], which is not a valid subsequence because it cannot be created by only deleting elements in the original sequence.
__label__Data-Structures __label__Advanced-Data-Structures Jim has invented a new flying object called HZ42. HZ42 is like a broom and can only fly horizontally, independent of the environment. One day, Jim started his flight from Dubai's highest skyscraper, traveled some distance and landed on another skyscraper of same height! So much fun! But unfortunately, new skyscrapers have been built recently. Let us describe the problem in one dimensional space. We have in total  skyscrapers aligned from left to right. The th skyscraper has a height of . A flying route can be described as  with , which means, Jim starts his HZ42 at the top of the skyscraper  and lands on the skyscraper . Since HZ42 can only fly horizontally, Jim will remain at the height  only. Thus the path  can be valid, only if each of the skyscrapers  is not strictly greater than  and if the height of the skyscraper he starts from and arrives on have the same height. Formally,  is valid iff  and . Help Jim in counting the number of valid paths represented by ordered pairs .   Input Format The first line contains , the number of skyscrapers. The next line contains  space separated integers representing the heights of the skyscrapers.  Output Format Print an integer that denotes the number of valid routes. Constraints  and no skyscraper will have height greater than  and less than . Sample Input #00 6 3 2 1 2 3 3  Sample Output #00 8  Sample Input #01 3 1 1000 1  Sample Output #01 0  Explanation First testcase: (1, 5), (1, 6) (5, 6) and (2, 4) and the routes in the opposite directions are the only valid routes.  Second testcase: (1, 3) and (3, 1) could have been valid, if there wasn't a big skyscraper with height 1000 between them.
__label__Data-Structures __label__Advanced-Data-Structures Consider a lowercase English alphabetic letter character denoted by . A shift operation on some  turns it into the next letter in the alphabet. For example, and , ,  .  Given a zero-indexed string, , of  lowercase letters, perform  queries on  where each query takes one of the following two forms: 1 i j t: All letters in the inclusive range from  to  are shifted  times.   1 i j t 2 i j: Consider all indices in the inclusive range from  to . Find the number of non-empty subsets of characters,  where , such that characters  can be rearranged to form a palindrome. Then print this number modulo  on a new line. Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. 2 i j Note Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a string of  lowercase English alphabetic letters (i.e., a through z) denoting .  Each of the  subsequent lines describes a query in one of the two formats defined above. a z Constraints      for each query.  for each query of type . Subtasks For  of the maximum score:      For another  of the maximum score:  All queries will be of type .  Output Format For each query of type  (i.e., 2 i j), print the number of non-empty subsets of characters satisfying the conditions given above, modulo , on a new line. 2 i j Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: 2 0 2:  and we want to find the palindromic subsets of substring . There are five such subsets that form palindromic strings (, , , , and ), so we print the result of  on a new line 2 0 2 2 0 0:  and we want to find the palindromic subsets of substring . Because this substring only has one letter, we only have one subset forming a palindromic string (). We then print the result of  on a new line.  2 0 0 2 1 2:   and we want to find the palindromic subsets of substring . There are two such subsets that form palindromic strings ( and ), so we print the result of  on a new line.   2 1 2 1 0 1 1:  and we need to perform  shift operations on each character from index  to index . After performing these shifts, .   1 0 1 1 2 0 2:  and we want to find the palindromic subsets of substring . There are three valid subsets that form palindromic strings (, , and ), so we print the result of  on a new line. 2 0 2
__label__Tree Taylor loves trees, and this new challenge has him stumped! Consider a tree, , consisting of  nodes. Each node is numbered from  to , and each node  has an integer, , attached to it.  A query on tree  takes the form w x y z. To process a query, you must print the count of ordered pairs of integers  such that the following four conditions are all satisfied:  w x y z   the path from node  to node .  path from node  to node .   Given  and  queries, process each query in order, printing the pair count for each query on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes) and  (the number of queries).  The second line contains  space-separated integers describing the respective values of each node (i.e., ).  Each of the  subsequent lines contains two space-separated integers,  and , defining a bidirectional edge between nodes  and .  Each of the  subsequent lines contains a w x y z query, defined above. w x y z Constraints         Scoring for this problem is Binary, that means you have to pass all the test cases to get a positive score. Output Format For each query, print the count of ordered pairs of integers satisfying the four given conditions on a new line. Sample Input 10 5 10 2 3 5 10 5 3 6 2 1 1 2 1 3 3 4 3 5 3 6 4 7 5 8 7 9 2 10 8 5 2 10 3 8 4 9 1 9 5 9 4 6 4 6 5 8 5 8  Sample Output 0 1 3 2 0  Explanation We perform  queries on the following tree:  Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . One such pair, , exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Three such pairs, , , and  exist, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Two such pairs,  and , exist, so we print .   Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print .
__label__Data-Structures __label__Advanced-Data-Structures Consider a sequence, , and a polynomial of degree  defined as . You must perform  queries on the sequence, where each query is one of the following two types: 1 i x: Replace  with . 1 i x 2 l r: Consider the polynomial  and determine whether  is divisible by  over the field , where . In other words, check if there exists a polynomial  with integer coefficients such that each coefficient of  is divisible by . If a valid  exists, print Yes on a new line; otherwise, print No. 2 l r Yes No Given the values of , , , and  queries, perform each query in order. Input Format The first line contains four space-separated integers describing the respective values of  (the length of the sequence),  (a coefficient in ),  (a coefficient in ), and  (the number of queries).  The second line contains  space-separated integers describing .  Each of the  subsequent lines contains three space-separated integers describing a query of either type 1 or type 2. 1 2 Constraints  For query type 1:  and . 1 For query type 2: . 2   Output Format For each query of type 2, print Yes on a new line if  is a divisor of ; otherwise, print No instead. 2 Yes No Sample Input 0 Sample Output 0 Explanation 0 Given  and the initial sequence , we perform the following  queries:  is not a divisor of , so we print No on a new line. No Set  to , so . After the second query, . Because , we print Yes on a new line. Yes
__label__Tree __label__Data-Structures Given an array, your goal is to find, for each element, the largest subarray containing it whose cost is at least . Specifically, let  be an array of length , and let  be the subarray from index  to index . Also, Let  be the largest number in . Let  be the smallest number in . Let  be the bitwise OR of the elements of . Let  be the bitwise AND of the elements of . The cost of , denoted , is defined as   You are given the array  and and an integer . For each index  from  to , your goal is to find the largest size of any subarray  such that  and . Consider, array  and . The possible sub-arrays and their costs would be as follows:   Complete the function costlyIntervals which takes two integers  and  as first line of input, and array  in the second line of input. Return an array of  integers, where the  element contains the answer for index  of the input array, . Every element of the output array denotes the largest size of a subarray containing  whose cost is at least , or  if there is no such subarray. costlyIntervals Constraints     Subtasks  For  of the maximum score, . For  of the maximum score, . Sample Input ,     Sample Output   Explanation In this example, we have . There is only one subarray whose cost is at least , and that is , since . Its size is . Thus, for  and , the answer is , and for the others, .
__label__Tree __label__Data-Structures One of the most important skills a programmer needs to learn early on is the ability to pose a problem in an abstract way. This skill is important not just for researchers but also in applied fields like software engineering and web development.   You are able to solve most of a problem, except for one last subproblem, which you have posed in an abstract way as follows: Given an array consisting of  integers , define   For example, for an input array [ 10, -5, 5, 20 ], a subsegment  would be computed as follows:    What is , i.e., the maximum value of  among all subsegments ?   Complete the function maximumValue which takes an integer array as input and returns the maximum value of  among all subsegments . maximumValue Note that:   Input Format The first line contains a single integer  The second line contains  space-separated integers  Constraints     Output Format Print a single integer denoting the answer Sample Input 0 Sample Output 0 Explanation 0 The maximum value occurs at  as shown below.   Sample Input 1 Sample Output 1 Explanation 1 The maximum value occurs at .
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Treeland is a country with  cities and  roads. There is exactly one path between any two cities.   The ruler of Treeland wants to implement a self-driving bus system and asks tree-loving Alex to plan the bus routes. Alex decides that each route must contain a subset of connected cities; a subset of cities is connected if the following two conditions are true: There is a path between every pair of cities which belongs to the subset. Every city in the path must belong to the subset.  In the figure above,  is a connected subset, but  is not  (for the second condition to be true,  would need to be part of the subset). Each self-driving bus will operate within a connected segment of Treeland. A connected segment  where  is defined by the connected subset of cities .  In the figure above,  is a connected segment that represents the subset . Note that a single city can be a segment too. Help Alex to find number of connected segments in Treeland. Input Format The first line contains a single positive integer, .  The  subsequent lines each contain two positive space-separated integers,  and , describe an edge connecting two nodes in tree . Constraints   Subtasks  For  score:  For  score:  Output Format Print a single integer: the number of segments , which are connected in tree . Sample Input 3 1 3 3 2  Sample Output 5  Explanation The connected segments for our test case are: , , , , and . These segments can be represented by the respective subsets: , , , , and .  Note:  is not a connected segment. It represents the subset  and the path between  and  goes through  which is not a member of the subset.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures You are given an unrooted tree of  nodes numbered from  to . Each node  has a color, .  Let  be the number of different colors in the path between node  and node . For each node , calculate the value of , defined as follows:   Your task is to print the value of  for each node . Input Format The first line contains a single integer, , denoting the number of nodes.  The second line contains  space-separated integers, , where each  describes the color of node .  Each of the  subsequent lines contains  space-separated integers,  and , defining an undirected edge between nodes  and . Constraints   Output Format Print  lines, where the  line contains a single integer denoting . Sample Input 5 1 2 3 2 3 1 2 2 3 2 4 1 5  Sample Output 10 9 11 9 12  Explanation The Sample Input defines the following tree:  Each  is calculated as follows:
__label__Tree __label__Data-Structures __label__Mathematics __label__Advanced-Data-Structures Shashank loves trees and math. He has a rooted tree, , consisting of  nodes uniquely labeled with integers in the inclusive range . The node labeled as  is the root node of tree , and each node in  is associated with some positive integer value (all values are initially ).  Let's define  as the  Fibonacci number. Shashank wants to perform  types of operations over his tree, :    Update the subtree rooted at node  such that the node at level  in subtree  (i.e., node ) will have  added to it, all the nodes at level  will have  added to them, and so on. More formally, all the nodes at a distance  from node  in the subtree of node  will have the  Fibonacci number added to them.    Find the sum of all values associated with the nodes on the unique path from  to . Print your sum modulo  on a new line. Given the configuration for tree  and a list of  operations, perform all the operations efficiently. Note: . Input Format The first line contains  space-separated integers,  (the number of nodes in tree ) and  (the number of operations to be processed), respectively.  Each line  of the  subsequent lines contains an integer, , denoting the parent of the  node.  Each of the  subsequent lines contains one of the two types of operations mentioned in the Problem Statement above. Constraints    Output Format For each operation of type  (i.e., ), print the required answer modulo  on a new line. Sample Input 5 10 1 1 2 2 Q 1 5 U 1 1 Q 1 1 Q 1 2 Q 1 3 Q 1 4 Q 1 5 U 2 2 Q 2 3 Q 4 5  Sample Output 0 1 2 2 4 4 4 10  Explanation Intially, the tree looks like this:  After update operation , it looks like this:  After update operation , it looks like this:
__label__Dynamic-Programming Given an array, we define its value to be the value obtained by following these instructions: Write down all pairs of numbers from this array.   Compute the product of each pair.   Find the sum of all the products. For example, for a given array, for a given array [, , , ],  Note that  is listed twice, one for each occurrence of .   Given an array of integers, find the largest value of any of its nonempty subarrays. Note: A subarray is a contiguous subsequence of the array. Complete the function largestValue which takes an array and returns an integer denoting the largest value of any of the array's nonempty subarrays.   largestValue Input Format The first line contains a single integer , denoting the number of integers in array .  The second line contains  space-separated integers  denoting the elements of array .   Constraints     Subtasks   for 20% of the points.    for 70% of the points. Output Format Print a single line containing a single integer denoting the largest value of any of the array's nonempty subarrays. Sample Input 0 Sample Output 0 Explanation 0 In this case, we have . The largest-valued subarray turns out to be  with value .   Sample Input 1 Sample Output 1
__label__Advanced-Data-Structures Let's define a function, , on a string, , of length  as follows:   where  denotes the ASCII value of the  character in string , , and .  Nikita has a string, , consisting of  lowercase letters that she wants to perform  queries on. Each query consists of an integer, , and you have to find the value of  where  is the  alphabetically smallest palindromic substring of . If  doesn't exist, print  instead. Input Format The first line contains  space-separated integers describing the respective values of  (the length of string ) and  (the number of queries).  The second line contains a single string denoting .  Each of the  subsequent lines contains a single integer denoting the value of  for a query.  Constraints     It is guaranteed that string  consists of lowercase English alphabetic letters only (i.e.,  to ).  .  Scoring  for  of the test cases.  for  of the test cases. Output Format For each query, print the value of function  where  is the  alphabetically smallest palindromic substring of ; if  doesn't exist, print  instead. Sample Input 5 7 abcba 1 2 3 4 6 7 8         Sample Output 97 97 696207567 98 29493435 99 -1  Explanation There are  palindromic substrings of . Let's list them in lexicographical order and find value of : ,   ,   ,   ,   ,   ,   ,    doesn't exist, so we print  for .
__label__Data-Structures __label__Advanced-Data-Structures White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques?  There are  types of query operations that can be performed on a tree: 1 u x: Assign  as the value of node . 1 u x 2 u v: Print the sum of the node values in the unique path from node  to node . 2 u v Given a tree with  nodes where each node's value is initially , execute  queries.  Input Format The first line contains  space-separated integers,  and , respectively.  The  subsequent lines each contain  space-separated integers describing an undirected edge in the tree.  Each of the  subsequent lines contains a query you must execute. Constraints   It is guaranteed that the input describes a connected tree with  nodes.  Nodes are enumerated with -based indexing. Output Format For each type- query, print its integer result on a new line. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 3  Explanation  After the first  queries, the value of node  and the value of node . The third query requires us to print the sum of the node values in the path from nodes  to , which is . Thus, we print  on a new line.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Simon received the board game Ticket to Ride as a birthday present. After playing it with his friends, he decides to come up with a strategy for the game. There are  cities on the map and  road plans. Each road plan consists of the following:  Two cities which can be directly connected by a road. The length of the proposed road.  The entire road plan is designed in such a way that if one builds all the roads, it will be possible to travel between any pair of cities.  A ticket enables you to travel between two different cities. There are  tickets, and each ticket has a cost associated with it. A ticket is considered to be useful if there is a path between those cities. Simon wants to choose two cities,  and , and build a minimal number of roads so that they form a simple path between them. Let  be the sum of costs of all useful tickets and  be the sum of lengths of all the roads Simon builds. The profit for pair  is defined as . Note that  and  are not necessarily unique and may be the same cities. Given  road plans and  ticket prices, help Simon by printing the value of his maximum possible profit on a new line. Input Format The first line contains single positive integer, , denoting the number of cities.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a road plan, where , , and . Here,  and  are two cities that the road plan proposes to connect and  is the length of the proposed road.  The next line contains a single positive integer, , denoting the number of tickets.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a ticket from city  to city  (where  is the cost of the ticket). Constraints    Output Format Print a single integer denoting the the maximum profit Simon can make. Time Limits   seconds for Java and C#. Please refer to our Environment page to see time limits for other languages. Sample Input 7 1 2 1 1 3 1 1 4 4 4 5 1 4 6 1 4 7 1 5 5 7 3 3 6 2 3 4 10 2 7 15 1 6 7  Sample Output 13  Explanation  Simon can maximize his profit by choosing the pair .  The roads on the path between them are , , and . The total road length is .  The useful tickets are , , and . The total ticket cost is .  The profit is .
__label__Data-Structures __label__Advanced-Data-Structures Our lazy white falcon finally decided to learn heavy-light decomposition. Her teacher gave an assignment for her to practice this new technique. Please help her by solving this problem.  You are given a tree with  nodes and each node's value is initially . The problem asks you to operate the following two types of queries: "1 u x" assign  to the value of the node . "2 u v" print the maximum value of the nodes on the unique path between  and . Input Format First line consists of two integers seperated by a space:  and . Following  lines consisting of two integers denotes the undirectional edges of the tree.  Following  lines consist of the queries you are asked to operate.  Constraints  It is guaranteed that input denotes a connected tree with  nodes. Nodes are enumerated with 0-based indexing. Output Format For each second type of query print single integer in a single line, denoting the asked maximum value. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 2  Explanation After the first two updates value of the th node is  and st node is . That is why maxiumum value on the path between  and  is .
__label__Data-Structures __label__Advanced-Data-Structures Alexey is playing with an array, , of  integers. His friend, Ivan, asks him to calculate the sum of the maximum values for all subsegments of . More formally, he wants Alexey to find . Alexey solved Ivan's challenge faster than expected, so Ivan decides to add another layer of difficulty by having Alexey answer  queries. The  query contains subsegment , and he must calculate the sum of maximum values on all subsegments inside subsegment .  More formally, for each query , Alexey must calculate the following function: . Can you help Alexey solve this problem? Input Format The first line contains  space-separated positive integers,  (the length of array ) and  (number of queries), respectively.  The second line contains  space-separated integers,  describing each element  (where ) in array .  Each of the  subsequent lines contains  space-separated positive integers describing the respective values for  and  in query  (where ). Constraints    Output Format For each query  (where ), print its answer on a new line. Sample Input 3 6 1 3 2 1 1 1 2 1 3 2 2 2 3 3 3  Sample Output 1 7 15 3 8 2  Explanation The answer for the second query is shown below:   The answer for the third query is shown below:
__label__Game-Theory __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Andy and Lily love playing games with numbers and trees. Today they have a  tree consisting of  nodes and  edges. Each edge  has an integer weight, . Before the game starts, Andy chooses an unordered pair of distinct nodes, , and uses all the edge weights present on the unique path from node  to node  to construct a list of numbers. For example, in the diagram below, Andy constructs a list from the edge weights along the path :  Andy then uses this list to play the following game with Lily: Two players move in alternating turns, and both players play optimally (meaning they will not make a move that causes them to lose the game if some better, winning move exists). Andy always starts the game by removing a single integer from the list. During each subsequent move, the current player removes an integer less than or equal to the integer removed in the last move. The first player to be unable to move loses the game. For example, if the list of integers is  and Andy starts the game by removing , the list becomes . Then, in Lily's move, she must remove a remaining integer less than or equal to  (i.e., , , , or ). The two friends decide to play  games, where each game is in the form of a tree. For each game, calculate the number of unordered pairs of nodes that Andy can choose to ensure he always wins the game. Input Format The first line contains a single integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of nodes in the tree. Each line  of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for the  edge connecting nodes  and  with weight . Constraints         Sum of  over all games does not exceed  Scoring  For  of score, the sum of  over all games does not exceed . For  of score, the sum of  over all games does not exceed . Output Format For each game, print an integer on a new line describing the number of unordered pairs Andy can choose to construct a list that allows him to win the game. Sample Input 0 Sample Output 0 Explanation 0 Andy and Lily play the following  games: The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line.
__label__Data-Structures __label__Advanced-Data-Structures White Falcon was amazed by what she can do with heavy-light decomposition on trees. As a resut, she wants to improve her expertise on heavy-light decomposition. Her teacher gave her an another assignment which requires path updates. As always, White Falcon needs your help with the assignment. You are given a tree with  nodes and each node's value  is initially . Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   The problem asks you to operate the following two types of queries on the tree: "1 u v x" Add  to ,  to ,  to , ...,   to .  "2 u v" print the sum of the nodes' values on the path between  and  at modulo . Input Format First line cosists of two integers  and  seperated by a space. Following  lines contains two integers which denote the undirectional edges of the tree. Following  lines contains one of the query types described above. Note: Nodes are numbered by using 0-based indexing.  Constraints   Output Format For every query of second type print a single integer. Sample Input 3 2 0 1 1 2 1 0 2 1 2 1 2  Sample Output 5  Explanation After the first type of query, . Hence the answer of the second query is .
__label__Data-Structures __label__Advanced-Data-Structures A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves. Change the number of books in one of the shelves. Change the number of books in one of the shelves. Obtain the number of books on the shelf having the kth rank within  the range of shelves.  Obtain the number of books on the shelf having the kth rank within  the range of shelves.  A shelf is said to have the kth rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order. Can you write a program to simulate the above queries? Input Format  The first line contains a single integer T, denoting the number of test cases.  The first line of each test case contains an integer N denoting the number of shelves in the library.  The next line contains N space separated integers where the ith integer represents the number of books on the ith shelf where 1<=i<=N.  The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query.  Queries can be of two types: 1 x k - Update the number of books in the xth shelf to k (1 <= x <= N). 0 x y k - Find the number of books on the shelf between the shelves x and y  (both inclusive) with the kth rank (1 <= x <= y <= N, 1 <= k <= y-x+1). Output Format  For every test case, output the results of the queries in a new line. Constraints  1 <= T <= 5  1 <= N <= 104  1 <= Q <= 104  The number of books on each shelf is always guaranteed to be between 1 and 1000. Sample Input 2 2 1 2 2 0 1 2 1 0 1 2 2 4 4 3 2 1 4 0 1 1 1 1 1 1 0 1 1 1 0 1 4 3  Sample Output 1 2 4 1 2  Explanation  There are two test cases : The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2. The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2.
__label__Mathematics __label__Data-Structures __label__Advanced-Data-Structures In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have N space-fighters.  Initially the ith fighter is located at (xi, yi). All of the space-fighters move with constant velocity V units/sec in the positive X direction.  i.e., fighter at (xi, yi) moves to (xi+V, yi) in 1 second.  The ith space-fighter broadcasts enemy information at a frequency fi. The republic is not scared of the artificially intelligent droid force as they have Yoda. Yoda has a special power, at any time T he can choose a region of the droid army and block one specific frequency F. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across X axis (refer image below for clarity). If a frequency (F) is blocked all the space-fighters in the region having the frequency F can’t communicate.  Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form: YU YD T where YU, YD are the bounds on y-axis inside which YODA can block a frequency at time T.  In the region described by the query, after a time T seconds from the start, if Yoda can chose one frequency (F) he wishes to, what is the maximum number of communications he can block? Input Format  Each test case is described as follows; the first line contains 3 space separated integers N - the number of space-fighters, Q - the number of queries you have to answer, and V - the velocity of the space-fighters separated by a single space.  N lines follow, each containing 3 space separated integers xi, yi, and fi, denoting the x co-ordinate, y co-ordinate and the frequency at which the ith ship broadcasts respectively. Each of the next Q lines contain 3 space separated integers representing YU, YD, T respectively. Refer the figure for more clarity Note: Points on the boundaries should be counted as well. Output Format  For each query you are to output a single integer denoting the result. Constraints  1 <= N <= 50000 1 <= Q <= 30000 1 <= V <= 10000 -109 <= xi <= 109 -109 <= yi <= 109 1 <= fi <= 109 -109 <= YU <= 109 -109 <= YD <= 109 1 <= T <= 10000 YU >= YD Sample Input 5 5 82 -4 1 4 -3 -2 2 -3 5 1 0 -5 2 1 -1 2 1 -1 57 -2 -5 11 5 -5 40 -1 -5 16 5 -1 93  Sample Output 1 2 3 3 1  Explanation Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.
__label__Data-Structures __label__Advanced-Data-Structures A Sumo wrestling championship is scheduled to be held this winter in the HackerCity where N wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K,  (i.e) wrestler A and wrestler B can fight if and only if |height(A)-height(B)|<=K.    Given an array H[], where H[i] represents the height of the ith fighter, for a given l, r where 0 <= l <= r < N, can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game? 0 <= l <= r < N Input Format  The first line contains an integer N and K  separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K.  The second line contains N integers separated by a single space, representing their heights H[0] H[1] ... H[N - 1].  The third line contains Q, the number of queries. This is followed by Q lines each having two integers l and r separated by a space.   Output Format  For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that K.   Constraints  1 <= N <= 100000  0 <= K <= 109  0 <= H[i] <= 109  1 <= Q <= 100000  0 <= l <= r < N   Sample Input Sample Output  Explanation  Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1.  Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| <=2. Hence output is 3.  Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.   Timelimits Timelimits are given here
__label__Data-Structures __label__Advanced-Data-Structures Shik loves sorted intervals. But currently he does not have enough time to sort all the numbers. So he decided to use Almost sorted intervals. An Almost sorted interval is a consecutive subsequence in a sequence which satisfies the following property: The first number is the smallest. The last number is the largest. Please help him count the number of almost sorted intervals in this permutation.   Note: Two intervals are different if at least one of the starting or ending indices are different. Input Format  The first line contains an integer N.  The second line contains a permutation from 1 to N. Output Format  Output the number of almost sorted intervals.   Constraints  1 ≤ N ≤ 106  Sample Input  5 3 1 2 5 4  Sample Output  8  Explanation  The subsequences [3], [1], [1 2], [1 2 5], [2], [2 5], [5], [4] are almost sorted intervals.
__label__Data-Structures __label__Advanced-Data-Structures In Burger Town new burger restaurants will be opened! Concretely,  restaurants will open in  days, while restaurant  will be opened on day  and will be located at . The town should be imagined as an one dimensional line in which every object's location can be described by the  coordinate. Tim has just recently arrived the town after a very bad result in a programming contest. Thus he wants to cheer himself up by starting a trip to try out some new burgers.  Every burger restaurant  is associated with two integers  and . If Tim eats a burger from , then his happiness will increase by , which can also be negative, depending on the deliciousness of the burger. On the other hand, if Tim looks through the window of an opened restaurant , from which he will not eat a burger, then his happiness decreases by , since Tim gets sad by only seeing the burgers.  Tim's journey can start from any day  at the burger restaurant  and eats a burger from there. On each subsequent day , Tim has the following options: Stay at the previous restaurant .  Or go to the new restaurant  to eat a burger from there. If he decides for the latter option, then on the path from  to  he will look through all the windows that are on his path and maybe lose some happiness. Concretely, if , then he will look through the window of every opened restaurant , having . Similar for the case . Since Tim is a very good friend of yours you should help him finding a trip that will maximize his happiness. If he should stay at home since no trip would cheer him up, then print 0.  0 Note: Tim's happiness is 0 at the beginning of the trip and is allowed to be negative throughout the time.  Input Format  will be given on the first line, then  lines will follow, describing the restaurants numbered from 1 to  accordingly. Restaurant  will be described by ,  and  separated by a single space. Output Format Output the maximium happiness on one line. Constraints         and no two restaurants will have the same  coordinates.  and no two restaurants will have the same  coordinates. Sample Input  3  2 -5 1  1 5 1  3 5 1  Sample Output 8  Sample Input  4  4 10 0  1 -5 0  3 0 10  2 10 0  Sample Output  15  Sample Input  3  1 -1 0  2 -2 0  3 -3 0  Sample Output  0  First testcase: His trip starts on day 2 at restaurant 2 located at . He gains  happiness points there by eating a burger. On the next day he goes from restaurant 2 to 3, but will look through the window of restaurant 2 and 1. Therefore he loses  and  points on the way to restaurant 3. There he eats a burger and gains another  points. In total his happiness is equal to  8 and this is optimal. 8 Second testcase: His trip starts on day 1 at restaurant 1. Then his actions on day 2, 3 and 4 will be go to restaurant 2, stay at restaurant 2 and go to restaurant 4 respectively. The happiness of this optimal trip is equal to  15. 15 Third testcase: It's not worth to start the trip from any of the restaurant since he will only have negative happiness. That's why he should stay at home and 0 should be printed.  0
__label__Data-Structures __label__Advanced-Data-Structures Roy has taken a liking to the Binary Search Trees(BST). He is interested in knowing the number of ways an array  of  integers can be arranged to form a BST. Thus, he tries a few combinations, and notes down the numbers at the odd levels and the numbers at the even levels.  You're given two values, alpha and beta. Can you calculate the sum of Liking of all possible BST's that can be formed from an array of  integers? Liking of each BST is defined as follows  (sum of numbers on even levels * alpha) - (sum of numbers on odd levels * beta)  Note  The root element is at level  ( Even ) The elements smaller or equal to the parent element are present in the left subtree, elements greater than or equal to the parent element are present in the right subtree.  Explained here If the answer is no less than , output the answer % .  (If the answer is less than , keep adding  until the value turns non negative.) Input Format  The first line of input file contains an integer, , denoting the number of test cases to follow.  Each testcase comprises of  lines.  The first line contains , the number of integers.  The second line contains two space separated integers, alpha and beta.  The third line contains space separated  integers_, denoting the  integer in array .   Output Format  Output  lines. Each line contains the answer to its respective test case.  Constraints          Sample Input Sample Output Explanation There are  test cases in total.  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  1 For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the third test case, we get  BSTs. The Liking of each of the BST from left  to right are  which sums to  and hence the answer.   Similarly, for the fourth test case, the answer is .
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes with every node being colored. A color is represented by an integer ranging from 1 to 109. Can you find the number of distinct colors available in a subtree rooted at the node s?  Input Format  The first line contains three space separated integers representing the number of nodes in the tree (N), number of queries to answer (M) and the root of the tree.  In each of the next N-1 lines, there are two space separated integers(a b) representing an edge from node a to Node b and vice-versa.    N lines follow: N+ith line contains the color of the ith node. M lines follow: Each line containg a single integer s. Output Format  Output exactly M lines, each line containing the output of the ith query. Constraints  0 <= M <= 105 1 <= N <= 105 1 <= root <= N 1 <= color of the Node <= 109 Example Sample Input 4 2 1 1 2 2 4 2 3 10 20 20 30 1 2  Sample Output 3 2  Explanation Query 1-Subtree rooted at 1 is the entire tree and colors used are 10 20 20 30 , so the answer is 3(10,20 and 30) Query 2-Subtree rooted at 2 contains color 20 20 30, so the answer is 2(20 and 30)
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  The update query is of the format i j X  This means you'd have to add a GP series to the nodes which lie in the path from node i to node j (both inclusive) with first term of the GP as X on node i and the common ratio as R (given in the input) i j X i R The retrieval query is of the format i j You need to return the sum of the node values (S) lying in the path from node i to node j modulo 100711433.  Input Format  The first line contains two integers (N and R respectively) separated by a space.  In the next N-1 lines, the ith line describes the ith edge: a line with two integers a b separated by a single space denotes an edge between a, b.  The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.  U lines follow. Each of the next U lines contains 3 space separated integers (i,j, and X respectively).  Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 100000  2 <= R <= 109  1 <= U <= 100000  1 <= Q <= 100000  1 <= X <= 10  1 <= a, b, i, j <= N   Sample Input  6 2 1 2 1 4 2 6 4 5 4 3 2 2 1 6 3 5 3 5 6 4 5 1  Sample Output 31 18  Explanation The node values after the first updation becomes :   3 6 0 0 0 12    The node values after second updation becomes :   3 6 20 10 5 12    Answer to Query #1: 12 + 6 + 3 + 10 = 31  Answer to Query #2: 5 + 10 +3 = 18
__label__Data-Structures __label__Advanced-Data-Structures You are given a sequence . The task is to perform the following queries on it: Type 1. Given two integers  and  . Reorder the elements of the sequence in such a way (changed part of the sequence is in brackets):   Type 2. Given two integers  and , print the value of sum . Input Format  The first line contains two integers  and . The second line contains  integers , denoting initial sequence. Each of the next  lines contains three integers , where  denotes the type of the query, and  are parameters of the query. It's guaranteed that for a first-type query  will be even.   Constraints           Output Format For each query of the second type print the required sum. Sample Input 6 4 1 2 3 4 5 6 1 2 5 2 2 3 2 3 4 2 4 5  Example Output 5 7 9  Explanation After the first query the sequence becomes [1, 3, 2, 5, 4, 6].
__label__Search __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Let  denote an arithmetic progression (AP) with first term  and common difference , i.e.  denotes an infinite . You are given  APs => . Let  denote the sequence obtained by multiplying these APs. Multiplication of two sequences is defined as follows. Let the terms of the first sequence be , and terms of the second sequence be . The sequence obtained by multiplying these two sequences is    If  are the terms of a sequence, then the terms of the first difference of this sequence are given by  calculated as  respectively. Similarly, the second difference is given by , and so on. We say that the  difference of a sequence is a constant if all the terms of the  difference are equal.   Let  be a sequence defined as =>   Similarly,  is defined as => product of .  Task:  Can you find the smallest  for which the  difference of the sequence  is a constant? You are also required to find this constant value.   You will be given many operations. Each operation is of one of the two forms:   1) 0 i j => 0 indicates a query . You are required to find the smallest  for which the  difference of  is a constant. You should also output this constant value.   0 i j 2) 1 i j v => 1 indicates an update . For all , we update .   1 i j v Input Format  The first line of input contains a single integer , denoting the number of APs.  Each of the next  lines consists of three integers  .  The next line consists of a single integer , denoting the number of operations. Each of the next  lines consist of one of the two operations mentioned above.    Output Format  For each query, output a single line containing two space-separated integers  and .  is the smallest value for which the  difference of the required sequence is a constant.  is the value of this constant. Since  might be large, output the value of  modulo 1000003.   Note:  will always be such that it fits into a signed 64-bit integer. All indices for query and update are 1-based. Do not take modulo 1000003 for . Constraints        For updates of the form 1 i j v,     1 i j v Sample Input  2   1 2 1   5 3 1   3   0 1 2   1 1 1 1   0 1 1    Sample Output  2 12   2 8    Explanation The first sequence given in the input is =>   The second sequence given in the input is =>   For the first query operation, we have to consider the product of these two sequences:  =>   =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 12.   2 12 After the update operation 1 1 1 1, the first sequence becomes =>   i.e =>   For the second query, we consider only the first sequence =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 8 1 1 1 1 2 8
__label__Data-Structures __label__Advanced-Data-Structures Coolguy gives you a simple problem. Given a -indexed array, , containing  elements, what will  be after this pseudocode is implemented and executed? Print . //f(a, b) is a function that returns the minimum element in interval [a, b]  ans = 0  for a -> [1, n]     for b -> [a, n]         for c -> [b + 1, n]             for d -> [c, n]                 ans = ans + min(f(a, b), f(c, d))  Input Format The first line contains  (the size of array ).  The second line contains  space-separated integers describing . Constraints  ≤  ≤   ≤  ≤  Note:  is -indexed (i.e.: ). Output Format Print the integer result of . Sample Input 3 3 2 1  Sample Output 6  Explanation       We then sum these numbers () and print , which is .
__label__Data-Structures __label__Advanced-Data-Structures White Falcon has a tree with  nodes. Each node contains a linear function. Let's denote by  the linear function contained in the node .   Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   White Falcon also has  queries. They are in the following format:       . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .     . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .    . Calculate  modulo     . Calculate  modulo  Input Format The first line contains , the number of nodes. The following  lines each contain two integers  and  that describe the function .   Following  lines contain edges of the tree.  The next line contains , the number of queries. Each subsequent line contains one of the queries described above. Output Format For every query of the second kind, print one line containing an integer, the answer for that query.   Constraints   (Number of nodes)   (Number of queries)   Sample Input 2 1 1 1 2 1 2 2 1 2 2 1 1 2 1 2 1  Sample Output 3  Explanation
__label__Data-Structures __label__Advanced-Data-Structures Given a rooted tree of  nodes, where each node is uniquely numbered in between [1..N]. The node 1 is the root of the tree. Each node has an integer value which is initially 0. You need to perform the following two kinds of queries on the tree: add t value: Add value to all nodes in subtree rooted at t max a b: Report maximum value on the path from a to b Input Format First line contains N, number of nodes in the tree. Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, the number of queries to process.  Next Q lines follow with either add or max query per line. Constraints           Output Format For each max query output the answer in a separate line. Sample Input 5 1 2 2 3 2 4 5 1 6 add 4 30 add 5 20 max 4 5 add 2 -20 max 4 5 max 3 4  Sample Output 30 20 10  Explanation In the test case we have the following tree:  Initially all node values are zero.  Queries are performed in the following way: add 4 30 // add 30 to node 4  add 5 20 // add 20 to node 5  max 4 5 // maximum of nodes 4,2,1,5 is 30  add 2 -20 // subtract 20 from nodes 2,3,4  max 4 5 // maximum of nodes 4,2,1,5 is 20  max 3 4 // maximum of nodes 3,2,4 is 10
__label__Search __label__Data-Structures __label__Advanced-Data-Structures There is an integer array  which does not contain more than two elements of the same value. How many distinct ascending triples () are present?  Input format  The first line contains an integer, , denoting the number of elements in the array. This is followed by a single line, containing  space-separated integers. Please note that there are no leading spaces before the first number, and there are no trailing spaces after the last number. Output format:  A single integer that denotes the number of distinct ascending triplets present in the array. Constraints:    Every element of the array is present at most twice.  Every element of the array is a 32-bit non-negative integer. Sample input:  6   1 1 2 2 3 4    Sample output:  4  Explanation  The distinct triplets are  (1,2,3)  (1,2,4)  (1,3,4)  (2,3,4) The elements of the array might not be sorted. Make no assumptions of the same.
__label__Bit __label__Data-Structures __label__Advanced-Data-Structures You are given an array, , consisting of  integers. A segment, , is beautiful if and only if the bitwise AND of all numbers in  with indices in the inclusive range of  is not greater than . In other words, segment  is beautiful if . You must answer  queries. Each query, , consists of  integers: , , and . The answer for each  is the number of beautiful segments  such that  and . Input Format The first line contains two space-separated integers,  (the number of integers in ) and  (the number of queries). The second line contains  space-separated integers, where the  integer denotes the  element of array . Each line  of the  subsequent lines contains  space-separated integers, , , and , respectively, describing query . Constraints       holds for test cases worth at least  of the problem's score.  holds for test cases worth at least  of the problem's score.  Output Format Print  lines, where the  line contains the number of beautiful segments for query . Sample Input 5 3 1 2 7 3 4 1 5 3 2 4 6 3 5 2  Sample Output 13 5 2  Explanation The beautiful segments for all queries are listed below. Query 0: The beautiful segments are . Query 1: The beautiful segments are . Query 2: The beautiful segments are .
__label__Data-Structures __label__Advanced-Data-Structures Two positive integers  and  are given.   is decimal representation of integer .  Lets define . For example, if :   For each query you will be given two integers  and  that define a substring equal to .  Your task is to calculate divisibility of given substring.  Divisibility of given substring is equal to number of  pairs such that:   and   is divisible by , assuming that  is divisible by any other integer. Timelimits  Timelimits for this challenge is given here Input Format First line contains two integers  and  separated by a single space.  is the number of queries.  Second line contains a big integer .  Next  lines contains two integers  and  separated by a single space each - begin and end points of substring. Constraints   Output Format Output  lines, the -th line of the output should contain single integer  divisibility of the -th query substring. Sample Input 3 5 4831318 3 5 5 7 1 7 1 2 2 3  Sample Output 2 3 9 1 1  Explanation In the first query, b = 3 and e = 5. Two such pairs that are divisible by P = 3 are   f(3, 3) = 3 and f(5, 5). Hence the answer 2.   In the second query, b = 5 and e = 7. Three such pairs that are divisible by P are   F(5, 5) = 3, f(6, 7) = 18 and f(5, 7) = 318
__label__Data-Structures __label__Advanced-Data-Structures Consider a binary search tree T which is initially empty. Also, consider the first N positive integers {1, 2, 3, 4, 5, ....., N} and its permutation P {a1, a2, ..., aN}.  N If we start adding these numbers to the binary search tree T, starting from a1, continuing with a2, ... (and so on) ..., ending with aN. After every addition we ask you to output the sum of distances between every pair of T's nodes. Input Format  The first line of the input consists of the single integer N, the size of the list.  The second line of the input contains N single space separated numbers the permutation a1, a2, ..., aN itself. Constraints  1 ≤ N ≤ 250000   Output Format  Output N lines.  On the ith line output the sum of distances between every pair of nodes after adding the first i numbers from the permutation to the binary search tree T  Sample Input #00 8 4 7 3 1 8 2 6 5  Sample Output #00 0 1 4 10 20 35 52 76  Explanation #00  After adding the first element, the distance is 0 as there is only 1 element  0 4  After adding the second element, the distance between 2 nodes is 1.   1 4  \   7  After adding the third element, the distance between every pair of elements is 2+1+1=4 2+1+1=4   4  / \ 3   7      After adding the fourth element, the distance between every pair of elements is 3 + 2 + 1 + 2 + 1 + 1 = 10 3 + 2 + 1 + 2 + 1 + 1 = 10     4    / \   3   7      / 1  After adding the fifth element, the distance between every pair of elements is 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20     4    / \   3   7      /     \ 1       8  After adding the sixth element, the distance between every pair of elements is 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35     4    / \   3   7      /     \ 1       8  \   2  After adding the seventh element, the distance between every pair of elements is 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52     4    / \   3   7      /   / \ 1   6   8  \   2  After adding the final element, the distance between every pair of elements is 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76         4       /   \     3      7      /      /   \  1      6     8   \    /    2  5
__label__Data-Structures __label__Advanced-Data-Structures You are given a list of  numbers . For each element at position  (), we define  and  as:   = closest index j such that j < i and . If no such j exists then  = 0.   = closest index k such that k > i and . If no such k exists then  = 0.    We define  =  * . You need to find out the maximum  among all i. Input Format The first line contains an integer , the number of integers. The next line contains the  integers describing the list a[1..N]. Constraints     Output Format Output the maximum  among all indices from  to .  Sample Input 5 5 4 3 4 5  Sample Output 8  Explanation We can compute the following:          The largest of these is 8, so it is the answer.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Burger Town is a city that consists of  special junctions and  pathways. There is exactly one shortest path between each pair of junctions. Junction  is located at  and the distance between two junctions  is defined by the Taxicab geometry.  Tim has recently afforded a taxicab to work as a taxicab driver. His vehicle was very cheap, but has a very big flaw. It can only drive  units horizontally and  units vertically before refueling.  If a customer wants to be brought from a junction  to another junction , then this car is only capable of driving the route, iff the sum of horizontal distances and the sum of vertical distances on this path are less than or equal to  and  respectively.  Also, there is a unique path between any two junctions.    Now he has thoughts about returning the vehicle back to the seller. But he first wants to know, if it's even worth it. That's why he wants to know the number of unordered pairs  such that it is not possible to drive a customer from junction  to junction .  Input Format On the first line you will be given ,  and  separated by a single space.  Each of the next  lines contains two space separated integers , denoting the location of junction . Each of the next  lines contains two space separated integers describing a path existing between , i.e., there is a path between  and .   Output Format Output the number of unordered pairs  such that it is not possible to drive from  to .  Constraints    Sample Input 3 2 1 0 0 1 1 2 0 1 2 2 3  Sample Output 1  Explanation The car is only capable of driving  units horizontally and  unit vertically. The horizontal distance between junction 1 and 3(via 2) is equal to 2(), which fits under the horizontal limit of the car. The vertical distance between 1 and 3 is also equal to 2(), but this is not possible for this car since .
__label__Data-Structures __label__Advanced-Data-Structures Jaggu is a little kid and he likes playing with water balloons. He took 1 million ( 106 ) empty buckets and he filled the bucket with water balloons under the instruction of his sister Ishika.  His sister gives him two types of commands: R pos1 pos2 which implies that jaggu needs to tell her what is the total number of water balloons in the bucket from pos1 to pos2 (both included). R pos1 pos2 U pos M plus which implies that he has to work like the function  U pos M plus Update(pos,M,plus) void Update(int pos,int M,int plus) {     int N=1000000;  //1 million     for (int i=1;i<=50;i++)     {         int back = pos         for(int j=1;j<=1000;j++)         {             add M water ballons at bucket pos             int s,in=__builtin_popcount(pos);             for(int k=0;;k++)             {                 s=pos+pow(2,k)                 if( __builtin_popcount(s) <= in )                 {                     in = __builtin_popcount(s)                     pos = s;                     if(pos>N)       break;                     add M water ballons at bucket pos                 }             }             pos = pos - N         }         pos = back+plus;         if(pos>N) pos-=N;     } }  Jaggu is too lazy to put the water ballons in the bucket. Afraid that he might be caught for not doing what his sister told him to do so, he asks your help to provide correct answers  for each of his sister's query. . Input Format First line contains Q, number of queries to follow. Next Q line follows , which can be either an Update Query or Report Query.Each Update Query is followed by atleast 1 report query. Output Format For each report query , output the answer in a separate line. Constraints 1 ≤ Q ≤ 2 * 105 1 ≤ pos1,pos2,pos ≤ 106 pos1 ≤ pos2 1 ≤ M ≤ 10 1 ≤ plus ≤ 999999 Sample Input 2 U 692778 7 291188 R 636916 747794  Sample Output 378   Explanation Follow the code above to get the answer. Note  Input is randomly generated. Input is randomly generated. __builtin_popcount(x) gives the number of set bits in binary representation of x. __builtin_popcount(x) gives the number of set bits in binary representation of x. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. Timelimit is 3 times the timelimit mentioned here
__label__Data-Structures __label__Advanced-Data-Structures Given a tree of N nodes, where each node is uniquely numbered in between [1, N]. Each node also has a value which is initially 0. You need to perform following two operations in the tree.   Update Operation Report Operation Update Operation U r t a b  Adds ab + (a+1)b + (b+1)a to all nodes in the subtree rooted at t, considering that tree is rooted at r (see explanation for more details).   ab + (a+1)b + (b+1)a t r Report Operation R r t m  Output the sum of all nodes in the subtree rooted at t, considering that tree is rooted at r. Output the sum modulo m (see explanation for more details). t r m Input Format First line contains N, number of nodes in the tree.  Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, number of queries to follow.  Next Q lines follow, each line will be either a report operation or an update operation.   Output Format For each report query output the answer in a separate line. Constraints 1 ≤ N ≤ 100000  1 ≤ Q ≤ 100000  1 ≤ m ≤ 101  1 ≤ r, t, x, y ≤ N  x ≠ y  1 ≤ a, b ≤ 1018  Notes There will be at most one edge between a pair of nodes. There will be no loop. Tree will be completely connected.  Sample Input 4 1 2 2 3 3 4 4 U 3 2 2 2 U 2 3 2 2 R 1 2 8 R 4 3 9  Sample Output 2 3  Explanation Initially Values in each node : [0,0,0,0]  The first query is U 3 2 2 2. Here, tree is rooted at 3. It looks like  U 3 2 2 2     3(0)    / \   /   \  2(0)  4(0)  |  |  1(0)  For the sub tree rooted at 2 ( nodes 2 and 1 ), we add ab  + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After first update operation, nodes 1, 2, 3, and 4 will have values 22, 22, 0 and 0 respectively.       3(0)    / \   /   \  2(22) 4(0)  |  |  1(22)  The second query is U 2 3 2 2. Here, tree is rooted at 2. It looks like U 2 3 2 2     2(22)    / \   /   \  1(22) 3(0)        |        |        4(0)  For the sub tree rooted at 3 (nodes 3 and 4), we add ab + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After second update operation, nodes 1, 2, 3, and 4 each have values 22,22,22,22 respectively.       2(22)    / \   /   \  1(22) 3(22)        |        |        4(22)  The first report query is R 1 2 8 asks for the sum modulo 8 of the subtree rooted at 2, when the tree is rooted at 1. The tree looks like  R 1 2 8 1(22)  \   \    2*(22)    |    |    3*(22)    |    |    4*(22)  The sum of the values of nodes 2, 3 and 4 are  (22 + 22 + 22) % 8 = 2  The second report query is R 4 3 9 asks for the sum modulo 9 of the subtree rooted at 3 when the tree is rooted at 4. The tree looks like  R 4 3 9 4(22)  \   \    3*(22)    |    |    2*(22)    |    |    1*(22)  The sum of the values of nodes 3, 2 and 1 are  (22 + 22 + 22) % 9 = 3  Time Limits:  C, C++: 4s | Java and other JVM based languages: 10s | Python, Python3 = 45s | Other interpreted Language: 30s | C#, Haskell: 10s | Rest: 3 times of default.
__label__Data-Structures __label__Advanced-Data-Structures In this problem you operate on two arrays of  integers. We will call them the  and the  respectively.  Your goal is just to maintain them under the modification operations, such as:    1   : Reverse the subarray of the  array, starting at the  number, ending at the  number, inclusively;   2     : Swap two consecutive fragments of the  array, the first is from the  number to the , the second is from the  number to the ;   3  : Swap the piece that starts at the  number and end at the  one between the  and the  array;   4  : We consider only the piece from the  number to the  one. The numbers in the  array are -coordinates of some set of points and the numbers in the  array are -coordinates of them. For the obtained set of points we would like to place such a circle on a plane that would contain all the points in it and would have the minimal radius. Find this minimal radius.   Input Format  The first line of input contains two space separated integers  and  denoting the number of integers in arrays and the number of queries respectively.  The second line contains  space separated integers: the initial elements of the  array.  The third line contains  space separated integers: the initial elements of the  array.  Then there are  lines containing queries in the format listed above.   Output Format  For each type-4 query output the sought minimal radius with exactly two symbols after the decimal point precision.   Constraints    All the numbers in arrays are non-negative and don't exceed .  The sum of  over the type-4 queries won't exceed .  In the query of the type 2, .  In the queries of the types 1, 3, 4, ; . Sample Input 10 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 3 2 6 1 0 9 9 4 6 9 2 0 2 7 9 9 1 0 3 6 2 1 2 3 4 5 1 1 7 10 2 1 8 8 9 10 4 6 9 2 0 2 2 4 6  Example Output 2.12 2.50
__label__Data-Structures __label__Advanced-Data-Structures You are given a rooted tree with N nodes and the root of the tree, R, is also given. Each node of the tree contains a value, that is initially empty. You have to mantain the tree under two operations: Update Operation Report Operation Update Operation  Each Update Operation begins with the character U. Character U is followed by 3 integers T, V and K. For every node which is the descendent of the node T, update it's value by adding V + d*K, where V and K are the parameters of the query and d is the distance of the node from T. Note that V is added to node T.   U U Report Operation  Each Report Operation begins with the character Q. Character Q is followed by 2 integers, A and B. Output the sum of values of nodes in the path from A to B modulo (109 + 7)  Q Q Input Format  The first Line consists of 3 space separated integers, N E R, where N is the number of nodes present, E is the total number of queries (update + report), and R is root of the tree.   Each of the next N-1 lines contains 2 space separated integers, X and Y (X and Y are connected by an edge). Thereafter, E lines follows: each line can represent either the Update Operation or the Report Operation. Update Operation is of the form : U T V K. Report Operation is of the form : Q A B. Output Format  Output the answer for every given report operation. Constraints  1 ≤ N, E ≤ 105  1 ≤ E ≤ 105  1 ≤ R, X, Y, T, A, B ≤ N  1 ≤ V, K ≤ 109  X ≠ Y Sample Input 7 7 1 1 2 2 3 2 4 2 5 5 6 6 7 U 5 10 2 U 4 5 3 Q 1 7 U 6 7 4 Q 2 7 Q 1 4 Q 2 4  Sample Output 36 54 5 5  Explanation  Values of Nodes after U 5 10 2: [0 0 0 0 10 12 14]. U 5 10 2 [0 0 0 0 10 12 14] Values of Nodes after U 4 5 3: [0 0 0 5 10 12 14].  U 4 5 3 [0 0 0 5 10 12 14] Sum of the Nodes from 1 to 7: 0 + 0 + 10 + 12 + 14 = 36. Values of Nodes after U 6 7 4: [0 0 0 5 10 19 25].   U 6 7 4 Sum of the Nodes from 2 to 7: 0 + 10 + 19 + 25 = 54.  Sum of the Nodes from 1 to 4: 0 + 0 + 5 = 5. Sum of the Nodes from 2 to 4: 0 + 5 = 5.
__label__Data-Structures __label__Advanced-Data-Structures Natural numbers from 1 to N have been placed in an increasing order over some helix ( a circular structure ). When the helix starts rotating, it is easy to find out  The position of a given number The number located at a given position.  The helix has numbers arranged in the following fashion:   [1, 2, 3, ..., N]  Due to some malfunction, the helix has started rotating in a weird manner. Right now, every possible contiguous interval can be rotated, and hence, locating a particular number or identifying the number at a given position is almost impossible. For example, if at some particular instant, the integer list is like this: [1, 2, 3, 4, 5, ..., N]  rotating the interval [5...N] will leave the list like this: [1, 2, 3, 4, N, N - 1, N - 2, ..., 5]  We need a software to handle this. Can you help us? Input Format  The first line of the input consists of two space separated integers, N, Q. N signifies that initially our list contains numbers from 1 to N, placed in an increasing order. Q lines follow and contain input in one of the following formats:   1 A B  indicating that the helix rotated circularly in the interval [A..B] ( both inclusive); 2 A  indicating that we are interested in knowing the current position of the number A   3 A  indicating that we are interested in knowing the number at position A.   Output Format  For each line in the input of the form 2 A  2 A output a line saying  element A is at position x  where A is the number we are interested in and x is its current position. For each line of the form 3 A 3 A output a line saying  element at position A is x  where A is the position we are interested in and x is the integer located at this position.  Constraints  1 ≤ N, Q ≤ 105  positions are 1-indexed.    Sample Input 5 10 1 1 3 2 3 3 3 1 3 5 1 2 4 3 1 3 5 2 4 1 5 5 2 2  Sample Output element 3 is at position 1 element at position 3 is 1 element at position 1 is 3 element at position 5 is 1 element 4 is at position 2 element 2 is at position 4  Explanation Initially elements are placed like this: [1, 2, 3, 4, 5]  after the first rotation, they are placed like this: [3, 2, 1, 4, 5]  and that's how we get the first 2 results (first 2 lines in the output). After second rotation, they are placed like this: [3, 2, 5, 4, 1]  and third one does this: [3, 4, 5, 2, 1]  In the last rotation (1 5 5), it's easy to see that output matches the initial positions of the elements. Last rotation doesn't change the positions of the elements.
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Time Limits C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5 Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions: Any pair of servers within the network should be directly connected by at most 1 link. Each link is controlled by some specific network administrator. No server has more than 2 links connected to it, that are controlled by the same administrator. For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers) Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software.  Operations performed by the directives are: Change the administrator assigned to some particular link. Place some number of security devices along a particular link. Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers. Input Format  Input begins with a line containing 4 integers  separated by a single whitespace, denoting the number of servers, links, network administrators and transformations, respectively.  lines follow each one with 3 integers  and , saying that there is a link between server  and server , and that link is controlled by administrator . Initially, network topology fulfills the restrictions described above and there is no security device along any link. Remaining  lines in the input follow one the next formats:     meaning that link between server  and server   is requested to be assigned to administrator      meaning that the number of security devices along the link between server  and server   will be fixed to  , removing any existing devices on this link before the operation. The involved link will always exist.       meaning that directives want to know the number of security devices placed along the path between server  and server , just considering links controlled by administrator . Output Format  For each network transformation in the form     you should output: "Wrong link" if there is no direct link between server  and server . "Already controlled link" if the requested link does exist, but it is already controlled by administrator . "Server overload" if administrator  already controls 2 links connected to one of the involved servers. "Network redundancy" if the requested assignment creates no new connection considering just the links controlled by . "Assignment done" if none of the above conditions holds. In this case, link directly connecting  with  is assigned to . For each network transformation in the form     you should output: "No connection" if there is no path between the requested servers considering just the links controlled by . " security devices placed" where D is the number of security devices placed so far on the existing connection between the requested servers considering just the links controlled by .  Constraints           Sample Input: 4 5 3 15 1 2 1 2 3 1 3 4 2 1 4 2 1 3 3 2 3 4 49 1 1 2 3 2 1 4 64 3 1 4 2 1 1 2 3 3 4 2 3 3 1 3 3 1 1 4 3 3 3 4 2 3 2 4 1 2 1 4 13 2 1 3 21 2 2 3 24 1 2 3 3 1 2 4 3  Sample Output: Assignment done 64 security devices placed Already controlled link No connection 0 security devices placed Server overload 49 security devices placed No connection Network redundancy Wrong link
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  Initially all node values are zero.   The update query is of the format a1 d1 a2 d2 A B  This means you'd have to add  in all nodes in the path from A to B where  is the distance between the node and A. The retrieval query is of the format i j  You need to return the sum of the node values lying in the path from node i to node j modulo 1000000007.  Note:    First all update queries are given and then all retrieval queries.   Distance between 2 nodes is the shortest path length between them taking each edge weight as 1.   Input Format  The first line contains two integers (N and R respectively) separated by a space.   In the next N-1 lines, the ith line describes the ith edge: a line with two integers x y separated by a single space denotes an edge between nodes x and y.   The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.   U lines follow. Each of the next U lines contains 6 space separated integers (a1,d1,a2,d2,A and B respectively). Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 105  2 <= R <= 109  1 <= U <= 105  1 <= Q <= 105  1 <= a1,a2,d1,d2 <= 108  1 <= x, y, i, j, A, B  <= N   Note  For the update operation, x can be equal to y and for the query operation, i can be equal to j.   Sample Input  7 2 1 2 1 3 2 4 2 6 4 5 6 7 1 4 1 1 1 1 4 6 4 5 2 7 4 7 5 3  Sample Output 1 44 45 9  Explanation The node values after updation becomes :   0 8 0 1 0 36 0  Answer to Query #1: 1+0 = 1    Answer to Query #2: 8+36+0 = 44 Answer to Query #3: 1+8+36+0 = 45 Answer to Query #4: 0+1+8+0+0 = 9
__label__Data-Structures __label__Advanced-Data-Structures Consider a permutation, , of integers from  to . Let's determine the  of  to be the minimum absolute difference between any  consecutive integers in :    Generate a lexicographically sorted list of all permutations of length  having a maximal distance between all permutations of the same length. Print the lexicographically  permutation. Input Format The first line contains an integer,  (the number of test cases). The  subsequent lines each contain two space-separated integers,  (the permutation length) and  (the 1-based index in the list of permutations having a maximal distance), respectively. The  line corresponds to the  test case.  Note: It is guaranteed that the sum of all  does not exceed . Constraints    Output Format For each test case: if the list of permutations having maximal distance has at least  elements, print the  permutation as sequential (i.e.: from  to ) space-separated integers on a new line; otherwise, print . Sample Input 3 3 5 4 2 4 3  Sample Output 3 1 2 3 1 4 2 -1  Explanation For  and :              Each of the  permutations has distance . We choose the fifth one (because ), and print 3 1 2 on a new line. 3 1 2 For  and :  The maximal distance in the list of permutations of integers from  to  is , and the only permutations having that distance are  and . We choose the second one (because ), and print 3 1 4 2 on a new line. 3 1 4 2
__label__Data-Structures The LRT Company has  employees. Each employee has a unique ID number from  to , where the director's ID is number . Every employee in the company has exactly one immediate supervisor — except the director, who has no supervisor. The company's employee hierarchy forms a tree of employee IDs that's rooted at employee number  (the director). The director decides to have a retreat lasting  days. Each day, the employees will be assigned to different groups for team building exercises. Groups are constructed in the following way: An employee can invite their immediate supervisor (the director has no supervisor and, thus, doesn't invite anyone). If employee  is invited by employee , then  and  are considered to be in the same group. Once an employee is invited to be in a group, they are in that group. This means that if two employees have the same immediate supervisor, only one of them can invite that supervisor to be in their group.   Every employee must be in a group, even if they are the only employee in it. The venue where LRT is hosting the retreat has different pricing for each of the  days of the retreat. For each day , there is a cost of  dollars per group and a per-group size limit of  (i.e., the maximum number of people that can be in any group on that day). Help the director find optimal groupings for each day so the cost of the -day retreat is minimal, then print the total cost of the retreat. As this answer can be quite large, your answer must be modulo . Input Format The first line contains two space-separated integers denoting the respective values of  (the number of employees) and  (the retreat's duration in days).  The next line contains  space-separated integers where each integer  denotes  (), which is the ID number of employee 's direct supervisor.  Each line  of the  subsequent lines contain two space-separated integers describing the respective values of  (the cost per group in dollars) and  (the maximum number of people per group) for the  day of the retreat. Constraints    Subtask   for  of the maximum possible score. Output Format Print a single integer denoting the minimum total cost for the -day retreat. As this number can be quite large, print your answer modulo . Sample Input 7 3 1 1 3 4 2 4 5 3 6 2 1 1  Sample Output 46  Explanation In the Sample Case above, the company has  employees and the retreat goes on for  days. The hierarchy looks like this:   On the first day, the cost per group is  dollars and each group has a maximum size of . The employees split into the following three groups: Employee  invites their manager, employee . Employee  then invites their manager, employee  (the director). Employee  invites their manager, employee . Employee  then invites their manager, employee . Employee 's manager is already in another group, so they are in a group by themself. These groupings are demonstrated in the following image where each group has a different pattern:  In other words, the final groups are , , and . This means the total cost for the first day is  dollars. On the second day, they split into  groups with a maximum size of  at a total cost of  dollars. On the third day, they split into  groups of size  at a total cost of  dollars. When we sum the costs for all three days, we get  as our answer.
__label__Data-Structures __label__Advanced-Data-Structures Alice purchased an array of  wooden boxes that she indexed from  to . On each box , she writes an integer that we'll refer to as . Alice wants you to perform  operations on the array of boxes. Each operation is in one of the following forms: (Note: For each type of operations, ) 1 l r c: Add  to each . Note that  can be negative. 1 l r c 2 l r d: Replace each  with .  2 l r d 3 l r: Print the minimum value of any . 3 l r 4 l r: Print the sum of all . 4 l r Recall that  is the maximum integer  such that  (e.g.,  and ). Given , the value of each , and  operations, can you perform all the operations efficiently?  Input Format The first line contains two space-separated integers denoting the respective values of  (the number of boxes) and  (the number of operations).  The second line contains  space-separated integers describing the respective values of  (i.e., the integers written on each box).  Each of the  subsequent lines describes an operation in one of the four formats defined above. Constraints      Output Format For each operation of type  or type , print the answer on a new line. Sample Input 0 Sample Output 0 Explanation 0 Initially, the array of boxes looks like this:  We perform the following sequence of operations on the array of boxes: The first operation is 1 0 4 1, so we add  to each  where :   The first operation is 1 0 4 1, so we add  to each  where :   1 0 4 1 The second operation is 1 5 9 1, so we add  to each  where :   The second operation is 1 5 9 1, so we add  to each  where :   1 5 9 1 The third operation is 2 0 9 3, so we divide each  where  by  and take the floor:   2 0 9 3 The fourth operation is 3 0 9, so we print the minimum value of  for , which is the result of . 3 0 9 The fifth operation is 4 0 9, so we print the sum of  for , which is the result of . 4 0 9 ... and so on.
__label__Data-Structures Transforming data into some other data is typical of a programming job. This problem is about a particular kind of transformation which we'll call the max transform. Let  be a zero-indexed array of integers. For , let  denote the subarray of  from index  to index , inclusive. Let's define the max transform of  as the array obtained by the following procedure: Let  be a list, initially empty. For  from  to : For  from  to : Let .   Append  to the end of .   For  from  to : Let .   Append  to the end of .   Let .   Append  to the end of .   Return .   The returned array is defined as the max transform of . We denote it by .  Complete the function solve that takes an integer array  as input. solve Given an array , find the sum of the elements of , i.e., the max transform of the max transform of . Since the answer may be very large, only find it modulo .   Input Format The first line of input contains a single integer  denoting the length of .   The second line contains  space-separated integers  denoting the elements of .   Constraints     Subtasks  For  of the total score,   Output Format Print a single line containing a single integer denoting the answer.   Sample Input 0 Sample Output 0 Explanation 0 In the sample case, we have:   Therefore, the sum of the elements of  is .
