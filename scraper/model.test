__label__Tree Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]
__label__Array Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.
__label__Mathematics You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False
__label__Game-Theory Two players (numbered  and ) are playing a game of Tower Breakers! The rules of the game are as follows: Player  always moves first. Initially there are  towers of various heights. The players move in alternating turns. In each turn, a player must choose a tower of height  and break it down into  towers, each of height . The numbers  and  must satisfy  and .   If the current player is unable to make any move, they lose the game. Given the value of  and the respective height values for all towers, can you determine who will win, assuming both players always move optimally? If the first player wins, print ; otherwise, print . Input Format The first line contains an integer, , denoting the number of test cases.  The  subsequent lines define the test cases. Each test case is described by two lines: An integer, , denoting the number of towers.  space-separated integers, , where each  describes the height of tower . Constraints    Output Format For each test case, print a single integer denoting the winner (i.e., either  or ) on a new line. Sample Input 2 2  1 2 3  1 2 3  Sample Output 1 2  Explanation In the first test case, the first player simply breaks down the second tower of height  into two towers of height  and wins. In the second test case, there are only two possible moves: Break the second tower into  towers of height . Break the third tower into  towers of height .  Whichever move player  makes, player  can make the other move and win the game.
__label__Strings Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5
__label__Tree __label__Depth-first-Search Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.
__label__Array Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.
__label__Mathematics __label__Strings Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.
__label__Dynamic-Programming The evil forest is guarded by vicious mandragoras. Garnet and her pet must make a journey through.  She starts with  health point () and  experience points.     As she encouters each mandragora, her choices are: Garnet's pet eats mandragora . This increments  by  and defeats mandragora .   Garnet's pet battles mandragora . This increases  by  experience points and defeats mandragora .  Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.   For example, as always, she starts out with  health point and  experience points.  Mandragoras have the following health values: .  For each of the beings, she has two choices, at or attle.  We have the following permutations of choices and outcomes: Action  s   p _______ _   __ e, e, e 4   0 e, e, b 3   15 e, b, b 2   14 b, b, b 1   10 b, b, e 2   10 b, e, e 3   9 b, e, b 2   16 e, b, e 3   6  Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have  health points, then battles the beast with  heatlth points to gain  experience points.  We see that the best option is to eat the beast with  points and battle the others to achieve  experience points. Function Description  Complete the mandragora function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn. mandragora has the following parameter(s):   H: an array of integers that represents the health values of mandragoras   Input Format The first line contains an integer, , denoting the number of test cases. Each test case is described over two lines: The first line contains a single integer , the number of mandragoras in the forest.  The second line contains  space-separated integers describing the respective health points for the mandragoras .     Constraints     , where   The sum of all s in a single test case is   Output Format For each test case, print a single line with an integer denoting the maximum number of experience points that Garnet can earn. Sample Input 1 3 3 2 2  Sample Output 10   Explanation There are  mandragoras having the following health points: . Initially,  and . The following is an optimal sequence of actions for achieving the maximum number of experience points possible:   Eat the second mandragora ().  is increased from  to , and  is still .  Battle the first mandragora ().  remains the same, but  increases by  experience points.  Battle the third mandragora ().  remains the same, but  increases by  experience points.  Garnet earns  experience points.
__label__Greedy-Algorithms Given two integers A and B, return any string S such that:  S has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters; The substring 'aaa' does not occur in S; The substring 'bbb' does not occur in S.    Example 1: Input: A = 1, B = 2 Output: "abb" Explanation: "abb", "bab" and "bba" are all correct answers.   Example 2: Input: A = 4, B = 1 Output: "aabaa"    Note:  0 <= A <= 100 0 <= B <= 100 It is guaranteed such an S exists for the given A and B.
__label__Array __label__Dynamic-Programming In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.    Note:  nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool Given pointers to the head nodes of  linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL. In the diagram below, the two lists converge at Node x: x [List #1] a--->b--->c                      \                       x--->y--->z--->NULL                      /      [List #2] p--->q  Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge.  int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) Input Format Do not read any input from stdin/console. The findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) method has two parameters,  and , which are the non-null head Nodes of two separate linked lists that are guaranteed to converge.   findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) Constraints The lists will merge.  .   .  Output Format Do not write any output to stdout/console.  Each Node has a data field containing an integer.  Return the integer data for the Node where the two lists merge.   Sample Input The diagrams below are graphical representations of the lists that input Nodes  and  are connected to. Recall that this is a method-only challenge; the method only has initial visibility to those  Nodes and must explore the rest of the Nodes using some algorithm of your own design. Test Case 0  1   \    2--->3--->NULL   /  1  Test Case 1 1--->2       \        3--->Null       /      1  Sample Output 2 3  Explanation Test Case 0: As demonstrated in the diagram above, the merge Node's data field contains the integer .  Test Case 1: As demonstrated in the diagram above, the merge Node's data field contains the integer .
__label__Greedy-Algorithms Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.    Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
__label__Dynamic-Programming Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
__label__Array __label__Two-Pointers You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element. Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.   Example 1: Input: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.  Example 2: Input: [-1,2] Output: false Explanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.  Example 3: Input: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction.   Note:  -1000 ≤ nums[i] ≤ 1000 nums[i] ≠ 0 1 ≤ nums.length ≤ 5000    Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?
__label__Game-Theory Nim is a famous game in which two players take turns removing items from  distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player removes the last item from the last non-empty pile. John and Kate modified Nim by adding the following rule, which they call a Zero-Move: For each non-empty pile, either player can remove  items from that pile and have it count as their move; however, this move can only be performed once per pile by either player. For example, let's say pile  initially has  items in it. If John decides to use a Zero-Move on pile , then neither John nor Kate can perform another Zero-Move on pile ; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet. John and Kate play  games of Zero-Move Nim. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print W on a new line if John can win; otherwise, print L instead. W L Input Format The first line contains an integer, , denoting the number of games. The  subsequent lines describe each game over two lines: The first line contains an integer, , denoting the number of heaps. The second line contains  space-separated integers describing .  Constraints       Subtasks  For  of the test cases,   For  of the test cases,  Output Format For each game, print W on a new line if John will win; otherwise, print L instead. W L Sample Input 0 Sample Output 0 Explanation 0 John and Kate play the following  games: We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. W John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. L
__label__Game-Theory Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects.  Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows:  Initially there are  piles of stones; pile  has  stone, pile  has  stones, and so on. Thus, the  pile has  stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy at least half of the stones in it. The winner is the saint who destroys the last available stone .  For example, from a pile of  stones, a saint must destroy at least  stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills. Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?   Input Format First line of the input consists of an integer ,  testcases follow, each in a new line. Each line will contain a single integer , which describes the number of initial piles as explained above. Constraints    Output Format For each line in the input, output the minimum number of stones Ryuho needs to destroy in his first turn, assuming he starts playing and that both he and Koga play always as well as possible. If this is not possible, just print . Sample Input 0 Sample Output 0 Explanation 0 For the first testcase, we can see that the saint can destroy the first stone and win the game.  Sample Input 1 Sample Output 1 Explanation 1 There are three piles with stones  and . Initially Ryuho will remove  stone from the first pile. Now other saint has  options -  First, to remove all stones from second pile. In that case Ryuho will remove all stones from third pile and win the game. Second, to remove all stones from third pile. In that case Ryuho will remove all stones from second pile and win the game. Third, to remove  stone from second pile. In that case Ryuho will remove  stones from third pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. Fourth, to remove  stones from the third pile. In that case Ryuho will remove  stone from second pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. So in all four cases Ryuho will win the game.
__label__Dynamic-Programming __label__Mathematics Consider an array, , of length . We can split  into contiguous segments called pieces and store them as another array, . For example, if , we have the following arrays of pieces:  contains three -element pieces.  contains two pieces, one having  elements and the other having  element.  contains two pieces, one having  element and the other having  elements.  contains one -element piece. We consider the value of a piece in some array  to be , and we consider the total value of some array  to be the sum of the values for all pieces in that . For example, the total value of  is . Given , find the total values for all possible 's, sum them together, and print this sum modulo  on a new line. Input Format The first line contains a single integer, , denoting the size of array .  The second line contains  space-separated integers describing the respective values in  (i.e., ). Constraints   Output Format Print a single integer denoting the sum of the total values for all piece arrays ('s) of , modulo . Sample Input 0 3 1 3 6  Sample Output 0 73  Explanation 0  Given , our piece arrays are: , and . , and . , and . , and . When we sum all the total values, we get . Thus, we print the result of  on a new line. Sample Input 1 5 4 2 9 10 1  Sample Output 1 971
__label__Array On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move.   Example 1:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  In this example the rook is able to capture all the pawns.  Example 2:  Input: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 0 Explanation:  Bishops are blocking the rook to capture any pawn.  Example 3:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  The rook can capture the pawns at positions b5, d6 and f5.    Note:  board.length == board[i].length == 8 board[i][j] is either 'R', '.', 'B', or 'p' There is exactly one cell with board[i][j] == 'R'
__label__Strings Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.   Example 1: Input: "cdadabcc" Output: "adbc"   Example 2: Input: "abcd" Output: "abcd"   Example 3: Input: "ecbacba" Output: "eacb"   Example 4: Input: "leetcode" Output: "letcod"    Note:  1 <= text.length <= 1000 text consists of lowercase English letters.
__label__Strings Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  In these strings like "heeellooo", we have groups of adjacent letters that are all the same:  "h", "eee", "ll", "ooo". For some given string S, a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is 3 or more. For example, starting with "hello", we could do an extension on the group "o" to get "hellooo", but we cannot get "helloo" since the group "oo" has size less than 3.  Also, we could do another extension like "ll" -> "lllll" to get "helllllooo".  If S = "helllllooo", then the query word "hello" would be stretchy because of these two extension operations: query = "hello" -> "hellooo" -> "helllllooo" = S. Given a list of query words, return the number of words that are stretchy.    Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.    Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters
__label__Hash-Table __label__Two-Pointers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A.   Example 1: Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].  Example 2: Input: A = [1,2,1,3,4], K = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].    Note:  1 <= A.length <= 20000 1 <= A[i] <= A.length 1 <= K <= A.length
__label__Graph-Algorithms You are given an array with  -bit integers: . BIT(x, i) = (x >> i) & 1. (where  is the  lower bit of  in binary form.) If we regard every bit as a vertex of a graph G, there exists one undirected edge between vertex  and vertex  if there exists at least one k such that BIT(d[k], i) == 1 && BIT(d[k], j) == 1. For every subset of the input array, how many  connected-components are there in that graph? The number of connected-components in a graph are the sets of nodes, which are accessible to each other, but not to/from the nodes in any other set.   For example if a graph has six nodes, labelled . And contains the edges . There are three connected-components: ,  and . Because  can be accessed from each other through one or more edges,  can access each other and  is isolated from everone else.   You only need to output the sum of the number of connected-component() in every graph. Input Format n d[0] d[1] ... d[n - 1]  Constraints    Output Format Print the value of .
__label__Two-Pointers Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.    Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.     Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.     Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.      Follow up: Can you solve it using O(1) (i.e. constant) memory?
__label__Array __label__Dynamic-Programming Given a matrix, and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.   Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0.   Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.     Note:  1 <= matrix.length <= 300 1 <= matrix[0].length <= 300 -1000 <= matrix[i] <= 1000 -10^8 <= target <= 10^8
__label__Search __label__Dynamic-Programming There are  variables and  requirements. Requirements are represented as , meaning that the  variable must be less than or equal to the  variable.  Your task is to assign non-negative numbers smaller than  to each variable and then calculate the number of different assignments satisfying all requirements. Two assignments are different if and only if at least one variable is assigned to a different number in both assignments. Print your answer modulo . Input Format The first line contains  space-separated integers,  and , respectively. Each of the  subsequent lines contains  space-seperated integers describing the respective  and  values for an  requirement. Constraints    Output Format Print your answer modulo . Sample Input 0 Sample Output 0 Explanation 0 There are  variables and  requirements. Let the variables be in the array . Requirements are -  One of the assignments is -  Similarly there are  assignments possible. Result = .
__label__Tree __label__Data-Structures You are given pointer to the root of the binary search tree and two values  and . You need to return the lowest common ancestor (LCA) of  and  in the binary search tree.     In the diagram above, the lowest common ancestor of the nodes  and  is the node .  Node  is the lowest node which has nodes  and  as descendants. Function Description  Complete the function lca in the editor below.  It should return a pointer to the lowest common ancestor node of the two values given.   lca has the following parameters:  -  root: a pointer to the root node of a binary search tree  -  v1: a node.data value  -  v2: a node.data value   Input Format The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers representing  values.  The third line contains two space-separated integers,  and .   To use the test data, you will have to create the binary search tree yourself.  Here on the platform, the tree will be created for you. Constraints       The tree will contain nodes with data equal to  and .   Output Format Return the a pointer to the node that is the lowest common ancestor of  and . Sample Input 6 4 2 3 1 7 6 1 7     and . Sample Output [reference to node 4] Explanation LCA of  and  is , the root in this case.  Return a pointer to the node.
__label__Strings We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9
__label__Array We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.
__label__Array Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.   Example 1: Input: day = 31, month = 8, year = 2019 Output: "Saturday"  Example 2: Input: day = 18, month = 7, year = 1999 Output: "Sunday"  Example 3: Input: day = 15, month = 8, year = 1993 Output: "Sunday"    Constraints:  The given dates are valid dates between the years 1971 and 2100.
__label__Depth-first-Search An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].
__label__Graph-Algorithms In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the red knight.   The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below.   The board is a grid of size . Each cell is identified with a pair of coordinates , where  is the row number and  is the column number, both zero-indexed. Thus,  is the upper-left corner and  is the bottom-right corner.  Complete the function printShortestPath, which takes as input the grid size , and the coordinates of the starting and ending position  and  respectively, as input. The function does not return anything.      printShortestPath Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word "Impossible".  Note: There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority: UL, UR, R, LR, LL, L. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input  for an illustration. Input Format The first line of input contains a single integer . The second line contains four space-separated integers .  denotes the coordinates of the starting position and  denotes the coordinates of the final position. Constraints     the starting and the ending positions are different Output Format If the destination can be reached, print two lines. In the first line, print a single integer denoting the minimum number of moves that the red knight has to make in order to reach the destination. In the second line, print the space-separated sequence of moves.  If the destination cannot be reached, print a single line containing only the word Impossible. Impossible Sample Input 0 Sample Output 0 Explanation 0  Sample Input 1 Sample Output 1 Explanation 1  Sample Input 2 Sample Output 2 Explanation 2
__label__Bit Louise and Richard have developed a numbers game.  They pick a number and check to see if it is a power of .  If it is, they divide it by .  If not, they reduce it by the next lower number which is a power of .  Whoever reduces the number to  wins the game.  Louise always starts. Given an initial value, determine who wins the game. As an example, let the initial value .  It's Louise's turn so she first determines that  is not a power of .  The next lower power of  is , so she subtracts that from  and passes  to Richard.   is a power of , so Richard divides it by  and passes  to Louise.  Likewise,  is a power so she divides it by  and reaches .  She wins the game. Update If they initially set counter to , Richard wins.  Louise cannot make a move so she loses. Function Description  Complete the counterGame function in the editor below.  It should return the winner's name, either Richard or Louise.   Richard Louise counterGame has the following parameter(s):   n: an integer to initialize the game counter   Input Format The first line contains an integer , the number of testcases.  Each of the next  lines contains an integer , the initial value for the game.   Constraints   Output Format For each test case, print the winner's name on a new line in the form Louise or Richard. Louise Richard Sample Input 0 Sample Output 0 Explanation 0  is not a power of  so Louise reduces it by the largest power of  less than :.    is a power of  so Richard divides by  to get  and wins the game.
__label__Depth-first-Search Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.) A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit. Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.   Example 1:  Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1  Output: [1,2,3,4,null,null,7,8,9,null,14]   Example 2:  Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22  Output: [5,4,8,11,null,17,4,7,null,null,null,5]   Example 3:  Input: root = [1,2,-3,-5,null,4,null], limit = -1  Output: [1,null,-3,4]    Note:  The given tree will have between 1 and 5000 nodes. -10^5 <= node.val <= 10^5 -10^9 <= limit <= 10^9
__label__Tree Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]
__label__Depth-first-Search (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Search __label__Mathematics Sunny and Johnny like to pool their money and go to the ice cream parlor.  Johnny never buys the same flavor that Sunny does.  The only other rule they have is that they spend all of their money. Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.   For example, they have  to spend and there are flavors costing .  The two flavors costing  and  meet the criteria.  Using -based indexing, they are at indices  and .   Function Description Complete the icecreamParlor function in the editor below.  It should return an array containing the indices of the prices of the two flavors they buy, sorted ascending.   icecreamParlor has the following parameter(s):   m: an integer denoting the amount of money they have to spend   cost: an integer array denoting the cost of each flavor of ice cream   Input Format The first line contains an integer, , denoting the number of trips to the ice cream parlor.   The next  sets of lines each describe a visit.  Each trip is described as follows: The integer , the amount of money they have pooled.  The integer , the number of flavors offered at the time.   space-separated integers denoting the cost of each flavor: .   Note:  The index within the cost array represents the flavor of the ice cream purchased.   Constraints       , ∀   There will always be a unique solution. Output Format For each test case, print two space-separated integers denoting the indices of the two flavors purchased, in ascending order.   Sample Input 2 4 5 1 4 5 3 2 4 4 2 2 4 3  Sample Output 1 4 1 2  Explanation Sunny and Johnny make the following two trips to the parlor: The first time, they pool together  dollars. Of the five flavors available that day, flavors  and  have a total cost of .   The second time, they pool together  dollars. TOf the four flavors available that day, flavors  and  have a total cost of .
__label__Strings Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2. One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index i to index j (i<=j) and asked them to find their strength. i j The strength of the group of students from i to j is defined as: strength(i , j) {     if a[i] = 0         return 0; //If first child has value 0 in the group, strength of group is zero     value = 0;     for k from i to j         value = value*10 + a[k]     return value; }   Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof. Input Format First line contains number of test cases T  Next T line contains the numbers of number plates the students were having when standing in the row in the form of a string A. Constraints 1 ≤ T ≤ 100  1 ≤ len(A) ≤ 105  0 ≤ A[i] ≤ 9 Output Format Output the total number of strengths of the form 2x such that 0 ≤ x ≤ 800.  Sample Input 0 Sample Output 0 Explanation 0 In following explanations group i-j is group of student from index i to index j (1-based indexing) In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In third case 65536 is only number in required form. It is strength of group 1-5 In third case 65536 is only number in required form. It is strength of group 1-5 In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fifth case, None of the group has strength of required form.   In fifth case, None of the group has strength of required form.
__label__Depth-first-Search In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.     Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0  Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0  Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Bit __label__Data-Structures __label__Advanced-Data-Structures You are given an array, , consisting of  integers. A segment, , is beautiful if and only if the bitwise AND of all numbers in  with indices in the inclusive range of  is not greater than . In other words, segment  is beautiful if . You must answer  queries. Each query, , consists of  integers: , , and . The answer for each  is the number of beautiful segments  such that  and . Input Format The first line contains two space-separated integers,  (the number of integers in ) and  (the number of queries). The second line contains  space-separated integers, where the  integer denotes the  element of array . Each line  of the  subsequent lines contains  space-separated integers, , , and , respectively, describing query . Constraints       holds for test cases worth at least  of the problem's score.  holds for test cases worth at least  of the problem's score.  Output Format Print  lines, where the  line contains the number of beautiful segments for query . Sample Input 5 3 1 2 7 3 4 1 5 3 2 4 6 3 5 2  Sample Output 13 5 2  Explanation The beautiful segments for all queries are listed below. Query 0: The beautiful segments are . Query 1: The beautiful segments are . Query 2: The beautiful segments are .
__label__Mathematics __label__Dynamic-Programming Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:  Choosing any x with 0 < x < N and N % x == 0. Replacing the number N on the chalkboard with N - x.  Also, if a player cannot make a move, they lose the game. Return True if and only if Alice wins the game, assuming both players play optimally.      Example 1: Input: 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves.   Example 2: Input: 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.    Note:  1 <= N <= 1000
__label__Array In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000
__label__Mathematics Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0.      Example 1: Input: [2,1,2] Output: 5   Example 2: Input: [1,2,1] Output: 0   Example 3: Input: [3,2,3,4] Output: 10   Example 4: Input: [3,6,2,3] Output: 8    Note:  3 <= A.length <= 10000 1 <= A[i] <= 10^6
__label__Tree __label__Depth-first-Search Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B. (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)   Example 1:  Input: [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation:  We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.    Note:  The number of nodes in the tree is between 2 and 5000. Each node will have value between 0 and 100000.
__label__Array Given an array A, we can perform a pancake flip: We choose some positive integer k <= A.length, then reverse the order of the first k elements of A.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A. Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.   Example 1: Input: [3,2,4,1] Output: [4,2,4,3] Explanation:  We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: A = [3, 2, 4, 1] After 1st flip (k=4): A = [1, 4, 2, 3] After 2nd flip (k=2): A = [4, 1, 2, 3] After 3rd flip (k=4): A = [3, 2, 1, 4] After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted.    Example 2: Input: [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted.     Note:  1 <= A.length <= 100 A[i] is a permutation of [1, 2, ..., A.length]
__label__Binary-Search (This problem is an interactive problem.) You may recall that an array A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i] A[i] > A[i+1] > ... > A[A.length - 1]    Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target.  If such an index doesn't exist, return -1. You can't access the mountain array directly.  You may only access the array using a MountainArray interface:  MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array.  Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer.  Also, any solutions that attempt to circumvent the judge will result in disqualification.     Example 1: Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1.    Constraints:  3 <= mountain_arr.length() <= 10000 0 <= target <= 10^9 0 <= mountain_arr.get(index) <= 10^9
__label__Data-Structures There are  values to represent nodes in a graph. They are divided into two sets  and . Each set has exactly  values. Set  is represent by .  can contain any value between  to (inclusive). Set  is represented by .  can contain any value between  to (inclusive). Same value can be chosen any number of times.   Here  represents the edges of the graph.   Your task is to print the number of vertices in the smallest and the largest connected components of the graph.   Note Single nodes should not be considered in the answer.  For more clarity look at the following figure.    For the above graph smallest connected component is 7 and largest connected component is 17.   Input Format First line contains an integer .  Each of the next  lines contain two space-separated integers,  line contains  and .   Constraints       Output Format Print two space separated integers, the number of vertices in the smallest and the largest components. Sample Input 5 1 6  2 7 3 8 4 9 2 6  Sample Output 2 4  Explanation The number of vertices in the smallest connected component in the graph is  i.e. either  or .  The number of vertices in the largest connected component in the graph is  i.e. .
__label__Strings Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.
__label__Strings Return the result of evaluating a given boolean expression, represented as a string. An expression can either be:  "t", evaluating to True; "f", evaluating to False; "!(expr)", evaluating to the logical NOT of the inner expression expr; "&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...; "|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...    Example 1: Input: expression = "!(f)" Output: true  Example 2: Input: expression = "|(f,t)" Output: true  Example 3: Input: expression = "&(t,f)" Output: false  Example 4: Input: expression = "|(&(t,f,t),!(t))" Output: false    Constraints:  1 <= expression.length <= 20000 expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}. expression is a valid expression representing a boolean, as given in the description.
__label__Strings A gene is represented as a string of length  (where  is divisible by ), composed of the letters , , , and . It is considered to be steady if each of the four letters occurs exactly  times.  For example,  and  are both steady genes. Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string .  It is not necessarily steady.  Fortunately, Limak can choose one (maybe empty) substring of  and replace it with any string of the same length. Modifying a large substring of bear genes can be dangerous. Given a string , can you help Limak find the length of the smallest possible substring that he can replace to make  a steady gene? Note: A substring of a string  is a subsequence made up of zero or more contiguous characters of . As an example, consider .  The substring  just before or after  can be replaced with  or .  One selection would create . Function Description Complete the  function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.   steadyGene has the following parameter:   gene: a string Input Format The first line contains an interger  divisible by , that denotes the length of a string .  The second line contains a string  of length . Constraints    is divisible by     Subtask   in tests worth  points. Output Format Print the length of the minimum length substring that can be replaced to make  stable. Sample Input 8   GAAATAAA  Sample Output 5  Explanation One optimal solution is to replace  with  resulting in .  The replaced substring has length .
__label__Mathematics __label__Two-Pointers We sampled integers between 0 and 255, and stored the results in an array count:  count[k] is the number of integers we sampled equal to k. Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers.  The mode is guaranteed to be unique. (Recall that the median of a sample is:  The middle element, if the elements of the sample were sorted and the number of elements is odd; The average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)    Example 1: Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,3.00000,2.37500,2.50000,3.00000] Example 2: Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,4.00000,2.18182,2.00000,1.00000]    Constraints:  count.length == 256 1 <= sum(count) <= 10^9 The mode of the sample that count represents is unique. Answers within 10^-5 of the true value will be accepted as correct.
__label__Strings Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.  Example: Input: "23" Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].  Note: Although the above answer is in lexicographical order, your answer could be in any order you want.
__label__Mathematics A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.
__label__Strings Given a string of lowercase letters in the range ascii[a-z], determine a character that can be removed to make the string a palindrome.  There may be more than one solution, but any will do.  For example, if your string is "bcbc", you can either remove 'b' at index  or 'c' at index .  If the word is already a palindrome or there is no solution, return -1.  Otherwise, return the index of a character to remove.   Function Description  Complete the palindromeIndex function in the editor below.  It must return the index of the character to remove or .   palindromeIndex has the following parameter(s):   s: a string to analyze Input Format The first line contains an integer , the number of queries.  Each of the next  lines contains a query string . Constraints     All characters are in the range ascii[a-z]. Output Format Print an integer denoting the zero-indexed position of the character to remove to make   a palindrome.  If  is already a palindrome or no such character exists, print .  Sample Input 3 aaab baa aaa  Sample Output 3 0 -1  Explanation Query 1: "aaab"  Removing 'b' at index  results in a palindrome, so we print  on a new line.      Query 2: "baa"  Removing 'b' at index  results in a palindrome, so we print  on a new line. Query 3: "aaa"  This string is already a palindrome, so we print .  Removing any one of the characters would result in a palindrome, but this test comes first. Note: The custom checker logic for this challenge is available here.
__label__Strings International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.
__label__Dynamic-Programming You have a warehouse with  containers filled with an infinite number of candies. The containers are arranged in a single row, equally spaced to be  meter apart. You also have  robots that can pick up  piece of candy and transport it between any two containers. The robots take instructions in the form of queries consisting of two integers,  and , respectively. To execute a query, a robot travels to container , picks up  candy, transports it to container , and then stops at  until it receives another query.    Calculate the minimum total distance the robots must travel to execute  queries in order.  Note: You choose which robot executes each query. Input Format The first line contains a single integer,  (the number of test cases); each of the  test cases is described over  lines.      The first line of a test case has two space-separated integers,  (the number of containers) and  (the number of queries).  The  subsequent lines each contain two space-separated integers,  and , respectively; each line  describes the  query. Constraints            Output Format On a new line for each test case, print an integer denoting the minimum total distance that the robots must travel to execute the queries in order. Sample Input 3 5 4 1 5 3 2 4 1 2 4 4 2 1 2 4 3 10 3 2 4 5 4 9 8  Sample Output 11 2 5  Explanation In this explanation, we refer to the two robots as  and , each container  as , and the total distance traveled for each query  as .  Note: For the first query a robot executes, there is no travel distance. For each subsequent query that robot executes, it must travel from the location where it completed its last query. Test Case 0:  The minimum distance traveled is :       Robot:      meters. Robot:      meter.     Robot:      meters.        Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 1:  Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 2:  Robot:      meters. Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line.
__label__Dynamic-Programming Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.  For example, if the string is , the substrings are  and .  Their sum is . Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo .   Function Description Complete the substrings function in the editor below.  It should return the sum of the integer values of all substrings in a string representation of a number, modulo .   substrings has the following parameter(s):   n: the string representation of an integer   Input Format A single line containing an integer as a string without leading zeros.   Constraints  Output Format A single line which is sum of the substrings,  Sample Input 0 Sample Output 0 Explanation 0 The substring of number 16 are 16, 1 and 6 which sums to 23. 16 16, 1 6 23 Sample Input 1 Sample Output 1 Explanation 1 The sub-strings of 123 are 1, 2, 3, 12, 23, 123 which sums to 164.  123 1, 2, 3, 12, 23, 123 164
__label__Graph-Algorithms Let  be a connected, directed graph with vertices numbered from  to  such that any vertex is reachable from vertex . In addition, any two distinct vertices,  and , are connected by at most one edge . Consider the standard DFS (Depth-First Search) algorithm starting from vertex . As every vertex is reachable, each edge  of  is classified by the algorithm into one of four groups: tree edge: If  was discovered for the first time when we traversed . back edge: If  was already on the stack when we tried to traverse . forward edge: If  was already discovered while  was on the stack. cross edge: Any edge that is not a tree, back, or forward edge. To better understand this, consider the following C++ pseudocode: Given four integers, , , , and , construct any graph  having exactly  tree edges, exactly  back edges, exactly  forward edges, and exactly  cross edges. Then print  according to the Output Format specified below. Input Format A single line of four space-separated integers describing the respective values of , , , and . Constraints  Output Format If there is no such graph , print -1; otherwise print the following: -1 The first line must contain an integer, , denoting the number of vertices in . Each line  of the  subsequent lines must contain the following space-separated integers: The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. Sample Input 0 Sample Output 0 Explanation 0 The DFS traversal order is: . Thus, ,  and  are tree edges;  is a back edge;  is a forward edge; and  is a cross edge. This is demonstrated by the diagram below, in which tree edges are black, forward edges are blue, back edges are red, and cross edges are green.  Sample Input 1 Sample Output 1 Explanation 1 No such graph exists satisfying the given values.
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Time Limits C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5 Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions: Any pair of servers within the network should be directly connected by at most 1 link. Each link is controlled by some specific network administrator. No server has more than 2 links connected to it, that are controlled by the same administrator. For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers) Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software.  Operations performed by the directives are: Change the administrator assigned to some particular link. Place some number of security devices along a particular link. Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers. Input Format  Input begins with a line containing 4 integers  separated by a single whitespace, denoting the number of servers, links, network administrators and transformations, respectively.  lines follow each one with 3 integers  and , saying that there is a link between server  and server , and that link is controlled by administrator . Initially, network topology fulfills the restrictions described above and there is no security device along any link. Remaining  lines in the input follow one the next formats:     meaning that link between server  and server   is requested to be assigned to administrator      meaning that the number of security devices along the link between server  and server   will be fixed to  , removing any existing devices on this link before the operation. The involved link will always exist.       meaning that directives want to know the number of security devices placed along the path between server  and server , just considering links controlled by administrator . Output Format  For each network transformation in the form     you should output: "Wrong link" if there is no direct link between server  and server . "Already controlled link" if the requested link does exist, but it is already controlled by administrator . "Server overload" if administrator  already controls 2 links connected to one of the involved servers. "Network redundancy" if the requested assignment creates no new connection considering just the links controlled by . "Assignment done" if none of the above conditions holds. In this case, link directly connecting  with  is assigned to . For each network transformation in the form     you should output: "No connection" if there is no path between the requested servers considering just the links controlled by . " security devices placed" where D is the number of security devices placed so far on the existing connection between the requested servers considering just the links controlled by .  Constraints           Sample Input: 4 5 3 15 1 2 1 2 3 1 3 4 2 1 4 2 1 3 3 2 3 4 49 1 1 2 3 2 1 4 64 3 1 4 2 1 1 2 3 3 4 2 3 3 1 3 3 1 1 4 3 3 3 4 2 3 2 4 1 2 1 4 13 2 1 3 21 2 2 3 24 1 2 3 3 1 2 4 3  Sample Output: Assignment done 64 security devices placed Already controlled link No connection 0 security devices placed Server overload 49 security devices placed No connection Network redundancy Wrong link
__label__Greedy-Algorithms Consider two -element arrays of integers,  and . You want to permute them into some  and  such that the relation  holds for all  where . For example, if , , and , a valid  satisfying our relation would be  and ,  and . You are given  queries consisting of , , and . For each query, print YES on a new line if some permutation ,  satisfying the relation above exists.  Otherwise, print NO.   YES NO Function Description  Complete the twoArrays function in the editor below.  It should return a string, either YES or NO.   YES NO twoArrays has the following parameter(s):   k: an integer   A: an array of integers   B: an array of integers   Input Format The first line contains an integer , the number of queries.  The next  sets of  lines are as follows: The first line contains two space-separated integers  and , the size of both arrays  and , and the relation variable. The second line contains  space-separated integers . The third line contains  space-separated integers . Constraints     Output Format For each query, print YES on a new line if valid permutations exist.  Otherwise, print NO. YES NO Sample Input 2 3 10 2 1 3 7 8 9 4 5 1 2 2 1 3 3 3 4  Sample Output YES NO  Explanation We perform the following two queries: , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  YES , , and . To permute  and  into a valid  and , we would need at least three numbers in  to be greater than ; as this is not the case, we print NO on a new line. NO
__label__Mathematics __label__Game-Theory Alice and Bob play the following game: They choose a permutation of the numbers  to .   Alice plays first and they alternate.   In a turn, they can remove any one remaining number from the permutation.   The game ends when the remaining numbers form an increasing sequence of  or more numbers. The person who played the last turn (after which the sequence becomes increasing) wins the game.   Assuming both play optimally, who wins the game?   For example, if  the starting permutation might be .  First, Alice chooses  or  (use  for the example) leaving .  Since this is a decreasing sequence, Bob can remove any number for optimum play (he will lose regardless).  Alice then removes any number leaving an array of only one element.  Since Alice removed the last element to create an increasing sequence, Alice wins.  Function Description  Complete the permutationGame function in the editor below.  It should return a string that represents the winner of the game, either Bob or Alice.   Bob Alice permutationGame has the following parameter:  - arr: an array of integers that represents the starting permutation   Input Format The first line contains the number of test cases .   Each of the next  pairs of lines is in the following format:  - The first line contains an integer , the size of the array   - The second line contains  space-separated integers,  where   Constraints    The permutation will not be an increasing sequence initially. Output Format Output  lines, one for each test case, containing Alice if Alice wins the game and Bob otherwise.   Alice Bob Sample Input 2 3 1 3 2 5 5 3 2 1 4  Sample Output Alice Bob  Explanation For the first test, Alice can remove the  or the  to make the sequence increasing and wins the game.     For the second test, if  is removed then the only way to have an increasing sequence is to only have  number left.  This would take a total of  moves, thus allowing Bob to win. On the first move if Alice removes the , it will take  more moves to create an increasing sequence thus Bob wins. If Alice does not remove the , then Bob can remove it on his next turn to create the same game state to win (decreasing sequence,  numbers left).
__label__Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__Greedy-Algorithms Sean invented a game involving a  matrix where each cell of the matrix contains an integer. He can reverse any of its rows or columns any number of times.  The goal of the game is to maximize the sum of the elements in the  submatrix located in the upper-left quadrant of the matrix. Given the initial configurations for  matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.   For example, given the matrix: It is  so we want to maximize the top left  matrix.  Reverse row : And now reverse column : The maximal sum is . Function Description  Complete the flippingMatrix function in the editor below.  It should return an integer that represents the maximum sum possible for the top  matrix.   flippingMatrix has the following parameters:  - matrix: a  array of integers   Input Format The first line contains an integer , the number of queries.    The next  sets of lines are in the following format: The first line of each query contains an integer, .  Each of the next  lines contains  space-separated integers  in row  of the matrix.   Constraints     , where . Output Format You must print  lines of output. For each query, print the maximum possible sum of the elements in the matrix's upper-left quadrant. Sample Input 1 2 112 42 83 119 56 125 56 49 15 78 101 43 62 98 114 108  Sample Output 414  Explanation We start out with the following  matrix:   We can perform the following operations to maximize the sum of the  submatrix in the upper-left corner: Reverse column  (), resulting in the matrix:   Reverse row  (), resulting in the matrix:   When we sum the values in the  submatrix in the upper-left quadrant, we get .
__label__Array __label__Two-Pointers Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.    Example 1: Input: [-4,-1,0,3,10] Output: [0,1,9,16,100]   Example 2: Input: [-7,-3,2,3,11] Output: [4,9,9,49,121]    Note:  1 <= A.length <= 10000 -10000 <= A[i] <= 10000 A is sorted in non-decreasing order.
__label__Greedy-Algorithms For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants.  Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is  where , there exists another team member whose skill level is . Note that a contestant can write buggy code and thus can have a negative skill level. The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible. For example, there are  contestants with skill levels .  There are many ways teams could be formed, e.g. [-1], [0],...,[3].  At the other end of the spectrum, we could form  and .  We're looking for the largest smaller team size though.  Two sets that meet the criteria are  and .  The largest smaller team size possible is . Note: There is an edge case where  contestants have registered.  As no teams are to be created, the largest team created will have  members. Input Format The first line contains an integer , the number of test cases.   Each of the next  lines contains a string of space-separated integers,  followed by  integers , a list of the contestants' skill levels. Constraints       Output Format For each test case, print the size of largest possible smallest team on a separate line. Sample Input 4   7 4 5 2 3 -4 -3 -5   1 -4   4 3 2 3 1   7 1 -2 -3 -4 2 0 -1    Sample Output 3 1 1 7  Explanation For the first case, Roy can form two teams: one with contestants with skill levels {-4,-3,-5} and the other one with {4,5,2,3}. The first group containing 3 members is the smallest.   {-4,-3,-5} {4,5,2,3} 3 In the second case, the only team is {-4}  {-4} In the third case, the teams are {3} , {1,2,3}, the size of the smaller group being 1. {3} {1,2,3} 1 In the last case, you can build one group containing all of the contestants. The size of the group equals the total number of contestants. Time limits  Time limits for this challenge are given here Note  If n = 0, print 0.
__label__Array __label__Dynamic-Programming On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].
__label__Data-Structures The median of a set of integers is the midpoint value of the data set for which an equal number of integers are less than and greater than the value. To find the median, you must first sort your set of integers in non-decreasing order, then: If your set contains an odd number of elements, the median is the middle element of the sorted sample. In the sorted set ,  is the median. If your set contains an even number of elements, the median is the average of the two middle elements of the sorted sample. In the sorted set ,  is the median. Given an input stream of  integers, you must perform the following task for each  integer: Add the  integer to a running list of integers. Find the median of the updated list (i.e., for the first element through the  element). Print the list's updated median on a new line. The printed value must be a double-precision number scaled to  decimal place (i.e.,  format). Input Format The first line contains a single integer, , denoting the number of integers in the data stream.  Each line  of the  subsequent lines contains an integer, , to be added to your list. Constraints    Output Format After each new integer is added to the list, print the list's updated median on a new line as a single double-precision number scaled to  decimal place (i.e.,  format). Sample Input 6 12 4 5 3 8 7  Sample Output 12.0 8.0 5.0 4.5 5.0 6.0  Explanation There are  integers, so we must print the new median on a new line as each integer is added to the list:
__label__Array Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1. Return the least number of moves to make every value in A unique.   Example 1: Input: [1,2,2] Output: 1 Explanation:  After 1 move, the array could be [1, 2, 3].   Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values.     Note:  0 <= A.length <= 40000 0 <= A[i] < 40000
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You are given the pointer to the head node of a linked list and you need to print all its elements in reverse order from tail to head, one element per line. The head pointer may be null meaning that the list is empty - in that case, do not print anything! Input Format You have to complete the void reversePrint(SinglyLinkedListNode* head) method which takes one argument - the head of the linked list. You should NOT read any input from stdin/console. void reversePrint(SinglyLinkedListNode* head) The first line of input contains , the number of test cases.  The input of each test case is as follows:   The first line contains an integer , denoting the number of elements in the list.   The next n lines contain one element each, denoting the elements of the linked list in the order. Constraints   , where  is the  element in the list.   Output Format Complete the reversePrint function in the editor below and print the elements of the linked list in the reverse order, each in a new line.  Sample Input 3 5 16 12 4 2 5 3 7 3 9 5 5 1 18 3 13  Sample Output 5 2 4 12 16 9 3 7 13 3 18 1 5  Explanation There are three test cases.  The first linked list has  elements: 16 -> 12 -> 4 -> 2 -> 5. Printing this in reverse order will produce: 5 -> 2 -> 4 -> 12 -> 16.  The second linked list has  elements: 7 -> 3 -> 9. Printing this in reverse order will produce: 9 -> 3 -> 7.  The third linked list has  elements: 5 -> 1 -> 18 -> 3 -> 13. Printing this in reverse order will produce: 13 -> 3 -> 18 -> 1 -> 5.   16 -> 12 -> 4 -> 2 -> 5 5 -> 2 -> 4 -> 12 -> 16 7 -> 3 -> 9 9 -> 3 -> 7 5 -> 1 -> 18 -> 3 -> 13 13 -> 3 -> 18 -> 1 -> 5
__label__Binary-Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].
__label__Greedy-Algorithms In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: 	A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: 	If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire. Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights any more since his right has been banned.  And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.    Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights anymore since his right has been banned.  And the third senator comes from Dire and he can ban the first senator's right in the round 1.  And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.    Note:  The length of the given string will in the range [1, 10,000].
__label__Array Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]
__label__Binary-Search You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.
__label__Mathematics Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1
__label__Strings Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.
__label__Strings Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.
__label__Hash-Table Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].
__label__Dynamic-Programming You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.
__label__Tree In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.
__label__Strings We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].
__label__Dynamic-Programming Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.    Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? Credits: Special thanks to @pbrother for adding this problem and creating all test cases.
__label__Mathematics __label__Game-Theory There are  piles of stones where the ith pile has  stones in it. Alice and Bob play the following game: Alice starts, and they alternate turns. Alice starts, and they alternate turns. In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .  In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .  The player who cannot make a move (because all the remaining piles are indivisible) loses the game. The player who cannot make a move (because all the remaining piles are indivisible) loses the game. Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)? Input Format The first line contains the number of test cases .  test cases follow. The first line for each test case contains , the number of piles initially. The next line contains  space delimited numbers, the number of stones in each of the piles. Constraints     Output Format Output  lines, one corresponding to each test case containing ALICE if Alice wins the game and BOB otherwise. ALICE BOB Sample Input 4   1   4   2   1 2   3   1 3 4   1   8  Sample Output BOB   BOB   ALICE   BOB  Explanation For the first case, the only possible move for Alice is (4) -> (1,3). Now Bob breaks up the pile with 3 stones into (1,2). At this point Alice cannot make any move and has lost.
__label__Mathematics __label__Dynamic-Programming We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9
__label__Hash-Table __label__Dynamic-Programming Given a list of words, each word consists of English lowercase letters. Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, "abc" is a predecessor of "abac". A word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on. Return the longest possible length of a word chain with words chosen from the given list of words.   Example 1: Input: ["a","b","ba","bca","bda","bdca"] Output: 4 Explanation: one of the longest word chain is "a","ba","bda","bdca".    Note:  1 <= words.length <= 1000 1 <= words[i].length <= 16 words[i] only consists of English lowercase letters.
__label__Data-Structures Victoria has a tree, , consisting of  nodes numbered from  to . Each edge from node  to  in tree  has an integer weight, . Let's define the cost, , of a path from some node  to some other node  as the maximum weight () for any edge in the unique path from node  to node . Victoria wants your help processing  queries on tree , where each query contains  integers,  and , such that . For each query, she wants to print the number of different paths in  that have a cost, , in the inclusive range . It should be noted that path from some node  to some other node  is considered same as path from node  to  i.e  is same as .  Input Format The first line contains  space-separated integers,  (the number of nodes) and  (the number of queries), respectively.  Each of the  subsequent lines contain  space-separated integers, , , and , respectively, describing a bidirectional road between nodes  and  which has weight .  The  subsequent lines each contain  space-separated integers denoting  and . Constraints         Scoring  for  of the test data.    for  of the test data. Output Format For each of the  queries, print the number of paths in  having cost  in the inclusive range  on a new line. Sample Input 5 5 1 2 3 1 4 2 2 5 6 3 4 1 1 1 1 2 2 3 2 5 1 6  Sample Output 1 3 5 5 10  Explanation :   :   :   :   ...etc.
__label__Tree __label__Depth-first-Search Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3
__label__Array Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.
__label__Greedy-Algorithms An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].
__label__Array __label__Hash-Table Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false
__label__Mathematics Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
__label__Dynamic-Programming There is a huge blanket on your bed but unfortunately it has N stains. You cover them using  a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly K stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth. Let X denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove K stains so that the remaining N-K stains can be covered with silk of area strictly less than X (We are looking for any configuration that will reduce the cost). Assume that each stain is a point and that the rectangle is aligned parallel to the axes.   Input Format The first line contains two integers N (1<=N<=1000) and K (0<=K<=N).  Next follow N lines, one for each stain. Each line contains two integers in the form 'X Y', (0<=X,Y<100000), the coordinates of each stain into the blanket. Each pair of coordinates is unique. Output Format Output a single integer. The remainder of the division by 1000000007 of the answer. Sample Input 5 2 0 1 3 3 2 0 0 3 2 3  Sample Output 8  Explanation We can clean two spots. So removing any of the following set of stains will lead us to a conbination that will need less amount of silk.(The numbers refer to the indices of the stains in the input and they begin from 1). 1, 4 2, 1 2, 3 2, 4 2, 5 3, 1 3, 4 3, 5  So there are 8 ways.
__label__Array __label__Two-Pointers Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.
__label__Search __label__Bit You will be given an array of integers.  All of the integers except one occur twice.  That one is unique in the array. Given an array of integers, find and print the unique element.   For example, , the unique element is .   Function Description  Complete the lonelyinteger function in the editor below.  It should return the integer which occurs only once in the input array.   lonelyinteger has the following parameter(s):   a: an array of integers   Input Format The first line contains a single integer, , denoting the number of integers in the array.  The second line contains  space-separated integers describing the values in . Constraints   It is guaranteed that  is an odd number and that there is one unique element.   , where . Output Format Print the unique integer in the array. Sample Input 0 Sample Output 0 Explanation 0 There is only one element in the array, thus it is unique. Sample Input 1 Sample Output 1 Explanation 1 We have two 's, and  is unique.  Sample Input 2 Sample Output 2 Explanation 2 We have two 's, two 's, and one .   is unique.
__label__Data-Structures Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed. There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by . If you join  adjacent buildings, they will form a solid rectangle of area .   For example, the heights array .  A rectangle of height  and length  can be constructed within the boundaries.  The area formed is .   Function Description Complete the function largestRectangle int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.   largestRectangle largestRectangle has the following parameter(s): h: an array of integers representing building heights Input Format The first line contains , the number of buildings.  The second line contains  space-separated integers, each representing the height of a building.    Constraints    Output Format Print a long integer representing the maximum area of rectangle formed. Sample Input 5 1 2 3 4 5  Sample Output 9  Explanation An illustration of the test case follows.
__label__Hash-Table A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.
__label__Two-Pointers In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length
__label__Strings Consider a string of  characters, , of where each character is indexed from  to . You are given  queries in the form of two integer indices:  and . For each query, count and print the number of different substrings of  in the inclusive range between  and .  Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string  aab, substrings  a and  a are the same but substrings  aa and  ab are different. aab a a aa ab Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a single string denoting .  Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  for a query. Constraints   String  consists of lowercase English alphabetic letters (i.e., a to z) only. a z Subtasks  For  of the test cases,   For  of the test cases,   For  of the test cases,   Output Format For each query, print the number of different substrings in the inclusive range between index  and index  on a new line.  Sample Input 0 Sample Output 0 Explanation 0 Given  aabaa, we perform the following  queries: aabaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 0 2: The substrings of aab are a, b, aa, ab, and aab, so we print  on a new line. 0 2 aab a b aa ab aab
__label__Greedy-Algorithms Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0
__label__Two-Pointers Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL
__label__Search __label__Dynamic-Programming You have a rectangular board consisting of  rows, numbered from  to , and  columns, numbered from  to . The top left is  and the bottom right is . Initially - at time  - there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:   *: Exactly one of your cells has letter '*'. *: Exactly one of your cells has letter '*'. U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . When the coin reaches a cell that has letter '*', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time  the coin will reach the cell having letter '*'. In each operation you can select a cell with some letter other than '*' and change the letter to 'U', 'L', 'R' or 'D'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations.  For example, given a grid of  rows and  columns: the goal is to get from  to  in as few steps as possible.  As the grid stands, it cannot be done because of the U in the cell at .  If  is changed to D, the path  is available.  It could also be changed to R which would make the path  available.  Either choice takes  change operation, which is the value sought if .  A lower value of  would result in a return value of  because the shortest path is  steps, starting from .   U D R Function Description  Complete the coinOnTheTable function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or  if it is not possible.   coinOnTheTable has the following parameters:   m: an integer, the number of columns on the board   k: an integer, the maximum time to reach the goal   board: an array of strings where each string represents a row of the board   Input Format The first line of input contains three integers, , , and , the number of rows, the number of columns and the maximum time respectively.   The next  lines contain  letters each, describing your board.    Constraints     Output Format Print an integer which represents the minimum number of operations required to achieve your goal. If you cannot achieve your goal, print . Sample Input 2 2 3   RD   *L  Sample output : 0  Sample input : 2 2 1   RD   *L  Sample output : 1  Explanation : In the first example, a valid path exists without making any changes.  In the second example, the letter of cell (1,1) must be changed to 'D' to make a valid path.  In each example, a path length  is available.
__label__Dynamic-Programming __label__Depth-first-Search In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.
__label__Graph-Algorithms There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the ith problem has estimated difficulty level i. You have also assigned a rating vi to each problem. Problems with similar vi values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their vi rating by at least K. What is the least number of days in which you can solve all problems? Input Format The first line contains the number of test cases T. T test cases follow. Each case contains an integer N and K on the first line, followed by integers v1,...,vn on the second line. Constraints 1 <= T <= 100  1 <= N <= 300  1 <= vi <= 1000  1 <= K <= 1000 Output Format Output T lines, one for each test case, containing the minimum number of days in which all problems can be solved. Sample Input 2   3 2   5 4 7   5 1   5 3 4 5 6  Sample Output 2   1  Explanation For the first example, you can solve the problems with rating 5 and 7 on the first day and the problem with rating 4 on the next day. Note that the problems with rating 5 and 4 cannot be completed consecutively because the ratings should differ by at least K (which is 2). Also, the problems cannot be completed in order 5,7,4 in one day because the problems solved on a day should be in increasing difficulty level. For the second example, all problems can be solved on the same day.
__label__Tree __label__Data-Structures A binary tree is a tree which is characterized by one of the following properties: It can be empty (null). It contains a root node only. It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees. In-order traversal is performed as Traverse the left subtree. Visit root. Traverse the right subtree. For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true: it is the first node visited, the first time visited  it is a leaf, should only be visited once   all of its subtrees have been explored, should only be visited once while this is true   it is the root of the tree, the first time visited   Swapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L. L R R L For example, in the following tree, we swap children of node 1. 1                                 Depth     1               1            [1]    / \             / \   2   3     ->    3   2          [2]    \   \           \   \     4   5           5   4        [3]  In-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4. 2 4 1 3 5 3 5 1 2 4 Swap operation:  We define depth of a node as follows: The root node is at depth 1. If the depth of the parent node is d, then the depth of current node will be d+1. d d+1 Given a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h ∈ [k, 2k, 3k,...].  In other words, if h is a multiple of k, swap the left and right subtrees of that level. k h h ∈ [k, 2k, 3k,...] h k You are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree. n [1..n] 1 t Function Description Complete the swapNodes function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation. swapNodes has the following parameter(s):  - indexes: an array of integers representing index values of each , beginning with , the first element, as the root.  - queries: an array of integers, each representing a  value. Input Format  The first line contains n, number of nodes in the tree.    n Each of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.    n a b a b Note: -1 is used to represent a null node.    -1 The next line contains an integer, t, the size of .  Each of the next t lines contains an integer , each being a value .   t t Output Format  For each k, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.   k Constraints        Either  or   Either  or   The index of a non-null child will always be greater than that of its parent.   Sample Input 0  3 2 3 -1 -1 -1 -1 2 1 1  Sample Output 0  3 1 2 2 1 3  Explanation 0 As nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.     1   [s]       1    [s]       1       / \      ->   / \        ->  / \     2   3 [s]     3   2  [s]     2   3  Note: [s] indicates that a swap operation is done at this depth. [s] Sample Input 1  5 2 3 -1 4 -1 5 -1 -1 -1 -1 1 2  Sample Output 1  4 2 1 5 3  Explanation 1 Swapping child nodes of node 2 and 3 we get     1                  1      / \                / \    2   3   [s]  ->    2   3    \   \            /   /      4   5          4   5    Sample Input 2  11 2 3 4 -1 5 -1 6 -1 7 8 -1 9 -1 -1 10 11 -1 -1 -1 -1 -1 -1 2 2 4  Sample Output 2  2 9 6 4 1 3 7 5 11 8 10 2 6 9 4 1 3 7 5 10 8 11  Explanation 2  Here we perform swap operations at the nodes whose depth is either 2 or 4 for  and then at nodes whose depth is 4 for .          1                     1                          1                      / \                   / \                        / \                    /   \                 /   \                      /   \                  2     3    [s]        2     3                    2     3                /      /                \     \                    \     \              /      /                  \     \                    \     \            4      5          ->        4     5          ->        4     5          /      / \                  /     / \                  /     / \        /      /   \                /     /   \                /     /   \      6      7     8   [s]        6     7     8   [s]        6     7     8  \          / \            /           / \              \         / \      \        /   \          /           /   \              \       /   \      9      10   11        9           11   10              9     10   11
__label__Graph-Algorithms The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two "somewhat near" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as "somewhat near" each other. Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this? Input Format The first line contains the number of test cases T. T test cases follow. The first line contains N, the number of cities in Byteland. The following N - 1 lines contain the description of the roads. The ith line contains two integers ai and bi, meaning that there was originally a road connecting cities with numbers ai and bi. Constraints 1 <= T <= 20  1 <= N <= 10000  0 <= ai,bi < N   Output Format Output T lines, one corresponding to each test case containing the required answer for that test case. Since the answers can be huge, output them modulo 1000000007. Sample Input 2  3  0 1  1 2  5  0 1  1 2  2 3  2 4 Sample Output 2  4 Explanation For the first case, a new road was build between cities 0 and 2. Now, the salesman has two tour possibilities: 0-1-2-0 or 0-2-1-0.
__label__Two-Pointers __label__Dynamic-Programming There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'
__label__Strings Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.
__label__Dynamic-Programming Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing. In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j]. If there is no way to make arr1 strictly increasing, return -1.   Example 1: Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4] Output: 1 Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].  Example 2: Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1] Output: 2 Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].  Example 3: Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3] Output: -1 Explanation: You can't make arr1 strictly increasing.   Constraints:  1 <= arr1.length, arr2.length <= 2000 0 <= arr1[i], arr2[i] <= 10^9
__label__Tree __label__Data-Structures We consider metric space to be a pair, , where  is a set and  such that the following conditions hold:     where  is the distance between points  and . Let's define the product of two metric spaces, , to be  such that:  , where , . So, it follows logically that  is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: . For example, , where  is a metric space. , where . In this challenge, we need a tree-space. You're given a tree, , where  is the set of vertices and  is the set of edges. Let the function  be the distance between two vertices in tree  (i.e.,  is the number of edges on the path between vertices  and ). Note that  is a metric space. You are given a tree, , with  vertices, as well as  points in . Find and print the distance between the two furthest points in this metric space! Input Format The first line contains two space-separated positive integers describing the respective values of  (the number of vertices in ) and  (the number of given points).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing edge  in .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for point . Constraints     Scoring This challenge uses binary scoring, so you must pass all test cases to earn a positive score. Output Format Print a single non-negative integer denoting the maximum distance between two of the given points in metric space . Sample Input 0 Sample Output 0 Explanation 0 The distance between points  and  is . Sample Input 1 Sample Output 1 Explanation 1 The best points are  and , which gives us a distance of .
__label__Hash-Table Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].
__label__Tree __label__Depth-first-Search Given the root of a binary tree, each node in the tree has a distinct value. After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees). Return the roots of the trees in the remaining forest.  You may return the result in any order.   Example 1:  Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]]    Constraints:  The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length <= 1000 to_delete contains distinct values between 1 and 1000.
__label__Dynamic-Programming __label__Strings __label__Mathematics Given a string consisting of the letters ,  and , we can perform the following operation:  Take any two adjacent distinct characters and replace them with the third character.  Find the shortest string obtainable through applying this operation repeatedly.   For example, given the string  we can reduce it to a  character string by replacing  with  and  with : .   Function Description  Complete the stringReduction function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.   stringReduction has the following parameter:  - s: a string   Input Format The first line contains the number of test cases .   Each of the next  lines contains a string  to process. Constraints   Output Format For each test case, print the length of the resultant minimal string on a new line.   Sample Input 3   cab   bcab   ccccc  Sample Output 2   1   5  Explanation For the first case, there are two solutions:   or .  For the second case, one optimal solution is: .  For the third case, no operations can be performed so the answer is .
__label__Greedy-Algorithms A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.
__label__Array Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.
__label__Hash-Table __label__Mathematics In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].
__label__Array __label__Mathematics Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000
__label__Mathematics __label__Greedy-Algorithms Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Array __label__Two-Pointers Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]
__label__Dynamic-Programming Christy is interning at HackerRank. One day she has to distribute some chocolates to her colleagues. She is biased towards her friends and plans to give them more than the others. One of the program managers hears of this and tells her to make sure everyone gets the same number. To make things difficult, she must equalize the number of chocolates in a series of operations. For each operation, she can give  chocolates to all but one colleague.  Everyone who gets chocolate in a round receives the same number of pieces.   For example, assume the starting distribution is .  She can give  bars to the first two and the distribution will be .  On the next round, she gives the same two  bars each, and everyone has the same number:  . Given a starting distribution, calculate the minimum number of operations needed so that every colleague has the same number of chocolates.  Function Description  Complete the equal function in the editor below.  It should return an integer that reperesents the minimum number of operations required.   equal has the following parameter(s):   arr: an array of integers to equalize   Input Format The first line contains an integer , the number of test cases.    Each test case has  lines.  - The first line contains an integer , the number of colleagues.  - The second line contains  space-separated integers denoting the number of chocolates each colleague has. Constraints     Number of initial chocolates each colleague has <   Output Format Print the minimum number of operations needed for each test case, one to a line. Sample Input 1 4 2 2 3 7  Sample Output 2  Explanation Start with   Add  to all but the 3rd element   Add  to all but the 4th element   Two operations were required. Sample Input 1 1 3 10 7 12  Sample Output 1 3  Explanation 1 Start with   Add  to the first two elements   Add  to the last two elements   Add  to the last two elements   Three operations were required.
__label__Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4
__label__Mathematics On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50
__label__Strings Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]
__label__Greedy-Algorithms Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.
__label__Mathematics __label__Binary-Search Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2  Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since               the decimal part is truncated, 2 is returned.
__label__Array __label__Hash-Table Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order.    Example 1: Input: ["bella","label","roller"] Output: ["e","l","l"]   Example 2: Input: ["cool","lock","cook"] Output: ["c","o"]    Note:  1 <= A.length <= 100 1 <= A[i].length <= 100 A[i][j] is a lowercase letter
__label__Mathematics __label__Binary-Search Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
__label__Array Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].
__label__Mathematics __label__Data-Structures __label__Advanced-Data-Structures In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have N space-fighters.  Initially the ith fighter is located at (xi, yi). All of the space-fighters move with constant velocity V units/sec in the positive X direction.  i.e., fighter at (xi, yi) moves to (xi+V, yi) in 1 second.  The ith space-fighter broadcasts enemy information at a frequency fi. The republic is not scared of the artificially intelligent droid force as they have Yoda. Yoda has a special power, at any time T he can choose a region of the droid army and block one specific frequency F. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across X axis (refer image below for clarity). If a frequency (F) is blocked all the space-fighters in the region having the frequency F can’t communicate.  Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form: YU YD T where YU, YD are the bounds on y-axis inside which YODA can block a frequency at time T.  In the region described by the query, after a time T seconds from the start, if Yoda can chose one frequency (F) he wishes to, what is the maximum number of communications he can block? Input Format  Each test case is described as follows; the first line contains 3 space separated integers N - the number of space-fighters, Q - the number of queries you have to answer, and V - the velocity of the space-fighters separated by a single space.  N lines follow, each containing 3 space separated integers xi, yi, and fi, denoting the x co-ordinate, y co-ordinate and the frequency at which the ith ship broadcasts respectively. Each of the next Q lines contain 3 space separated integers representing YU, YD, T respectively. Refer the figure for more clarity Note: Points on the boundaries should be counted as well. Output Format  For each query you are to output a single integer denoting the result. Constraints  1 <= N <= 50000 1 <= Q <= 30000 1 <= V <= 10000 -109 <= xi <= 109 -109 <= yi <= 109 1 <= fi <= 109 -109 <= YU <= 109 -109 <= YD <= 109 1 <= T <= 10000 YU >= YD Sample Input 5 5 82 -4 1 4 -3 -2 2 -3 5 1 0 -5 2 1 -1 2 1 -1 57 -2 -5 11 5 -5 40 -1 -5 16 5 -1 93  Sample Output 1 2 3 3 1  Explanation Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.
__label__Dynamic-Programming Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.
__label__Dynamic-Programming Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.
__label__Dynamic-Programming Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].
__label__Depth-first-Search In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space.  These characters divide the square into contiguous regions. (Note that backslash characters are escaped, so a \ is represented as "\\".) Return the number of regions.                Example 1: Input: [   " /",   "/ " ] Output: 2 Explanation: The 2x2 grid is as follows:    Example 2: Input: [   " /",   "  " ] Output: 1 Explanation: The 2x2 grid is as follows:    Example 3: Input: [   "\\/",   "/\\" ] Output: 4 Explanation: (Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.) The 2x2 grid is as follows:    Example 4: Input: [   "/\\",   "\\/" ] Output: 5 Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.) The 2x2 grid is as follows:    Example 5: Input: [   "//",   "/ " ] Output: 3 Explanation: The 2x2 grid is as follows:     Note:  1 <= grid.length == grid[0].length <= 30 grid[i][j] is either '/', '\', or ' '.
__label__Array __label__Greedy-Algorithms Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.
__label__Game-Theory __label__Game-Theory Poker Nim is another -player game that's a simple variation on a Nim game. The rules of the games are as follows: The game starts with  piles of chips indexed from  to . Each pile  (where ) has  chips. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. To ensure that the game ends in finite time, a player cannot add chips to any pile  more than  times. The player who removes the last chip wins the game. Given the values of , , and the numbers of chips in each of the  piles, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: Two space-separated integers,  (the number of piles) and  (the maximum number of times an individual player can add chips to some pile ), respectively.  space-separated integers, , where each  describes the number of chips at pile . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either  or ). Sample Input 2 2 5 1 2 3 5 2 1 3  Sample Output First Second
__label__Data-Structures __label__Advanced-Data-Structures A Sumo wrestling championship is scheduled to be held this winter in the HackerCity where N wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K,  (i.e) wrestler A and wrestler B can fight if and only if |height(A)-height(B)|<=K.    Given an array H[], where H[i] represents the height of the ith fighter, for a given l, r where 0 <= l <= r < N, can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game? 0 <= l <= r < N Input Format  The first line contains an integer N and K  separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K.  The second line contains N integers separated by a single space, representing their heights H[0] H[1] ... H[N - 1].  The third line contains Q, the number of queries. This is followed by Q lines each having two integers l and r separated by a space.   Output Format  For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that K.   Constraints  1 <= N <= 100000  0 <= K <= 109  0 <= H[i] <= 109  1 <= Q <= 100000  0 <= l <= r < N   Sample Input Sample Output  Explanation  Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1.  Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| <=2. Hence output is 3.  Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.   Timelimits Timelimits are given here
__label__Data-Structures There is a collection of input strings and a collection of query strings.  For each query string, determine how many times it occurs in the list of input strings.   For example, given input  and , we find  instances of ',  of '' and  of ''.  For each query, we add an element to our return array, .   Function Description Complete the function matchingStrings in the editor below.  The function must return an array of integers representing the frequency of occurrence of each query string in strings. matchingStrings has the following parameters: strings - an array of strings to search   queries - an array of query strings   Input Format The first line contains and integer , the size of .  Each of the next  lines contains a string .  The next line contains , the size of .  Each of the next  lines contains a string .   Constraints      .  Output Format Return an integer array of the results of all queries in order.
__label__Array Given an array of integers nums, write a method that returns the "pivot" index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.    Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.    Note:  The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].
__label__Hash-Table __label__Strings Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.
__label__Tree __label__Data-Structures Complete the inOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your inOrder function. Constraints 1 Nodes in the tree   500 Output Format Print the tree's inorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 3 4 5 6
__label__Graph-Algorithms Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from  to , and edges will have varying distances or lengths. For example, consider the following graph of 5 nodes:   Starting at node , the shortest path to  is direct and distance .  Going from  to , there are two paths:  at a distance of  or  at a distance of .  Choose the shortest path, .  From  to , choose the shortest path through  and extend it:  for a distance of   There is no route to node , so the distance is . The distances to all nodes in increasing node order, omitting the starting node, are 5 11 13 -1. 5 11 13 -1 Function Description  Complete the shortestReach function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.   shortestReach has the following parameter(s):   n: the number of nodes in the graph   edges: a 2D array of integers where each  consists of three integers that represent the start and end nodes of an edge, followed by its length   s: the start node number   Input Format The first line contains , the number of test cases.  Each test case is as follows:  - The first line contains two space-separated integers  and , the number of nodes and edges in the graph.  - Each of the next  lines contains three space-separated integers , , and , the beginning and ending nodes of an edge, and the length of the edge.  - The last line of each test case has an integer , denoting the starting position.   Constraints           If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges. Output Format For each of the  test cases, print a single line consisting  space separated integers denoting the shortest distance to the  nodes from starting position  in  increasing order of their labels, excluding .  For unreachable nodes, print . Sample Input 1 4 4 1 2 24 1 4 20 3 1 3 4 3 12 1  Sample Output 24 3 15  Explanation The graph given in the test case is shown as :   * The lines are weighted edges where weight denotes the length of the edge. The shortest paths followed for the three nodes 2, 3 and 4 are as follows : 1/S->2 - Shortest Path Value :  1/S->3 - Shortest Path Value :  1/S->3->4 - Shortest Path Value :
__label__Binary-Search __label__Dynamic-Programming table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
__label__Array __label__Two-Pointers __label__Binary-Search Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
__label__Binary-Search Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.
__label__Array __label__Mathematics In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000
__label__Array __label__Mathematics Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6    Example 2: Input: [1,2,3,4] Output: 24    Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.
__label__Array __label__Binary-Search Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2  Example 2: Input: [1,3,5,6], 2 Output: 1  Example 3: Input: [1,3,5,6], 7 Output: 4  Example 4: Input: [1,3,5,6], 0 Output: 0
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Data-Structures __label__Advanced-Data-Structures A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves. Change the number of books in one of the shelves. Change the number of books in one of the shelves. Obtain the number of books on the shelf having the kth rank within  the range of shelves.  Obtain the number of books on the shelf having the kth rank within  the range of shelves.  A shelf is said to have the kth rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order. Can you write a program to simulate the above queries? Input Format  The first line contains a single integer T, denoting the number of test cases.  The first line of each test case contains an integer N denoting the number of shelves in the library.  The next line contains N space separated integers where the ith integer represents the number of books on the ith shelf where 1<=i<=N.  The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query.  Queries can be of two types: 1 x k - Update the number of books in the xth shelf to k (1 <= x <= N). 0 x y k - Find the number of books on the shelf between the shelves x and y  (both inclusive) with the kth rank (1 <= x <= y <= N, 1 <= k <= y-x+1). Output Format  For every test case, output the results of the queries in a new line. Constraints  1 <= T <= 5  1 <= N <= 104  1 <= Q <= 104  The number of books on each shelf is always guaranteed to be between 1 and 1000. Sample Input 2 2 1 2 2 0 1 2 1 0 1 2 2 4 4 3 2 1 4 0 1 1 1 1 1 1 0 1 1 1 0 1 4 3  Sample Output 1 2 4 1 2  Explanation  There are two test cases : The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2. The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2.
__label__Tree __label__Depth-first-Search Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.
__label__Dynamic-Programming Chinese Version Russian Version Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that: Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.   All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component The absolute difference between the number of chocolates in pieces should be at most K After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this:  XX  XX Input Format The first line of the input contains 3 integers M, N and K separated by a single space.  M lines follow, each of which contains N characters.  Each character is 'T','D' or 'U'. Constraints 0≤ M, N ≤8  0≤ K ≤ M * N Output Format A single line containing the number of ways to divide the chocolate bar. Sample Input 2 2 4 UU UU  Sample Output 12  Explanation Note: In the explanation T and D are used to represent, which parts belong to Tom and Derpina respectively. There are 24 = 16 possible separations.  The 4 invalid are: TT TT  DD DD  DT TD  TD DT  Some of the valid ones are: TD TD  TT DD  DD TT  DT DT
__label__Strings Under a grammar given below, strings can represent a set of lowercase words.  Let's use R(expr) to denote the set of words the expression represents. Grammar can best be understood through simple examples:  Single letters represent a singleton set containing that word. 	 R("a") = {"a"} R("w") = {"w"}   When we take a comma delimited list of 2 or more expressions, we take the union of possibilities. 	 R("{a,b,c}") = {"a","b","c"} R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains each word at most once)   When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. 	 R("{a,b}{c,d}") = {"ac","ad","bc","bd"} R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}    Formally, the 3 rules for our grammar:  For every lowercase letter x, we have R(x) = {x} For expressions e_1, e_2, ... , e_k with k >= 2, we have R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ... For expressions e_1 and e_2, we have R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}, where + denotes concatenation, and × denotes the cartesian product.  Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.    Example 1: Input: "{a,b}{c,{d,e}}" Output: ["ac","ad","ae","bc","bd","be"]   Example 2: Input: "{{a,z},a{b,c},{ab,z}}" Output: ["a","ab","ac","z"] Explanation: Each distinct word is written only once in the final answer.    Constraints:  1 <= expression.length <= 50 expression[i] consists of '{', '}', ','or lowercase English letters. The given expression represents a set of words based on the grammar given in the description.
__label__Tree Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.    Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.
__label__Array Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1
__label__Array For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1]. Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.      Example 1: Input: A = [1,2,0,0], K = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234   Example 2: Input: A = [2,7,4], K = 181 Output: [4,5,5] Explanation: 274 + 181 = 455   Example 3: Input: A = [2,1,5], K = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021   Example 4: Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1 Output: [1,0,0,0,0,0,0,0,0,0,0] Explanation: 9999999999 + 1 = 10000000000    Note：  1 <= A.length <= 10000 0 <= A[i] <= 9 0 <= K <= 10000 If A.length > 1, then A[0] != 0
__label__Greedy-Algorithms There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
__label__Greedy-Algorithms Quibdó in Colombia is one among the cities that receive maximum rainfall in the world. All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you.  Every cloud covers all towns located at a certain distance from it. A town is said to be in darkness if there exists at least one cloud such that the town is within the cloud's range. Otherwise, it is said to be sunny.  The city council has determined that they have enough money to remove exactly one cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud? Note: If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer. Complete the function maximumPeople which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud. maximumPeople Input Format The first line of input contains a single integer , the number of towns. The next line contains  space-separated integers . The  integer in this line denotes the population of the  town.   The next line contains  space-separated integers  denoting the location of the  town on the one-dimensional line. The next line consists of a single integer  denoting the number of clouds covering the city.   The next line contains  space-separated integers  the  of which denotes the location of the  cloud on the coordinate axis. The next line consists of  space-separated integers  denoting the range of the  cloud.  Note: The range of each cloud is computed according to its location, i.e., the  cloud is located at position  and it covers every town within a distance of  from it. In other words, the  cloud covers every town with location in the range . Constraints    Output Format Print a single integer denoting the maximum number of people that will be in a sunny town by removing exactly one cloud. Sample Input 0 Sample Output 0 Explanation 0 In the sample case, there is only one cloud which covers the first town. Our only choice is to remove this sole cloud which will make all towns sunny, and thus, all  people will live in a sunny town.   As you can see, the only cloud present, is at location  on the number line and has a range , so it covers towns located at ,  and  on the number line. Hence, the first town is covered by this cloud and removing this cloud makes all towns sunny.
__label__Strings Roy wanted to increase his typing speed for programming contests.  His friend suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly.  This sentence is known as a pangram because it contains every letter of the alphabet. After typing the sentence several times, Roy became bored with it so he started to look for other pangrams. Given a sentence, determine whether it is a pangram.  Ignore case. Function Description Complete the function pangrams in the editor below.  It should return the string pangram if the input string is a pangram.  Otherwise, it should return not pangram.   pangram not pangram pangrams has the following parameter(s): s: a string to test Input Format Input consists of a string .  Constraints   Each character of ,  Output Format Output a line containing pangram if  is a pangram, otherwise output not pangram.   Sample Input 0  pangram not pangram We promptly judged antique ivory buckles for the next prize We promptly judged antique ivory buckles for the next prize Sample Output 0 pangram pangram Sample Explanation 0 All of the letters of the alphabet are present in the string.   Sample Input 1  We promptly judged antique ivory buckles for the prize We promptly judged antique ivory buckles for the prize Sample Output 1 not pangram not pangram Sample Explanation 0 The string lacks an x.   x
__label__Tree Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.
__label__Strings Louise joined a social networking site to stay in touch with her friends. The signup page required her to input a name and a password. However, the password must be strong. The website considers a password to be strong if it satisfies the following criteria: Its length is at least .   It contains at least one digit.   It contains at least one lowercase English character.  It contains at least one uppercase English character.  It contains at least one special character. The special characters are: !@#$%^&*()-+  !@#$%^&*()-+ She typed a random string of length  in the password field but wasn't sure if it was strong. Given the string she typed, can you find the minimum number of characters she must add to make her password strong? Note: Here's the set of types of characters in a form you can paste in your solution: Input Format The first line contains an integer  denoting the length of the string. The second line contains a string consisting of  characters, the password typed by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character. Constraints   Output Format Print a single line containing a single integer denoting the answer to the problem. Sample Input 0 Sample Output 0 Explanation 0 She can make the password strong by adding  characters, for example, $hk, turning the password into Ab1$hk which is strong.  $hk Ab1$hk  characters aren't enough since the length must be at least .   Sample Input 1 Sample Output 1 Explanation 1 The password isn't strong, but she can make it strong by adding a single digit.
__label__Hash-Table __label__Mathematics The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.
__label__Array Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000
__label__Array A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?
__label__Array __label__Dynamic-Programming Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
__label__Tree __label__Data-Structures The square-ten tree decomposition of an array is defined as follows: The lowest () level of the square-ten tree consists of single array elements in their natural order. The  level (starting from ) of the square-ten tree consists of subsequent array subsegments of length  in their natural order. Thus, the  level contains subsegments of length , the  level contains subsegments of length , the  level contains subsegments of length , etc. In other words, every  level (for every ) of square-ten tree consists of array subsegments indexed as:    The image below depicts the bottom-left corner (i.e., the first  array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:  Task  Given the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence  such as  for every , , , where every  belongs to any of the square-ten tree levels and  is minimal amongst all such variants. Input Format The first line contains a single integer denoting .  The second line contains a single integer denoting . Constraints  The numbers in input do not contain leading zeroes. Output Format As soon as array indices are too large, you should find a sequence of  square-ten tree level numbers, , meaning that subsegment  belongs to the  level of the square-ten tree.  Print this sequence in the following compressed format:  On the first line, print the value of  (i.e., the compressed sequence block count).  For each of the  subsequent lines, print  space-separated integers,  and  (, ), meaning that the number  appears consequently  times in sequence . Blocks should be listed in the order they appear in the sequence. In other words,  should be equal to ,  should be equal to , etc. Thus  must be true and  must be true for every . All numbers should be printed without leading zeroes. Sample Input 0 Sample Output 0 Explanation 0 Segment  belongs to level  of the square-ten tree.
__label__Two-Pointers Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?
__label__Dynamic-Programming Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109
__label__Dynamic-Programming Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4
__label__Tree __label__Data-Structures __label__Mathematics __label__Advanced-Data-Structures Shashank loves trees and math. He has a rooted tree, , consisting of  nodes uniquely labeled with integers in the inclusive range . The node labeled as  is the root node of tree , and each node in  is associated with some positive integer value (all values are initially ).  Let's define  as the  Fibonacci number. Shashank wants to perform  types of operations over his tree, :    Update the subtree rooted at node  such that the node at level  in subtree  (i.e., node ) will have  added to it, all the nodes at level  will have  added to them, and so on. More formally, all the nodes at a distance  from node  in the subtree of node  will have the  Fibonacci number added to them.    Find the sum of all values associated with the nodes on the unique path from  to . Print your sum modulo  on a new line. Given the configuration for tree  and a list of  operations, perform all the operations efficiently. Note: . Input Format The first line contains  space-separated integers,  (the number of nodes in tree ) and  (the number of operations to be processed), respectively.  Each line  of the  subsequent lines contains an integer, , denoting the parent of the  node.  Each of the  subsequent lines contains one of the two types of operations mentioned in the Problem Statement above. Constraints    Output Format For each operation of type  (i.e., ), print the required answer modulo  on a new line. Sample Input 5 10 1 1 2 2 Q 1 5 U 1 1 Q 1 1 Q 1 2 Q 1 3 Q 1 4 Q 1 5 U 2 2 Q 2 3 Q 4 5  Sample Output 0 1 2 2 4 4 4 10  Explanation Intially, the tree looks like this:  After update operation , it looks like this:  After update operation , it looks like this:
__label__Depth-first-Search A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.
__label__Tree __label__Data-Structures One of the most important skills a programmer needs to learn early on is the ability to pose a problem in an abstract way. This skill is important not just for researchers but also in applied fields like software engineering and web development.   You are able to solve most of a problem, except for one last subproblem, which you have posed in an abstract way as follows: Given an array consisting of  integers , define   For example, for an input array [ 10, -5, 5, 20 ], a subsegment  would be computed as follows:    What is , i.e., the maximum value of  among all subsegments ?   Complete the function maximumValue which takes an integer array as input and returns the maximum value of  among all subsegments . maximumValue Note that:   Input Format The first line contains a single integer  The second line contains  space-separated integers  Constraints     Output Format Print a single integer denoting the answer Sample Input 0 Sample Output 0 Explanation 0 The maximum value occurs at  as shown below.   Sample Input 1 Sample Output 1 Explanation 1 The maximum value occurs at .
__label__Dynamic-Programming You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.   As an example, bricks are numbered .  You can remove either ,  or .  For your friend, your moves would leave the options of  to  elements from  leaving  for you (total score = ),  or .  In this case, it will never be optimal for your friend to take fewer than the maximum available number of elements.  Your maximum possible score is , achievable two ways:  first move and  the second, or  in your first move.   Function Description  Complete the bricksGame function in the editor below.  It should return an integer that represents your maximum possible score.   bricksGame has the following parameter(s):   arr:  an array of integers   Input Format The first line will contain an integer , the number of test cases.   Each of the next  pairs of lines are in the following format:  The first line contains an integer , the number of bricks in .  The next line contains  space-separated integers $arr[i].   Constraints       Output Format For each test case, print a single line containing your maximum score. Sample Input 2 5 999 1 1 1 0 5 0 1 1 1 999  Sample Output 1001 999  Explanation In first test case, you will pick 999,1,1. If you play in any other way, you will not get a score of 1001.  In second case, best option will be to pick up the first brick (with 0 score) at first. Then your friend  will choose the next three blocks, and you will get the last brick.
__label__Graph-Algorithms Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board.  Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible.  But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board . Note  Immovable blocks cannot be moved while cheating.  A block can be moved only in the directions UP, DOWN, LEFT or RIGHT.  Input Format The first line contains four integers N, M, K, Q separated by a single space.  N lines follow.  Each line contains M integers 0 or 1 separated by a single space. If the jth integer is 1, then the block in ith row and jth column is movable. If the jth integer is 0 then the block in ith row and jth column is fixed. Then Q lines follows, each line contains six integers EXi, EYi, SXi, SYi, TXi, TYi separated by a single space. The ith query is the Cao Cao block is in row SXi column SYi, the exit is in TXi, TYi, and the empty position is in row EXi column EYi. It is guaranteed that the blocks in these positions are movable. Find the minimum seconds Acme needs to finish the game. If it is impossible to finish the game, you should answer -1. Constraints N,M ≤ 200  1 ≤ Q ≤ 250  10 ≤ K≤ 15  1 ≤ EXi,  SXi,  TXi≤ N  1 ≤ EYi, SYi,TYi ≤ M Output Format You should output Q lines, i-th line contains an integer which is the answer to i-th query. Sample Input 5 5 12 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1 5 4 3 4 1  Sample Output 20  Explanation Move the block in (1, 4) to (1, 5);  Move the block in (1, 3) to (1, 4);  Move the block in (1, 2) to (1, 3);  Move the block in (2, 2) to (1, 2);  Move the block in (3, 2) to (2, 2);  Move the block in (4, 2) to (3, 2);  Move the block in (4, 3) to (4, 2);  Move the block in (4, 1) to (4, 3) by cheating;  Move the block in (4, 2) to (4, 1).   So, 1 + 1 + 1 + 1 + 1 + 1 + 1 + 12 + 1 = 20.
__label__Hash-Table Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0. Return the maximum number of rows that have all values equal after some number of flips.      Example 1: Input: [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal.   Example 2: Input: [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values.   Example 3: Input: [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values.    Note:  1 <= matrix.length <= 300 1 <= matrix[i].length <= 300 All matrix[i].length's are equal matrix[i][j] is 0 or 1
__label__Game-Theory __label__Game-Theory Two players called  and  are playing a game with a starting number of stones. Player  always plays first, and the two players move in alternating turns. The game's rules are as follows: In a single move, a player can remove either , , or  stones from the game board.  If a player is unable to make a move, that player loses the game. Given the starting number of stones, find and print the name of the winner.   is named First and  is named Second.  Each player plays optimally, meaning they will not make a move that causes them to lose the game if a winning move exists. First Second For example, if ,  can make the following moves:    removes  stones leaving .  will then remove  stones and win.  removes  stones leaving .  cannot move and loses.  would make the second play and win the game. Function Description Complete the gameOfStones function in the editor below.  It should return a string, either First or Second.   First Second gameOfStones has the following parameter(s): n: an integer that represents the starting number of stones Input Format The first line contains an integer , the number of test cases.  Each of the next  lines contains an integer , the number of stones in a test case. Constraints  Output Format On a new line for each test case, print First if the first player is the winner.  Otherwise print Second. First Second Sample Input 8 1 2 3 4 5 6 7 10  Sample Output Second First First First First First Second First  Explanation In the sample, we have  testcases.   If ,  can't make any moves and loses the game. If ,  removes  stones and wins the game. If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes all  stones from the game board, winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  can make any of the following three moves: Remove  stones, leaving  stones on the board.  then removes  stones, winning the game.   Remove  stones, leaving  stones on the board.  then removes  stones, leaving  stone left on the board and winning the game.   Remove  stones, leaving  stones on the board.  then removes the  remaining stones and wins the game.   All possible moves result in  winning. If ,  can remove either  or  stones to win the game.
__label__Mathematics In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].
__label__Mathematics Given a number N, return a string consisting of "0"s and "1"s that represents its value in base -2 (negative two). The returned string must have no leading zeroes, unless the string is "0".    Example 1: Input: 2 Output: "110" Explantion: (-2) ^ 2 + (-2) ^ 1 = 2   Example 2: Input: 3 Output: "111" Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3   Example 3: Input: 4 Output: "100" Explantion: (-2) ^ 2 = 4    Note:  0 <= N <= 10^9
__label__Dynamic-Programming Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000
__label__Data-Structures __label__Advanced-Data-Structures Given a rooted tree of  nodes, where each node is uniquely numbered in between [1..N]. The node 1 is the root of the tree. Each node has an integer value which is initially 0. You need to perform the following two kinds of queries on the tree: add t value: Add value to all nodes in subtree rooted at t max a b: Report maximum value on the path from a to b Input Format First line contains N, number of nodes in the tree. Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, the number of queries to process.  Next Q lines follow with either add or max query per line. Constraints           Output Format For each max query output the answer in a separate line. Sample Input 5 1 2 2 3 2 4 5 1 6 add 4 30 add 5 20 max 4 5 add 2 -20 max 4 5 max 3 4  Sample Output 30 20 10  Explanation In the test case we have the following tree:  Initially all node values are zero.  Queries are performed in the following way: add 4 30 // add 30 to node 4  add 5 20 // add 20 to node 5  max 4 5 // maximum of nodes 4,2,1,5 is 30  add 2 -20 // subtract 20 from nodes 2,3,4  max 4 5 // maximum of nodes 4,2,1,5 is 20  max 3 4 // maximum of nodes 3,2,4 is 10
__label__Two-Pointers __label__Strings Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
__label__Dynamic-Programming There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.
__label__Greedy-Algorithms Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building  and at a height of .  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.   Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:   If the bot's  is less than the height of the building, his   If the bot's  is greater than the height of the building, his   For example, building heights are given as .  If the bot starts with , we get the following table: botEnergy   height  delta 4               2       +2 6               3       +3 9               4       +5 14              3       +11 25              2       +23 48  That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting  in this case is .   Function Description  Complete the chiefHopper function in the editor below.  It should return an integer that represents the minimum starting  that will allow completion of the course.   chiefHopper has the following parameter(s):   arr: an array of integers that represent building heights   Input Format The first line contains an integer , the number of buildings.  The next line contains  space separated integers  representing the heights of the buildings.   Constraints     Output Format Print a single integer representing minimum units of energy required to complete the game. Sample Input 0 Sample Output 0 Explanation 0 If initial energy is 4, after step 1 energy is 5, after step 2 it's 6, after step 3 it's 9 and after step 4 it's 16, finally at step 5 it's 28.  If initial energy were 3 or less, the bot could not complete the course.  Sample Input 1 Sample Output 1 Explanation 1 In the second test case if bot has energy 4, it's energy is changed by (4 - 4 = 0) at every step and remains 4.   Sample Input 2 Sample Output 2 Explanation 2 botEnergy   height  delta 3           1       +2 5           6       -1 4           4       0 4  We can try lower values to assure that they won't work.
__label__Graph-Algorithms __label__Tree Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day. Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office. Input Format There are N cities numbered 0 to N-1 and M bidirectional roads.   The first line of the input contains two integers N and M.   M lines follow, each containing three space-separated integers u , v and w, where u and v are cities connected by a bi-directional road and w is the length of this road. There is at most one road between any two cities and no road connects a city to itself.   The next line contains two integers S and D. S is the city where Ms. Kox lives and D is the city where her office is located.   The next line contains an integer Q, the number of queries.   Q lines follow, each containing two integers u and v, where the road between u and v has been blocked that day. Constraints          Output Format Output Q lines, with each line containing the minimum distance Ms.Kox has to travel on that day. If there is no path, print "Infinity". Sample Input 6 9   0 1 1   1 2 1   2 3 1   3 4 1   4 5 1   2 4 5   3 5 8   1 3 3   0 2 4   0 5   9   0 1   1 2   2 3   3 4   4 5   2 4   3 5   1 3   0 2  Sample Output 7   6   6   8   11   5   5   5   5
__label__Greedy-Algorithms We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"]. Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]). Return the minimum possible value of D.length.          Example 1: Input: ["ca","bb","ac"] Output: 1 Explanation:  After deleting the first column, A = ["a", "b", "c"]. Now A is in lexicographic order (ie. A[0] <= A[1] <= A[2]). We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.   Example 2: Input: ["xc","yb","za"] Output: 0 Explanation:  A is already in lexicographic order, so we don't need to delete anything. Note that the rows of A are not necessarily in lexicographic order: ie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation:  We have to delete every column.      Note:  1 <= A.length <= 100 1 <= A[i].length <= 100
__label__Array Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]
__label__Graph-Algorithms Update: A slight modification in the problem statement (see below)   Evil Nation A is angry and plans to launch N guided-missiles at the peaceful Nation B in an attempt to wipe out all of Nation B's people. Nation A's missile i will arrive in nation B at time ti. Missile i communicates with its headquarters by unique radio signals with a frequency equal to fi. Can you help the peaceful Nation B survive by building a defensive system that will stop the missiles dead in the sky? Defensive system:  The only way to defend Nation B from the attacking missile is by counter attacking them with a hackerX missile. You have a lot of hackerX missiles and each one of them has its own radio frequency. An individual hackerX missile can destroy Evil Nation A’s attacking missile if the radio frequency of both of the missiles match. Each hackerX missile can be used an indefinite number of times. Its invincible and doesn't get destroyed in the collision. The good news is you can adjust the frequency of the hackerX missile to match the evil missiles' frequency. When changing the hackerX missile's initial frequency fA to the new defending frequency fB, you will need \|fB - fA\| units of time to do.  Each hackerX missile can only destroy one of Nation A's missile at a time. So if two evil missiles with same frequency arrive at the same time, you need at least two hackerX missiles with the same frequency as the evil missiles to avoid damage.  If two evil missles with same frequency arrive at the same time, we can destroy them both with one hackerX missile. You can set the frequency of a hackerX missile to any value when its fired.   What is the minimum number of hackerX missiles you must launch to keep Nation B safe? Input Format:  The first line contains a single integer N denoting the number of missiles.  This is followed by N lines each containing two integers ti and fi denoting the time & frequency of the ith missile. Output Format:  A single integer denoting the minimum number of hackerX missiles you need to defend the nation. Constraints:  1 <=  N  <= 100000  0 <= ti <= 100000  0 <= fi <= 100000  t1 <= t2 <= ... <= tN  Sample Input #00  4 1 1 2 2 3 1 5 1  Sample Output #00  1  Explanation #00 A HackerX missile is launched at t = 1 with a frequency f = 1, and destroys the first missile. It re-tunes its frequency to f = 2 in 1 unit of time, and destroys the missile that is going to hit Nation B at t = 2. It re-tunes its frequency back to 1 in 1 unit of time and destroys the missile that is going to hit the nation at t = 3. It is relaunched at t = 5 with f = 1 and destroys the missile that is going to hit nation B at t = 5. Hence, you need only 1 HackerX to protect nation B.  Sample Input #01  4 1 1 2 3 3 1 5 1  Sample Output #01  2  Explanation #01 Destroy 1 missile at t = 1, f = 1. now at t = 2, there is a missile with frequency 3. The launched missile takes 2 units of time to destroy this, hence we need a new hackerX missile to destroy this one. The first hackerX missile can destroy the 3rd missile which has the same frequency as itself. The same hackerX missile destroys the missile that is hitting its city at t = 5. Thus, we need atleast 2 hackerX missiles.
__label__Tree A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued.   Example 1:  Input: [1,1,1,1,1,null,1] Output: true   Example 2:  Input: [2,2,2,5,2] Output: false     Note:  The number of nodes in the given tree will be in the range [1, 100]. Each node's value will be an integer in the range [0, 99].
__label__Tree Print a binary tree in an m*n 2D string array following these rules:   The row number m should be equal to the height of the given binary tree. The column number n should always be an odd number. The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them.  Each unused space should contain an empty string "". Print the subtrees following the same rules.  Example 1: Input:      1     /    2 Output: [["", "1", ""],  ["2", "", ""]]   Example 2: Input:      1     / \    2   3     \      4 Output: [["", "", "", "1", "", "", ""],  ["", "2", "", "", "", "3", ""],  ["", "", "4", "", "", "", ""]]   Example 3: Input:       1      / \     2   5    /    3   /  4  Output:  [["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]  ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]  ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]  ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]   Note: The height of binary tree is in the range of [1, 10].
__label__Mathematics An integer  is a divisor of an integer  if the remainder of .   Given an integer, for each digit that makes up the integer determine whether it is a divisor.  Count the number of divisors occurring within the integer.   Note: Each digit is considered to be unique, so each occurrence of the same digit should be counted (e.g. for ,  is a divisor of  each time it occurs so the answer is ). Function Description Complete the findDigits function in the editor below.  It should return an integer representing the number of digits of  that are divisors of .   findDigits has the following parameter(s): n: an integer to analyze Input Format The first line is an integer, , indicating the number of test cases.  The  subsequent lines each contain an integer, .   Constraints    Output Format For every test case, count the number of digits in  that are divisors of .  Print each answer on a new line. Sample Input 2 12 1012  Sample Output 2 3  Explanation The number  is broken into two digits,  and . When  is divided by either of those two digits, the remainder is  so they are both divisors. The number  is broken into four digits, , , , and .  is evenly divisible by its digits , , and , but it is not divisible by  as division by zero is undefined.
__label__Graph-Algorithms Sophia is playing a game on the computer. There are two random arrays A & B, each having the same number of elements. The game begins with Sophia removing a pair (Ai, Bj) from the array if they are not co-prime. She keeps a count on the number of times this operation is done.  Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value? Input Format The first line contains an integer n. 2 lines follow, each line containing n numbers separated by a single space. The format is shown below.  n A[0] A[1] ... A[n - 1] B[0] B[1] ... B[n - 1]  Constraints 0 < n <= 105  2 <= A[i], B[i] <= 109  Each element in both arrays are generated randomly between 2 and 109 Output Format Output S which is the maximum number of times the above operation can be made. Sample Input 4 2 5 6 7 4 9 10 12  Sample Output 3  Explanation You can remove: (2, 4) (5, 10) (6, 9)  hence 3.
__label__Strings Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.   Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1 Example 4: Input: version1 = "1.01", version2 = "1.001" Output: 0 Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1” Example 5: Input: version1 = "1.0", version2 = "1.0.0" Output: 0 Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"   Note:  Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes.  Version strings do not start or end with dots, and they will not be two consecutive dots.
__label__Strings Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?
__label__Search Numeros the Artist had two lists that were permutations of one another.  He was very proud. Unfortunately, while transporting them from one exhibition to another, some numbers were lost out of the first list. Can you find the missing numbers? As an example, the array with some numbers missing, .  The original array of numbers .  The numbers missing are .   Notes  If a number occurs multiple times in the lists, you must ensure that the frequency of that number in both lists is the same. If that is not the case, then it is also a missing number.  You have to print all the missing numbers in ascending order.  Print each missing number once, even if it is missing multiple times.  The difference between maximum and minimum number in the second list is less than or equal to .   Function Description  Complete the missingNumbers function in the editor below.  It should return a sorted array of missing numbers.   missingNumbers has the following parameter(s): arr: the array with missing numbers    brr: the original array of numbers    Input Format There will be four lines of input:    - the size of the first list,    The next line contains  space-separated integers    - the size of the second list,    The next line contains  space-separated integers   Constraints       Output Format Output the missing numbers in ascending order. Sample Input Sample Output Explanation  is present in both arrays. Its frequency in  is , while its frequency in  is . Similarly,  and  occur twice in , but three times in . The rest of the numbers have the same frequencies in both lists.
__label__Mathematics Meereen is famous for its fighting pits where fighters fight each other to the death. Initially, there are  fighters and each fighter has a strength value. The  fighters are divided into  teams, and each fighter belongs exactly one team. For each fight, the Great Masters of Meereen choose two teams,  and , that must fight each other to the death. The teams attack each other in alternating turns, with team  always launching the first attack. The fight ends when all the fighters on one of the teams are dead. Assume each team always attacks optimally. Each attack is performed as follows: The attacking team chooses a fighter from their team with strength . The chosen fighter chooses at most  fighters from other team and kills all of them.  The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries: 1 p x Add a new fighter with strength  to team . It is guaranteed that this new fighter's strength value will not be less than any current member of team . 1 p x 2 x y Print the name of the team that would win a matchup between teams  and  in their current state (recall that team  always starts first). It is guaranteed that .  2 x y Given the initial configuration of the teams and  queries, perform each query so the Great Masters can plan the next fight. Note: You are determining the team that would be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups. Input Format The first line contains three space-separated integers describing the respective values of  (the number of fighters),  (the number of teams), and  (the number of queries).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of fighter 's strength, , and team number, .  Each of the  subsequent lines contains a space-separated query in one of the two formats defined in the Problem Statement above (i.e., 1 p x or 2 x y). 1 p x 2 x y Constraints     It is guaranteed that both teams in a query matchup will always have at least one fighter. Scoring  This challange has binary scoring. This means you will get a full score if your solution passes all test cases; otherwise, you will get  points. Output Format After each type  query, print the name of the winning team on a new line. For example, if  and  are matched up and  wins, you would print . Sample Input 7 2 6 1 1 2 1 1 1 1 2 1 2 1 2 2 2 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2 2 2 1  Sample Output 1 2 1 1  Explanation Team  has three fighters with the following strength levels: .  Team  has four fighters with the following strength levels: .       The first query matching up team  and  would play out as follows: Team  attacks  The fighter with strength  can kill one fighter with strength  and one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the last fighter with strength . Now, , and . After this last attack, all of Team 's fighters would be dead. Thus, we print  as team  would win that fight.
__label__Binary-Search Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]    Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?
__label__Array __label__Tree __label__Depth-first-Search Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7
__label__Data-Structures __label__Advanced-Data-Structures White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques?  There are  types of query operations that can be performed on a tree: 1 u x: Assign  as the value of node . 1 u x 2 u v: Print the sum of the node values in the unique path from node  to node . 2 u v Given a tree with  nodes where each node's value is initially , execute  queries.  Input Format The first line contains  space-separated integers,  and , respectively.  The  subsequent lines each contain  space-separated integers describing an undirected edge in the tree.  Each of the  subsequent lines contains a query you must execute. Constraints   It is guaranteed that the input describes a connected tree with  nodes.  Nodes are enumerated with -based indexing. Output Format For each type- query, print its integer result on a new line. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 3  Explanation  After the first  queries, the value of node  and the value of node . The third query requires us to print the sum of the node values in the path from nodes  to , which is . Thus, we print  on a new line.
__label__Dynamic-Programming We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9
__label__Depth-first-Search Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.   Example:  Input: {"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}  Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3.    Note:  The number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph.
__label__Hash-Table Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.
__label__Greedy-Algorithms Given an array of stick lengths, use  of them to construct a non-degenerate triange with the maximum possible perimeter. Print the lengths of its sides as  space-separated integers in non-decreasing order. If there are several valid triangles having the maximum perimeter:  Choose the one with the longest maximum side.  If more than one has that maximum, choose from them the one with the longest minimum side.  If more than one has that maximum as well, print any one them. If no non-degenerate triangle exists, print -1. -1 For example, assume there are stick lengths .  The triplet  will not form a triangle.  Neither will  or , so the problem is reduced to  and .  The longer perimeter is .   Function Description  Complete the maximumPerimeterTriangle function in the editor below.  It should return an array of  integers that represent the side lengths of the chosen triangle in non-decreasing order.   maximumPerimeterTriangle has the following parameter(s):   sticks: an integer array that represents the lengths of sticks available   Input Format The first line contains single integer , the size of array .  The second line contains  space-separated integers , each a stick length. Constraints   Output Format Print the lengths of the  chosen sticks as space-separated integers in non-decreasing order. If no non-degenerate triangle can be formed, print -1. -1 Sample Input 0 Sample Output 0 Explanation 0 There are  possible unique triangles:     The second triangle has the largest perimeter, so we print its side lengths on a new line in non-decreasing order. Sample Input 1 Sample Output 1 Explanation 1 The triangle  is degenerate and thus can't be constructed, so we print -1 on a new line. -1 Sample Input 2 Sample Output 2 Explanation 2 The triangle (1,1,1) is the only valid triangle.
__label__Dynamic-Programming __label__Mathematics Given an integer, , find the smallest integer  such that  is divisible by  (i.e.,  is a factor of ) and satisfies the following properties:  must not contain zeroes in its decimal representation.  The sum of 's digits must be greater than or equal to the product of 's digits.  Given , find  and print the number of digits in 's decimal representation.  Input Format A single integer denoting . Constraints   is not divisible by . Time Limits The time limits for this challenge are available here. Output Format Print the number of digits in the decimal representation of the smallest possible . Sample Input 0 Sample Output 0 Explanation 0  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in  (which also happens to be ) as our answer. Sample Input 1 Sample Output 1 Explanation 1  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in , which is , as our answer.
__label__Hash-Table __label__Binary-Search Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
__label__Strings __label__Greedy-Algorithms Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?
__label__Strings Alice wrote a sequence of words in CamelCase as a string of letters, , having the following properties: It is a concatenation of one or more words consisting of English letters. All letters in the first word are lowercase.  For each of the subsequent words, the first letter is uppercase and rest of the letters are lowercase. Given , print the number of words in  on a new line. For example, .  There are  words in the string.   Function Description Complete the camelcase function in the editor below.  It must return the integer number of words in the input string.   camelcase has the following parameter(s): s: the string to analyze   Input Format A single line containing string . Constraints  Output Format Print the number of words in string . Sample Input saveChangesInTheEditor  Sample Output 5  Explanation String  contains five words: save Changes In The Editor Thus, we print  on a new line. Need help? Try this problem first to get familiar with HackerRank environment.
__label__Strings You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.   Example 1: Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"] Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]    Constraints:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.
__label__Depth-first-Search There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network. A critical connection is a connection that, if removed, will make some server unable to reach some other server. Return all critical connections in the network in any order.   Example 1:  Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output: [[1,3]] Explanation: [[3,1]] is also accepted.    Constraints:  1 <= n <= 10^5 n-1 <= connections.length <= 10^5 connections[i][0] != connections[i][1] There are no repeated connections.
__label__Hash-Table __label__Mathematics Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
__label__Tree __label__Depth-first-Search Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5
__label__Array On an infinite number line, the position of the i-th stone is given by stones[i].  Call a stone an endpoint stone if it has the smallest or largest position. Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]   Example 1: Input: [7,4,9] Output: [1,2] Explanation:  We can move 4 -> 8 for one move to finish the game. Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.   Example 2: Input: [6,5,4,3,10] Output: [2,3] We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.   Example 3: Input: [100,101,104,102,103] Output: [0,0]     Note:  3 <= stones.length <= 10^4 1 <= stones[i] <= 10^9 stones[i] have distinct values.
__label__Dynamic-Programming Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.
__label__Data-Structures __label__Advanced-Data-Structures Two positive integers  and  are given.   is decimal representation of integer .  Lets define . For example, if :   For each query you will be given two integers  and  that define a substring equal to .  Your task is to calculate divisibility of given substring.  Divisibility of given substring is equal to number of  pairs such that:   and   is divisible by , assuming that  is divisible by any other integer. Timelimits  Timelimits for this challenge is given here Input Format First line contains two integers  and  separated by a single space.  is the number of queries.  Second line contains a big integer .  Next  lines contains two integers  and  separated by a single space each - begin and end points of substring. Constraints   Output Format Output  lines, the -th line of the output should contain single integer  divisibility of the -th query substring. Sample Input 3 5 4831318 3 5 5 7 1 7 1 2 2 3  Sample Output 2 3 9 1 1  Explanation In the first query, b = 3 and e = 5. Two such pairs that are divisible by P = 3 are   f(3, 3) = 3 and f(5, 5). Hence the answer 2.   In the second query, b = 5 and e = 7. Three such pairs that are divisible by P are   F(5, 5) = 3, f(6, 7) = 18 and f(5, 7) = 318
__label__Strings The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"
__label__Tree Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)   Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12]     Note:   1 <= preorder.length <= 100 The values of preorder are distinct.
__label__Dynamic-Programming A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.
__label__Mathematics You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].
__label__Dynamic-Programming __label__Strings We define a function, , on a string, , as follows:   where:  denotes the number of characters in string .  denotes the number of distinct characters in string . Consuela loves creating string challenges and she needs your help testing her newest one! Given a string, , consisting of  lowercase letters, compute the summation of function  (provided above) over all possible distinct substrings of . As the result is quite large, print it modulo . Input Format The first line contains a single integer, , denoting the number of test cases.  Each of the  subsequent lines contains a string, . Constraints     The sum of  over all test cases does not exceed . Scoring  for  of test data.  for  of test data.    for  of test data. Output Format For each test case, print the answer modulo . Sample Input 3 aa aba abc  Sample Output 3 19 38  Explanation Test 0:  and  are the only distinct substrings.     Test 1: , , , , and  are the only distinct substrings.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head node of a doubly linked list. Reverse the order of the nodes in the list. The head node might be NULL to indicate that the list is empty.  Change the next and prev pointers of all the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.  Function Description Complete the reverse function in the editor below.  It should return a reference to the head of your reversed list. reverse has the following parameter(s): head: a reference to the head of a DoublyLinkedList Input Format The first line contains an integer , the number of test cases.   Each test case is of the following format: The first line contains an integer , the number of elements in the linked list.   The next  lines contain an integer each denoting an element of the linked list. Constraints       Output Format Return a reference to the head of your reversed list.  The provided code will print the reverse array as a one line of space-separated integers for each test case.   Sample Input 1 4 1 2 3 4  Sample Output 4 3 2 1   Explanation The initial doubly linked list is:   The reversed doubly linked list is:
__label__Depth-first-Search Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.
__label__Mathematics On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C
__label__Tree We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree. Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:  If A is empty, return null. Otherwise, let A[i] be the largest element of A.  Create a root node with value A[i]. The left child of root will be Construct([A[0], A[1], ..., A[i-1]]) The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) Return root.  Note that we were not given A directly, only a root node root = Construct(A). Suppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values. Return Construct(B).   Example 1:  Input: root = [4,1,3,null,null,2], val = 5 Output: [5,4,null,1,3,null,null,2] Explanation: A = [1,4,2,3], B = [1,4,2,3,5]   Example 2:  Input: root = [5,2,4,null,1], val = 3 Output: [5,2,4,null,1,null,3] Explanation: A = [2,1,5,4], B = [2,1,5,4,3]   Example 3:  Input: root = [5,2,3,null,1], val = 4 Output: [5,2,4,null,1,3] Explanation: A = [2,1,5,3], B = [2,1,5,3,4]      Note:  1 <= B.length <= 100
__label__Array Students are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)   Example 1: Input: [1,1,4,2,1,3] Output: 3 Explanation:  Students with heights 4, 3 and the last 1 are not standing in the right positions.    Note:  1 <= heights.length <= 100 1 <= heights[i] <= 100
__label__Strings A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.) Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.   Example 1: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB" Output: [true,false,true,true,false] Explanation:  "FooBar" can be generated like this "F" + "oo" + "B" + "ar". "FootBall" can be generated like this "F" + "oot" + "B" + "all". "FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer". Example 2: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa" Output: [true,false,true,false,false] Explanation:  "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r". "FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".  Example 3: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT" Output: [false,true,false,false,false] Explanation:  "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".    Note:  1 <= queries.length <= 100 1 <= queries[i].length <= 100 1 <= pattern.length <= 100 All strings consists only of lower and upper case English letters.
__label__Graph-Algorithms Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in  houses in Happy Harbor that are numbered sequentially from  to . There are  roads, and each road  connects two different houses,  and . Each superhero house  (where ) has  dollars stashed away for a rainy day. As long as a superhero is home at house , Killgrave knows they will hand over all of their saved money, . Once he gets money from them, he moves on to the next house. However, the superheroes are cunning; when Killgrave comes to house , every neighbor immediately connected to house  by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road. What is the maximum amount of money Killgrave can collect from the superheroes, and how many different ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different. Note: Killgrave can start at an arbitrary house and doesn't have to only use the roads. Input Format The first line contains two space-separated integers,  (the number of houses) and  (the number of roads), respectively.  The second line contains  space-separated integers, where each integer  describes the amount of money, , at house .  Each line  of the  subsequent lines contains two space-separated integers defining a road connecting houses  and . Every road connects a different pair of houses. Constraints    , where  No unordered pair  will appear more than once. Output Format Print two space-separated integers: The first integer must denote the maximum amount of money Killgrave can get out of the Justice League. The second integer must denote the number of different ways he can collect that amount of money. Sample Input 3 2 6 8 2 1 2 3 2  Sample Output 8 2  Explanation  Killgrave has two possible courses of action: Visit house  and get  dollars. Visit houses  and  and get  dollars.  Both of these options result in  dollars, so we know that this is maximal. Thus, we print the maximum amount of money () followed by the number of ways he can get that amount of money () as two space-separated values on a single line.
__label__Array A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.   Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}    Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].
__label__Array Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]
__label__Array Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]
__label__Array A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15
__label__Array __label__Hash-Table __label__Binary-Search __label__Dynamic-Programming Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].    Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100
__label__Bit Johnny is playing with a large binary number, . The number is so large that it needs to be compressed into an array of integers, , where the values in even indices () represent some number of consecutive  bits and the values in odd indices () represent some number of consecutive  bits in alternating substrings of .        For example, suppose we have array .  represents ,  represents ,  represents ,  represents , and  represents . The number of consecutive binary characters in the  substring of  corresponds to integer , as shown in this diagram:  When we assemble the sequential alternating sequences of 's and 's, we get . We define setCount() to be the number of 's in a binary number, . Johnny wants to find a binary number, , that is the smallest binary number  where setCount() = setCount(). He then wants to compress  into an array of integers,  (in the same way that integer array  contains the compressed form of binary string ). Johnny isn't sure how to solve the problem. Given array , find integer array  and print its length on a new line. Then print the elements of array  as a single line of space-separated integers. Input Format The first line contains a single positive integer, , denoting the number of test cases. Each of the  subsequent lines describes a test case over  lines: The first line contains a single positive integer, , denoting the length of array .  The second line contains  positive space-separated integers describing the respective elements in integer array  (i.e., ). Constraints   Subtasks For a  score, . For a  score, . Output Format For each test case, print the following  lines:   Print the length of integer array  (the array representing the compressed form of binary integer ) on a new line.  Print each element of  as a single line of space-separated integers. It is guaranteed that a solution exists. Sample Input 0 Sample Output 0 Explanation 0 , which expands to . We then find setCount() . The smallest binary number  which also has eleven 's is . This can be reduced to the integer array . This is demonstrated by the following figure:  Having found , we print its length () as our first line of output, followed by the space-separated elements in  as our second line of output.
__label__Hash-Table Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].
__label__Two-Pointers Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5
__label__Tree __label__Depth-first-Search Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin.    Example 1:  Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.   Example 2:  Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.   Example 3:  Input: [1,0,2] Output: 2   Example 4:  Input: [1,0,0,null,3] Output: 4    Note:  1<= N <= 100 0 <= node.val <= N
__label__Graph-Algorithms There are  people at the railway station, and each one wants to buy a ticket to go to one of  different destinations. The  people are in a queue.   There are  ticket windows from which tickets can be purchased. The  people will be distributed in the windows such that the order is maintained. In other words, suppose we number the people  to  from front to back. If person  and person  go to the same window and , then person  should still be ahead of person  in the window.   Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.   For example, suppose there are  people in the queue for a single ticket window, all with the same destination which costs  bucks. Then the first person in the queue pays  bucks, and the 2nd and 3rd persons get a discount of 20% on  bucks, so they end up paying  bucks each instead of  bucks.   Try to distribute the  people across the  windows such that the total cost  paid by all  people is minimized.   Input Format The first line contains  integers:  is the number of people    is the number of ticket windows    is the number of destinations separated by a single space (in the same order)  Then  lines follow. The  line contains an alphanumeric string  and an integer :  is the  destination    is the ticket price for   Then  lines follow. The  line contains an alphanumeric string  which is the destination of the  person.   Constraints       The  available destinations have nonempty and distinct names.   Each person's destination appears in the list of  available destinations.     Output Format Output  lines. The first line contains , the total cost that is to be minimized. In the  following line, print the ticket window which the  person goes to. The windows are indexed  to . There may be multiple ways to distribute the people among the windows such that the total cost is minimized; any one will be accepted.   The answer  will be accepted if it is within an error of  of the true answer.   Sample Input 5 2 3 CALIFORNIA 10 HAWAII 8 NEWYORK 12 NEWYORK NEWYORK CALIFORNIA NEWYORK HAWAII  Sample Output 49.2 1 1 2 1 1  Explanation At the beginning, all the people are in the same queue, and will go to the ticket windows one by one in the initial order.    will buy ticket in the first window.   will buy ticket in the second window.   In the first ticket window, #1 will pay  bucks to go to NEWYORK, and #2 and #4 have the same destination with the person in front of them, so they will get 20% off, and will pay  bucks each. #5 has a different destination, so it will cost him  bucks to go to HAWAII.   NEWYORK HAWAII In the second ticket window, #3 will pay  bucks to go to CALIFORNIA.   CALIFORNIA
__label__Dynamic-Programming There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100
__label__Graph-Algorithms __label__Greedy-Algorithms Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:   The subgraph contains all the nodes present in the original graph.   The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.   It is also required that there is exactly one, exclusive path between any two nodes of the subgraph.  One specific node  is fixed as the starting point of finding the subgraph using Prim's Algorithm.  Find the total weight or the sum of all edges in the subgraph.   For example, consider a graph with  nodes.  Possible edges are  weight ,  weight  and  weight .  Starting from node , we select the lower weight path, i.e. , weight .  From node , there is only one path left,  weight .  We have all nodes connected at a cost of .   Function Description Complete the prims function in the editor below.  It should return and integer that represents the minimum weight to connect all nodes in the graph provided.   prims has the following parameter(s):   n: an integer that represents the number of nodes in the graph   edges: a two-dimensional array where each element contains three integers, two nodes numbers that are connected and the weight of that edge   start: an integer that represents the number of the starting node   Input Format The first line has two space-separated integers  and , the number of nodes and edges in the graph.   Each of the next  lines contains three space-separated integers ,  and , the end nodes of , and the edge's weight.  The last line has an integer , denoting the starting node.   Constraints         There may be multiple edges between two nodes. Output Format Print a single integer denoting the total weight of the subgraph.   Sample Input 0 Sample Output 0 Explanation 0 The graph given in the test case is shown as :  The starting node is  (in the given test case) Applying the Prim's algorithm, edge choices available at first are :  (WT. 3)  and  (WT. 4) , out of which  is chosen (smaller weight of edge). Now the available choices are :   (WT. 4) ,  (WT. 5) ,  (WT. 2) and  (WT. 6) , out of which  is chosen by the algorithm.  Following the same method of the algorithm, the next chosen edges , sequentially are :  and . Hence the overall sequence of edges picked up by Prim's are:   and the total weight of the MST (minimum spanning tree) is :
__label__Data-Structures __label__Advanced-Data-Structures Coolguy gives you a simple problem. Given a -indexed array, , containing  elements, what will  be after this pseudocode is implemented and executed? Print . //f(a, b) is a function that returns the minimum element in interval [a, b]  ans = 0  for a -> [1, n]     for b -> [a, n]         for c -> [b + 1, n]             for d -> [c, n]                 ans = ans + min(f(a, b), f(c, d))  Input Format The first line contains  (the size of array ).  The second line contains  space-separated integers describing . Constraints  ≤  ≤   ≤  ≤  Note:  is -indexed (i.e.: ). Output Format Print the integer result of . Sample Input 3 3 2 1  Sample Output 6  Explanation       We then sum these numbers () and print , which is .
__label__Dynamic-Programming __label__Tree Byteland has  cities (numbered from  to ) and  bidirectional roads. A path is comprised of  or more connected roads. It is guaranteed that there is a path from any city to any other city. Steven is a road maintenance worker in Byteland. He is required to maintain exactly  paths on any given workday. He cannot work on the same road twice in one day (so no  paths can contain the same  roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city. Given , help Steven determine how many different possible path sets will allow him to perform his maintenance duties. Then print the answer modulo . Input Format The first line contains  space-separated integers,  (the number of cities) and  (the number of roads to maintain).  Each line  of the  subsequent lines contains  space-separated integers, , describing a bidirectional road between cities  and . Constraints     Output Format Find the number of different path sets that will allow Steven to complete  orders, and print the answer .  Sample Input 4 2 1 2 2 3 2 4  Sample Output 6  Explanation For the following Byteland map:   Steven can maintain  roads using any of the following  routes:  and   and   and   and   and   and  Thus, we print the result of  on a new line, which is .
