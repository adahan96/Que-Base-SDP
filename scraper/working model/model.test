__label__Strings John has collected various rocks. Each rock has various minerals embeded in it.  Each type of mineral is designated by a lowercase letter in the range . There may be multiple occurrences of a mineral in a rock. A mineral is called a gemstone if it occurs at least once in each of the rocks in John's collection. Given a list of minerals embedded in each of John's rocks, display the number of types of gemstones he has in his collection. For example, the array of mineral composition strings .  The minerals  and  appear in each composite, so there are  gemstones. Function Description  Complete the gemstones function in the editor below.  It should return an integer representing the number of gemstones found in the list of rocks.   gemstones has the following parameter(s):   arr: an array of strings   Input Format The first line consists of an integer , the size of .  Each of the next  lines contains a string  where each letter represents an occurence of a mineral in the current rock. Constraints    | arr[i] |   Each composition  consists of only lower-case Latin letters ('a'-'z').   Output Format Print the number of types of gemstones in John's collection. If there are none, print . Sample Input 3 abcdde baccd eeabg  Sample Output 2  Explanation Only  and  are gemstones because they are the only types that occur in every rock.
__label__Tree __label__Data-Structures Greg has a tree of nodes containing integer data.  He wants to insert a node with some non-zero integer value somewhere into the tree.  His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount.  This is called a balanced forest.  Being frugal, the data value he inserts should be minimal.  Determine the minimal amount that a new node can have to allow creation of a balanced forest.  If it's not possible to create a balanced forest, return -1. For example, you are given node values  and .  It is the following tree:     The blue node is root, the first number in a node is node number and the second is its value.  Cuts can be made between nodes  and  and nodes  and  to have three trees with sums ,  and .  Adding a new node  of  to the third tree completes the solution.   Function Description Complete the balancedForest function in the editor below.  It must return an integer representing the minimum value of  that can be added to allow creation of a balanced forest, or  if it is not possible.   balancedForest has the following parameter(s): c: an array of integers, the data values for each node   edges: an array of 2 element arrays, the node pairs per edge   Input Format The first line contains a single integer, , the number of queries.   Each of the following  sets of lines is as follows:   The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers describing the respective values of , where each  denotes the value at node . Each of the following  lines contains two space-separated integers,  and , describing edge  connecting nodes  and . Constraints       Each query forms a valid undirected tree.   Subtasks For  of the maximum score:   For  of the maximum score:   Output Format For each query, return the minimum value of the integer .  If no such value exists, return  instead.  Sample Input 2 5 1 2 2 1 1 1 2 1 3 3 5 1 4 3 1 3 5 1 3 1 2  Sample Output 2 -1  Explanation We perform the following two queries: The tree initially looks like this:         Greg can add a new node  with  and create a new edge connecting nodes  and . Then he cuts the edge connecting nodes  and  and the edge connecting nodes  and . We now have a three-tree balanced forest where each tree has a sum of .       In the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .
__label__Dynamic-Programming Capeta is working part-time for an animal shipping company. He needs to pick up animals from various zoos and drop them to other zoos. The company ships four kinds of animals: elephants, dogs, cats, and mice. There are  zoos, numbered  to . Also, there are  animals. For each animal , Capeta knows its type  (E for elephant, D for dog, C for cat and M for mouse), source zoo  where Capeta has to pick it up from, and destination zoo  where Capeta needs to deliver it to.  E D C M  Capeta is given a truck with a huge capacity where  animals can easily fit. He is also given additional instructions: He must visit the zoos in increasing order. He also cannot skip zoos.  He must visit the zoos in increasing order. He also cannot skip zoos.  Dogs are scared of elephants, so he is not allowed to bring them together at the same time.  Dogs are scared of elephants, so he is not allowed to bring them together at the same time.  Cats are scared of dogs, so he is not allowed to bring them together at the same time.  Mice are scared of cats, so he is not allowed to bring them together at the same time.  Elephants are scared of mice, so he is not allowed to bring them together at the same time.  Also, loading and unloading animals are complicated, so once an animal is loaded onto the truck, that animal will only be unloaded at its destination.  Because of these reasons, Capeta might not be able to transport all animals. He will need to ignore some animals. Which ones? The company decided to leave that decision for Capeta. He is asked to prepare a report and present it at a board meeting of the company. Capeta needs to report the minimum number of zoos that must be reached so that she is able to transport  animals, for each  from  to .  Complete the function minimumZooNumbers and return an integer array where the  integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport  animals, or  if it is impossible to transport  animals.  minimumZooNumbers He is good at driving, but not so much at planning. Hence, he needs your help. Input Format The first line contains a single integer , the number of test cases. Each test case consists of four lines. The first line contains two space-separated integers  and . The second line contains  space-separated characters . The third line contains  space-separated integers . The fourth line contains  space-separated integers .   ,  and  are the details for the th animal, as described in the problem statement. Constraints         is either E, D, C or M E D C M Subtasks  For  of the total score,   Output Format For each case, print a single line containing  space-separated integers, where the  integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport  animals. If it is not possible to transport  animals at all, then put  instead. Sample Input 0 Sample Output 0 Explanation 0 First Test Case Capeta can transport one animal by traveling up to zoo number . Just drop the dog there. Next, in order to transport  animals (elephant and cat), Capeta has to go up to zoo number . Second Test Case  Animal: Drop the elephant to zoo .  Animal: Drop the elephant and cat to zoo .  Animal: Drop the elephant and cat to zoo . Then drop the mouse to zoo .  Animal: Drop the elephant and cat to zoo . Then drop the mouse to zoo . Finally, drop either the elephant or the dog to . It is impossible to transport  or  animals.
__label__Hash-Table __label__Depth-first-Search You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.  Â  Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.
__label__Dynamic-Programming A war has broken down between Vim and Emacs. Gedit, being Vim's ally, is captured by Emacs as a prisoner of war and it is up to Vim to rescue him by defeating Emacs. For this task, Vim has to assemble an army of appropriate skills. He can choose a non-empty subset of soldiers from a set of  soldiers (numbered from  to ). Each soldier has some subset of skills out of  different skills (numbered from  to ). The skill-set of an army is the union of skill-sets of its constituent soldiers. To win the war, Vim needs to know how many different subsets of soldiers satisfy his skill-set requirement. Since the answer can be huge, print it modulo .  Note : The chosen army's skill-set must exactly match the skill-set requirement of Vim (i.e no extra skills must be present in the army's skill-set than what is required). Input Format The first line contains  and , the number of soldiers to choose from and the number of different skills possible respectively.  The next  lines contain  boolean characters each. If the  character of the  line is , then the  soldier possess the  skill and if it is , then not.  The last line contains  boolean characters denoting the requirement skill-set of Vim where the  character being  signifies that Vim wants the  skill to be present in his final army and not, otherwise. Constraints     Output Format Output in a single line the required answer, as explained above.   Sample Input 4 2   00   10   01   11   11    Sample Output 10  Explanation Vim wants both the skills to be present in his selected army. Hence, he can choose the following subsets of soldiers:
__label__Tree __label__Depth-first-Search Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]  Â   -10 Â  Â / \ Â  9 Â 20 Â  Â  / Â \ Â  Â 15 Â  7  Output: 42
__label__Game-Theory __label__Game-Theory Alice and Bob are playing a game, defined below: There is an undirected tree graph with  nodes that has the following properties:  Each node has  golden coins.  Node  is root of the tree.  The parent node of some node  is defined as . Each node has  golden coins.  Node  is root of the tree.  The parent node of some node  is defined as . Moves Players move in turns.  During a move, a player can select a node  and move one or more coins to .  If the current player can't make any move, they lose the game. Players move in turns.  During a move, a player can select a node  and move one or more coins to .  If the current player can't make any move, they lose the game. The game quickly becomes boring because the result is determined by the tree's configuration and the number of coins in each node (assuming that both players play optimally). Alice decides to instead challenge Bob by asking him  questions. For each question : Alice picks a node  and removes the edge between  and .  She picks another node  and draws a new undirected edge between  and . So now . Bob must determine if the first player has a winning strategy for the new tree or not. It's possible that after Alice draws the new edge, the graph will no longer be a tree; if that happens, the question is invalid. Each question is independent, so the answer depends on the initial state of the graph (and not on previous questions). Given the tree and the number of coins in each node, can you help Bob answer all  questions? Input Format The first line contains an integer,  (the number of nodes).  The second line contains  space-separated integers, , describing the number of coins in each node.  Each of the  subsequent lines contains  space-separated integers denoting an undirected edge between nodes  and , respectively.  The next line contains an integer,  (the number of questions Alice asks).  Each of the  subsequent lines contains  space-separated integers,  and , respectively. Constraints    For each question:    Output Format On a new line for each question, print  if the first player has a winning strategy, print  if they do not, or print  if the question is not valid. Sample Input 6 0 2 2 1 3 2 1 2 1 3 3 4 3 5 4 6 3 6 2 4 1 3 6  Sample Output NO YES INVALID  Explanation Initally the tree looks like this:  After the first question (), the tree looks like this:  Alice removes the edge conecting node  to  and makes  the new parent node of . Because this configuration does not result in a winning strategy, we print  on a new line. After the second question (), the tree looks like this:  Alice removes the edge conecting node  to  and makes  the new parent node of . Because this configuration results in a winning strategy, we print  on a new line. After the third question (), the graph is no longer a tree:  Alice removes the edge conecting node  to  and makes  the new parent node of . The graph is now partitioned into two separate subgraphs (one of which is also not a tree); because the game must be played on a single undirected tree graph, we print  on a new line.
__label__Array Given string S and aÂ dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range ofÂ [1, 5000]. The length of words[i] will be in the range of [1, 50].
__label__Game-Theory Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as to find tactical ideas. Consider the following simplified version of chess: Board:  It's played on a  board between two players named Black and White. Rows are numbered from  to , where the top row is  and the bottom row is .   Columns are lettered from  to , where the leftmost column is  and the rightmost column is . It's played on a  board between two players named Black and White. Rows are numbered from  to , where the top row is  and the bottom row is .   Columns are lettered from  to , where the leftmost column is  and the rightmost column is . Pieces and Movement:  White initially has  pieces and Black initially has  pieces. There are no Kings on the board. Each player initially has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). White's Pawns move up the board, while Black's Pawns move down the board. Each move made by any player counts as a single move. Each piece's possible moves are the same as in classical chess, with the following exceptions: Pawns cannot move two squares forward. The en passant move is not possible. Promotion: Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  White initially has  pieces and Black initially has  pieces. There are no Kings on the board. Each player initially has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). White's Pawns move up the board, while Black's Pawns move down the board. Each move made by any player counts as a single move. Each piece's possible moves are the same as in classical chess, with the following exceptions: Pawns cannot move two squares forward. The en passant move is not possible. Pawns cannot move two squares forward. The en passant move is not possible. Promotion: Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  Objective:  The goal of the game is to capture the opponentâs Queen without losing your own. There will never be a draw or tie scenario like you might see in classical chess. The goal of the game is to capture the opponentâs Queen without losing your own. There will never be a draw or tie scenario like you might see in classical chess. Given  and the layout of pieces for  games, implement a very basic engine for our simplified version of chess that determines whether or not White can win in  moves (regardless of how Black plays) if White always moves first. For each game, print YES on a new line if White can win in  moves; otherwise, print NO. YES NO Input Format The first line contains an integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains three space-separated integers describing the respective values of  (the number of white pieces),  (the number of black pieces), and  (the maximum number of moves we want to know if White can win in). The  subsequent lines describe each chess piece in the form t c r, where  is a character  denoting the type of piece (where  is Queen,  is Knight,  is Bishop,  is Rook, and  is a Pawn), and  and  denote the respective column and row on the board where the figure is located (where  and ). These inputs are  given as follows:  Each of the first  lines describes the type and location of a White piece. Each of the subsequent  lines describes the type and location of a Black piece. t c r Each of the first  lines describes the type and location of a White piece. Each of the subsequent  lines describes the type and location of a Black piece. Constraints       Each player has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). It is guaranteed that the initial location of each chess piece is distinct. No pawn is initially placed in a row where it would promote. Output Format For each of the  games of simplified chess, print whether or not White can win in  moves on a new line. If it's possible, print YES; otherwise, print NO instead. YES NO Sample Input 0 Sample Output 0 Explanation 0 We play the following  game of simplified chess:  White wins by moving their Pawn to  and capturing Black's Queen, so we print YES on a new line. YES
__label__Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i withÂ 0 < iÂ < A.length - 1Â such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[A.length - 1]    Â  Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true   Â  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000
__label__Dynamic-Programming In Chile, land are partitioned into a one large grid, where each element represents a land of size 1x1.   Shaka is a newcomer in Chile and is trying to start his own business. He is planning to build a store. He has his own ideas for the "perfect store" which can be represented by a HxW grid. Element at position (i, j) represents height of land at index (i, j) in the grid.   Shaka has purchased a land area which can be represented RxC grid (H <= R, W <= C). Shaka is interested in finding best HxW sub-grid in the acquired land. In order to compare the possible sub-grids, Shaka will be using the sum of squared difference between each cell of his "perfect store" and  it's corresponding cell in the subgrid. Amongst all possible sub-grids, he will choose the one with smallest such sum. Note The grids are 1-indexed and rows increase from top to bottom and columns increase from left to right.  If x is the height of a cell in the "perfect store" and y is the height of the corresponding cell in a sub-grid of the acquired land, then the squared difference is defined as (x-y)2  Input Format The first line of the input consists of two integers, R C, separated by single space.  Then R lines follow, each one containing C space separated integers, which describe the height of each land spot of the purchased land.  The next line contains two integers, H W, separated by a single space, followed by H lines with W space separated integers, which describes the "perfect store".   Constraints 1 <= R, C <= 500  1 <= H <= R  1 <= W <= C  No height will have an absolute value greater than 20.   Output Format In the first line, output the smallest possible sum (as defined above) Shaka can find on exploring all the sub-grids (of size HxW)  in the purchased land.  In second line, output two space separated integers, i j, which represents the index of top left corner of sub-grid (on the acquired land) with the minimal such sum. If there are multiple sub-grids with minimal sum, output the one with the smaller row index. If there are still multiple sub-grids with minimal sum, output the one with smaller column index.  Sample Input 3 3 19 19 -12 5 8 -14 -12 -11 9 2 2 -18 -12 -10 -7  Sample Output 937 2 2  Explanation The result is computed as follows: (8 - (-18)) 2 +  (-14 - (-12)) 2 + (-11 - (-10)) 2 + (9 - (-7)) 2 = 937
__label__Depth-first-Search There areÂ n servers numbered fromÂ 0Â toÂ n-1 connected byÂ undirected server-to-server connections forming a network where connections[i] = [a, b]Â represents a connection between servers aÂ and b. Any server can reach any other server directly or indirectly through the network. A critical connectionÂ is a connection that, if removed, will make some server unable to reach some other server. Return all critical connections in the network in any order. Â  Example 1:  Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output: [[1,3]] Explanation: [[3,1]] is also accepted.  Â  Constraints:  1 <= n <= 10^5 n-1 <= connections.length <= 10^5 connections[i][0] != connections[i][1] There are no repeated connections.
__label__Tree __label__Data-Structures Jenny loves experimenting with trees. Her favorite tree has  nodes connected by  edges, and each edge is  unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius  from this tree by performing the following two steps: Choose a node, , from the tree. Cut a subtree consisting of all nodes which are not further than  units from node .  For example, the blue nodes in the diagram below depict a subtree centered at  that has radius :  Given , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not  isomorphic. Input Format The first line contains two space-separated integers denoting the respective values of  and .  Each of the next  subsequent lines contains two space-separated integers,  and , describing a bidirectional edge in Jenny's tree having length . Constraints      Subtasks For  of the max score:     Output Format Print the total number of different possible subtrees. Sample Input 0 Sample Output 0 Explanation 0 In the diagram below, blue nodes denote the possible subtrees:  The last  subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 In the diagram below, blue nodes denote the possible subtrees:  Here, we have four possible different subtrees.
__label__Array Some people will make friend requests. TheÂ list of their ages is given andÂ ages[i]Â is the age of theÂ ith person.Â  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B]Â <= 0.5 * age[A]Â + 7 age[B]Â > age[A] age[B]Â > 100 &&Â age[A]Â < 100  Otherwise, A will friend request B. Note that ifÂ A requests B, B does not necessarily request A.Â  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.  Â  Notes:  1 <= ages.lengthÂ <= 20000. 1 <= ages[i] <= 120.
__label__Binary-Search Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  GivenÂ targetÂ =Â 5, returnÂ true. GivenÂ targetÂ =Â 20, returnÂ false.
__label__Graph-Algorithms __label__Tree You have a rooted tree with  vertices numbered from  through  where the root is vertex .  You are given  triplets, the  triplet is denoted by three integers . The  triplet represents a simple path in the tree with endpoints in  and  such that  is ancestor of . The cost of the path is .  You have to select a subset of the paths such that the sum of path costs is maximum and the  edge of the tree belongs to at most  paths from the subset. Print the sum as the output. Input Format The first line contains a single integer, , denoting the number of testcases. Each testcase is defined as follows: The first line contains two space-separated integers,  (the number of vertices) and  (the number of paths), respectively. Each line  of the  subsequent lines contains three space-separated integers describing the respective values of , , and  where (, ) is an edge in the tree and  is maximum number of paths which can include this edge. Each line of the  subsequent lines contains three space-separated integers describing the respective values of , , and  () that define the  path and its cost. Constraints Let  be the sum of  over all the trees.  Let  be the sum of  over all the trees.          Output Format You must print  lines, where each line contains a single integer denoting the answer for the corresponding testcase. Sample Input 1 8 8 1 2 3 1 3 1 2 4 5 2 5 1 2 6 1 3 7 2 4 8 1 1 2 3 2 8 5 1 8 7 1 5 8 1 6 10 3 7 5 1 7 6 1 7 6  Sample Output 37  Explanation  One of the possible subsets contains paths . Its total cost is .
__label__Dynamic-Programming Mr. Dorsey Dawson recently stole  grams of gold from ACME Jewellers. He is now on a train back home. To avoid getting caught by the police, he has to convert all the gold he has into paper money. He turns into a salesman and starts selling the gold in the train.   There are  passengers who have shown interest in buying the gold. The  passenger agrees to buy  grams of gold by paying  dollars. Dawson wants to escape from the police and also maximize the profit. Can you help him maximize the profit? Note: The  passenger would buy exactly  grams if the transaction is successful. Input Format The first line contains two space separated integers,  and ,  where  is the number of passengers who agreed to buy and  is the stolen amount of gold (in grams).   lines follow. Each line contains two space separated integers -  and , where  is the the value which the  passenger has agreed to pay in exchange for  grams of gold.   Constraints     all 's and 's are less than or equal to  and greater than .   Output Format If it's possible for Dorsey to escape, print the maximum profit he can enjoy, otherwise print Got caught!.   Got caught! Sample Input 0 Sample Output 0 Explanation 0 Selling it to passengers buying 4 grams and 6 grams would lead to 1050 dollars whereas selling it to passengers buying 5 grams gold would lead to 1140 dollars. Hence the answer.  Sample Input 1 Sample Output 1 Explanation 1 There is no way to sell all 9 grams of gold.
__label__Array __label__Dynamic-Programming A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28
__label__Data-Structures __label__Advanced-Data-Structures Roy has taken a liking to the Binary Search Trees(BST). He is interested in knowing the number of ways an array  of  integers can be arranged to form a BST. Thus, he tries a few combinations, and notes down the numbers at the odd levels and the numbers at the even levels.  You're given two values, alpha and beta. Can you calculate the sum of Liking of all possible BST's that can be formed from an array of  integers? Liking of each BST is defined as follows  (sum of numbers on even levels * alpha) - (sum of numbers on odd levels * beta)  Note  The root element is at level  ( Even ) The elements smaller or equal to the parent element are present in the left subtree, elements greater than or equal to the parent element are present in the right subtree.  Explained here If the answer is no less than , output the answer % .  (If the answer is less than , keep adding  until the value turns non negative.) Input Format  The first line of input file contains an integer, , denoting the number of test cases to follow.  Each testcase comprises of  lines.  The first line contains , the number of integers.  The second line contains two space separated integers, alpha and beta.  The third line contains space separated  integers_, denoting the  integer in array .   Output Format  Output  lines. Each line contains the answer to its respective test case.  Constraints          Sample Input Sample Output Explanation There are  test cases in total.  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  1 For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the third test case, we get  BSTs. The Liking of each of the BST from left  to right are  which sums to  and hence the answer.   Similarly, for the fourth test case, the answer is .
__label__Array __label__Dynamic-Programming In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.  Â  Note:  nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).
__label__Array __label__Two-Pointers Given n non-negative integers a1, a2, ..., anÂ , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note:Â You may not slant the container and n is at least 2. Â   The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can containÂ is 49.  Â  Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49
__label__Tree __label__Data-Structures You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function. Input Format You are given a function, Node * insert (Node * root ,int data) {  }  Constraints No. of nodes in the  tree  500 Output Format Return the root of the binary search tree after inserting the value into the tree. Sample Input         4        / \       2   7      / \     1   3  The value to be inserted is 6. Sample Output          4        /   \       2     7      / \   /     1   3 6
__label__Strings Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.
__label__Game-Theory __label__Game-Theory Big Cat and Little Cat love playing games. Today, they decide to play a Game of Stones, the Kitties are Coming edition. The game's rules are as follows:  The game starts with  stones that are randomly divided into  piles.  The cats move in alternating turns, and Little Cat always moves first. During a move, a cat picks a pile having a number of stones  and splits it into any number of non-empty piles in the inclusive range from  to .  The first cat to be unable to make a move (e.g., because all piles contain exactly  stone) loses the game.  Little Cat is curious about the number of ways in which the stones can be initially arranged so that she is guaranteed to win. Two arrangements of stone piles are considered to be different if they contain different sequences of values. For example, arrangements  and  are different. Given the values for , , and , find the number of winning configurations for Little Cat and print it modulo .  Note: Each cat always moves optimally, meaning that they're both playing to win and neither cat will make a move that causes them to lose the game if some other (winning) sequence of moves can be made. Input Format The first line of input contains three space-separated integers,  (the number of stones),  (the number of piles), and  (the maximum number of piles into which a pile can be split during a single move), respectively. Constraints    Output Format Print the number of initial arrangements of piles that will result in Little Cat winning, modulo . Sample Input 4 3 3  Sample Output 3  Explanation There are three possible arrangements:    For any arrangement, Little Cat can pick a pile containing  stones and split it into  piles with  stone each. At this point, the pile configuration will be , so Big Cat won't be able to make any moves and the game ends. We then print the result of  on a new line.
__label__Data-Structures __label__Advanced-Data-Structures You are given a list of  numbers . For each element at position  (), we define  and  as:   = closest index j such that j < i and . If no such j exists then  = 0.   = closest index k such that k > i and . If no such k exists then  = 0.    We define  =  * . You need to find out the maximum  among all i. Input Format The first line contains an integer , the number of integers. The next line contains the  integers describing the list a[1..N]. Constraints     Output Format Output the maximum  among all indices from  to .  Sample Input 5 5 4 3 4 5  Sample Output 8  Explanation We can compute the following:          The largest of these is 8, so it is the answer.
__label__Tree Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]
__label__Strings Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]
__label__Dynamic-Programming A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 Â   A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 â¤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k â¥ 2. The function should return the number of arithmetic subsequence slices in the array A. The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 â¤ N â¤ 1000. The output is guaranteed to be less than 231-1. Â   Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]
__label__Strings Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.
__label__Data-Structures __label__Advanced-Data-Structures You are given a rooted tree with N nodes and the root of the tree, R, is also given. Each node of the tree contains a value, that is initially empty. You have to mantain the tree under two operations: Update Operation Report Operation Update Operation  Each Update Operation begins with the character U. Character U is followed by 3 integers T, V and K. For every node which is the descendent of the node T, update it's value by adding V + d*K, where V and K are the parameters of the query and d is the distance of the node from T. Note that V is added to node T.   U U Report Operation  Each Report Operation begins with the character Q. Character Q is followed by 2 integers, A and B. Output the sum of values of nodes in the path from A to B modulo (109 + 7)  Q Q Input Format  The first Line consists of 3 space separated integers, N E R, where N is the number of nodes present, E is the total number of queries (update + report), and R is root of the tree.   Each of the next N-1 lines contains 2 space separated integers, X and Y (X and Y are connected by an edge). Thereafter, E lines follows: each line can represent either the Update Operation or the Report Operation. Update Operation is of the form : U T V K. Report Operation is of the form : Q A B. Output Format  Output the answer for every given report operation. Constraints  1 â¤ N, E â¤ 105  1 â¤ E â¤ 105  1 â¤ R, X, Y, T, A, B â¤ N  1 â¤ V, K â¤ 109  X â  Y Sample Input 7 7 1 1 2 2 3 2 4 2 5 5 6 6 7 U 5 10 2 U 4 5 3 Q 1 7 U 6 7 4 Q 2 7 Q 1 4 Q 2 4  Sample Output 36 54 5 5  Explanation  Values of Nodes after U 5 10 2: [0 0 0 0 10 12 14]. U 5 10 2 [0 0 0 0 10 12 14] Values of Nodes after U 4 5 3: [0 0 0 5 10 12 14].  U 4 5 3 [0 0 0 5 10 12 14] Sum of the Nodes from 1 to 7: 0 + 0 + 10 + 12 + 14 = 36. Values of Nodes after U 6 7 4: [0 0 0 5 10 19 25].   U 6 7 4 Sum of the Nodes from 2 to 7: 0 + 10 + 19 + 25 = 54.  Sum of the Nodes from 1 to 4: 0 + 0 + 5 = 5. Sum of the Nodes from 2 to 4: 0 + 5 = 5.
__label__Array __label__Strings Let's define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example,Â if s = "dcce" then f(s) = 2 because the smallest character is "c" and its frequency is 2. Now, given string arrays queriesÂ and words, return an integer array answer, where each answer[i]Â is the number of words such that f(queries[i])Â < f(W), where WÂ is a word in words. Â  Example 1: Input: queries = ["cbd"], words = ["zaaaz"] Output: [1] Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").  Example 2: Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"] Output: [1,2] Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").  Â  Constraints:  1 <= queries.length <= 2000 1 <= words.length <= 2000 1 <= queries[i].length, words[i].length <= 10 queries[i][j], words[i][j] are English lowercase letters.
__label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]
__label__Strings We consider two strings to be anagrams of each other if the first string's letters can be rearranged to form the second string. In other words, both strings must contain the same exact letters in the same exact frequency. For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not. bacdc dcbac bacdc dcbad Alice is taking a cryptography class and finding anagrams to be very useful. She decides on an encryption scheme involving two large strings where encryption is dependent on the minimum number of character deletions required to make the two strings anagrams. Can you help her find this number?  Given two strings,  and , that may not be of the same length, determine the minimum number of character deletions required to make  and  anagrams. Any characters can be deleted from either of the strings.  For example,  and .  The only characters that match are the 's so we have to remove  from  and  from  for a total of  deletions.   Function Description  Complete the makingAnagrams function in the editor below.  It should return an integer representing the minimum number of deletions needed to make the strings anagrams.   makingAnagrams has the following parameter(s):   s1: a string   s2: a string   Input Format The first line contains a single string, .  The second line contains a single string, . Constraints   It is guaranteed that  and  consist of lowercase English letters, ascii[a-z]. Output Format Print a single integer denoting the minimum number of characters which must be deleted to make the two strings anagrams of each other. Sample Input cde abc  Sample Output 4  Explanation We delete the following characters from our two strings to turn them into anagrams of each other: Remove d and e from cde to get c. d e cde c Remove a and b from abc to get c. a b abc c We had to delete  characters to make both strings anagrams.
__label__Search Numeros the Artist had two lists that were permutations of one another.  He was very proud. Unfortunately, while transporting them from one exhibition to another, some numbers were lost out of the first list. Can you find the missing numbers? As an example, the array with some numbers missing, .  The original array of numbers .  The numbers missing are .   Notes  If a number occurs multiple times in the lists, you must ensure that the frequency of that number in both lists is the same. If that is not the case, then it is also a missing number.  You have to print all the missing numbers in ascending order.  Print each missing number once, even if it is missing multiple times.  The difference between maximum and minimum number in the second list is less than or equal to .   Function Description  Complete the missingNumbers function in the editor below.  It should return a sorted array of missing numbers.   missingNumbers has the following parameter(s): arr: the array with missing numbers    brr: the original array of numbers    Input Format There will be four lines of input:    - the size of the first list,    The next line contains  space-separated integers    - the size of the second list,    The next line contains  space-separated integers   Constraints       Output Format Output the missing numbers in ascending order. Sample Input Sample Output Explanation  is present in both arrays. Its frequency in  is , while its frequency in  is . Similarly,  and  occur twice in , but three times in . The rest of the numbers have the same frequencies in both lists.
__label__Strings To some string S, we will perform someÂ replacementÂ operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source wordÂ xÂ and a target wordÂ y.Â  The rule is that if xÂ starts at position iÂ in the original string S, then we will replace that occurrence ofÂ xÂ withÂ y.Â  If not, we do nothing. For example, if we haveÂ S = "abcd"Â and we have some replacement operationÂ i = 2, x = "cd", y = "ffff", then becauseÂ "cd"Â starts at position 2Â in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operationÂ i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original stringÂ S[2] = 'c', which doesn't matchÂ x[0] = 'e'. All these operations occur simultaneously.Â  It's guaranteed that there won't be any overlap in replacement: for example,Â S = "abc", indexes = [0, 1],Â sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <=Â indexes.length =Â sources.length =Â targets.length <= 100 0Â <Â indexes[i]Â < S.length <= 1000 All characters in given inputs are lowercase letters.
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  The update query is of the format i j X  This means you'd have to add a GP series to the nodes which lie in the path from node i to node j (both inclusive) with first term of the GP as X on node i and the common ratio as R (given in the input) i j X i R The retrieval query is of the format i j You need to return the sum of the node values (S) lying in the path from node i to node j modulo 100711433.  Input Format  The first line contains two integers (N and R respectively) separated by a space.  In the next N-1 lines, the ith line describes the ith edge: a line with two integers a b separated by a single space denotes an edge between a, b.  The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.  U lines follow. Each of the next U lines contains 3 space separated integers (i,j, and X respectively).  Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 100000  2 <= R <= 109  1 <= U <= 100000  1 <= Q <= 100000  1 <= X <= 10  1 <= a, b, i, j <= N   Sample Input  6 2 1 2 1 4 2 6 4 5 4 3 2 2 1 6 3 5 3 5 6 4 5 1  Sample Output 31 18  Explanation The node values after the first updation becomes :   3 6 0 0 0 12    The node values after second updation becomes :   3 6 20 10 5 12    Answer to Query #1: 12 + 6 + 3 + 10 = 31  Answer to Query #2: 5 + 10 +3 = 18
__label__Hash-Table __label__Two-Pointers __label__Strings Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
__label__Hash-Table In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"  Â  Note:  The input will only have lower-case letters. 1 <= dict words number <= 1000 1 <= sentence words number <= 1000 1 <= root length <= 100 1 <= sentence words length <= 1000
__label__Mathematics __label__Game-Theory There are  piles of stones where the ith pile has  stones in it. Alice and Bob play the following game: Alice starts, and they alternate turns. Alice starts, and they alternate turns. In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .Â  In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .Â  The player who cannot make a move (because all the remaining piles are indivisible) loses the game. The player who cannot make a move (because all the remaining piles are indivisible) loses the game. Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)? Input Format The first line contains the number of test cases .  test cases follow. The first line for each test case contains , the number of piles initially. The next line contains  space delimited numbers, the number of stones in each of the piles. Constraints     Output Format Output  lines, one corresponding to each test case containing ALICE if Alice wins the game and BOB otherwise. ALICE BOB Sample Input 4   1   4   2   1 2   3   1 3 4   1   8  Sample Output BOB   BOB   ALICE   BOB  Explanation For the first case, the only possible move for Alice is (4) -> (1,3). Now Bob breaks up the pile with 3 stones into (1,2). At this point Alice cannot make any move and has lost.
__label__Strings You have two strings,  and . Find a string, , such that:  can be expressed as  where  is a non-empty substring of  and  is a non-empty substring of .  is a palindromic string. The length of  is as long as possible. For each of the  pairs of strings ( and ) received as input, find and print string  on a new line. If you're able to form more than one valid string , print whichever one comes first alphabetically. If there is no valid answer, print  instead. Input Format The first line contains a single integer, , denoting the number of queries. The subsequent lines describe each query over two lines: The first line contains a single string denoting . The second line contains a single string denoting . Constraints      and  contain only lowercase English letters. Sum of |a| over all queries does not exceed  Sum of |b| over all queries does not exceed  Output Format For each pair of strings ( and ), find some  satisfying the conditions above and print it on a new line. If there is no such string, print  instead. Sample Input 3 bac bac abc def jdfh fds  Sample Output aba -1 dfhfd  Explanation We perform the following three queries: Concatenate  with  to create . We're given  and ; because both strings are composed of unique characters, we cannot use them to form a palindromic string. Thus, we print . Concatenate  with  to create . Note that we chose these particular substrings because the length of string  must be maximal.
__label__Strings Ashton appeared for a job interview and is asked the following question. Arrange all the distinct substrings  of a given string in lexicographical order and concatenate them. Print the  character of the concatenated string. It is assured that given value of  will be valid i.e. there will be a  character. Can you help Ashton out with this?   For example, given the string , its distinct substrings are .  Sorted and concatenated, they make the string .  If  then, the answer is , the  character of the 1-indexed concatenated string.   Note We have distinct substrings here, i.e. if string is aa, it's distinct substrings are a and aa.   aa a aa Function Description  Complete the ashtonString function in the editor below.  It should return the  character from the concatenated string, 1-based indexing.   ashtonString has the following parameters:  - s: a string  - k: an integer   Input Format The first line will contain an integer , the number of test cases.   Each of the subsequent  pairs of lines is as follows:  - The first line of each test case contains a string, .  - The second line contains an integer, .   Constraints     Each character of string    will be an appropriate integer.  Output Format Print the  character (1-based index) of the concatenation of the ordered distinct substrings of . Sample Input 1 dbac 3  Sample Output c  Explanation The substrings when arranged in lexicographic order are as follows    a, ac, b, ba, bac, c, d, db, dba, dbac  On concatenating them, we get  aacbbabaccddbdbadbac  The third character in this string is c.  c
__label__Hash-Table Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0. Â   Example 1: Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4   Example 2: Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2  Â  Note:  1 <= points.length <= 500 0 <=Â points[i][0] <=Â 40000 0 <=Â points[i][1] <=Â 40000 All points are distinct.
__label__Tree __label__Depth-first-Search Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note:Â A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimumÂ depth = 2.
__label__Array __label__Two-Pointers __label__Binary-Search Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum â¥ s. If there isn't one, return 0 instead. Example:Â  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
__label__Array __label__Binary-Search Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false
__label__Mathematics Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1
__label__Hash-Table __label__Strings Given a stringÂ text, you want to use the characters ofÂ textÂ to form as many instances of the word "balloon" as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. Â  Example 1:  Input: text = "nlaebolko" Output: 1  Example 2:  Input: text = "loonbalxballpoon" Output: 2  Example 3: Input: text = "leetcode" Output: 0  Â  Constraints:  1 <= text.length <= 10^4 textÂ consists of lower case English letters only.
__label__Array In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.Â  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.Â  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seatsÂ contains only 0s or 1s, at least one 0, and at least one 1.
__label__Greedy-Algorithms Consider two -element arrays of integers,  and . You want to permute them into some  and  such that the relation  holds for all  where . For example, if , , and , a valid  satisfying our relation would be  and ,  and . You are given  queries consisting of , , and . For each query, print YES on a new line if some permutation ,  satisfying the relation above exists.  Otherwise, print NO.   YES NO Function Description  Complete the twoArrays function in the editor below.  It should return a string, either YES or NO.   YES NO twoArrays has the following parameter(s):   k: an integer   A: an array of integers   B: an array of integers   Input Format The first line contains an integer , the number of queries.  The next  sets of  lines are as follows: The first line contains two space-separated integers  and , the size of both arrays  and , and the relation variable. The second line contains  space-separated integers . The third line contains  space-separated integers . Constraints     Output Format For each query, print YES on a new line if valid permutations exist.  Otherwise, print NO. YES NO Sample Input 2 3 10 2 1 3 7 8 9 4 5 1 2 2 1 3 3 3 4  Sample Output YES NO  Explanation We perform the following two queries: , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  YES , , and . To permute  and  into a valid  and , we would need at least three numbers in  to be greater than ; as this is not the case, we print NO on a new line. NO
__label__Strings Louise joined a social networking site to stay in touch with her friends. The signup page required her to input a name and a password. However, the password must be strong. The website considers a password to be strong if it satisfies the following criteria: Its length is at least .   It contains at least one digit.   It contains at least one lowercase English character.  It contains at least one uppercase English character.  It contains at least one special character. The special characters are: !@#$%^&*()-+  !@#$%^&*()-+ She typed a random string of length  in the password field but wasn't sure if it was strong. Given the string she typed, can you find the minimum number of characters she must add to make her password strong? Note: Here's the set of types of characters in a form you can paste in your solution: Input Format The first line contains an integer  denoting the length of the string. The second line contains a string consisting of  characters, the password typed by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character. Constraints   Output Format Print a single line containing a single integer denoting the answer to the problem. Sample Input 0 Sample Output 0 Explanation 0 She can make the password strong by adding  characters, for example, $hk, turning the password into Ab1$hk which is strong.  $hk Ab1$hk  characters aren't enough since the length must be at least .   Sample Input 1 Sample Output 1 Explanation 1 The password isn't strong, but she can make it strong by adding a single digit.
__label__Array A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, returnÂ TrueÂ if and only if the matrix is Toeplitz. Â  Example 1: Input: matrix = [ Â  [1,2,3,4], Â  [5,1,2,3], Â  [9,5,1,2] ] Output: True Explanation: In the above grid, theÂ diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [ Â  [1,2], Â  [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?
__label__Mathematics Given a non-emptyÂ array of unique positive integers A, consider the following graph:  There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j]Â if and only ifÂ A[i] and A[j] share a common factor greater than 1.  Return the size of the largest connected component in the graph. Â     Example 1: Input: [4,6,15,35] Output: 4    Example 2: Input: [20,50,9,63] Output: 2    Example 3: Input: [2,3,6,7,4,12,21,39] Output: 8   Note:  1 <= A.length <= 20000 1 <= A[i] <= 100000
__label__Dynamic-Programming Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
__label__Bit Sansa has an array. She wants to find the value obtained by XOR-ing the contiguous subarrays, followed by XOR-ing the values thus obtained. Determine this value.   For example, if :  Now we take the resultant values and XOR them together:   Function Description  Complete the sansaXor function in the editor below.  It should return an integer that represents the results of the calculations.   sansaXor has the following parameter(s):   arr:  an array of integers   Input Format The first line contains an integer , the number of the test cases.    Each of the next  pairs of lines is as follows:  - The first line of each test case contains an integer , the number of elements in .  - The second line of each test case contains  space-separated integers .     Constraints       Output Format Print the results of each test case on a separate line.   Sample Input 0 Sample Output 0 Explanation 0 Test case 0:     Test case 1:    Sample Input 1 Sample Output 1 Explanation 1 Test Case 0:   Test Case 1:
__label__Graph-Algorithms __label__Greedy-Algorithms Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:   The subgraph contains all the nodes present in the original graph.   The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.   It is also required that there is exactly one, exclusive path between any two nodes of the subgraph.  One specific node  is fixed as the starting point of finding the subgraph using Prim's Algorithm.  Find the total weight or the sum of all edges in the subgraph.   For example, consider a graph with  nodes.  Possible edges are  weight ,  weight  and  weight .  Starting from node , we select the lower weight path, i.e. , weight .  From node , there is only one path left,  weight .  We have all nodes connected at a cost of .   Function Description Complete the prims function in the editor below.  It should return and integer that represents the minimum weight to connect all nodes in the graph provided.   prims has the following parameter(s):   n: an integer that represents the number of nodes in the graph   edges: a two-dimensional array where each element contains three integers, two nodes numbers that are connected and the weight of that edge   start: an integer that represents the number of the starting node   Input Format The first line has two space-separated integers  and , the number of nodes and edges in the graph.   Each of the next  lines contains three space-separated integers ,  and , the end nodes of , and the edge's weight.  The last line has an integer , denoting the starting node.   Constraints         There may be multiple edges between two nodes. Output Format Print a single integer denoting the total weight of the subgraph.   Sample Input 0 Sample Output 0 Explanation 0 The graph given in the test case is shown as :  The starting node is  (in the given test case) Applying the Prim's algorithm, edge choices available at first are :  (WT. 3)  and  (WT. 4) , out of which  is chosen (smaller weight of edge). Now the available choices are :   (WT. 4) ,  (WT. 5) ,  (WT. 2) and  (WT. 6) , out of which  is chosen by the algorithm.  Following the same method of the algorithm, the next chosen edges , sequentially are :  and . Hence the overall sequence of edges picked up by Prim's are:   and the total weight of the MST (minimum spanning tree) is :
__label__Dynamic-Programming __label__Strings Megan is playing a string game with the following rules: It starts with a string, . During each turn, she performs the following move: Choose an index in . The chosen index must be strictly greater than any index chosen in a prior move.  Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index. For example, let's say  abcdefjghi. During our move, we choose to do three right rotations of the suffix starting at index :    Note that this counts as one move. During each turn, she performs the following move: Choose an index in . The chosen index must be strictly greater than any index chosen in a prior move.  Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index. For example, let's say  abcdefjghi. During our move, we choose to do three right rotations of the suffix starting at index :    Note that this counts as one move. abcdefjghi The goal of the game is to convert  into the lexicographically smallest possible string in as few moves as possible. In other words, we want the characters to be in alphabetical order. Megan plays this game  times, starting with a new string  each time. For each game, find the minimum number of moves necessary to convert  into the lexicographically smallest string and print that number on a new line. Input Format The first line contains an integer, , denoting the number of games.  Each of the  subsequent lines contains a single string denoting the initial value of string  for a game. Constraints    consists of lowercase English alphabetic letters only. Output Format For each game, print an integer on a new line denoting the minimum number of moves required to convert  into the lexicographically smallest string possible. Sample Input 0 Sample Output 0 Explanation 0 We play the following  games: In the first game, abcdefghij is already as lexicographically small as possible (each sequential letter is in alphabetical order). Because we don't need to perform any moves, we print  on a new line. abcdefghij In the second game, we rotate the suffix starting at index , so acab becomes aabc. Because the string is lexicographically smallest after one move, we print  on a new line. acab aabc In the third game, we perform the following moves: Rotate the suffix starting at index  (i.e., the entire string), so baba becomes abab.  Rotate the suffix starting at index , so abab becomes aabb. Because the string is lexicographically smallest after two moves, we print  on a new line. In the third game, we perform the following moves: Rotate the suffix starting at index  (i.e., the entire string), so baba becomes abab.  baba abab Rotate the suffix starting at index , so abab becomes aabb. abab aabb Because the string is lexicographically smallest after two moves, we print  on a new line.
__label__Array Given a list of dominoes,Â dominoes[i] = [a, b]Â is equivalent to dominoes[j] = [c, d]Â if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, andÂ dominoes[i] is equivalent to dominoes[j]. Â  Example 1: Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1  Â  Constraints:  1 <= dominoes.length <= 40000 1 <= dominoes[i][j] <= 9
__label__Mathematics Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [â231,Â  231Â â 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
__label__Search __label__Dynamic-Programming Queens on Board You have an N * M chessboard on which some squares are blocked out. In how many ways can you place one or more queens on the board, such that, no two queens attack each other? Two queens attack each other, if one can reach the other by moving horizontally, vertically, or diagonally without passing over any blocked square. At most one queen can be placed on a square. A queen cannot be placed on a blocked square. Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains integers N and M on the first line. The following N lines contain M characters each, and represent a board. A '#' represents a blocked square and a '.' represents an unblocked square. Constraints 1 <= T <= 100  1 <= N <= 50  1 <= M <= 5 Output Format Output T lines containing the required answer for each test case. As the answers can be really large, output them modulo 109+7. Sample Input 4   3 3   ...   ...   ...   3 3   .#.   .#.   ...   2 4   .#..   ....   1 1   #  Sample Output 17   18   14   0
__label__Array __label__Greedy-Algorithms Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum Â             jump length is 0, which makes it impossible to reach the last index.
__label__Array __label__Mathematics We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return trueÂ if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.
__label__Greedy-Algorithms We have a two dimensional matrixÂ A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possibleÂ score. Â     Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Â  Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j]Â is 0 or 1.
__label__Dynamic-Programming Superman has been invited to India to celebrate Diwali. Unfortunately, on his arrival he learns that he has been invited mainly to help rescue people from a fire accident that has happened in a posh residential locale of New Delhi, where rescue is proving to be especially difficult. As he reaches the place of the fire, before him there are  buildings, each of the same height , which are on fire. Since it is Diwali, some floors of the buildings are empty as the occupants have gone elsewhere for celebrations. In his hurry to start the rescue Superman reaches the top of the building, but realizes that his jumping power is depleted and restricted due to change in his geographical setting. He soon understands the restrictions of his jumping power, and they are as follows:  He can use the jumping power any number of times until he reaches the bottom floor, which means he can use the jumping power only until before he reaches the bottom (Ground floor), which means, once he reaches the bottom floor, he cannot move to the top floor again and try to save people. (In one single drop from the top to bottom) He can use the jumping power any number of times until he reaches the bottom floor, which means he can use the jumping power only until before he reaches the bottom (Ground floor), which means, once he reaches the bottom floor, he cannot move to the top floor again and try to save people. (In one single drop from the top to bottom) While switching buildings, he loses height  while jumping. While switching buildings, he loses height  while jumping. The second restriction is explained below with an example. Assume . Now Superman is in the 2nd building 5th floor (, ). If he wants to switch to the fifth building (), he will lose height (), which means he will be at floor 3 at building 5 (, ). He can jump freely from the current floor to the floor below on the same building . That is, suppose if he is at , he can go to  without any restrictions. He cannot skip a floor while jumping in the same building. He can go to the floor below the current floor of the same building or use his jumping power, switch building, and lose height . Given the information about the occupied floors in each of the  buildings, help Superman to determine the maximum number of people he can save in one single drop from the top to the bottom floor with the given restrictions. Input Format Input starts with three values:  the number of buildings , the height of the buildings , and the height Superman will lose when he switches buildings . These are followed by  lines. Each  line starts with a non negative integer  indicating how many people are in the th building. Each of the following  integers indicates that a person is at height  in the  buiding. Each of the following  integers are given and repetitions are allowed which means there can be more than one person in a floor.  indicates building number and  indicates floor number. Building number will not be given; since  lines follow the first line, you can assume that the  line indicates the  building's specifications. Constraints       (for each , which means the maximum number of people in a particular building will not exceed )   Output Format Output the maximum number of people Superman can save. Sample Input 4 15 2  5 1 1 1 4 10 8 9 5 7 7 3 9 8 8 5 9 5 6 4 3 0     Sample Output 12  Explanation Input starts with , ,  .  lines follow. Each line describes building . Each line begins with , which denotes the number of persons in a particular building, followed by floor number, where each person resides. Floor number can repeat as any number of people can reside on a particular floor.   I've attached a figure here to explain the sample test case.   You can verify the first building's specifications with the figure.   (Total number of persons in the first building), followed by 1 1 1 4 10(Floor numbers).   floor = 3 persons.  floor = 1 person.  floor = 1 person.  Similarly, the specifications for the other three buildings follow.  The connected line shows the path which Superman can use to save the maximum number of people. In this case, that number is . You can also note in the figure that when he switches from Building 2 to Building 3, he loses height  (). Similarly, when he switches from Building 3 to Building 1 ,the same height loss happens as mentioned in the problem statement.
__label__Tree __label__Data-Structures The square-ten tree decomposition of an array is defined as follows: The lowest () level of the square-ten tree consists of single array elements in their natural order. The  level (starting from ) of the square-ten tree consists of subsequent array subsegments of length  in their natural order. Thus, the  level contains subsegments of length , the  level contains subsegments of length , the  level contains subsegments of length , etc. In other words, every  level (for every ) of square-ten tree consists of array subsegments indexed as:    The image below depicts the bottom-left corner (i.e., the first  array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:  Task  Given the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence  such as  for every , , , where every  belongs to any of the square-ten tree levels and  is minimal amongst all such variants. Input Format The first line contains a single integer denoting .  The second line contains a single integer denoting . Constraints  The numbers in input do not contain leading zeroes. Output Format As soon as array indices are too large, you should find a sequence of  square-ten tree level numbers, , meaning that subsegment  belongs to the  level of the square-ten tree.  Print this sequence in the following compressed format:  On the first line, print the value of  (i.e., the compressed sequence block count).  For each of the  subsequent lines, print  space-separated integers,  and  (, ), meaning that the number  appears consequently  times in sequence . Blocks should be listed in the order they appear in the sequence. In other words,  should be equal to ,  should be equal to , etc. Thus  must be true and  must be true for every . All numbers should be printed without leading zeroes. Sample Input 0 Sample Output 0 Explanation 0 Segment  belongs to level  of the square-ten tree.
__label__Array __label__Two-Pointers Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output:Â [1,2,2,3,5,6]
__label__Data-Structures You are given  queries. Each query consists of a single number . You can perform any of the  operations on  in each move: 1: If we take 2 integers  and  where , , then we can change  2: Decrease the value of  by .  Determine the minimum number of moves required to reduce the value of  to . Input Format The first line contains the integer .  The next  lines each contain an integer, .   Constraints     Output Format Output  lines. Each line containing the minimum number of moves required to reduce the value of  to . Sample Input 2 3 4  Sample Output 3 3  Explanation For test case 1, We only have one option that gives the minimum number of moves.  Follow  ->  ->  -> . Hence,  moves. For the case 2, we can either go  ->  ->  ->  ->  or  ->  ->  -> . The 2nd option is more optimal. Hence,  moves.
__label__Mathematics Given a number N, return a string consisting of "0"s and "1"sÂ that represents its value in base -2Â (negative two). The returned string must have no leading zeroes, unless the string is "0". Â   Example 1: Input: 2 Output: "110" Explantion: (-2) ^ 2 + (-2) ^ 1 = 2   Example 2: Input: 3 Output: "111" Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3   Example 3: Input: 4 Output: "100" Explantion: (-2) ^ 2 = 4  Â  Note:  0 <= N <= 10^9
__label__Array Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.
__label__Mathematics On an infinite plane, aÂ robot initially stands at (0, 0) and faces north.Â Â The robot can receive one of three instructions:  "G": go straight 1 unit; "L": turn 90 degrees to the left; "R": turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle. Â  Example 1: Input: "GGLLGG" Output: true Explanation:  The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0). When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.  Example 2: Input: "GG" Output: false Explanation:  The robot moves north indefinitely.  Example 3: Input: "GL" Output: true Explanation:  The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...  Â  Note:  1 <= instructions.length <= 100 instructions[i] is in {'G', 'L', 'R'}
__label__Binary-Search Given an array w of positive integers, where w[i] describes the weight of index i,Â write a function pickIndexÂ which randomlyÂ picks an indexÂ in proportionÂ to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndexÂ will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists:Â the subroutines calledÂ and theirÂ arguments.Â Solution'sÂ constructor has one argument, theÂ array w. pickIndex has no arguments.Â ArgumentsÂ areÂ always wrapped with a list, even if there aren't any.
__label__Array __label__Two-Pointers __label__Binary-Search Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note:  Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.  Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
__label__Mathematics __label__Dynamic-Programming Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ...Â where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).Â  For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3Â which is a value of 3. When writing such an expression, we adhere to the following conventions:  The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happens before addition and subtraction. It's not allowed to use the unary negationÂ operator (-).Â  For example, "xÂ - x"Â is a valid expression as it only uses subtraction, but "-x +Â x" is not because it uses negation.  We would like to write an expression with the least number of operators such that the expression equals the given target.Â  Return the least number of operators used. Â   Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.  Example 2:  Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.   Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100.  The expression contains 3 operations. Â     Note:  2 <= x <= 100 1 <= target <= 2 * 10^8
__label__Mathematics Given a string date representing a GregorianÂ calendar date formatted as YYYY-MM-DD, return the day number of the year. Â  Example 1: Input: date = "2019-01-09" Output: 9 Explanation: Given date is the 9th day of the year in 2019.  Example 2: Input: date = "2019-02-10" Output: 41  Example 3: Input: date = "2003-03-01" Output: 60  Example 4: Input: date = "2004-03-01" Output: 61  Â  Constraints:  date.length == 10 date[4] == date[7] == '-', and all other date[i]'s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.
__label__Search We take a line segment of length  on a one-dimensional plane and bend it to create a circle with circumference  that's indexed from  to . For example, if :  We denote a pair of points,  and , as . We then plot  pairs of points (meaning a total of  individual points) at various indices along the circle's circumference. We define the distance  between points  and  in pair  as . Next, let's consider two pairs:  and . We define distance  as the minimum of the six distances between any two points among points , , , and . In other words:    For example, consider the following diagram in which the relationship between points in pairs at non-overlapping indices is shown by a connecting line:  Given  pairs of points and the value of , find and print the maximum value of , where , among all pairs of points. Input Format The first line contains two space-separated integers describing the respective values of  (the number of pairs of points) and  (the circumference of the circle).  Each line  of the  subsequent lines contains two space-separated integers describing the values of  and  (i.e., the locations of the points in pair ). Constraints    Output Format Print a single integer denoting the maximum , , where . Sample Input 0 Sample Output 0 Explanation 0 In the diagram below, the relationship between points in pairs at non-overlapping indices is shown by a connecting line:  As you can see, the maximum distance between any two pairs of points is , so we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 In the diagram below, we have four individual points located at three indices:  Because two of the points overlap, the minimum distance between the two pairs of points is . Thus, we print  as our answer.
__label__Dynamic-Programming Given two integer arraysÂ arr1 and arr2, return the minimum number of operations (possibly zero) neededÂ to make arr1 strictly increasing. In one operation, you can choose two indicesÂ 0 <=Â i < arr1.lengthÂ andÂ 0 <= j < arr2.lengthÂ and do the assignmentÂ arr1[i] = arr2[j]. If there is no way to makeÂ arr1Â strictly increasing,Â returnÂ -1. Â  Example 1: Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4] Output: 1 Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].  Example 2: Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1] Output: 2 Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].  Example 3: Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3] Output: -1 Explanation: You can't make arr1 strictly increasing. Â  Constraints:  1 <= arr1.length, arr2.length <= 2000 0 <= arr1[i], arr2[i] <= 10^9
__label__Data-Structures This question is designed to help you get a better understanding of basic heap operations.  You will be given queries of  types: " "  - Add an element  to the heap.   " "  - Delete the element  from the heap.   "" - Print the minimum of all the elements in the heap. NOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap. Input Format The first line contains the number of queries, .  Each of the next  lines contains a single query of any one of the  above mentioned types.    Constraints     Output Format For each query of type , print the minimum value on a single line.   Sample Input 5   1 4   1 9   3   2 4   3    Sample Output 4   9   Explanation After the first  queries, the heap contains {}. Printing the minimum gives  as the output. Then, the  query deletes  from the heap, and the  query gives  as the output.
__label__Array __label__Dynamic-Programming A sequence X_1, X_2, ..., X_nÂ is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2}Â for allÂ i + 2 <= n  Given a strictly increasingÂ arrayÂ A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.Â  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A byÂ deleting any number ofÂ elements (including none)Â from A, without changing the order of the remaining elements.Â  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].) Â    Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].  Â  Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)
__label__Dynamic-Programming There are  bulbs in a straight line, numbered from  to .  Each bulb  has a button associated with it, and there is a cost, , for pressing this button. When some button  is pressed, all the bulbs at a distance  from bulb  will be toggled(off->on, on->off).  Given , , and the costs for each button, find and print the minimum cost of turning off all  bulbs if they're all on initially. Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains  space-separated integers describing the respective costs of each bulb (i.e., ). Constraints    Output Format Print a long integer denoting the minimum cost of turning off all  bulbs. Sample Input 3 1 1 1 1  Sample Output 1  Explanation If we press the middle switch, the middle bulb and the  closest adjacent bulbs (i.e., the first and third) will turn off. Because all bulbs will be off in one button press, this cost is minimal. Thus, we print  as our answer.
__label__Array On an infinite number line, the position of the i-th stone is given byÂ stones[i].Â  Call a stone an endpoint stone if it has the smallest or largest position. Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. In particular,Â if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made?Â  Return the answer as an length 2 array:Â answer = [minimum_moves, maximum_moves] Â  Example 1: Input: [7,4,9] Output: [1,2] Explanation:  We can move 4 -> 8 for one move to finish the game. Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.   Example 2: Input: [6,5,4,3,10] Output: [2,3] We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.   Example 3: Input: [100,101,104,102,103] Output: [0,0] Â    Note:  3 <= stones.length <= 10^4 1 <= stones[i] <= 10^9 stones[i] have distinct values.
__label__Dynamic-Programming There are  balls in a row, and each ball is either black (B) or white (W). Perform  removal operations with the goal of maximizing the number of white balls picked. For each operation  (where ): B W Choose an integer, , uniformly and independently from  to  (inclusive). Remove the  ball from either the left end or right end of the row, which decrements the number of available balls in the row by . You can choose to remove the ball from whichever end in each step maximizing the expected total number of white balls picked at the end. Given a string describing the initial row of balls as a sequence of  W's and B's, find and print the expected number of white balls providing that you make all choices optimally. A correct answer has an absolute error of at most .   W B Input Format The first line contains two space-separated integers describing the respective values of  (the number of balls) and  (the number of operations).  The second line describes the initial sequence balls as a single string of  characters; each character is either B or W and describes a black or white ball, respectively. B W Constraints  Output Format Print a single floating-point number denoting the expected number of white balls picked. Your answer is considered to be correct if it has an absolute error of at most .   Sample Input 0 Sample Output 0 Explanation 0  Independent of your choice of , one white ball will always be picked so the expected number of white balls chosen after  operation is . Thus, we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 We perform the following  operations:   Independent of your choice of , a white ball will always be chosen during the first operation (meaning the expected number of white balls in the first operation is ).   For the second operation, there are  possible row orderings (depending on which ball was picked during the first operation). In the first possible row ordering, the probability of picking a white ball is . In the second possible row ordering, the probability of picking a white ball is . This means the expected number of white balls chosen in the second operation is . After performing all  operations, we print the total expected number of white balls chosen, which is .
__label__Dynamic-Programming __label__Mathematics Lukas is a Civil Engineer who loves designing road networks to connect  cities numbered from  to . He can build any number of bidirectional roads as long as the resultant network satisfies these constraints: It must be possible to reach any city from any other city by traveling along the network of roads.   No two roads can directly connect the same two cities.    A road cannot directly connect a city to itself.   In other words, the roads and cities must form a simple connected labeled graph. You must answer  queries, where each query consists of some  denoting the number of cities Lukas wants to design a bidirectional network of roads for. For each query, find and print the number of ways he can build roads connecting  cities on a new line; as the number of ways can be quite large, print it modulo . Input Format The first line contains an integer, , denoting the number of queries.  Each of the  subsequent lines contains an integer denoting the value of  for a query. Constraints  Output Format For each of the  queries, print the number of ways Lukas can build a network of bidirectional roads connecting  cities, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 We answer the first two queries like this: When , the only option satisfying Lukas' three constraints is to not build any roads at all. Thus, we print the result of  on a new line.   When , there are four ways for Lukas to build roads that satisfy his three constraints:  Thus, we print the result of  on a new line.  When , there are four ways for Lukas to build roads that satisfy his three constraints:  Thus, we print the result of  on a new line.
__label__Hash-Table __label__Two-Pointers __label__Strings Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
__label__Strings Given two strings A and BÂ of lowercase letters, return true if and only if weÂ can swap two letters in A so that the result equals B. Â  Example 1:  Input: A = "ab", B = "ba" Output: true   Example 2: Input: A = "ab", B = "ab" Output: false   Example 3: Input: A = "aa", B = "aa" Output: true   Example 4: Input: A = "aaaaaaabc", B = "aaaaaaacb" Output: true   Example 5: Input: A = "", B = "aa" Output: false  Â  Note:  0 <= A.length <= 20000 0 <= B.length <= 20000 A andÂ B consist only of lowercase letters.
__label__Tree Given a binary tree, return the preorder traversal of its nodes' values. Example: Input:Â [1,null,2,3]    1     \      2     /    3  Output:Â [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Hash-Table __label__Mathematics Write an algorithm to determine if a number is "happy". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example:Â  Input: 19 Output: true Explanation:  12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes with every node being colored. A color is represented by an integer ranging from 1 to 109. Can you find the number of distinct colors available in a subtree rooted at the node s?  Input Format  The first line contains three space separated integers representing the number of nodes in the tree (N), number of queries to answer (M) and the root of the tree.  In each of the next N-1 lines, there are two space separated integers(a b) representing an edge from node a to Node b and vice-versa.    N lines follow: N+ith line contains the color of the ith node. M lines follow: Each line containg a single integer s. Output Format  Output exactly M lines, each line containing the output of the ith query. Constraints  0 <= M <= 105 1 <= N <= 105 1 <= root <= N 1 <= color of the Node <= 109 Example Sample Input 4 2 1 1 2 2 4 2 3 10 20 20 30 1 2  Sample Output 3 2  Explanation Query 1-Subtree rooted at 1 is the entire tree and colors used are 10 20 20 30 , so the answer is 3(10,20 and 30) Query 2-Subtree rooted at 2 contains color 20 20 30, so the answer is 2(20 and 30)
__label__Data-Structures __label__Advanced-Data-Structures Consider a lowercase English alphabetic letter character denoted by . A shift operation on some  turns it into the next letter in the alphabet. For example, and , ,  .  Given a zero-indexed string, , of  lowercase letters, perform  queries on  where each query takes one of the following two forms: 1 i j t: All letters in the inclusive range from  to  are shifted  times.   1 i j t 2 i j: Consider all indices in the inclusive range from  to . Find the number of non-empty subsets of characters,  where , such that characters  can be rearranged to form a palindrome. Then print this number modulo  on a new line. Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. 2 i j Note Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a string of  lowercase English alphabetic letters (i.e., a through z) denoting .  Each of the  subsequent lines describes a query in one of the two formats defined above. a z Constraints      for each query.  for each query of type . Subtasks For  of the maximum score:      For another  of the maximum score:  All queries will be of type .  Output Format For each query of type  (i.e., 2 i j), print the number of non-empty subsets of characters satisfying the conditions given above, modulo , on a new line. 2 i j Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: 2 0 2:  and we want to find the palindromic subsets of substring . There are five such subsets that form palindromic strings (, , , , and ), so we print the result of  on a new line 2 0 2 2 0 0:  and we want to find the palindromic subsets of substring . Because this substring only has one letter, we only have one subset forming a palindromic string (). We then print the result of  on a new line.  2 0 0 2 1 2:   and we want to find the palindromic subsets of substring . There are two such subsets that form palindromic strings ( and ), so we print the result of  on a new line.   2 1 2 1 0 1 1:  and we need to perform  shift operations on each character from index  to index . After performing these shifts, .   1 0 1 1 2 0 2:  and we want to find the palindromic subsets of substring . There are three valid subsets that form palindromic strings (, , and ), so we print the result of  on a new line. 2 0 2
__label__Array __label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Â             Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Array __label__Hash-Table You are given an array of stringsÂ wordsÂ and a stringÂ chars. A string is goodÂ ifÂ it can be formed byÂ characters from charsÂ (each characterÂ can only be used once). Return the sum of lengths of all good strings in words. Â  Example 1: Input: words = ["cat","bt","hat","tree"], chars = "atach" Output: 6 Explanation:  The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.  Example 2: Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr" Output: 10 Explanation:  The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.  Â  Note:  1 <= words.length <= 1000 1 <= words[i].length, chars.lengthÂ <= 100 All strings contain lowercase English letters only.
__label__Array __label__Dynamic-Programming Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [      [2],     [3,4],    [6,5,7],   [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
__label__Array Given a non-negativeÂ index kÂ where k â¤Â 33, return the kthÂ index row of the Pascal's triangle. Note that the row index starts fromÂ 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?
__label__Array Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.Â  After concatenating them,Â the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.  Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1].
__label__Hash-Table __label__Strings On an alphabet board, we start at position (0, 0), corresponding to characterÂ board[0][0]. Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.  We may make the following moves:  'U' moves our position up one row, if the position exists on the board; 'D' moves our position down one row, if the position exists on the board; 'L' moves our position left one column, if the position exists on the board; 'R' moves our position right one column, if the position exists on the board; '!'Â adds the character board[r][c] at our current position (r, c)Â to theÂ answer.  (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to targetÂ in the minimum number of moves.Â  You may return any path that does so. Â  Example 1: Input: target = "leet" Output: "DDR!UURRR!!DDD!" Example 2: Input: target = "code" Output: "RR!DDRR!UUL!R!"  Â  Constraints:  1 <= target.length <= 100 target consists only of English lowercase letters.
__label__Mathematics Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"
__label__Tree Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible amongÂ any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree. Â  Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation:    We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree. The output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type.  Â  Note:  The number of nodes in the tree will be between 1 and 500. The values of each node are unique.
__label__Bit An XOR operation on a list is defined here as the xor () of all its elements (e.g.: ).  The  of set  is defined here as the sum of the s of all non-empty subsets of  known as . The set  can be expressed as:   For example: Given set  The set of possible non-empty subsets is:   The set of possible non-empty subsets is:   The  of these non-empty subsets is then calculated as follows:   =  The  of these non-empty subsets is then calculated as follows:   =  Given a list of  space-separated integers, determine and print .     For example, .  There are three possible subsets, .  The XOR of , of  and of .  The XorSum is the sum of these:  and .   Note: The cardinality of powerset is , so the set of non-empty subsets of set  of size  contains  subsets. Function Description  Complete the xoringNinja function in the editor below.  It should return an integer that represents the XorSum of the input array, modulo .   xoringNinja has the following parameter(s):   arr: an integer array Input Format The first line contains an integer , the number of test cases.        Each test case consists of two lines:  -  The first line contains an integer , the size of the set .  -  The second line contains  space-separated integers .   Constraints       Output Format For each test case, print its  on a new line.  The  line should contain the output for the  test case. Sample Input 0 Sample Output 0 Explanation 0 The input set, , has  possible non-empty subsets: . We then determine the  of each subset in :                Then sum the results of the  of each individual subset in , resulting in  and . Sample Input 1 Sample Output 1
__label__Dynamic-Programming There are  pairs of hard disk drives (HDDs) in a cluster. Each HDD is located at an integer coordinate on an infinite straight line, and each pair consists of one primary HDD and one backup HDD. Next, you want to place  computers at integer coordinates on the same infinite straight line. Each pair of HDDs must then be connected to a single computer via wires, but a computer can have any number (even zero) of HDDs connected to it. The length of a wire connecting a single HDD to a computer is the absolute value of the distance between their respective coordinates on the infinite line. We consider the total length of wire used to connect all the HDDs to computers to be the sum of the lengths of all the wires used to connect HDDs to computers. Note that both the primary and secondary HDDs in a pair must connect to the same computer. Given the locations of  pairs (i.e., primary and backup) of HDDs and the value of , place all  computers in such a way that the total length of wire needed to connect each pair of HDDs to computers is minimal. Then print the total length on a new line. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of pairs of HDDs) and  (the number of computers).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  (coordinate of the primary HDD) and  (coordinate of the backup HDD) for a pair of HDDs. Constraints       Output Format Print a single integer denoting the minimum total length of wire needed to connect all the pairs of HDDs to computers. Sample Input 5 2 6 7 -1 1 0 1 5 2 7 3  Sample Output 13  Explanation For the given Sample Case, it's optimal to place computers at positions  and  on our infinite line. We then connect the second () and the third () pairs of HDDs to the first computer (at position ) and then connect the remaining pairs to the second computer (at position ).     We calculate the wire lengths needed to connect the drives to each computer. The amount of wire needed to connect the second and third drives to the first computer is , and the amount of wire needed to connect the rest of the drives to the second computer is . When we sum the lengths of wire needed to connect all pairs of drives to the two computers, we get a total length of . Thus, we print  as our answer.
__label__Array __label__Two-Pointers Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.
__label__Two-Pointers __label__Greedy-Algorithms A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.
__label__Dynamic-Programming Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].
__label__Tree Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:  The root is the maximum number in the array.  The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.    Construct the maximum tree by the given array and output the root node of this tree.  Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree:        6     /   \    3     5     \    /       2  0           \         1   Note:  The size of the given array will be in the range [1,1000].
__label__Depth-first-Search We are stacking blocks to form a pyramid. Each block has a color which is a one letter string. We are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple. We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3. Return true if we can build the pyramid all the way to the top, otherwise false. Example 1: Input: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   G   E  / \ / \ B   C   D  We are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E. Â  Example 2: Input: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.  Â  Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.
__label__Dynamic-Programming We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1]. We want to place these books in orderÂ onto bookcase shelves that have total width shelf_width. We chooseÂ some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.Â  We repeat this process until there are no more books to place. Note again that at each step of the aboveÂ process, the order of the books we place is the same order as the given sequence of books.Â  For example, if we have an ordered list of 5Â books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf. Return the minimum possible height that the total bookshelf can be after placing shelves in this manner. Â  Example 1:  Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 Output: 6 Explanation: The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6. Notice that book number 2 does not have to be on the first shelf.  Â  Constraints:  1 <= books.length <= 1000 1 <= books[i][0] <= shelf_width <= 1000 1 <= books[i][1] <= 1000
__label__Strings Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".Â  In these strings like "heeellooo", we have groups of adjacent letters that are all the same:Â  "h", "eee", "ll", "ooo". For some given string S, a query word is stretchy if it can be made to be equal to S by anyÂ number ofÂ applications of the following extension operation: choose a group consisting ofÂ characters c, and add some number of characters c to the group so that the size of the group is 3 or more. For example, starting with "hello", we could do an extension on the group "o" to get "hellooo", but we cannot get "helloo" since the group "oo" has size less than 3.Â  Also, we could do another extension like "ll" -> "lllll" to get "helllllooo".Â  If S = "helllllooo", then the query word "hello" would be stretchy because of these two extension operations:Â query = "hello" -> "hellooo" ->Â "helllllooo" = S. Given a list of query words, return the number of words that are stretchy.Â  Â  Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.  Â  Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in wordsÂ consist only ofÂ lowercase letters
__label__Hash-Table __label__Strings Given an expressionÂ such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)Â  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]Â  Terms (including constant terms) with coefficient 0 are not included.Â  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].
__label__Mathematics Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
__label__Hash-Table Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].
__label__Strings __label__Dynamic-Programming Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false
__label__Dynamic-Programming You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width): Using these blocks, you want to make a wall of height  and width . Features of the wall are:   - The wall should not have any holes in it.  - The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks.  - The bricks must be laid horizontally.    How many ways can the wall be built? For example, the wall's height  and its width .  Here are some configurations:     These are not all of the valid permutations. Function Description  Complete the legoBlocks function in the editor below.  It should return an integer that represents the number of valid wall formations for the given wall dimensions modulo . legoBlocks has the following parameter(s): n: an integer that represents the height of the wall   m: an integer that represents the width of the wall   Input Format The first line contains the number of test cases .   Each of the next  lines contains two space-separated integers  and .   Constraints     Output Format Output one line for each test case containing the number of ways to build the wall. As the numbers can be very large, output the result modulo 1000000007. Sample Input 4   2 2   3 2   2 3   4 4  Sample Output 3   7   9   3375  Explanation For the first case, we can have:       For the second case, each row of the wall can contain either two blocks of width 1, or one block of width 2. However, the wall where all rows contain two blocks of width 1 is not a solid one as it can be divided vertically. Thus, the number of ways is  and .
__label__Data-Structures Given two numbers  and .  indicates the number of elements in the array  and  indicates number of queries. You need to perform two types of queries on the array .   You are given  queries. Queries can be of two types, type 1 and type 2.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   1 i j Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   2 i j Your task is to simply print  of the resulting array after the execution of  queries followed by the resulting array.   Note While adding at back or front the order of elements is preserved.   Input Format First line consists of two space-separated integers,  and .  Second line contains  integers, which represent the elements of the array.   queries follow. Each line contains a query of either type 1 or type 2 in the form   Constraints       Output Format Print the absolute value i.e.  in the first line.  Print elements of the resulting array in the second line. Each element should be seperated by a single space. Sample Input 8 4 1 2 3 4 5 6 7 8 1 2 4 2 3 5 1 4 7 2 1 4  Sample Output 1 2 3 6 5 7 8 4 1  Explanation Given array is .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  Now  is  i.e.  and the array is
__label__Tree Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. Example: Input:     1     \      3     /    2  Output: 1  Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).  Â  Note: There are at least two nodes in this BST.
__label__Strings James found a love letter that his friend Harry has written to his girlfriend. James is a prankster, so he decides to meddle with the letter. He changes all the words in the letter into palindromes.    To do this, he follows two rules:   He can only reduce the value of a letter by , i.e. he can change d to c, but he cannot change c to d or d to b.   The letter a may not be reduced any further.   Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations required to convert a given string into a palindrome. For example, given the string , the following two operations are performed:  cde â cdd â cdc.   Function Description  Complete the theLoveLetterMystery function in the editor below.  It should return the integer representing the minimum number of operations needed to make the string a palindrome.   theLoveLetterMystery has the following parameter(s):   s: a string Input Format The first line contains an integer , the number of queries.  The next  lines will each contain a string . Constraints    | s |   All strings are composed of lower case English letters, *ascii[a-z], with no spaces. Output Format A single line containing the minimum number of operations corresponding to each test case. Sample Input 4 abc abcba abcd cba  Sample Output 2 0 4 2  Explanation For the first test case, abc â abb â aba. For the second test case, abcba is already a palindromic string. For the third test case, abcd â abcc â abcb â abca â abba. For the fourth test case, cba â bba â aba.
__label__Array We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.
__label__Strings __label__Data-Structures Sherlock considers a string to be valid if all characters of the string appear the same number of times.  It is also valid if he can remove just  character at  index in the string, and the remaining characters will occur the same number of times.  Given a string , determine if it is valid.  If so, return YES, otherwise return NO. YES NO For example, if , it is a valid string because frequencies are .  So is  because we can remove one  and have  of each character in the remaining string.  If  however, the string is not valid as we can only remove  occurrence of .  That would leave character frequencies of .   Function Description  Complete the isValid function in the editor below.  It should return either the string YES or the string NO.   YES NO isValid has the following parameter(s):   s: a string   Input Format A single string . Constraints   Each character  Output Format Print YES if string  is valid, otherwise, print NO. YES NO Sample Input 0 Sample Output 0 Explanation 0 Given , we would need to remove two characters, both c and d  aabb or a and b  abcd, to make it valid. We are limited to removing only one character, so  is invalid. c d aabb a b abcd Sample Input 1 Sample Output 1 Explanation 1 Frequency counts for the letters are as follows:   {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 1, 'g': 1, 'h': 1, 'i': 1} {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 1, 'g': 1, 'h': 1, 'i': 1} There are two ways to make the valid string: Remove  characters with a frequency of : .    Remove  characters of frequency : .   Neither of these is an option. Sample Input 2 Sample Output 2 Explanation 2 All characters occur twice except for  which occurs  times.  We can delete one instance of  to have a valid string.
__label__Mathematics __label__Binary-Search Write a program to find theÂ n-th ugly number. Ugly numbers areÂ positive integersÂ which are divisible byÂ aÂ orÂ bÂ or c. Â  Example 1: Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. Example 2: Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.  Example 3: Input: n = 5, a = 2, b = 11, c = 13 Output: 10 Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.  Example 4: Input: n = 1000000000, a = 2, b = 217983653, c = 336916467 Output: 1999999984  Â  Constraints:  1 <= n, a, b, c <= 10^9 1 <= a * b * c <= 10^18 It's guaranteed that the result will be in rangeÂ [1,Â 2 * 10^9]
__label__Mathematics __label__Strings A string S of lowercase letters is given.Â  Then, we may make any number of moves. In each move, weÂ choose oneÂ of the first K letters (starting from the left), remove it,Â and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves. Â   Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".  Â  Note:  1 <= K <= S.lengthÂ <= 1000 SÂ consists of lowercase letters only.
__label__Dynamic-Programming Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109
__label__Mathematics __label__Binary-Search You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: Â¤ Â¤ Â¤ Â¤ Â¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: Â¤ Â¤ Â¤ Â¤ Â¤ Â¤ Â¤ Â¤  Because the 4th row is incomplete, we return 3.
__label__Array Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.Â  For example, flippingÂ [1, 1, 0]Â horizontally results inÂ [0, 1, 1]. To invert an image meansÂ that each 0 is replaced by 1, and each 1 is replaced by 0.Â For example, invertingÂ [0, 1, 1]Â results inÂ [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j]Â <=Â 1
__label__Array Given an array of integers A, find the sum of min(B), where B ranges overÂ every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7. Â  Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.Â  Sum is 17. Â  Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000
__label__Strings A gene is represented as a string of length  (where  is divisible by ), composed of the letters , , , and . It is considered to be steady if each of the four letters occurs exactly  times.  For example,  and  are both steady genes. Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string .  It is not necessarily steady.  Fortunately, Limak can choose one (maybe empty) substring of  and replace it with any string of the same length. Modifying a large substring of bear genes can be dangerous. Given a string , can you help Limak find the length of the smallest possible substring that he can replace to make  a steady gene? Note: A substring of a string  is a subsequence made up of zero or more contiguous characters of . As an example, consider .  The substring  just before or after  can be replaced with  or .  One selection would create . Function Description Complete the  function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.   steadyGene has the following parameter:   gene: a string Input Format The first line contains an interger  divisible by , that denotes the length of a string .  The second line contains a string  of length . Constraints    is divisible by     Subtask   in tests worth  points. Output Format Print the length of the minimum length substring that can be replaced to make  stable. Sample Input 8   GAAATAAA  Sample Output 5  Explanation One optimal solution is to replace  with  resulting in .  The replaced substring has length .
__label__Dynamic-Programming A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.  If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction. Note:  The number of stones is â¥ 2 and is < 1,100. Each stone's position will be a non-negative integer < 231. The first stone's position is always 0.   Example 1: [0,1,3,5,6,8,12,17]  There are a total of 8 stones. The first stone at the 0th unit, second stone at the 1st unit, third stone at the 3rd unit, and so on... The last stone at the 17th unit.  Return true. The frog can jump to the last stone by jumping  1 unit to the 2nd stone, then 2 units to the 3rd stone, then  2 units to the 4th stone, then 3 units to the 6th stone,  4 units to the 7th stone, and 5 units to the 8th stone.   Example 2: [0,1,2,3,4,8,9,11]  Return false. There is no way to jump to the last stone as  the gap between the 5th and 6th stone is too large.
__label__Dynamic-Programming One day, Wet Shark was given an array . As always, he started playing with its subsequences.   When you came to know about this habit, you presented him a task of finding all pairs of subsequences, , which satisfies all of the following constraints. We will represent a pair of subsequence as  and    and  must be of same length, i.e., .   Please help Wet Shark determine how many possible subsequences  and  can exist. Because the number of choices may be big, output your answer modulo .  Note:  Two segments are different if there's exists at least one index  such that element  is present in exactly one of them. Both subsequences can overlap each other. Subsequences do not necessarily have to be distinct Input Format The first line consists of 3 space-separated integers ,â,â, where  denotes the length of the original array, , and  and  are as defined above.  The next line contains  space-separated integers,  , representing the elements of . Constraints       Output Format Output total number of pairs of subsequences, , satisfying the above conditions. As the number can be large, output it's modulo  Sample Input 0 Sample Output 0 Explanation 0 For array  there are three pairs of subsequences:
__label__Dynamic-Programming A new gangster is trying to take control of the city. He makes a list of his  adversaries (e.g. gangster , gangster , ... gangster , gangster ) and plans to get rid of them.  mercenaries are willing to do the job. The gangster can use any number of these mercenaries. But he has to honor one condition set by them: they have to be assigned in such a way that they eliminate a consecutive group of gangsters in the list, e.g. gangster , gangster , ..., gangster , gangster , where the following is true: . While our new gangster wants to kill all of them, he also wants to pay the least amount of money. All mercenaries charge a different amount to kill different people. So he asks you to help him minimize his expenses.   Input Format The first line contains two space-separated integers,   and . Then  lines follow, each containing  integers as follows: The th number on the th line is the amount charged by the th mercenary for killing the th gangster on the list. Constraints     Output Format Just one line, the minimum cost for killing the  gangsters on the list. Sample Input 3 2 1 4 1 2 2 2  Sample Output  5  Explanation The new gangster can assign mercenary 1 to kill gangster 1, and mercenary 2 to kill gangster 2 and gangster 3.
__label__Array Given an array of size n, find the majority element. The majority element is the element that appears more than â n/2 â times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2
__label__Mathematics Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000. Example: Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]
__label__Array __label__Two-Pointers Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].
__label__Tree A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structureÂ CBTInserterÂ that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given treeÂ with head node root; CBTInserter.insert(int v) will insert a TreeNodeÂ into the tree with value node.val =Â vÂ so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.     Â  Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]   Â  Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.
__label__Bit __label__Data-Structures __label__Advanced-Data-Structures You are given an array, , consisting of  integers. A segment, , is beautiful if and only if the bitwise AND of all numbers in  with indices in the inclusive range of  is not greater than . In other words, segment  is beautiful if . You must answer  queries. Each query, , consists of  integers: , , and . The answer for each  is the number of beautiful segments  such that  and . Input Format The first line contains two space-separated integers,  (the number of integers in ) and  (the number of queries). The second line contains  space-separated integers, where the  integer denotes the  element of array . Each line  of the  subsequent lines contains  space-separated integers, , , and , respectively, describing query . Constraints       holds for test cases worth at least  of the problem's score.  holds for test cases worth at least  of the problem's score.  Output Format Print  lines, where the  line contains the number of beautiful segments for query . Sample Input 5 3 1 2 7 3 4 1 5 3 2 4 6 3 5 2  Sample Output 13 5 2  Explanation The beautiful segments for all queries are listed below. Query 0: The beautiful segments are . Query 1: The beautiful segments are . Query 2: The beautiful segments are .
__label__Strings The Kingdom of Gridland contains  provinces. Each province is defined as a  grid where each cell in the grid represents a city. Every cell in the grid contains a single lowercase character denoting the first character of the city name corresponding to that cell. From a city with the coordinates , it is possible to move to any of the following cells in  unit of time (provided that the destination cell is within the confines of the grid):     A knight wants to visit all the cities in Gridland. He can start his journey in any city and immediately stops his journey after having visited each city at least once. Moreover, he always plans his journey in such a way that the total time required to complete it is minimum. After completing his tour of each province, the knight forms a string by concatenating the characters of all the cells in his path. How many distinct strings can he form in each province? Input Format The first line contains a single integer, , denoting the number of provinces. The  subsequent lines describe each province over the following three lines:  The first line contains an integer, , denoting the number of columns in the province.  Each of the next two lines contains a string, , of length  denoting the characters for the first and second row of the province. Constraints       Output Format For each province, print the number of distinct strings the knight can form on a new line. Sample Input 3 1 a a 3 dab abd 5 ababa babab  Sample Output 1 8 2  Explanation Province 0:   The knight can only form one string (aa), so we print  on a new line. aa Province 1:   The knight can form eight different strings (abdbad, adabdb, badabd, bdbada, dababd, dabdba, dbabad, and dbadab), so we print  on a new line.  abdbad adabdb badabd bdbada dababd dabdba dbabad dbadab Province 2:   The knight can form two different strings (ababababab and bababababa), so we print  on a new line. ababababab bababababa
__label__Array __label__Dynamic-Programming __label__Greedy-Algorithms Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.
__label__Strings __label__Mathematics Dothraki are planning an attack to usurp King Robert's throne. King Robert learns of this conspiracy from Raven and plans to lock the single door through which the enemy can enter his kingdom.  But, to lock the door he needs a key that is an anagram of a palindrome.  He starts to go through his box of strings, checking to see if they can be rearranged into a palindrome. For example, given the string , one way it can be arranged into a palindrome is . Function Description  Complete the gameOfThrones function below to determine whether a given string can be rearranged into a palindrome. If it is possible, return YES, otherwise return NO.   YES NO gameOfThrones has the following parameter(s):   s: a string to analyze   Input Format A single line which contains , the input string. Constraints  |s|    contains only lowercase letters in the range  Output Format A single line which contains YES or NO. YES NO Sample Input 0 Sample Output 0 Explanation 0 A palindromic permutation of the given string is bbaaabb.    Sample Input 1 Sample Output 1 Explanation 1 Palindromes longer than 1 character are made up of pairs of characters.  There are none here.   Sample Input 2 Sample Output 2 Explanation 2 An example palindrome from the string:  ddcceefeeccdd.
__label__Mathematics On aÂ NÂ *Â N grid, we place someÂ 1 * 1 * 1Â cubes that are axis-aligned with the x, y, and z axes. Each valueÂ v = grid[i][j]Â represents a tower ofÂ vÂ cubes placed on top of grid cell (i, j). Now we view theÂ projectionÂ of these cubesÂ onto the xy, yz, and zx planes. A projection is like a shadow, thatÂ maps our 3 dimensional figure to a 2 dimensional plane.Â  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. Â                                         Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21  Â     Note:  1 <= grid.length = grid[0].lengthÂ <= 50 0 <= grid[i][j] <= 50
__label__Dynamic-Programming Given an array A of strings, find anyÂ smallest string that contains each string in A as aÂ substring. We may assume that no string in A is substring of another string in A. Â   Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc" Â    Note:  1 <= A.length <= 12 1 <= A[i].length <= 20
__label__Hash-Table Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.
__label__Mathematics Every non-negative integer NÂ has a binary representation.Â  For example,Â 5 can be represented as "101"Â in binary, 11 as "1011"Â in binary, and so on.Â  Note that except for N = 0, there are no leading zeroes in anyÂ binary representation. The complementÂ of a binary representationÂ is the number in binary you get when changing every 1 to a 0 and 0 to a 1.Â  For example, the complement of "101" in binary is "010" in binary. For a given number N in base-10, return the complement of it's binary representation as aÂ base-10 integer. Â     Example 1: Input: 5 Output: 2 Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.   Example 2: Input: 7 Output: 0 Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.   Example 3: Input: 10 Output: 5 Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.  Â  Note:  0 <= N < 10^9
__label__Array Given an integer array of size n, find all elements that appear more than â n/3 â times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]
__label__Tree __label__Depth-first-Search Given a binary tree, return all root-to-leaf paths. Note:Â A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3
__label__Dynamic-Programming We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocksÂ and smash them together.Â  Suppose the stones have weights x and y with x <= y.Â  The result of this smash is:  If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.  At the end, there is at most 1 stone left.Â  Return the smallest possible weight of this stone (the weight isÂ 0 if there are no stones left.) Â  Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation:  We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.  Â  Note:  1 <= stones.length <= 30 1 <= stones[i] <= 100
__label__Greedy-Algorithms Given two integers A and B, return any string S such that:  S has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters; The substringÂ 'aaa'Â does not occur in S; The substring 'bbb' does not occur in S.  Â  Example 1: Input: A = 1, B = 2 Output: "abb" Explanation: "abb", "bab" and "bba" are all correct answers.   Example 2: Input: A = 4, B = 1 Output: "aabaa" Â   Note:  0 <= A <= 100 0 <= B <= 100 It is guaranteed such an S exists for the given A and B.
__label__Array Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same totalÂ amount of candy.Â  (The total amount of candyÂ a person has is the sum of the sizes of candyÂ bars they have.) Return an integer array ansÂ where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.Â  It is guaranteed an answer exists. Â   Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]  Â  Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts ofÂ candy. It is guaranteed there exists anÂ answer.
__label__Data-Structures You are a waiter at a party. There are  stacked plates on pile . Each plate has a number written on it. Then there will be  iterations. In -th iteration, you start picking up the plates in  from the top one by one and check whether the number written on the plate is divisible by the -th prime. If the number is divisible, you stack that plate on pile . Otherwise, you stack that plate on pile . After  iterations, plates can only be on pile , . Output numbers on these plates from top to bottom of each piles in order of , . Input Format The first line contains two space separated integers,  and .  The next line contains  space separated integers representing the initial pile of plates, i.e., . The leftmost value represents the bottom plate of the pile. Constraints        Output Format Output  lines. Each line contains a number written on the plate. Printing should be done in the order defined above. Sample Input 0 Sample Output 0 Explanation 0 Initially:  = [3, 4, 7, 6, 5]<-TOP After 1 iteration:  = []<-TOP  = [6, 4]<-TOP  = [5, 7, 3]<-TOP We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom. Sample Input 1 Sample Output 1 Explanation 1 Initially:  = [3, 3, 4, 4, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<-TOP  = [3, 3, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<- TOP  = [3, 3, 9]<-TOP  We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom.
__label__Mathematics You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated. Â -50 <= points[i][j] <= 50. Answers withinÂ 10^-6Â of the true value will be accepted as correct.
__label__Data-Structures __label__Advanced-Data-Structures In this problem you operate on two arrays of  integers. We will call them the  and the  respectively.  Your goal is just to maintain them under the modification operations, such as:    1   : Reverse the subarray of the  array, starting at the  number, ending at the  number, inclusively;   2     : Swap two consecutive fragments of the  array, the first is from the  number to the , the second is from the  number to the ;   3  : Swap the piece that starts at the  number and end at the  one between the  and the  array;   4  : We consider only the piece from the  number to the  one. The numbers in the  array are -coordinates of some set of points and the numbers in the  array are -coordinates of them. For the obtained set of points we would like to place such a circle on a plane that would contain all the points in it and would have the minimal radius. Find this minimal radius.   Input Format  The first line of input contains two space separated integers  and  denoting the number of integers in arrays and the number of queries respectively.  The second line contains  space separated integers: the initial elements of the  array.  The third line contains  space separated integers: the initial elements of the  array.  Then there are  lines containing queries in the format listed above.   Output Format  For each type-4 query output the sought minimal radius with exactly two symbols after the decimal point precision.   Constraints    All the numbers in arrays are non-negative and don't exceed .  The sum of  over the type-4 queries won't exceed .  In the query of the type 2, .  In the queries of the types 1, 3, 4, ; . Sample Input 10 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 3 2 6 1 0 9 9 4 6 9 2 0 2 7 9 9 1 0 3 6 2 1 2 3 4 5 1 1 7 10 2 1 8 8 9 10 4 6 9 2 0 2 2 4 6  Example Output 2.12 2.50
__label__Search There are  bikers present in a city (shaped as a grid) having  bikes. All the bikers want to participate in the HackerRace competition, but unfortunately only  bikers can be accommodated in the race. Jack is organizing the HackerRace and wants to start the race as soon as possible. He can instruct any biker to move towards any bike in the city. In order to minimize the time to start the race, Jack instructs the bikers in such a way that the first  bikes are acquired in the minimum time. Every biker moves with a unit speed and one bike can be acquired by only one biker. A biker can proceed in any direction. Consider distance between bikes and bikers as Euclidean distance. Jack would like to know the square of required time to start the race as soon as possible.  Input Format The first line contains three integers, , , and , separated by a single space.  The following  lines will contain  pairs of integers denoting the co-ordinates of  bikers. Each pair of integers is separated by a single space. The next  lines will similarly denote the co-ordinates of the  bikes. Constraints       ,   Output Format A single line containing the square of required time. Sample Input 3 3 2 0 1 0 2 0 3 100 1 200 2  300 3  Sample Output 40000  Explanation There's need for two bikers for the race. The first biker (0,1) will be able to reach the first bike (100,1) in 100 time units. The second biker (0,2) will be able to reach the second bike (200,2) in 200 time units. This is the most optimal solution and will take 200 time units. So output will be 2002 = 40000.
__label__Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.  Â  For example: Given BST [1,null,2,2],    1     \      2     /    2  Â  return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).
__label__Depth-first-Search Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Â  Example 1:  Input: [[0,0,0],  [0,1,0],  [0,0,0]]  Output: [[0,0,0], Â [0,1,0], Â [0,0,0]]  Example 2:  Input: [[0,0,0],  [0,1,0],  [1,1,1]]  Output: [[0,0,0],  [0,1,0],  [1,2,1]]  Â  Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.
__label__Greedy-Algorithms We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviestÂ rocksÂ and smash them together.Â  Suppose the stones have weights x and y with x <= y.Â  The result of this smash is:  If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.  At the end, there is at most 1 stone left.Â  Return the weight of this stone (or 0 if there are no stones left.) Â  Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation:  We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone. Â  Note:  1 <= stones.length <= 30 1 <= stones[i] <= 1000
__label__Mathematics Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...  Note: n is positive and will fit within the range of a 32-bit signed integer (n < 231).  Example 1: Input: 3  Output: 3   Example 2: Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
__label__Hash-Table Design a HashMapÂ without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) :Â Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) :Â Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1); Â  Â  Â  Â  Â  hashMap.put(2, 2); Â  Â  Â  Â   hashMap.get(1); Â  Â  Â  Â  Â  Â // returns 1 hashMap.get(3); Â  Â  Â  Â  Â  Â // returns -1 (not found) hashMap.put(2, 1); Â  Â  Â  Â  Â // update the existing value hashMap.get(2); Â  Â  Â  Â  Â  Â // returns 1  hashMap.remove(2); Â  Â  Â  Â  Â // remove the mapping for 2 hashMap.get(2); Â  Â  Â  Â  Â  Â // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range ofÂ [1, 10000]. Please do not use the built-in HashMap library.
__label__Greedy-Algorithms You are given two  arrays,  and , both containing  integers. A pair of indices  is beautiful if the  element of array  is equal to the  element of array . In other words, pair  is beautiful if and only if . A set containing beautiful pairs is called a beautiful set. A beautiful set is called pairwise disjoint if for every pair  belonging to the set there is no repetition of either  or  values. For instance, if  and  the beautiful set  is not pairwise disjoint as there is a repetition of , that is .  Your task is to change exactly  element in  so that the size of the pairwise disjoint beautiful set is maximum. Function Description  Complete the beautifulPairs function in the editor below.  It should return an integer that represents the maximum number of pairwise disjoint beautiful pairs that can be formed.   beautifulPairs has the following parameters:   A: an array of integers   B: an array of integers   Input Format The first line contains a single integer , the number of elements in  and .  The second line contains  space-separated integers .  The third line contains  space-separated integers . Constraints   Output Format Determine and print the maximum possible number of pairwise disjoint beautiful pairs.  Note: You must first change  element in , and your choice of element must be optimal. Sample Input 0 Sample Output 0 Explanation 0 You are given  and .  The beautiful set is  and maximum sized pairwise disjoint beautiful set is either  or .  We can do better. We change the  element of array  from  to . Now new B array is:  and the pairwise disjoint beautiful set is . So, the answer is 4.  Note that we could have also selected index 3 instead of index 2 but it would have yeilded the same result. Any other choice of index is not optimal. Sample Input 1 Sample Output 1
__label__Tree Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1: Input:              1          /   \         3     2        / \     \         5   3     9   Output: 4 Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).  Example 2: Input:             1          /           3            / \              5   3       Output: 2 Explanation: The maximum width existing in the third level with the length 2 (5,3).  Example 3: Input:             1          / \         3   2         /               5        Output: 2 Explanation: The maximum width existing in the second level with the length 2 (3,2).  Example 4: Input:             1          / \         3   2        /     \         5       9       /         \     6           7 Output: 8 Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).    Note: Answer will in the range of 32-bit signed integer.
__label__Depth-first-Search Given the rootÂ of a binary tree, consider all root to leaf paths: paths from the rootÂ to any leaf.Â  (A leaf is a node with no children.) A node is insufficient ifÂ every such root to leaf path intersecting this node has sum strictly less thanÂ limit. Delete all insufficient nodes simultaneously, and return the root of the resultingÂ binary tree. Â  Example 1:  Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1  Output: [1,2,3,4,null,null,7,8,9,null,14]   Example 2:  Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22  Output: [5,4,8,11,null,17,4,7,null,null,null,5] Â  Example 3:  Input: root = [1,2,-3,-5,null,4,null], limit = -1  Output: [1,null,-3,4]  Â  Note:  The given tree will have between 1 and 5000 nodes. -10^5Â <= node.val <= 10^5 -10^9 <= limitÂ <= 10^9
__label__Graph-Algorithms __label__Graph-Algorithms Dave is a die-hard fan of a show called "HackerRank", in which a young programmer uses her problem-solving abilities to solve crimes. He splurged on a Digital Video Recorder (DVR) so that he can record HackerRank episodes and watch them later. Luckily, Dave managed to get his hands on schedules for all the episodes in each upcoming season. Each season has  episodes numbered from  to . Each episode airs twice; the first time it's called "live", and the second time it's called "repeat". So, for each episode, we have  integers,  and  for the live airing and  and  for the repeat airing, where  is episode's start time and and  is its end time. All times are given as integers representing the number of minutes passed since the start of the season. Episodes broadcast on multiple channels, so some of the air times overlap and the episodes may not broadcast sequentially. It's possible that both the live and repeat broadcasts of some episode  are held before episode , even though . In addition, live and repeat broadcasts of the same episode may differ in length due to the number of advertisements during the broadcast.  Dave only has one TV with a DVR attached to it, and the DVR is capable of recording one episode at a time. For each episode in a season, Dave first decides whether or not he will record it. If he decides to record it, he will either record it during  or . Dave will only ever record one of the two airings of an episode, and he always records full episodes. This means that once he starts recording an episode, he will always record it until the end (i.e., he never records partial episodes).  Dave realizes that it might not be possible for him to record all episodes successfully, so instead of focusing on recording all episodes of HackerRank (which may be impossible), he decides to record all consecutively airing episodes whose episode number occurs in some inclusive  interval such that  (i.e., the number of consecutive episodes recorded) is as large as possible.    Given the programming schedule for each season, find  and  episode numbers for largest range of consecutive episodes Dave can record during that season and print these respective values as two space-separated integers on a new line. If two or more such intervals exist, choose the one having the smallest  value. Input Format The first line contains a single positive integer, , denoting number of seasons of HackerRank.  The subsequent lines describe each of the  seasons in the following format: The first line contains an integer, , denoting the number of episodes in the season. Each line  of the  subsequent line contains four space-separated integers describing the respective values of , , , and . Constraints       Output Format On a new line for each season, print two space-separated integers denoting the respective  and  (inclusive) values for the maximum possible range of consecutive episodes Dave can record such that  is as large as possible. If more than one such interval exists, choose the interval having the smallest . Sample Input 3 3 10 20 30 40 20 35 21 35 14 30 35 50 1 10 20 30 40 3 11 19 31 39 12 38 13 37 10 20 30 40  Sample Output 1 2 1 1 1 1  Explanation For the first season, Dave records the live airing of episode  and the repeat airing of episode . Note that it is not possible to record episodes ,  and  simultaneously. For the second season, there is only one episode so Dave records from episode  to episode  and we print 1 1 on a new line. 1 1 For the third season, Dave must choose to record either episode  or episode  (episode  starts while episode  is still airing and ends after episode  starts); he cannot record both, because he only wants to record consecutive episodes. Thus, we pick the episode with the smallest  value, which is episode , and print 1 1 as we are only recording episode . 1 1
__label__Two-Pointers In a row of trees, the i-th treeÂ producesÂ fruit with typeÂ tree[i]. You start at any treeÂ of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.Â  If you cannot, stop. Move to the next tree to the right of the current tree.Â  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree:Â you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure? Â  Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.  Â     Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length
__label__Array Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3], Â  [1], Â  [2], Â  [1,2,3], Â  [1,3], Â  [2,3], Â  [1,2], Â  [] ]
__label__Array Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) Â  Example 1: Input: [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1   Example 2: Input: [0,2,1,-6,6,7,9,-1,2,0,1] Output: false   Example 3: Input: [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4    Â  Note:  3 <= A.length <= 50000 -10000 <= A[i] <= 10000
__label__Depth-first-Search Given a 2-dimensionalÂ grid of integers, each value in the grid represents the color of the grid square at that location. Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions. TheÂ border of a connected component isÂ all the squares in the connected component that areÂ either 4-directionally adjacent toÂ a square not in the component, or on the boundary of the grid (the first or last row or column). Given a square at locationÂ (r0, c0)Â in the grid and a color, color theÂ border of the connected component of that square with the given color, and return the final grid. Â  Example 1: Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3 Output: [[3, 3], [3, 2]]   Example 2: Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3 Output: [[1, 3, 3], [2, 3, 3]]   Example 3: Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2 Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]   Â  Note:  1 <= grid.length <= 50 1 <= grid[0].length <= 50 1 <= grid[i][j] <= 1000 0 <= r0 < grid.length 0 <= c0 < grid[0].length 1 <= color <= 1000
__label__Dynamic-Programming You are given a tree that has N vertices and N-1 edges. Your task is to mark as small number of vertices as possible, such that, the maximum distance between two unmarked vertices is less than or equal to K. Output this value. Distance between two vertices i and j is defined as the minimum number of edges you have to pass in order to reach vertex i from vertex j.   Input Format  The first line of input contains two integers N and K. The next N-1 lines contain two integers (ui,vi) each, where 1 <= ui,vi <= N. Each of these lines specifies an edge.  N is no more than 100. K is less than N.   Output Format  Print an integer that denotes the result of the test. Sample Input: 5 1   1 2   1 3   1 4   1 5  Sample Output: 3  Sample Input: 5 2   1 2   1 3   1 4   1 5  Sample Output: 0  Explanation: In the first case you have to mark at least 3 vertices, and in the second case you don't need to mark any vertices.
__label__Array __label__Hash-Table Given an array of integers AÂ with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <=Â i < len(A) / 2. Â           Example 1: Input: [3,1,3,6] Output: false   Example 2: Input: [2,1,2,6] Output: false   Example 3: Input: [4,-2,2,-4] Output: true Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].   Example 4: Input: [1,2,4,16,8,4] Output: false  Â  Note:  0 <= A.length <= 30000 A.length is even -100000 <= A[i] <= 100000
__label__Strings You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False
__label__Hash-Table There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules:  If a cell has two adjacent neighbors that are both occupied or both vacant,Â then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.) We describe the current state of the prisonÂ in the following way:Â cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0. Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.) Â       Example 1: Input: cells = [0,1,0,1,1,0,0,1], N = 7 Output: [0,0,1,1,0,0,0,0] Explanation:  The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0]    Example 2: Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000 Output: [0,0,1,1,1,1,1,0]  Â  Note:  cells.length == 8 cells[i] is in {0, 1} 1 <= N <= 10^9
__label__Dynamic-Programming You are given a grid having N rows and M columns. A grid square can either be blocked or empty. Blocked squares are represented by a '#' and empty squares are represented by '.'. Find the number of ways to tile the grid using L shaped bricks. A L brick has one side of length three units while other of length 2 units. All empty squares in the grid should be covered by exactly one of the L shaped tiles, and blocked squares should not be covered by any tile. The bricks can be used in any orientation (they can be rotated or flipped). Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains N and M on the first line, followed by N lines describing each row of the grid. Constraints 1 <= T <= 50  1 <= N <= 20  1 <= M <= 8  Each grid square will be either '.' or '#'. Output Format Output the number of ways to tile the grid. Output each answer modulo 1000000007. Sample Input 3   2 4   ....   ....   3 3   ...   .#.   ...   2 2   ##   ##  Sample Output 2   4   1  Explanation NOTE:  If all points in the grid are blocked the number of ways is 1, as in the last sample testcase.
__label__Mathematics __label__Tree __label__Data-Structures __label__Advanced-Data-Structures A subsequence of a sequence is a sequence which is obtained by deleting zero or more elements from the sequence.Â  You are given a sequence A in which every element is a pair of integers Â i.e Â A = [(a1, w1), (a2, w2),..., (aN, wN)]. A A For a subseqence B = [(b1, v1), (b2, v2), ...., (bM, vM)] of the given sequence :Â  B We call it increasing if for every i (1 <= i < M ) , bi < bi+1. Weight(B) = v1 + v2 + ... + vM.   Task:  Given a sequence, output the maximum weight formed by an increasing subsequence. Input:  The first line of input contains a single integer T. T test-cases follow. The first line of each test-case contains an integer N. The next line contains a1, a2 ,... , aNÂ separated by a single space. The next line contains w1, w2, ..., wNÂ separated by a single space. Output:  For each test-case output a single integer: The maximum weight of increasing subsequences of the given sequence.   Constraints:  1 <= T <= 5  1 <= N <= 150000  1 <= ai <= 109, where i â [1..N]  1 <= wi <= 109, where i â [1..N]  Sample Input: 2   4   1 2 3 4   10 20 30 40   8   1 2 3 4 1 2 3 4   10 20 30 40 15 15 15 50  Sample Output: 100   110  Explanation:  In the first sequence, the maximum size increasing subsequence is 4, and there's only one of them. We choose B = [(1, 10), (2, 20), (3, 30), (4, 40)], and we have Weight(B) = 100. B = [(1, 10), (2, 20), (3, 30), (4, 40)] Weight(B) = 100 In the second sequence, the maximum size increasing subsequence is still 4, but there are now 5 possible subsequences: 1 2 3 4   10 20 30 40  1 2 3 4   10 20 30 50  1 2 3 4   10 20 15 50  1 2 3 4   10 15 15 50  1 2 3 4   15 15 15 50  Of those, the one with the greatest weight is B = [(1, 10), (2, 20), (3, 30), (4, 50)], with Weight(B) = 110. B = [(1, 10), (2, 20), (3, 30), (4, 50)] Weight(B) = 110 Please note that this is not the maximum weight generated from picking the highest value element of each index. That value, 115, comes fromÂ [(1, 15), (2, 20), (3, 30), (4, 50)], which is not a valid subsequence because it cannot be created by only deleting elements in the original sequence.
__label__Graph-Algorithms __label__Tree You are given a tree (a simple connected graph with no cycles).  Find the maximum number of edges you can remove from the tree to get a forest such that each connected component of the forest contains an even number of nodes. As an example, the following tree with  nodes can be cut at most  time to create an even forest.     Function Description  Complete the evenForest function in the editor below.  It should return an integer as described.   evenForest has the following parameter(s):   t_nodes: the number of nodes in the tree   t_edges: the number of undirected edges in the tree   t_from: start nodes for each edge   t_to: end nodes for each edge, (Match by index to t_from.)   Input Format The first line of input contains two integers  and , the number of nodes and edges.  The next  lines contain two integers  and  which specify nodes connected by an edge of the tree. The root of the tree is node . Constraints     Note: The tree in the input will be such that it can always be decomposed into components containing an even number of nodes.  is the set of positive even integers. Output Format Print the number of removed edges.
__label__Tree Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree: Â   Â  Return its preorder traversal as: [1,3,5,6,2,4]. Â  Note: Recursive solution is trivial, could you do it iteratively?
__label__Search Lauren has a chart of distinct projected prices for a house over the next several years.  She must buy the house in one year and sell it in another, and she must do so at a loss.  She wants to minimize her financial loss.   For example, the house is valued at  over the next  years.  She can purchase the home in any year, but she must resell the house at a loss in one of the following years.  Her minimum loss would be incurred by purchasing in year  at  and reselling in year  at . Find and print the minimum amount of money Lauren must lose if she buys the house and resells it within the next  years. Note: It's guaranteed that a valid answer exists. Function Description  Complete the minimumLoss function in the editor below.  It should return an integer that represents the minimum loss that can be achieved.   minimumLoss has the following parameter(s):   price: an array of integers that represent prices at each year   Input Format The first line contains an integer , the number of years of house data.  The second line contains  space-separated long integers describing each . Constraints   All the prices are distinct.  A valid answer exists. Subtasks  for  of the maximum score.  Output Format Print a single integer denoting the minimum amount of money Lauren must lose if she buys and resells the house within the next  years. Sample Input 0 Sample Output 0 Explanation 0 Lauren buys the house in year  at  and sells it in year  at  for a minimal loss of . Sample Input 1 Sample Output 1 Explanation 1 Lauren buys the house in year  at  and sells it in year  at  for a minimal loss of .
__label__Tree Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.
__label__Array __label__Hash-Table Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false
__label__Mathematics Given an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59.Â  Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5.Â  If no valid time can be made, return an empty string. Â   Example 1: Input: [1,2,3,4] Output: "23:41"   Example 2: Input: [5,5,5,5] Output: ""  Â  Note:  A.length == 4 0 <= A[i] <= 9
__label__Game-Theory Two players are playing a game of Tower Breakers! The rules of the game are as follows:   - Player  always moves first, and both players always play optimally.  - Initially there are  towers, where each tower is of height .  - The players move in alternating turns. In each turn, a player can choose a tower of height  and reduce its height to , where  and  evenly divides .  - If the current player is unable to make a move, they lose the game.    Given the values of  and , determine which player will win. If the first player wins, return .  Otherwise, return .   For example, there are  towers, each  high.  Player  can remove  pieces from a tower to leave  as .  Player  can also remove  pieces leaving .  Let Player  remove .  Player  matches the move.  Now Player  has only one move: remove  pieces leaving .  Player  matches again leaving Player  with no move. Function Description  Complete the towerBreakers function in the editor below.  It should return an integer that represents the winning player.   towerBreakers has the following paramter(s):   n: an integer that represents the number of towers   m: an integer that represents the height of each tower   Input Format The first line contains a single integer , the number of test cases.  Each of the next  lines describes a test case in the form of  space-separated integers,  and .   Constraints   Output Format For each test case, if the first player wins, return .  Otherwise, return . Sample Input 2 2 2 1 4  Sample Output 2 1  Explanation We'll refer to player  as  and player  as  In the first test case,  chooses one of the two towers and reduces it to . Then  reduces the remaining tower to a height of . As both towers now have height ,  cannot make a move so  is the winner. In the second test case, there is only one tower of height .  can reduce it to a height of either  or .  chooses  as both players always choose optimally. Because  has no possible move,  wins.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool Youâre given the pointer to the head nodes of two sorted linked lists. The data in both lists will be sorted in ascending order. Change the next pointers to obtain a single, merged linked list which also has data in ascending order. Either head pointer given may be null meaning that the corresponding list is empty. next Input Format You have to complete the SinglyLinkedListNode MergeLists(SinglyLinkedListNode headA, SinglyLinkedListNode headB) method which takes two arguments - the heads of the two sorted linked lists to merge. You should NOT read any input from stdin/console. SinglyLinkedListNode MergeLists(SinglyLinkedListNode headA, SinglyLinkedListNode headB) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases.  The format for each test case is as follows:   The first line contains an integer , denoting the length of the first linked list.  The next  lines contain an integer each, denoting the elements of the linked list.  The next line contains an integer , denoting the length of the second linked list.  The next  lines contain an integer each, denoting the elements of the second linked list.   Constraints    , where  is the  element of the list. Output Format Change the next pointer of individual nodes so that nodes from both lists are merged into a single list. Then return the head of this merged list. Do NOT print anything to stdout/console. next return The output is handled by the editor and the format is as follows:   For each test case, print in a new line, the linked list after merging them separated by spaces.   Sample Input 1 3 1 2 3 2 3 4  Sample Output 1 2 3 3 4   Explanation The first linked list is: 1 -> 2 -> 3 -> NULL The second linked list is: 3 -> 4 -> NULL Hence, the merged linked list is: 1 -> 2 -> 3 -> 3 -> 4 -> NULL
__label__Strings We are given aÂ personal information string S, which may representÂ either an email address or a phone number. We would like to mask thisÂ personal information according to theÂ following rules:  1. Email address: We define aÂ name to be a string of length â¥ 2 consistingÂ of only lowercase lettersÂ a-z or uppercaseÂ lettersÂ A-Z. An email address starts with a name, followed by theÂ symbol '@', followed by a name, followed by theÂ dotÂ '.'Â andÂ followed by a name.Â  All email addresses areÂ guaranteed to be valid and in the format ofÂ "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting ofÂ only the digits 0-9 or the characters from the set {'+', '-', '(', ')', 'Â '}.Â You may assume a phoneÂ number containsÂ 10 to 13 digits. The last 10 digits make up the localÂ number, while the digits before those make up the country code. Note thatÂ the country code is optional. We want to expose only the last 4 digitsÂ and mask all otherÂ digits. The localÂ numberÂ should be formatted and masked as "***-***-1111",Â where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".Â  The '+'Â sign and the first '-'Â sign before the local number should only exist if there is a country code.Â  For example, a 12 digit phone number maskÂ should startÂ with "+**-". Note that extraneous characters like "(", ")", " ", as well asÂ extra dashes or plus signs not part of the above formatting scheme should be removed. Â  Return the correct "mask" of the information provided. Â  Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation:Â All names are converted to lowercase, and the letters between the Â             first and last letter of the first name is replaced by 5 asterisks. Â             Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation:Â There must be 5 asterisks between the first and last letter  Â             of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation:Â 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation:Â 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.lengthÂ <=Â 40. Emails have length at least 8. Phone numbers have length at least 10.
__label__Tree You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11
__label__Binary-Search Given the root of a binary search tree with distinct values, modify it so that every nodeÂ has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val. As a reminder, aÂ binary search tree is a tree that satisfies these constraints:  The left subtree of a node contains only nodes with keysÂ less thanÂ the node's key. The right subtree of a node contains only nodes with keysÂ greater thanÂ the node's key. Both the left and right subtrees must also be binary search trees.  Â  Example 1:  Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]   Â   Note:  The number of nodes in the tree is between 1 and 100. Each node will have value between 0 and 100. The given tree is a binary search tree.
__label__Bit __label__Tree Xorq has invented an encryption algorithm which uses bitwise XOR operations extensively. This encryption algorithm uses a sequence of non-negative integers  as its key. To implement this algorithm efficiently, Xorq needs to find maximum value of  for given integers ,  and , such that, . Help Xorq implement this function.   For example, , ,  and .  We test each  for all values of  between  and  inclusive: j   x[j]    x[j]^4 1   3       7 2   5       1 3   9       13  Our maximum value is . Function Description Complete the xorKey function in the editor below.  It should return an integer array where each value is the response to a query. xorKey has the following parameters:   x: a list of integers   queries: a two dimensional array where each element is an integer array that consists of  for the  query at indices  and  respectively.   Input Format The first line contains an integer , the number of test cases.  The first line of each test case contains two space-separated integers  and , the size of the integer array  and the number of queries against the test case.  The next line contains  space-separated integers .  Each of next  lines describes a query which consists of three integers  and .    Constraints         Output Format For each query, print the maximum value for , such that,  on a new line.   Sample Input 0 Sample Output 0 Explanation 0 First Query (10 6 10): .  The maximum is .   First Query (10 6 10): .  The maximum is .   Second Query (1023 7 7):   Second Query (1023 7 7):   Third Query (33 5 8):   Third Query (33 5 8):   Fourth Query (182 5 10):  Fourth Query (182 5 10):
__label__Dynamic-Programming __label__Strings You are given a string, , consisting of lowercase English letters. A string is beautiful with respect to  if it can be derived from  by removing exactly  characters. Find and print the number of different strings that are beautiful with respect to . Input Format A single string of lowercase English letters denoting . Constraints   holds for test cases worth at least  of the problem's score.  holds for test cases worth at least  of the problem's score. Output Format Print the number of different strings that are beautiful with respect to . Sample Input abba  Sample Output 4  Explanation   The following strings can be derived by removing  characters from : . This gives us our set of unique beautiful strings, . As , we print .
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  Initially all node values are zero.   The update query is of the format a1 d1 a2 d2 A B  This means you'd have to add  in all nodes in the path from A to B where  is the distance between the node and A. The retrieval query is of the format i j  You need to return the sum of the node values lying in the path from node i to node j modulo 1000000007.  Note:    First all update queries are given and then all retrieval queries.   Distance between 2 nodes is the shortest path length between them taking each edge weight as 1.   Input Format  The first line contains two integers (N and R respectively) separated by a space.   In the next N-1 lines, the ith line describes the ith edge: a line with two integers x y separated by a single space denotes an edge between nodes x and y.   The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.   U lines follow. Each of the next U lines contains 6 space separated integers (a1,d1,a2,d2,A and B respectively). Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 105  2 <= R <= 109  1 <= U <= 105  1 <= Q <= 105  1 <= a1,a2,d1,d2 <= 108  1 <= x, y, i, j, A, B  <= N   Note  For the update operation, x can be equal to y and for the query operation, i can be equal to j.   Sample Input  7 2 1 2 1 3 2 4 2 6 4 5 6 7 1 4 1 1 1 1 4 6 4 5 2 7 4 7 5 3  Sample Output 1 44 45 9  Explanation The node values after updation becomes :   0 8 0 1 0 36 0  Answer to Query #1: 1+0 = 1    Answer to Query #2: 8+36+0 = 44 Answer to Query #3: 1+8+36+0 = 45 Answer to Query #4: 0+1+8+0+0 = 9
__label__Search __label__Mathematics A pair of nodes, , is a similar pair if the following conditions are true: node  is the ancestor of node   Given a tree where each node is labeled from  to , find the number of similar pairs in the tree. For example, given the following tree:     We have the following pairs of ancestors and dependents:   If  for example, we have  pairs that are similar, where . Function Description Complete the similarPair function in the editor below.  It should return an integer that represents the number of pairs meeting the criteria. similarPair has the following parameter(s):   n: an integer that represents the number of nodes   k: an integer edges: a two dimensional array where each element consists of two integers that represent connected node numbers   Input Format The first line contains two space-separated integers  and , the number of nodes and the similarity threshold.  Each of the next  lines contains two space-separated integers defining an edge connecting nodes  and , where node  is the parent to node . Constraints       Output Format Print a single integer denoting the number of similar pairs in the tree. Sample Input 5 2 3 2 3 1 1 4 1 5  Sample Output 4  Explanation   The similar pairs are , , , and , so we print  as our answer.  Observe that  and  are not similar pairs because they do not satisfy  for .
__label__Tree __label__Depth-first-Search You are given a perfect binary treeÂ whereÂ all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node {   int val;   Node *left;   Node *right;   Node *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Â  Example:  Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}  Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}  Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.  Â  Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__Depth-first-Search Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.
__label__Data-Structures __label__Advanced-Data-Structures You are given a sequence . The task is to perform the following queries on it: Type 1. Given two integers  and  . Reorder the elements of the sequence in such a way (changed part of the sequence is in brackets):   Type 2. Given two integers  and , print the value of sum . Input Format  The first line contains two integers  and . The second line contains  integers , denoting initial sequence. Each of the next  lines contains three integers , where  denotes the type of the query, and  are parameters of the query. It's guaranteed that for a first-type query  will be even.   Constraints           Output Format For each query of the second type print the required sum. Sample Input 6 4 1 2 3 4 5 6 1 2 5 2 2 3 2 3 4 2 4 5  Example Output 5 7 9  Explanation After the first query the sequence becomes [1, 3, 2, 5, 4, 6].
__label__Tree __label__Depth-first-Search Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input:Â [1,2,3,null,5,null,4] Output:Â [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---
__label__Mathematics Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures You are given an unrooted tree of  nodes numbered from  to . Each node  has a color, .  Let  be the number of different colors in the path between node  and node . For each node , calculate the value of , defined as follows:   Your task is to print the value of  for each node . Input Format The first line contains a single integer, , denoting the number of nodes.  The second line contains  space-separated integers, , where each  describes the color of node .  Each of the  subsequent lines contains  space-separated integers,  and , defining an undirected edge between nodes  and . Constraints   Output Format Print  lines, where the  line contains a single integer denoting . Sample Input 5 1 2 3 2 3 1 2 2 3 2 4 1 5  Sample Output 10 9 11 9 12  Explanation The Sample Input defines the following tree:  Each  is calculated as follows:
__label__Mathematics Given two arrays of integers with equal lengths, return the maximum value of: |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| where the maximum is taken over all 0 <= i, j < arr1.length. Â  Example 1: Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6] Output: 13  Example 2: Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4] Output: 20  Â  Constraints:  2 <= arr1.length == arr2.length <= 40000 -10^6 <= arr1[i], arr2[i] <= 10^6
__label__Search is a chess piece that moves in an L shape. We define the possible moves of  as any movement from some position  to some  satisfying either of the following: L  and , or    and   Note that  and  allow for the same exact set of movements. For example, the diagram below depicts the possible locations that  or  can move to from its current location at the center of a  chessboard:  Observe that for each possible movement, the Knight moves  units in one direction (i.e., horizontal or vertical) and  unit in the perpendicular direction. Given the value of  for an  chessboard, answer the following question for each  pair where : What is the minimum number of moves it takes for  to get from position  to position ? If it's not possible for the Knight to reach that destination, the answer is -1 instead. -1 Then print the answer for each  according to the Output Format specified below. Input Format A single integer denoting . Constraints  Output Format Print exactly  lines of output in which each line  (where ) contains  space-separated integers describing the minimum number of moves  must make for each respective  (where ). If some  cannot reach position , print -1 instead.   -1 For example, if , we organize the answers for all the  pairs in our output like this: (1,1) (1,2) (2,1) (2,2)  Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts possible minimal paths for , , and :  One minimal path for  is:   We then print 4 4 2 8 as our first line of output because  took  moves,  took  moves,  took  moves, and  took  moves.  4 4 2 8 In some of the later rows of output, it's impossible for  to reach position . For example,  can only move back and forth between  and  so it will never reach .
__label__Strings __label__Dynamic-Programming Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output:Â 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output:Â 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^
__label__Strings You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.  Evaluation Examples: Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.   Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.
__label__Dynamic-Programming There are N cities and N directed roads in Steven's world. The cities are numbered from 0 to N - 1. Steven can travel from city i to city (i + 1) % N, ( 0-> 1 -> 2 -> .... -> N - 1 -> 0).  Steven wants to travel around the world by car. The capacity of his car's fuel tank is C gallons. There are a[i] gallons he can use at the beginning of city i and the car takes b[i] gallons to travel from city i to (i + 1) % N.   How many cities can Steven start his car from so that he can travel around the world and reach the same city he started?  Note  The fuel tank is initially empty.  Input Format The first line contains two integers (separated by a space): city number N and capacity C.  The second line contains N space-separated integers: a[0], a[1], â¦ , a[N - 1].  The third line contains N space-separated integers: b[0], b[1], â¦ , b[N - 1].   Constraints 2 â¤ N â¤ 105  1 â¤ C â¤ 1018  0 â¤ a[i], b[i] â¤ 109  Output Format The number of cities which can be chosen as the start city. Sample Input 3 3 3 1 2 2 2 2  Sample Output 2  Explanation Steven starts from city 0, fills his car with 3 gallons of fuel, and use 2 gallons of fuel to travel to city 1. His fuel tank now has 1 gallon of fuel.  On refueling 1 gallon of fuel at city 1, he then travels to city 2 by using 2 gallons of fuel. His fuel tank is now empty.  On refueling 2 gallon of fuel at city 2, he then travels back to city 0 by using 2 gallons of fuel.   Here is the second possible solution.  Steven starts from city 2, fill his car with 2 gallons, and travels to city 0.  On refueling 3 gallons of fuel from city 0, he then travels to city 1, and exhausts 2 gallons of fuel. His fuel tank contains 1 gallon of fuel now. He can then refuel 1 gallon of fuel at City 1, and increase his car's fuel to 2 gallons and travel to city 2.  However, Steven cannot start from city 1, because he is given only 1 gallon of fuel, but travelling to city 2 requires 2 gallons.  Hence the answer 2.
__label__Greedy-Algorithms Given a stringÂ S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if:  It is the empty string, or It can be written as ABÂ (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Â  Example 1: Input: "())" Output: 1   Example 2: Input: "(((" Output: 3   Example 3: Input: "()" Output: 0   Example 4: Input: "()))((" Output: 4 Â     Note:  S.length <= 1000 S only consists of '(' and ')' characters.
__label__Game-Theory Our unsung tower-breaking heroes (players  and ) only have one tower left, and they've decided to break it for a special game commemorating the end of  days of Game Theory! The rules are as follows:  always moves first, and both players always move optimally. Initially there is  tower of height . The players move in alternating turns. The moves performed by each player are different: At each turn,  divides the current tower into some number of smaller towers. If the turn starts with a tower of height  and  breaks it into  smaller towers, the following condition must apply: , where  denotes the height of the  new tower. At each turn,  chooses some tower  of the  new towers made by  (where ). Then  must pay  coins to . After that,  gets another turn with tower  and the game continues. At each turn,  divides the current tower into some number of smaller towers. If the turn starts with a tower of height  and  breaks it into  smaller towers, the following condition must apply: , where  denotes the height of the  new tower. At each turn,  chooses some tower  of the  new towers made by  (where ). Then  must pay  coins to . After that,  gets another turn with tower  and the game continues. The game is over when no valid move can be made by , meaning that . 's goal is to pay as few coins as possible, and 's goal is to earn as many coins as possible.  Can you predict the number of coins that  will earn? Input Format The first line contains a single integer, , denoting the number of test cases.  Each of the  subsequent lines contains a single integer, , defining the initial tower height for a test case. Constraints   Output Format For each test case, print a single integer denoting the number of coins earned by  on a new line. Sample Input 3 4 2 7  Sample Output 6 4 8  Explanation Test Case 0:  Our players make the following moves:   splits the initial tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.   splits the initial tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.    splits the tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.  splits the tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.   splits the tower into  smaller towers of size .   chooses the second tower and earns  coins.  splits the tower into  smaller towers of size .   chooses the second tower and earns  coins. The total number of coins earned by  is , so we print  on a new line.
__label__Graph-Algorithms Jack has just moved to a new city called Rapture. He wants to use the public public transport system. The fare rules are as follows:   Each pair of connected stations has a fare assigned to it regardless of direction of travel.   If a passenger travels from station A to station B, he only has to pay the  difference between the fare from A to B and the cumulative fare that he has paid to reach station A [fare(A,B) - total fare to reach station A].  If the difference is negative, he can travel free of cost from A to B.   Jack is low on cash and needs your help to figure out the most cost efficient way to go from the first station to the last station. Given the number of stations  (numbered from  to ), and the fare between the  pairs of stations that are connected, determine the lowest fare from station  to station .   For example, there are  stations with undirected connections at the costs indicated:     Travel from station  costs  for the first segment () then the cost differential, an additional  for the remainder.  The total cost is .  Travel from station  costs  for the first segment, then an additional  for the remainder, a total cost of .  The lower priced option costs .   Complete the program in the editor below.  It should print the cost of the lowest priced route from station  to station .  If there is no route, print NO PATH EXISTS.   NO PATH EXISTS Function Description  Complete the getCost function in the editor below.  It should print the cost of the lowest priced route from station  to station , or if there is no route, print NO PATH EXISTS.  There is no expected return value from the function. NO PATH EXISTS getCost has the following parameters: : an integer that represents the number of stations in the network   : an array of integers that represent end stations of a bidirectional connection   : an array of integers that represent end stations of a bidirectional connection, where  is connected to   at cost   : an array of integers that represent the cost of travel between associated stations   Input Format The first line contains two space-separated integers,  and , the number of stations and the number of connections between them.  Each of the next  lines contains three space-separated integers,  and , the starting and ending stations that are connected and the fare between them.   Constraints       Output Format The minimum fare to be paid to reach station  from station . If the station  cannot be reached from station , print NO PATH EXISTS NO PATH EXISTS
__label__Depth-first-Search There areÂ nÂ items eachÂ belonging to zero or one ofÂ mÂ groups where group[i]Â is the group that the i-th item belongs to and it's equal to -1Â if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that:  The items that belong to the same group are next to each other in the sorted list. There are someÂ relationsÂ between these items whereÂ beforeItems[i]Â is a list containing all the items that should come before theÂ i-th item in the sorted array (to the left of theÂ i-th item).  Return any solution if there is more than one solution and return an empty listÂ if there is no solution. Â  Example 1:  Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] Output: [6,3,4,1,5,2,0,7]  Example 2: Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] Output: [] Explanation:Â This is the same as example 1 except that 4 needs to be before 6 in the sorted list.   Â  Constraints:  1 <= m <= n <= 3*10^4 group.length == beforeItems.length == n -1 <= group[i] <= m-1 0 <= beforeItems[i].length <= n-1 0 <= beforeItems[i][j] <= n-1 i != beforeItems[i][j] beforeItems[i]Â does not containÂ duplicates elements.
__label__Graph-Algorithms Markov takes out his Snakes and Ladders game, stares at the board and wonders:   "If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?"    Rules The game is played with a cubic die of  faces numbered  to . Starting from square , land on square  with the exact roll of the die.  If moving the number rolled would place the player beyond square , no move is made. Starting from square , land on square  with the exact roll of the die.  If moving the number rolled would place the player beyond square , no move is made. If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only. If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only. If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only. If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only. Function Description  Complete the quickestWayUp function in the editor below.  It should return an integer that represents the minimum number of moves required.   quickestWayUp has the following parameter(s):   ladders: a 2D integer array where each  contains the start and end cell numbers of a ladder    snakes: a 2D integer array where each  contains the start and end cell numbers of a snake   Input Format The first line contains the number of tests, .    For each testcase:  - The first line contains , the number of ladders.  - Each of the next  lines contains two space-separated integers, the start and end of a ladder.  - The next line contains the integer , the number of snakes.  - Each of the next  lines contains two space-separated integers, the start and end of a snake. Constraints     The board is always  with squares numbered  to .  Neither square  nor square  will be the starting point of a ladder or snake.  A square will have at most one endpoint from either a snake or a ladder.   Output Format For each of the t test cases, print the least number of rolls to move from start to finish on a separate line.  If there is no solution, print -1. -1 Sample Input 2 3 32 62 42 68 12 98 7 95 13 97 25 93 37 79 27 75 19 49 47 67 17 4 8 52 6 80 26 42 2 72 9 51 19 39 11 37 29 81 3 59 5 79 23 53 7 43 33 77 21   Sample Output 3 5  Explanation For the first test:  The player can roll a  and a  to land at square .  There is a ladder to square .  A roll of  ends the traverse in  rolls.   For the second test:  The player first rolls  and climbs the ladder to square .  Three rolls of  get to square .  A final roll of  lands on the target square in  total rolls.
__label__Data-Structures __label__Advanced-Data-Structures Consider a binary search tree T which is initially empty. Also, consider the first N positive integers {1, 2, 3, 4, 5, ....., N} and its permutation P {a1, a2, ..., aN}.  N If we start adding these numbers to the binary search tree T, starting from a1, continuing with a2, ... (and so on) ..., ending with aN. After every addition we ask you to output the sum of distances between every pair of T's nodes. Input Format  The first line of the input consists of the single integer N, the size of the list.  The second line of the input contains N single space separated numbers the permutation a1, a2, ..., aN itself. Constraints  1 â¤ N â¤ 250000   Output Format  Output N lines.  On the ith line output the sum of distances between every pair of nodes after adding the first i numbers from the permutation to the binary search tree T  Sample Input #00 8 4 7 3 1 8 2 6 5  Sample Output #00 0 1 4 10 20 35 52 76  Explanation #00  After adding the first element, the distance is 0 as there is only 1 element  0 4  After adding the second element, the distance between 2 nodes is 1.   1 4  \   7  After adding the third element, the distance between every pair of elements is 2+1+1=4 2+1+1=4   4  / \ 3   7      After adding the fourth element, the distance between every pair of elements is 3 + 2 + 1 + 2 + 1 + 1 = 10 3 + 2 + 1 + 2 + 1 + 1 = 10     4    / \   3   7      / 1  After adding the fifth element, the distance between every pair of elements is 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20     4    / \   3   7      /     \ 1       8  After adding the sixth element, the distance between every pair of elements is 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35     4    / \   3   7      /     \ 1       8  \   2  After adding the seventh element, the distance between every pair of elements is 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52     4    / \   3   7      /   / \ 1   6   8  \   2  After adding the final element, the distance between every pair of elements is 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76         4       /   \     3      7      /      /   \  1      6     8   \    /    2  5
__label__Array Today, the bookstore owner has a store open for customers.length minutes.Â  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute. On some minutes, the bookstore owner is grumpy.Â  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.Â  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied. The bookstore owner knows a secret technique to keep themselvesÂ not grumpy for XÂ minutes straight, but can only use it once. Return the maximum number of customers that can be satisfied throughout the day. Â  Example 1: Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation:Â The bookstore owner keeps themselvesÂ not grumpy for the last 3 minutes.  The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.  Â  Note:  1 <= X <=Â customers.length ==Â grumpy.length <= 20000 0 <=Â customers[i] <= 1000 0 <=Â grumpy[i] <= 1
__label__Strings __label__Dynamic-Programming Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false
__label__Mathematics __label__Dynamic-Programming Given a non-negative integer n, count all numbers with unique digits, x, where 0 â¤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 â¤ x < 100,  Â             excluding 11,22,33,44,55,66,77,88,99
__label__Strings Given a string text, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters. Â  Example 1: Input: text = "ababa" Output: 3 Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa", which its length is 3.  Example 2: Input: text = "aaabaaa" Output: 6 Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa", which its length is 6.  Example 3: Input: text = "aaabbaaa" Output: 4  Example 4: Input: text = "aaaaa" Output: 5 Explanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.  Example 5: Input: text = "abcdef" Output: 1  Â  Constraints:  1 <= text.length <= 20000 text consist of lowercase English characters only.
__label__Array Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [ Â  [1,1,1], Â  [1,0,1], Â  [1,1,1] ] Output:  [ Â  [1,0,1], Â  [0,0,0], Â  [1,0,1] ]  Example 2: Input:  [ Â  [0,1,2,0], Â  [3,4,5,2], Â  [1,3,1,5] ] Output:  [ Â  [0,0,0,0], Â  [0,4,5,0], Â  [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?
__label__Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:Â  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note:Â Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__Mathematics Given a positive integerÂ N, how many ways can we write it as a sum ofÂ consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note:Â 1 <= N <= 10 ^ 9.
__label__Search An English text needs to be encrypted using the following encryption scheme.  First, the spaces are removed from the text. Let  be the length of this text.  Then, characters are written into a grid, whose rows and columns have the following constraints:   For example, the sentence , after removing spaces is  characters long.   is between  and , so it is written in the form of a grid with 7 rows and 8 columns.  ifmanwas   meanttosÂ Â Â Â Â Â Â Â    tayonthe   groundgo   dwouldha   vegivenu   sroots  Ensure that   If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e. .   The encoded message is obtained by displaying the characters in a column, inserting a space, and then displaying the next column and inserting a space, and so on. For example, the encoded message for the above rectangle is:   imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau  imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau You will be given a message to encode and print. Function Description  Complete the encryption function in the editor below.  It should return a single string composed as described.   encryption has the following parameter(s):   s: a string to encrypt   Input Format One line of text, the string  Constraints    is comprised only of characters in the range ascii[a-z]. Output Format Print the encoded message on one line as described. Sample Input haveaniceday  Sample Output 0 hae and via ecy  Explanation 0  ,  is between  and .  Rewritten with  rows and  columns: have anic eday  Sample Input 1 feedthedog Â  Â   Sample Output 1 fto ehg ee dd  Explanation 1  ,  is between  and .  Rewritten with  rows and  columns:   feed thed og  Sample Input 2 chillout  Sample Output 2 clu hlt io  Explanation 2  ,  is between  and .  Rewritten with  columns and  rows ( so we have to use .) chi llo ut
__label__Dynamic-Programming An Introduction to the Longest Increasing Subsequence Problem  The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in strictly ascending order. This is called the Longest Increasing Subsequence (LIS) problem. For example, the length of the LIS for  is  since the longest increasing subsequence is .   Here's a great YouTube video of a lecture from MIT's Open-CourseWare covering the topic.     This is one approach which solves this in quadratic time using dynamic programming. A more efficient algorithm which solves the problem in  time is available here.  Given a sequence of integers, find the length of its longest strictly increasing subsequence. Function Description  Complete the longestIncreasingSubsequence function in the editor below.  It should return an integer that denotes the array's LIS.   longestIncreasingSubsequence has the following parameter(s):   arr: an unordered array of integers   Input Format The first line contains a single integer , the number of elements in .  Each of the next  lines contains an integer,  Constraints     Output Format Print a single line containing a single integer denoting the length of the longest increasing subsequence. Sample Input 0 Sample Output 0 Explanation 0 In the array , the longest increasing subsequence is .  It has a length of . Sample Input 1 Sample Output 1 Explanation 1 The LIS of  is .
__label__Array In a stringÂ SÂ of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" andÂ "yy". Call a group large if it has 3 or more characters.Â  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order. Â  Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]] Â  Note:Â Â 1 <= S.length <= 1000
__label__Strings Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com,Â alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.Â  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.Â  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will beÂ ignored. This allows certain emails to be filtered, for exampleÂ m.y+name@email.comÂ will be forwarded toÂ my@email.com.Â  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.Â Â How many different addresses actually receive mails?Â  Â   Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation:Â "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails  Â  Note:  1 <= emails[i].lengthÂ <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character. All local and domain names are non-empty. Local names do not start with a '+' character.
__label__Binary-Search Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i â¤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.
__label__Binary-Search Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].
__label__Array __label__Two-Pointers You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward kÂ steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element. Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements. Â  Example 1: Input: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.  Example 2: Input: [-1,2] Output: false Explanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.  Example 3: Input: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction. Â  Note:  -1000 â¤Â nums[i] â¤Â 1000 nums[i] â Â 0 1 â¤Â nums.length â¤ 5000  Â  Follow up: Could you solve it in O(n) time complexity andÂ O(1) extra space complexity?
__label__Dynamic-Programming Chinese Version Russian Version Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that: Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.   All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component The absolute difference between the number of chocolates in pieces should be at most K After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this:  XX  XX Input Format The first line of the input contains 3 integers M, N and K separated by a single space.  M lines follow, each of which contains N characters.  Each character is 'T','D' or 'U'. Constraints 0â¤ M, N â¤8  0â¤ K â¤ M * N Output Format A single line containing the number of ways to divide the chocolate bar. Sample Input 2 2 4 UU UU  Sample Output 12  Explanation Note: In the explanation T and D are used to represent, which parts belong to Tom and Derpina respectively. There are 24 = 16 possible separations.  The 4 invalid are: TT TT  DD DD  DT TD  TD DT  Some of the valid ones are: TD TD  TT DD  DD TT  DT DT
__label__Dynamic-Programming Tim is visiting his grandma for two days and is bored due to the lack of the electricity over there. That's why he starts to play with grandma's colorful candle collection. He aligned the  candles from left to right. The th candle from the left has the height  and the color , an integer ranged from 1 to a given , the number of colors.  Now he stares at the sequence of candles and wonders, how many strictly increasing ( in height ) colorful subsequences are there? A subsequence is considered as colorful if every of the  colors appears at least one times in the subsequence.  As the number of subsequences fulfilling the requirement can be large, print the result modulo . Input Format On the first line you will be given  and , then  lines will follow. On the th line you will be given two integers  and .  Constraints    Output Format Print the number of strictly increasing colorful subsequences modulo .  Sample Input 4 3 1 1 3 2 2 2 4 3  Sample Output 2  Explanation In the first sample the only two valid subsequences are (1, 2, 4) and (1, 3, 4).
__label__Strings A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.) Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern. Â  Example 1: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB" Output: [true,false,true,true,false] Explanation:  "FooBar" can be generated like this "F" + "oo" + "B" + "ar". "FootBall" can be generated like this "F" + "oot" + "B" + "all". "FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer". Example 2: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa" Output: [true,false,true,false,false] Explanation:  "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r". "FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".  Example 3: Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT" Output: [false,true,false,false,false] Explanation:  "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".  Â  Note:  1 <= queries.length <= 100 1 <= queries[i].length <= 100 1 <= pattern.length <= 100 All strings consists only of lower and upper case English letters.
__label__Mathematics The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. GivenÂ kÂ will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"
__label__Bit You are given a string , consisting of  small latin letters 'a' and 'b'. You are also given  queries to process. The queries are as follows: a b C   : all the symbols in the string, starting at the , ending at the  become equal to ;   S    : swap two consecutive fragments of the string, where the first is denoted by a substring starting from  ending at  and the second is denoted by a substring starting at  ending at ;    R  : reverse the fragment of the string that starts at the  symbol and ends at the  one;   W  : output the substring of the string that starts at the  symbol and ends at the  one;   H   : output the Hamming distance between the consecutive substrings that starts at  and  respectively and have the length of .   Everything is 1-indexed here. Input Format The first line of input contains a single integer   the length of the string.  The second line contains the initial string  itself.  The third line of input contains a single integer   the number of queries.  Then, there are  lines, each denotes a query of one of the types above.   Constraints     Total number of characters printed in W-type queries will not exceed   For C-type, R-type, W-type queries: ;  equals either a, or b  For S-type queries:   For H-type queries: ; ; .   a b Output Format For each query of the type W or the type H output an answer on the separate line of output. W H Sample Input 0 Sample Output 0 Explanation 0 Initial String - aabbbabbab
__label__Bit It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue.  Initial positions increment by  from  at the front of the line to  at the back. Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others.  For example, if  and  bribes , the queue will look like this: . Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state! Function Description Complete the function minimumBribes in the editor below.  It must print an integer representing the minimum number of bribes necessary, or Too chaotic if the line configuration is not possible.   Too chaotic minimumBribes has the following parameter(s): q: an array of integers   Input Format The first line contains an integer , the number of test cases.    Each of the next  pairs of lines are as follows:  - The first line contains an integer , the number of people in the queue  - The second line has  space-separated integers describing the final state of the queue.   Constraints    Subtasks For  score  For  score  Output Format Print an integer denoting the minimum number of bribes needed to get the queue into its final state.  Print Too chaotic if the state is invalid, i.e. it requires a person to have bribed more than  people. Too chaotic Sample Input 2 5 2 1 5 3 4 5 2 5 1 3 4  Sample Output 3 Too chaotic  Explanation Test Case 1 The initial state:  After person  moves one position ahead by bribing person :  Now person  moves another position ahead by bribing person :  And person  moves one position ahead by bribing person :  So the final state is  after three bribing operations. Test Case 2 No person can bribe more than two people, so its not possible to achieve the input state.
__label__Array Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE:Â input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Tree __label__Data-Structures We consider metric space to be a pair, , where  is a set and  such that the following conditions hold:     where  is the distance between points  and . Let's define the product of two metric spaces, , to be  such that:  , where , . So, it follows logically that  is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: . For example, , where  is a metric space. , where . In this challenge, we need a tree-space. You're given a tree, , where  is the set of vertices and  is the set of edges. Let the function  be the distance between two vertices in tree  (i.e.,  is the number of edges on the path between vertices  and ). Note that  is a metric space. You are given a tree, , with  vertices, as well as  points in . Find and print the distance between the two furthest points in this metric space! Input Format The first line contains two space-separated positive integers describing the respective values of  (the number of vertices in ) and  (the number of given points).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing edge  in .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for point . Constraints     Scoring This challenge uses binary scoring, so you must pass all test cases to earn a positive score. Output Format Print a single non-negative integer denoting the maximum distance between two of the given points in metric space . Sample Input 0 Sample Output 0 Explanation 0 The distance between points  and  is . Sample Input 1 Sample Output 1 Explanation 1 The best points are  and , which gives us a distance of .
__label__Mathematics Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) (Recall that an integerÂ is prime if and only if it is greater than 1, and cannot be written as a product of two positive integersÂ both smaller than it.) Since the answer may be large, return the answer modulo 10^9 + 7. Â  Example 1: Input: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.  Example 2: Input: n = 100 Output: 682289015  Â  Constraints:  1 <= n <= 100
__label__Array __label__Hash-Table Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. Â   Example 1: Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]  Â  Note:  1 <= A.length <= 30000 -10000 <= A[i] <= 10000 2 <= K <= 10000
__label__Strings A palindrome is a string that reads the same from left to right as it does from right to left. Given a string, , of  lowercase English letters, we define a -length rotation as cutting the first  characters from the beginning of  and appending them to the end of . For each , there are  possible -length rotations (where ). See the Explanation section for examples. Given  and , find all  -length rotations of ; for each rotated string, , print the maximum possible length of any palindromic substring of  on a new line. Input Format The first line contains an integer,  (the length of ).  The second line contains a single string, . Constraints    Output Format There should be  lines of output, where each line  contains an integer denoting the maximum length of any palindromic substring of rotation . Sample Input 0 13 aaaaabbbbaaaa  Sample Output 0 12 12 10 8 8 9 11 13 11 9 8 8 10  Sample Input 1 7 cacbbba  Sample Output 1 3 3 3 3 3 3 3  Sample Input 2 12 eededdeedede  Sample Output 2 5 7 7 7 7 9 9 9 9 7 5 4  Explanation Consider Sample Case 1, where .  The possible rotations, , for string  are:  .              The longest palindromic substrings for each  are:   and , so we print their length () on a new line.  , so we print its length () on a new line.   and , so we print their length () on a new line.   and , so we print their length () on a new line.   and , so we print their length () on a new line.   and , so we print their length () on a new line.   and , so we print their length () on a new line.
__label__Game-Theory General Iroh and Commandant Bumi are heading to the Republic City to stop a rebellion. But it's quite a long travel, so in the meantime they have started discussing about possible attacking plans. Right now, they're arguing about best ways for moving soldiers during the battle. Tired of not getting a final and concise strategy, Iroh proposed a particularly original idea. Iroh: Bumi, look at this map: here we have all possible locations in the battle field soldiers can occupy. I know a game which can give us some ideas.  Bumi: A game? How will a game help us here?  Iroh: It's pretty simple, we know which location is connected to each one, and also, that all those paths between locations are one-way (it's too dangerous to have two ways paths), so we place some soldiers at random initial locations, take turns, and in each turn, we try to make a valid move with one soldier from one location to another. Eventually, we won't be able to move any man so, the first one which is not able to perform any valid move, loses. One important thing is, at some moment, we may have some men at the same field location.  Bumi: Are you sure we are gonna end this? We have so many locations and paths... don't know, soldiers could be moving in circles for ever.  Iroh: Take it easy man, those paths were built by the best architects I've ever known, so there is no way that could happen.  Bumi: Well, I still don't get how does this help us.  Iroh: Me neither, but greatest generals from the Earth Kingdom created their strategies from this game, so, who knows?  Bumi: Ok, I'm in. Who plays first?  Iroh: You go first my friend. Just make sure you always do your best, because I will show no mercy to you :).  Input Format First line in the input contains two integers N and M, describing the number of locations and paths between them, respectively. M lines follow, each one with two integers u and v, denoting a one-way path from u to v.  Then comes a line with a single integer Q, denoting how many times Bumi and Iroh played the game over the given field. Q queries follow each one with two lines, first one with a single integer K, the number of soldiers in the field; and second one with K integers b_i separated by space, each one denoting the initial location of some soldier. Constraints 1 < N <= 105  1 <= M <= 106  1 <= u, v, b_i <= N  1 <= K <= 102  1 <= Q <= 105  Output Format Output Q lines, each one saying Bumi if Bumi should be the winner of the corresponding game or Iroh otherwise.  Remember that, being both top strategy masters, they will always perform the best possible move each turn. Sample Input 10 10 1 10 3 10 7 8 6 8 7 4 9 4 7 6 5 8 1 8 2 8 5 4 10 7 6 4 3 1 9 4 3 8 3 5 3 4 9 7 3 7 9 10  Sample Output Bumi Iroh Iroh Bumi Bumi
__label__Data-Structures __label__Advanced-Data-Structures White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques?  There are  types of query operations that can be performed on a tree: 1 u x: Assign  as the value of node . 1 u x 2 u v: Print the sum of the node values in the unique path from node  to node . 2 u v Given a tree with  nodes where each node's value is initially , execute  queries.  Input Format The first line contains  space-separated integers,  and , respectively.  The  subsequent lines each contain  space-separated integers describing an undirected edge in the tree.  Each of the  subsequent lines contains a query you must execute. Constraints   It is guaranteed that the input describes a connected tree with  nodes.  Nodes are enumerated with -based indexing. Output Format For each type- query, print its integer result on a new line. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 3  Explanation  After the first  queries, the value of node  and the value of node . The third query requires us to print the sum of the node values in the path from nodes  to , which is . Thus, we print  on a new line.
__label__Tree Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the propertyÂ root.val = min(root.left.val, root.right.val)Â always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.  Â  Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.
__label__Array Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].
__label__Search __label__Mathematics Sunny and Johnny like to pool their money and go to the ice cream parlor.  Johnny never buys the same flavor that Sunny does.  The only other rule they have is that they spend all of their money. Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.   For example, they have  to spend and there are flavors costing .  The two flavors costing  and  meet the criteria.  Using -based indexing, they are at indices  and .   Function Description Complete the icecreamParlor function in the editor below.  It should return an array containing the indices of the prices of the two flavors they buy, sorted ascending.   icecreamParlor has the following parameter(s):   m: an integer denoting the amount of money they have to spend   cost: an integer array denoting the cost of each flavor of ice cream   Input Format The first line contains an integer, , denoting the number of trips to the ice cream parlor.   The next  sets of lines each describe a visit.  Each trip is described as follows: The integer , the amount of money they have pooled.  The integer , the number of flavors offered at the time.   space-separated integers denoting the cost of each flavor: .   Note:  The index within the cost array represents the flavor of the ice cream purchased.   Constraints       , â   There will always be a unique solution. Output Format For each test case, print two space-separated integers denoting the indices of the two flavors purchased, in ascending order.   Sample Input 2 4 5 1 4 5 3 2 4 4 2 2 4 3  Sample Output 1 4 1 2  Explanation Sunny and Johnny make the following two trips to the parlor: The first time, they pool together  dollars. Of the five flavors available that day, flavors  and  have a total cost of .   The second time, they pool together  dollars. TOf the four flavors available that day, flavors  and  have a total cost of .
__label__Bit Jack and Daniel are friends.  They want to encrypt their conversations so that they can save themselves from interception by a detective agency so they invent a new cipher.   Every message is encoded to its binary representation. Then it is written down  times, shifted by  bits. Each of the columns is XORed together to get the final encoded string. If  and  it looks like so:   1001011     shift 0  01001011    shift 1 001001011   shift 2 0001001011  shift 3 ---------- 1110101001  <- XORed/encoded string s  Now we have to decode the message.  We know that .  The first digit in  so our output string is going to start with .  The next two digits are also , so they must have been XORed with .  We know the first digit of our  shifted string is a  as well.  Since the  digit of  is , we XOR that with our  and now know there is a  in the  position of the original string.  Continue with that logic until the end. Then the encoded message  and the key  are sent to Daniel.    Jack is using this encoding algorithm and asks Daniel to implement a decoding algorithm.  Can you help Daniel implement this?   Function Description  Complete the cipher function in the editor below.  It should return the decoded string.   cipher has the following parameter(s):   k: an integer that represents the number of times the string is shifted  s: an encoded string of binary digits Input Format The first line contains two integers  and , the length of the original decoded string and the number of shifts.  The second line contains the encoded string  consisting of  ones and zeros.   Constraints       It is guaranteed that  is valid.   Output Format Return the decoded message of length , consisting of ones and zeros.   Sample Input 0 Sample Output 0 Explanation 0 1001010  1001010   1001010    1001010 ---------- 1110100110  Sample Input 1 Sample Output 1 Explanation 1 101111  101111 ------- 1110001  Sample Input 2 Sample Output 2 Explanation 2 10000101 010000101 1110011011
__label__Tree __label__Depth-first-Search Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note:Â A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]
__label__Greedy-Algorithms Alice gives Bob a board composed of  wooden squares and asks him to find the minimum cost of breaking the board back down into its individual squares. To break the board down, Bob must make cuts along its horizontal and vertical lines.  To reduce the board to squares, Bob makes horizontal and vertical cuts across the entire board.  Each cut has a given cost,  or  for each cut along a row or column across one board, so the cost of a cut must be multiplied by the number of segments it crosses.  The cost of cutting the whole board down into  squares is the sum of the costs of each successive cut.    Can you help Bob find the minimum cost?  The number may be large, so print the value modulo . For example, you start with a  board.  There are two cuts to be made at a cost of  for the horizontal and  for the vertical.  Your first cut is across  piece, the whole board.  You choose to make the horizontal cut between rows  and  for a cost of .  The second cuts are vertical through the two smaller boards created in step  between columns  and .  Their cost is .  The total cost is  and . Function Description  Complete the boardCutting function in the editor below.  It should return an integer.   boardCutting has the following parameter(s):   cost_x: an array of integers, the costs of vertical cuts   cost_y: an array of integers, the costs of horizontal cuts   Input Format The first line contains an integer , the number of queries. The following  sets of lines are as follows: The first line has two positive space-separated integers  and , the number of rows and columns in the board.     The second line contains  space-separated integers cost_y[i], the cost of a  horizontal cut between rows  and  of one board. The third line contains  space-separated integers cost_x[j], the cost of a vertical cut between columns  and  of one board. Constraints       Output Format For each of the  queries, find the minimum cost () of cutting the board into  squares and print the value of . Sample Input 0 1 2 2 2 1  Sample Output 0 4  Explanation 0  We have a  board, with cut costs  and . Our first cut is horizontal between  and , because that is the line with the highest cost (). Our second cut is vertical, at . Our first cut has a  of  because we are making a cut with cost  across  segment, the uncut board. The second cut also has a  of  but we are making a cut of cost  across  segments. Our answer is . Sample Input 1 1 6 4 2 1 3 1 4 4 1 2  Sample Output 1  42  Explanation 1  Our sequence of cuts is: , , , , , ,  and .  Cut 1: Horizontal with cost  across  segment. .  Cut 2: Vertical with cost  across  segments. .  Cut 3: Horizontal with cost  across  segments. .  Cut 4: Horizontal with cost  across  segments. .  Cut 5: Vertical with cost  across  segments. .  Cut 6: Horizontal with cost  across  segments. .  Cut 7: Horizontal with cost  across  segments. .  Cut 8: Vertical with cost  across  segments. .       . We then print the value of .
__label__Tree __label__Depth-first-Search Given the rootÂ of a binary tree, each node in the tree has a distinct value. After deletingÂ all nodes with a value in to_delete, we are left with a forest (aÂ disjoint union of trees). Return the roots of the trees in the remaining forest.Â  You may return the result in any order. Â  Example 1:  Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]]  Â  Constraints:  The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length <= 1000 to_delete contains distinct values between 1 and 1000.
__label__Dynamic-Programming Red John has committed another murder. This time, he doesn't leave a red smiley behind. Instead he leaves a puzzle for Patrick Jane to solve. He also texts Teresa Lisbon that if Patrick is successful, he will turn himself in. The puzzle begins as follows.   There is a wall of size 4xn in the victim's house. The victim has an infinite supply of bricks of size 4x1 and 1x4 in her house. There is a hidden safe which can only be opened by a particular configuration of bricks. First we must calculate the total number of ways in which the bricks can be arranged so that the entire wall is covered.  The following diagram shows how bricks might be arranged to cover walls where :  There is one more step to the puzzle.  Call the number of possible arrangements .   Patrick must calculate the number of prime numbers  in the inclusive range .   As an example, assume .  From the diagram above, we determine that there is only one configuration that will cover the wall properly.   is not a prime number, so . A more complex example is .  The bricks can be oriented in  total configurations that cover the wall.  The two primes  and  are less than or equal to , so .  Function Description  Complete the redJohn function in the editor below.  It should return the number of primes determined, as an integer.   redJohn has the following parameter(s):   n: an integer that denotes the length of the wall   Input Format The first line contains the integer , the number of test cases.  Each of the next  lines contains an integer , the length of the  wall. Constraints   Output Format Print the integer  on a separate line for each test case. Sample Input 2 1 7  Sample Output 0 3  Explanation For , the brick can be laid in 1 format only: vertically.   The number of primes  is .  For , one of the ways in which we can lay the bricks is   There are  ways of arranging the bricks for  and there are  primes .
__label__Array In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.
__label__Strings A numeric string, , is beautiful if it can be split into a sequence of two or more positive integers, , satisfying the following conditions:  for any  (i.e., each element in the sequence is  more than the previous element). No  contains a leading zero. For example, we can split  into the sequence , but it is not beautiful because  and  have leading zeroes. The contents of the sequence cannot be rearranged. For example, we can split  into the sequence , but it is not beautiful because it breaks our first constraint (i.e., ). The diagram below depicts some beautiful strings:  You must perform  queries where each query consists of some integer string . For each query, print whether or not the string is beautiful on a new line. If it's beautiful, print YES x, where  is the first number of the increasing sequence.  If there are multiple such values of , choose the smallest.  Otherwise, print NO.   YES x NO Function Description  Complete the separateNumbers function in the editor below.  It should print a string as described above.   separateNumbers has the following parameter:   s: an integer value represented as a string   Input Format The first line contains an integer , the number of strings to evaluate.  Each of the next  lines contains an integer string  to query. Constraints    Output Format For each query, print its answer on a new line (i.e., either YES x where  is the smallest first number of the increasing sequence, or NO). YES x NO Sample Input 0 Sample Output 0 Explanation 0 The first three numbers are beautiful (see the diagram above). The remaining numbers are not beautiful: For , all possible splits violate the first and/or second conditions. For , it starts with a zero so all possible splits violate the second condition. For , the only possible split is , which violates the first condition. For , there are no possible splits because  only has one digit. Sample Input 1 Sample Output 1
__label__Hash-Table You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island. Â  Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:
__label__Dynamic-Programming We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  NÂ  will be in range [1, 1000].
__label__Tree __label__Data-Structures Given an array, your goal is to find, for each element, the largest subarray containing it whose cost is at least . Specifically, let  be an array of length , and let  be the subarray from index  to index . Also, Let  be the largest number in . Let  be the smallest number in . Let  be the bitwise OR of the elements of . Let  be the bitwise AND of the elements of . The cost of , denoted , is defined as   You are given the array  and and an integer . For each index  from  to , your goal is to find the largest size of any subarray  such that  and . Consider, array  and . The possible sub-arrays and their costs would be as follows:   Complete the function costlyIntervals which takes two integers  and  as first line of input, and array  in the second line of input. Return an array of  integers, where the  element contains the answer for index  of the input array, . Every element of the output array denotes the largest size of a subarray containing  whose cost is at least , or  if there is no such subarray. costlyIntervals Constraints     Subtasks  For  of the maximum score, . For  of the maximum score, . Sample Input ,     Sample Output   Explanation In this example, we have . There is only one subarray whose cost is at least , and that is , since . Its size is . Thus, for  and , the answer is , and for the others, .
__label__Hash-Table __label__Mathematics Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | | Â  Â  Â  Â o | Â  Â  o | Â o Â  +-------------> 0 Â 1 Â 2 Â 3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o | Â Â Â Â oÂ Â       o | Â Â Â Â    o | Â o Â       o +-------------------> 0 Â 1 Â 2 Â 3 Â 4 Â 5 Â 6  NOTE:Â input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Mathematics __label__Strings Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 orÂ 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"
__label__Data-Structures __label__Advanced-Data-Structures A cricket match is going to be held. The field is represented by a 1D plane. A cricketer, Mr. X has  favorite shots. Each shot has a particular range. The range of the   shot is from i to i. That means his favorite shot can be anywhere in this range. Each player on the opposite team  can field only in a particular range. Player  can field from i to i. You are given the  favorite shots of Mr. X and the range of  players.  represents the strength of each player i.e. the number of shots player  can stop.  Your task is to find: . Game Rules: A player can stop the  shot if the range overlaps with the player's fielding range. For more clarity about overlapping, study the following figure:    Input Format The first line consists of two space separated integers,  and . Each of the next  lines contains two space separated integers. The  line contains  and . Each of the next  lines contains two integers. The  line contains integers  and . Output Format You need to print the sum of the strengths of all the players: . Constraints:    Sample Input 4 4                 1 2  2 3 4 5 6 7 1 5 2 3 4 7 5 7     Sample Output 9  Explanation Player 1 can stop the 1st, 2nd and 3rd shot so the strength is . Player 2 can stop the 1st and 2nd shot so the strength is . Player 3 can stop the 3rd and 4th shot so the strength is . Player 4 can stop the 3rd and 4th shot so the strength is . The sum of the strengths of all the players is .
