__label__Strings __label__Dynamic-Programming Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). Example 1: Input: S = "rabbbit", T = "rabbit" Output: 3 Explanation:  As shown below, there are 3 ways you can generate "rabbit" from S. (The caret symbol ^ means the chosen letters)  rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^  Example 2: Input: S = "babgbag", T = "bag" Output: 5 Explanation:  As shown below, there are 5 ways you can generate "bag" from S. (The caret symbol ^ means the chosen letters)  babgbag ^^ ^ babgbag ^^    ^ babgbag ^    ^^ babgbag   ^  ^^ babgbag     ^^^
__label__Graph-Algorithms Alex has a board game consisting of: A chip for marking his current location on the board.  fields numbered from  to . Each position  has a value, , denoting the next position for the chip to jump to from that field. A die with  faces numbered from  to . Each face  has a probability, , of being rolled. Alex then performs the following actions: Begins the game by placing the chip at a position in a field randomly and with equiprobability.  Takes  turns; during each turn he: Rolls the die. We'll denote the number rolled during a turn as . Jumps the chip  times. Recall that each field contains a value denoting the next field number to jump to. Rolls the die. We'll denote the number rolled during a turn as . Jumps the chip  times. Recall that each field contains a value denoting the next field number to jump to. After completing  turns, the game ends and he must calculate the respective probabilities for each field as to whether the game ended with the chip in that field. Given , , , the game board, and the probabilities for each die face, print  lines where each line  contains the probability that the chip is on field  at the end of the game. Note: All the probabilities in this task are rational numbers modulo . That is, if the probability can be expressed as the irreducible fraction  where , then it corresponds to the number  (or, alternatively, ). Click here to learn about Modular Multiplicative Inverse. Input Format The first line contains three space-separated integers describing the respective values of  (the number of positions),  (the number of die faces), and  (the number of turns).  The second line contains  space-separated integers describing the respective values of each  (i.e., the index of the field that field  can transition to).  The third line contains  space-separated integers describing the respective values of each  (where ) describing the probabilities of the faces of the -sided die.   Constraints         The sum of  is   Note: The time limit for this challenge is doubled for all languages. Read more about standard time limits at our environment page. Output Format Print  lines of output in which each line  contains a single integer,  (where ), denoting the probability that the chip will be on field  after  turns. Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts the respective probabilities of each die face being rolled:  The diagram below depicts each field with an arrow pointing to the next field:  There are four equiprobable initial fields, so each field has a  probability of being the chip's initial location. Next, we calculate the probability that the chip will end up in each field after  turn: The only way the chip ends up in this field is if it never jumps from the field, which only happens if Alex rolls a . So, this field's probability is . We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . Start in field  and roll a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . Start in field  and roll a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. If the chip is initially placed in field , it will always end up in field  regardless of how many turns are taken (because this field loops back onto itself). Thus, this field's probability is . We then calculate and print the result of  on a new line.
__label__Dynamic-Programming Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.
__label__Depth-first-Search (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Dynamic-Programming We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9
__label__Search Anna loves graph theory! She has a tree where each vertex is numbered from  to , and each contains a data value.   The sum of a tree is the sum of all its nodes' data values.  If she cuts an edge in her tree, she forms two smaller trees.  The difference between two trees is the absolute value between their sums.   Given a tree, determine which edge to cut so that the resulting trees have a minimal difference between them, then return that difference.   For example, your tree's nodes have weights of .  In this case, node numbers match their weights for convenience.  In the diagram below, you have the following edges: .    The values are calculated as follows:   Edge    Tree 1  Tree 2  Absolute Cut     Sum      Sum     Difference 1        8         13         5 2        9         12         3 3        6         15         9 4        4         17        13 5        5         16        11  The minimum absolute difference is . Note: The tree is always rooted at vertex .   Function Description  Complete the cutTheTree function in the editor below.  Return an integer that represents the minimal absolute difference achievable between the resultant two trees.   cutTheTree has the following parameter(s):   data: an array of integers that represent node values   edges: an 2 dimensional array of integer pairs where each pair represents an edge in the graph   Input Format The first line contains an integer , the number of vertices in the tree.  The second line contains  space-separated integers, where each integer  denotes the value of .  Each of the  subsequent lines contains two space-separated integers  and  describing edge  in tree .        Constraints   , where . Output Format A single line containing the minimum difference possible for tree . Sample Input 6 100 200 100 500 100 600 1 2 2 3 2 5 4 5 5 6  Sample Output 400  Explanation We can visualize the initial, uncut tree as:    There are  edges we can cut: Edge  results in   Edge  results in  Edge  results in   Edge  results in  Edge  results in  The minimum difference is .
__label__Mathematics Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"
__label__Dynamic-Programming __label__Data-Structures You have two arrays of integers,  and , where both have  number of elements. Consider the following function: score = 0  int Go(step, energy) {     if (step == N) {         score += V[step];         return (score);     }     else {         int way = random(1, 2);         if (way == 1) {             score += V[step];         }         else {             energy = P[step];         }         if (energy > 0) {             Go(step + 1, energy - 1);         }         else {             KillTheWorld();         }     } }  What is the maximum possible value of score that we can get in the end, if we call ?.  Note that the function should never invoke KillTheWorld function. And  generates a random integer from set  [1, 2].  It is guaranteed there will be a solution that wont kill the world. Input Format The first line contains an integer N. Each of the following N lines contains a pair of integers. The i-th line contains a pair of numbers, , separated by space.   Constraints       Output Format Derive the maximum score given by return (score);. return (score); Sample Input 4 4 2 0 2 4 0 3 4  Sample Output 7  Explanation In the best case, the first and second function call in Go variable  will take value 2, while in the other calls it will be equal to 1 then the final score will be equal to the value of 7.
__label__Mathematics __label__Strings Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__Search Numeros the Artist had two lists that were permutations of one another.  He was very proud. Unfortunately, while transporting them from one exhibition to another, some numbers were lost out of the first list. Can you find the missing numbers? As an example, the array with some numbers missing, .  The original array of numbers .  The numbers missing are .   Notes  If a number occurs multiple times in the lists, you must ensure that the frequency of that number in both lists is the same. If that is not the case, then it is also a missing number.  You have to print all the missing numbers in ascending order.  Print each missing number once, even if it is missing multiple times.  The difference between maximum and minimum number in the second list is less than or equal to .   Function Description  Complete the missingNumbers function in the editor below.  It should return a sorted array of missing numbers.   missingNumbers has the following parameter(s): arr: the array with missing numbers    brr: the original array of numbers    Input Format There will be four lines of input:    - the size of the first list,    The next line contains  space-separated integers    - the size of the second list,    The next line contains  space-separated integers   Constraints       Output Format Output the missing numbers in ascending order. Sample Input Sample Output Explanation  is present in both arrays. Its frequency in  is , while its frequency in  is . Similarly,  and  occur twice in , but three times in . The rest of the numbers have the same frequencies in both lists.
__label__Tree For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.   Example 1: Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.     Note:  Each tree will have at most 100 nodes. Each value in each tree will be a unique integer in the range [0, 99].
__label__Strings __label__Dynamic-Programming Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = "great":     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t  To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t  We say that "rgeat" is a scrambled string of "great". Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a  We say that "rgtae" is a scrambled string of "great". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = "great", s2 = "rgeat" Output: true  Example 2: Input: s1 = "abcde", s2 = "caebd" Output: false
__label__Hash-Table __label__Strings Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.
__label__Data-Structures __label__Advanced-Data-Structures A cricket match is going to be held. The field is represented by a 1D plane. A cricketer, Mr. X has  favorite shots. Each shot has a particular range. The range of the   shot is from i to i. That means his favorite shot can be anywhere in this range. Each player on the opposite team  can field only in a particular range. Player  can field from i to i. You are given the  favorite shots of Mr. X and the range of  players.  represents the strength of each player i.e. the number of shots player  can stop.  Your task is to find: . Game Rules: A player can stop the  shot if the range overlaps with the player's fielding range. For more clarity about overlapping, study the following figure:    Input Format The first line consists of two space separated integers,  and . Each of the next  lines contains two space separated integers. The  line contains  and . Each of the next  lines contains two integers. The  line contains integers  and . Output Format You need to print the sum of the strengths of all the players: . Constraints:    Sample Input 4 4                 1 2  2 3 4 5 6 7 1 5 2 3 4 7 5 7     Sample Output 9  Explanation Player 1 can stop the 1st, 2nd and 3rd shot so the strength is . Player 2 can stop the 1st and 2nd shot so the strength is . Player 3 can stop the 3rd and 4th shot so the strength is . Player 4 can stop the 3rd and 4th shot so the strength is . The sum of the strengths of all the players is .
__label__Tree Taylor loves trees, and this new challenge has him stumped! Consider a tree, , consisting of  nodes. Each node is numbered from  to , and each node  has an integer, , attached to it.  A query on tree  takes the form w x y z. To process a query, you must print the count of ordered pairs of integers  such that the following four conditions are all satisfied:  w x y z   the path from node  to node .  path from node  to node .   Given  and  queries, process each query in order, printing the pair count for each query on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes) and  (the number of queries).  The second line contains  space-separated integers describing the respective values of each node (i.e., ).  Each of the  subsequent lines contains two space-separated integers,  and , defining a bidirectional edge between nodes  and .  Each of the  subsequent lines contains a w x y z query, defined above. w x y z Constraints         Scoring for this problem is Binary, that means you have to pass all the test cases to get a positive score. Output Format For each query, print the count of ordered pairs of integers satisfying the four given conditions on a new line. Sample Input 10 5 10 2 3 5 10 5 3 6 2 1 1 2 1 3 3 4 3 5 3 6 4 7 5 8 7 9 2 10 8 5 2 10 3 8 4 9 1 9 5 9 4 6 4 6 5 8 5 8  Sample Output 0 1 3 2 0  Explanation We perform  queries on the following tree:  Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . One such pair, , exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Three such pairs, , , and  exist, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Two such pairs,  and , exist, so we print .   Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print .
__label__Mathematics __label__Binary-Search Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]
__label__Search __label__Data-Structures __label__Advanced-Data-Structures There is an integer array  which does not contain more than two elements of the same value. How many distinct ascending triples () are present?  Input format  The first line contains an integer, , denoting the number of elements in the array. This is followed by a single line, containing  space-separated integers. Please note that there are no leading spaces before the first number, and there are no trailing spaces after the last number. Output format:  A single integer that denotes the number of distinct ascending triplets present in the array. Constraints:    Every element of the array is present at most twice.  Every element of the array is a 32-bit non-negative integer. Sample input:  6   1 1 2 2 3 4    Sample output:  4  Explanation  The distinct triplets are  (1,2,3)  (1,2,4)  (1,3,4)  (2,3,4) The elements of the array might not be sorted. Make no assumptions of the same.
__label__Strings Two strings are anagrams of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.   For example , the list of all anagrammatic pairs is  at positions  respectively. Function Description Complete the function sherlockAndAnagrams in the editor below.  It must return an integer that represents the number of anagrammatic pairs of substrings in . sherlockAndAnagrams has the following parameter(s): s: a string .  Input Format The first line contains an integer , the number of queries.  Each of the next  lines contains a string  to analyze.  Constraints     String  contains only lowercase letters  ascii[a-z].  Output Format For each query, return the number of unordered anagrammatic pairs.   Sample Input 0 Sample Output 0 Explanation 0 The list of all anagrammatic pairs is  and  at positions  and  respectively.   No anagrammatic pairs exist in the second query as no character repeats. Sample Input 1 Sample Output 1 Explanation 1 For the first query, we have anagram pairs  and  at positions  and  respectively. For the second query:  There are 6 anagrams of the form  at positions  and .  There are 3 anagrams of the form  at positions  and .  There is 1 anagram of the form  at position . Sample Input 2 Sample Output 2 Explanation 2 There are two anagrammatic pairs of length :  and .  There are three anagrammatic pairs of length :  at positions  respectively.
__label__Graph-Algorithms Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board.  Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible.  But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board . Note  Immovable blocks cannot be moved while cheating.  A block can be moved only in the directions UP, DOWN, LEFT or RIGHT.  Input Format The first line contains four integers N, M, K, Q separated by a single space.  N lines follow.  Each line contains M integers 0 or 1 separated by a single space. If the jth integer is 1, then the block in ith row and jth column is movable. If the jth integer is 0 then the block in ith row and jth column is fixed. Then Q lines follows, each line contains six integers EXi, EYi, SXi, SYi, TXi, TYi separated by a single space. The ith query is the Cao Cao block is in row SXi column SYi, the exit is in TXi, TYi, and the empty position is in row EXi column EYi. It is guaranteed that the blocks in these positions are movable. Find the minimum seconds Acme needs to finish the game. If it is impossible to finish the game, you should answer -1. Constraints N,M ≤ 200  1 ≤ Q ≤ 250  10 ≤ K≤ 15  1 ≤ EXi,  SXi,  TXi≤ N  1 ≤ EYi, SYi,TYi ≤ M Output Format You should output Q lines, i-th line contains an integer which is the answer to i-th query. Sample Input 5 5 12 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1 5 4 3 4 1  Sample Output 20  Explanation Move the block in (1, 4) to (1, 5);  Move the block in (1, 3) to (1, 4);  Move the block in (1, 2) to (1, 3);  Move the block in (2, 2) to (1, 2);  Move the block in (3, 2) to (2, 2);  Move the block in (4, 2) to (3, 2);  Move the block in (4, 3) to (4, 2);  Move the block in (4, 1) to (4, 3) by cheating;  Move the block in (4, 2) to (4, 1).   So, 1 + 1 + 1 + 1 + 1 + 1 + 1 + 12 + 1 = 20.
__label__Dynamic-Programming Shashank loves strings, but he loves palindromic strings the most. He has a list of  strings, , where each string, , consists of lowercase English alphabetic letters. Shashank wants to count the number of ways of choosing non-empty subsequences  such that the following conditions are satisfied:  is a subsequence of string ,  is a subsequence of string ,  is a subsequence of string , , and  is a subsequence of string .  is a palindromic string, where + denotes the string concatenation operator. + You are given  queries where each query consists of some list, . For each query, find and print the number of ways Shashank can choose  non-empty subsequences satisfying the criteria above, modulo , on a new line. Note: Two subsequences consisting of the same characters are considered to be different if their characters came from different indices in the original string. Input Format The first line contains a single integer, , denoting the number of queries. The subsequent lines describe each query in the following format: The first line contains an integer, , denoting the size of the list.  Each line  of the  subsequent lines contains a non-empty string describing . Constraints      over a test case. For  of the maximum score:    over a test case. Output Format For each query, print the number of ways of choosing non-empty subsequences, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 The first two queries are explained below: We can choose the following five subsequences: , , , where  is the first character of  and  is the first character of . , , , where  is the second character of  and  is the second character of .  , , , where  is the first character of  and  is the second character of . , , , where  is the second character of  and  is the first character of .    , ,   Thus, we print the result of  on a new line. We can choose the following five subsequences: , , , where  is the first character of  and  is the first character of . , , , where  is the second character of  and  is the second character of .  , , , where  is the first character of  and  is the second character of . , , , where  is the second character of  and  is the first character of .    , ,   Thus, we print the result of  on a new line. There is no way to choose non-empty subsequences such that their concatenation results in a palindrome, as each string contains unique characters. Thus, we print  on a new line.
__label__Strings You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.     A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).     You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: "PPALLP" Output: True   Example 2: Input: "PPALLL" Output: False
__label__Array Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1
__label__Bit You will be given a list of 32 bit unsigned integers. Flip all the bits ( and ) and print the result as an unsigned integer.   For example, your decimal input .  We're working with 32 bits, so:       Function Description Complete the flippingBits function in the editor below.  It should return the unsigned decimal integer result.   flippingBits has the following parameter(s): n: an integer Input Format The first line of the input contains , the number of queries.  Each of the next  lines contain an integer, , to process.   Constraints    Output Format Output one line per element from the list with the decimal value of the resulting unsigned integer. Sample Input 0 Sample Output 0 Explanation 0             Sample Input 1 Sample Output 1 Explanation 1         Sample Input 2 Sample Output 2 Explanation 2
__label__Hash-Table Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
__label__Array In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition. You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately. Example 1: Input: [1,4], 2 Output: 4 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately.  This poisoned status will last 2 seconds until the end of time point 2.  And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds.  So you finally need to output 4.    Example 2: Input: [1,2], 2 Output: 3 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned.  This poisoned status will last 2 seconds until the end of time point 2.  However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.  Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3.  So you finally need to output 3.    Note:  You may assume the length of given time series array won't exceed 10000. You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.
__label__Two-Pointers Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?
__label__Dynamic-Programming A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000
__label__Mathematics __label__Dynamic-Programming Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.
__label__Mathematics __label__Dynamic-Programming Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:  Choosing any x with 0 < x < N and N % x == 0. Replacing the number N on the chalkboard with N - x.  Also, if a player cannot make a move, they lose the game. Return True if and only if Alice wins the game, assuming both players play optimally.      Example 1: Input: 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves.   Example 2: Input: 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.    Note:  1 <= N <= 1000
__label__Data-Structures This question is designed to help you get a better understanding of basic heap operations.  You will be given queries of  types: " "  - Add an element  to the heap.   " "  - Delete the element  from the heap.   "" - Print the minimum of all the elements in the heap. NOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap. Input Format The first line contains the number of queries, .  Each of the next  lines contains a single query of any one of the  above mentioned types.    Constraints     Output Format For each query of type , print the minimum value on a single line.   Sample Input 5   1 4   1 9   3   2 4   3    Sample Output 4   9   Explanation After the first  queries, the heap contains {}. Printing the minimum gives  as the output. Then, the  query deletes  from the heap, and the  query gives  as the output.
__label__Greedy-Algorithms Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way.   Example 1: Input: A = [4,2,3], K = 1 Output: 5 Explanation: Choose indices (1,) and A becomes [4,-2,3].   Example 2: Input: A = [3,-1,0,2], K = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].   Example 3: Input: A = [2,-3,-1,5,-4], K = 2 Output: 13 Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].      Note:  1 <= A.length <= 10000 1 <= K <= 10000 -100 <= A[i] <= 100
__label__Game-Theory __label__Game-Theory Big Cat and Little Cat love playing games. Today, they decide to play a Game of Stones, the Kitties are Coming edition. The game's rules are as follows:  The game starts with  stones that are randomly divided into  piles.  The cats move in alternating turns, and Little Cat always moves first. During a move, a cat picks a pile having a number of stones  and splits it into any number of non-empty piles in the inclusive range from  to .  The first cat to be unable to make a move (e.g., because all piles contain exactly  stone) loses the game.  Little Cat is curious about the number of ways in which the stones can be initially arranged so that she is guaranteed to win. Two arrangements of stone piles are considered to be different if they contain different sequences of values. For example, arrangements  and  are different. Given the values for , , and , find the number of winning configurations for Little Cat and print it modulo .  Note: Each cat always moves optimally, meaning that they're both playing to win and neither cat will make a move that causes them to lose the game if some other (winning) sequence of moves can be made. Input Format The first line of input contains three space-separated integers,  (the number of stones),  (the number of piles), and  (the maximum number of piles into which a pile can be split during a single move), respectively. Constraints    Output Format Print the number of initial arrangements of piles that will result in Little Cat winning, modulo . Sample Input 4 3 3  Sample Output 3  Explanation There are three possible arrangements:    For any arrangement, Little Cat can pick a pile containing  stones and split it into  piles with  stone each. At this point, the pile configuration will be , so Big Cat won't be able to make any moves and the game ends. We then print the result of  on a new line.
__label__Dynamic-Programming __label__Greedy-Algorithms A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?
__label__Data-Structures __label__Advanced-Data-Structures Consider a sequence, , and a polynomial of degree  defined as . You must perform  queries on the sequence, where each query is one of the following two types: 1 i x: Replace  with . 1 i x 2 l r: Consider the polynomial  and determine whether  is divisible by  over the field , where . In other words, check if there exists a polynomial  with integer coefficients such that each coefficient of  is divisible by . If a valid  exists, print Yes on a new line; otherwise, print No. 2 l r Yes No Given the values of , , , and  queries, perform each query in order. Input Format The first line contains four space-separated integers describing the respective values of  (the length of the sequence),  (a coefficient in ),  (a coefficient in ), and  (the number of queries).  The second line contains  space-separated integers describing .  Each of the  subsequent lines contains three space-separated integers describing a query of either type 1 or type 2. 1 2 Constraints  For query type 1:  and . 1 For query type 2: . 2   Output Format For each query of type 2, print Yes on a new line if  is a divisor of ; otherwise, print No instead. 2 Yes No Sample Input 0 Sample Output 0 Explanation 0 Given  and the initial sequence , we perform the following  queries:  is not a divisor of , so we print No on a new line. No Set  to , so . After the second query, . Because , we print Yes on a new line. Yes
__label__Greedy-Algorithms Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0
__label__Search We define the following: A subarray of array  of length  is a contiguous segment from  through  where . The sum of an array is the sum of its elements. Given an  element array of integers, , and an integer, , determine the maximum value of the sum of any of its subarrays modulo . For example,  Assume  and .  The following table lists all subarrays and their moduli: The maximum modulus is . Function Description Complete the maximumSum function in the editor below.  It should return a long integer that represents the maximum value of . maximumSum has the following parameter(s): a: an array of long integers, the array to analyze m: a long integer, the modulo divisor Input Format The first line contains an integer , the number of queries to perform. The next  pairs of lines are as follows: The first line contains two space-separated integers  and (long), the length of  and the modulo divisor.   The second line contains  space-separated long integers . Constraints        the sum of  over all test cases   Output Format For each query, return the maximum value of  as a long integer. Sample Input 1 5 7 3 3 9 9 5  Sample Output 6  Explanation The subarrays of array  and their respective sums modulo  are ranked in order of length and sum in the following list:  and    and                        The maximum value for  for any subarray is .
__label__Strings Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  In these strings like "heeellooo", we have groups of adjacent letters that are all the same:  "h", "eee", "ll", "ooo". For some given string S, a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is 3 or more. For example, starting with "hello", we could do an extension on the group "o" to get "hellooo", but we cannot get "helloo" since the group "oo" has size less than 3.  Also, we could do another extension like "ll" -> "lllll" to get "helllllooo".  If S = "helllllooo", then the query word "hello" would be stretchy because of these two extension operations: query = "hello" -> "hellooo" -> "helllllooo" = S. Given a list of query words, return the number of words that are stretchy.    Example: Input:  S = "heeellooo" words = ["hello", "hi", "helo"] Output: 1 Explanation:  We can extend "e" and "o" in the word "hello" to get "heeellooo". We can't extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.    Notes:   0 <= len(S) <= 100. 0 <= len(words) <= 100. 0 <= len(words[i]) <= 100. S and all words in words consist only of lowercase letters
__label__Array __label__Binary-Search Implementing the class MajorityChecker, which has the following API:  MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr; int query(int left, int right, int threshold) has arguments such that: 	 0 <= left <= right < arr.length representing a subarray of arr; 2 * threshold > right - left + 1, ie. the threshold is always a strict majority of the length of the subarray    Each query(...) returns the element in arr[left], arr[left+1], ..., arr[right] that occurs at least threshold times, or -1 if no such element exists.   Example: MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // returns 1 majorityChecker.query(0,3,3); // returns -1 majorityChecker.query(2,3,2); // returns 2    Constraints:  1 <= arr.length <= 20000 1 <= arr[i] <= 20000 For each query, 0 <= left <= right < len(arr) For each query, 2 * threshold > right - left + 1 The number of queries is at most 10000
__label__Strings We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules:  1. Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name.  All email addresses are guaranteed to be valid and in the format of "name1@name2.name3". To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.  2. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits. To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with "+**-". Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.   Return the correct "mask" of the information provided.   Example 1: Input: "LeetCode@LeetCode.com" Output: "l*****e@leetcode.com" Explanation: All names are converted to lowercase, and the letters between the              first and last letter of the first name is replaced by 5 asterisks.              Therefore, "leetcode" -> "l*****e".  Example 2: Input: "AB@qq.com" Output: "a*****b@qq.com" Explanation: There must be 5 asterisks between the first and last letter               of the first name "ab". Therefore, "ab" -> "a*****b".  Example 3: Input: "1(234)567-890" Output: "***-***-7890" Explanation: 10 digits in the phone number, which means all digits make up the local number.  Example 4: Input: "86-(10)12345678" Output: "+**-***-***-5678" Explanation: 12 digits, 2 digits for country code and 10 digits for local number.   Notes:  S.length <= 40. Emails have length at least 8. Phone numbers have length at least 10.
__label__Array __label__Hash-Table Given an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2.            Example 1: Input: [3,1,3,6] Output: false   Example 2: Input: [2,1,2,6] Output: false   Example 3: Input: [4,-2,2,-4] Output: true Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].   Example 4: Input: [1,2,4,16,8,4] Output: false    Note:  0 <= A.length <= 30000 A.length is even -100000 <= A[i] <= 100000
__label__Strings Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd"
__label__Data-Structures __label__Advanced-Data-Structures White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques?  There are  types of query operations that can be performed on a tree: 1 u x: Assign  as the value of node . 1 u x 2 u v: Print the sum of the node values in the unique path from node  to node . 2 u v Given a tree with  nodes where each node's value is initially , execute  queries.  Input Format The first line contains  space-separated integers,  and , respectively.  The  subsequent lines each contain  space-separated integers describing an undirected edge in the tree.  Each of the  subsequent lines contains a query you must execute. Constraints   It is guaranteed that the input describes a connected tree with  nodes.  Nodes are enumerated with -based indexing. Output Format For each type- query, print its integer result on a new line. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 3  Explanation  After the first  queries, the value of node  and the value of node . The third query requires us to print the sum of the node values in the path from nodes  to , which is . Thus, we print  on a new line.
__label__Mathematics You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation:  The five points are show in the figure below. The red triangle is the largest.   Notes:   3 <= points.length <= 50. No points will be duplicated.  -50 <= points[i][j] <= 50. Answers within 10^-6 of the true value will be accepted as correct.
__label__Dynamic-Programming A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.  Longest common subsequence (LCS) of 2 sequences is a subsequence, with maximal length, which is common to both the sequences.   Given two sequences of integers,  and , find the longest common subsequence and print it as a line of space-separated integers. If there are multiple common subsequences with the same maximum length, print any one of them. In case multiple solutions exist, print any of them. It is guaranteed that at least one non-empty common subsequence will exist.     Recommended References  This Youtube video tutorial explains the problem and its solution quite well.     Function Description  Complete the longestCommonSubsequence function in the editor below.  It should return an integer array of a longest common subsequence.   longestCommonSubsequence has the following parameter(s):   a: an array of integers   b: an array of integers Input Format The first line contains two space separated integers  and , the sizes of sequences  and .  The next line contains  space-separated integers .  The next line contains  space-separated integers . Constraints          Constraints     Output Format Print the longest common subsequence as a series of space-separated integers on one line. In case of multiple valid answers, print any one of them. Sample Input 5 6 1 2 3 4 1 3 4 1 2 1 3  Sample Output 1 2 3  Explanation There is no common subsequence with length larger than 3. And "1 2 3",  "1 2 1", "3 4 1" are all correct answers.   Tested by Khongor
__label__Greedy-Algorithms In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.   Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2].   Example 2: Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].   Example 3: Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]      Note:  1 <= A.length <= 30000 1 <= K <= A.length
__label__Data-Structures __label__Advanced-Data-Structures Consider a lowercase English alphabetic letter character denoted by . A shift operation on some  turns it into the next letter in the alphabet. For example, and , ,  .  Given a zero-indexed string, , of  lowercase letters, perform  queries on  where each query takes one of the following two forms: 1 i j t: All letters in the inclusive range from  to  are shifted  times.   1 i j t 2 i j: Consider all indices in the inclusive range from  to . Find the number of non-empty subsets of characters,  where , such that characters  can be rearranged to form a palindrome. Then print this number modulo  on a new line. Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. 2 i j Note Two palindromic subsets are considered to be different if their component characters came from different indices in the original string. Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a string of  lowercase English alphabetic letters (i.e., a through z) denoting .  Each of the  subsequent lines describes a query in one of the two formats defined above. a z Constraints      for each query.  for each query of type . Subtasks For  of the maximum score:      For another  of the maximum score:  All queries will be of type .  Output Format For each query of type  (i.e., 2 i j), print the number of non-empty subsets of characters satisfying the conditions given above, modulo , on a new line. 2 i j Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: 2 0 2:  and we want to find the palindromic subsets of substring . There are five such subsets that form palindromic strings (, , , , and ), so we print the result of  on a new line 2 0 2 2 0 0:  and we want to find the palindromic subsets of substring . Because this substring only has one letter, we only have one subset forming a palindromic string (). We then print the result of  on a new line.  2 0 0 2 1 2:   and we want to find the palindromic subsets of substring . There are two such subsets that form palindromic strings ( and ), so we print the result of  on a new line.   2 1 2 1 0 1 1:  and we need to perform  shift operations on each character from index  to index . After performing these shifts, .   1 0 1 1 2 0 2:  and we want to find the palindromic subsets of substring . There are three valid subsets that form palindromic strings (, , and ), so we print the result of  on a new line. 2 0 2
__label__Dynamic-Programming __label__Mathematics Given an array of  integers (), find all possible increasing subsequences of maximum length, . Then print the lexicographically  longest increasing subsequence as a single line of space-separated integers; if there are less than  subsequences of length , print . Two subsequences  and  are considered to be different if there exists at least one  such that . Input Format The first line contains  space-separated integers,  and , respectively.  The second line consists of  space-separated integers denoting  respectively. Constraints      Scoring  for  of the test data.    for  of the test data. Output Format Print a single line of  space-separated integers denoting the lexicographically  longest increasing subsequence; if there are less than  subsequences of length , print . Note:  is the length of longest increasing subsequence in the array. Sample Input 0 5 3 1 3 1 2 5  Sample Output 0 1 3 5  Sample Input 1 5 2 1 3 2 4 5  Sample Output 1 1 3 4 5      Explanation Sample Case 0:  The longest possible increasing subsequences in lexicographical order are:      Notice that the first and second subsequences appear the same; they are actually both different because the  in the first subsequence comes from array element , and the  in the second subsequence comes from array element . Because , we print the  one () as a single line of space-separated integers. Sample Case 1:  The longest possible increasing subsequences in lexicographical order are:      Because , we print the  one () as a single line of space-separated integers.
__label__Game-Theory __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Andy and Lily love playing games with numbers and trees. Today they have a  tree consisting of  nodes and  edges. Each edge  has an integer weight, . Before the game starts, Andy chooses an unordered pair of distinct nodes, , and uses all the edge weights present on the unique path from node  to node  to construct a list of numbers. For example, in the diagram below, Andy constructs a list from the edge weights along the path :  Andy then uses this list to play the following game with Lily: Two players move in alternating turns, and both players play optimally (meaning they will not make a move that causes them to lose the game if some better, winning move exists). Andy always starts the game by removing a single integer from the list. During each subsequent move, the current player removes an integer less than or equal to the integer removed in the last move. The first player to be unable to move loses the game. For example, if the list of integers is  and Andy starts the game by removing , the list becomes . Then, in Lily's move, she must remove a remaining integer less than or equal to  (i.e., , , , or ). The two friends decide to play  games, where each game is in the form of a tree. For each game, calculate the number of unordered pairs of nodes that Andy can choose to ensure he always wins the game. Input Format The first line contains a single integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of nodes in the tree. Each line  of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for the  edge connecting nodes  and  with weight . Constraints         Sum of  over all games does not exceed  Scoring  For  of score, the sum of  over all games does not exceed . For  of score, the sum of  over all games does not exceed . Output Format For each game, print an integer on a new line describing the number of unordered pairs Andy can choose to construct a list that allows him to win the game. Sample Input 0 Sample Output 0 Explanation 0 Andy and Lily play the following  games: The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line.
__label__Dynamic-Programming The King of Byteland wants to grow his territory by conquering  other countries. To prepare his  heirs for the future, he decides they must work together to capture each country.  The King has an army, , of  battalions; the  battalion has  soldiers. For each battle, the heirs get a detachment of soldiers to share but will fight amongst themselves and lose the battle if they don't each command the same number of soldiers (i.e.: the detachment must be divisible by ). If given a detachment of size , the heirs will fight alone without any help. The battalions chosen for battle must be selected in the following way: A subsequence of  battalions must be selected (from the  battalions in army ).  The  battle will have a squad of soldiers from the  selected battalion such that its size is divisible by .  The soldiers within a battalion have unique strengths. For a battalion of size , the detachment of soldiers  is different from the detachment of soldiers  The King tasks you with finding the number of ways of selecting  detachments of battalions to capture  countries using the criterion above. As this number may be quite large, print the answer modulo . Input Format The first line contains two space-separated integers,  (the number of battalions in the King's army) and  (the number of countries to conquer), respectively. The second line contains  space-separated integers describing the King's army, , where the  integer denotes the number of soldiers in the  battalion ().  Constraints     holds for test cases worth at least  of the problem's score. Output Format Print the number of ways of selecting the  detachments of battalions modulo . Sample Input 3 2 3 4 5  Sample Output 20  Explanation First, we must find the ways of selecting  of the army's  battalions; then we must find all the ways of selecting detachments for each choice of battalion.  Battalions :   has  soldiers, so the only option is an empty detachment ().   has  soldiers, giving us  detachment options ( and ).  So for this subset of battalions, we get  possible detachments. Battalions :   has  soldiers, so the only option is an empty detachment ().   has  soldiers, giving us  detachment options (, , , , , ). So for this subset of battalions, we get  possible detachments. Battalions :   has  soldiers, giving us  detachment options ( and ).   has  soldiers, giving us  detachment options (, , , , , ).  So for this subset of battalions, we get  possible detachments. In total, we have  ways to choose detachments, so we print , which is .
__label__Array In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.  Example 1: Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.  Example 2: Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.  Note:  1 <= seats.length <= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.
__label__Hash-Table __label__Mathematics Write an algorithm to determine if a number is "happy". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example:  Input: 19 Output: true Explanation:  12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1
__label__Array Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
__label__Binary-Search Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9
__label__Dynamic-Programming Given an unsorted array of integers, find the number of longest increasing subsequence.  Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].   Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.   Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
__label__Hash-Table There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules:  If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.) We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0. Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)        Example 1: Input: cells = [0,1,0,1,1,0,0,1], N = 7 Output: [0,0,1,1,0,0,0,0] Explanation:  The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0]    Example 2: Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000 Output: [0,0,1,1,1,1,1,0]    Note:  cells.length == 8 cells[i] is in {0, 1} 1 <= N <= 10^9
__label__Mathematics __label__Bit Given an integer , find each  such that:   where  denotes the bitwise XOR operator. Print the number of 's satisfying the criteria. For example, if , there are four values:      .   Function Description Complete the sumXor function in the editor below.  It should return the number of values determined, as an integer.   sumXor has the following parameter(s):  - n: an integer   Input Format A single integer, . Constraints  Subtasks  for  of the maximum score. Output Format Print the total number of integers  satisfying the criteria. Sample Input 0 5  Sample Output 0 2  Explanation 0 For , the  values  and  satisfy the conditions:   Sample Input 1 10  Sample Output 1 4  Explanation 1 For , the  values , , , and  satisfy the conditions:
__label__Tree __label__Data-Structures Kitty has a tree, , consisting of  nodes where each node is uniquely labeled from  to . Her friend Alex gave her  sets, where each set contains  distinct nodes. Kitty needs to calculate the following expression on each set:   where:  denotes an unordered pair of nodes belonging to the set.  denotes the number of edges on the unique path between nodes  and . Given  and  sets of  distinct nodes, can you help her calculate the expression for each set? For each set of nodes, print the value of the expression modulo  on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes in tree ) and  (the number of sets).  Each of the  subsequent lines contains two space-separated integers,  and , describing an undirected edge between nodes  and .  The  subsequent lines define each set over two lines in the following format: The first line contains an integer, , denoting the size of the set.  The second line contains  space-separated integers describing the set's elements. Constraints        The sum of  over all  does not exceed .  All elements in each set are distinct.  Subtasks  for  of the maximum score.   for  of the maximum score.  for  of the maximum score. Output Format Print  lines of output where each line  contains the expression for the  query, modulo . Sample Input 0 Sample Output 0 Explanation 0 Tree  looks like this:  We perform the following calculations for  sets: Set : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:   Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line: Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:
__label__Array Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.   Example 1: Input: [1,0,2,3,0,4,5,0] Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]  Example 2: Input: [1,2,3] Output: null Explanation: After calling your function, the input array is modified to: [1,2,3]    Note:  1 <= arr.length <= 10000 0 <= arr[i] <= 9
__label__Greedy-Algorithms Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.
__label__Tree __label__Depth-first-Search Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B. (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)   Example 1:  Input: [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation:  We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.    Note:  The number of nodes in the tree is between 2 and 5000. Each node will have value between 0 and 100000.
__label__Tree __label__Depth-first-Search Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.
__label__Depth-first-Search Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.  Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1: Input: [1,1,2,2,2] Output: true  Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.   Example 2: Input: [3,3,3,3,4] Output: false  Explanation: You cannot find a way to form a square with all the matchsticks.   Note:  The length sum of the given matchsticks is in the range of 0 to 10^9. The length of the given matchstick array will not exceed 15.
__label__Dynamic-Programming Sophia has discovered several alien languages. Suprisingly, all of these languages have an alphabet, and each of them may contain thousands of characters! Also, all the words in a language have the same number of characters in it. However, the aliens like their words to be aesthetically pleasing, which for them means that for the  letter of an -letter alphabet (letters are indexed ): if , then the  letter may be the last letter of a word, or it may be immediately followed by any letter, including itself. if , then the  letter may be the last letter of a word, or it may be immediately followed by any letter, including itself. if , then the  letter can not be the last letter of a word and also can only be immediately followed by  letter if and only if .   if , then the  letter can not be the last letter of a word and also can only be immediately followed by  letter if and only if .   Sophia wants to know how many different words exist in this language. Since the result may be large, she wants to know this number, modulo . Input Format The first line contains , the number of test cases. The first line is followed by  lines, each line denoting a test case. Each test case will have two space-separated integers ,  which denote the number of letters in the language and the length of words in this language respectively. Constraints       Output Format For each test case, output the number of possible words modulo . Sample Input 3 1 3 2 3 3 2  Sample Output 1 3 6  Explanation For the first test case, there's one letter ('a') and all the words consist of  letters. There's only one possibility which is "aaa".   For the second test case, there are two letters ('a' and 'b') and all the words are of  letters. The possible strings are "abb", "bab", & "bbb". The words can end only with 'b' because  and for 'a', it's . "aab" is not allowed because 'a' can not be followed immediately by 'a'. For a word of length 4 and alphabet of size 2, "abab" would be allowed. For the third test case, there are three letters ('a', 'b' and 'c') and all of the words are  letters. The words can only end with 'b' or 'c'. The possible words are "ab", "ac", "bb", "cc", "bc", "cb".
__label__Dynamic-Programming You are given a grid having N rows and M columns. A grid square can either be blocked or empty. Blocked squares are represented by a '#' and empty squares are represented by '.'. Find the number of ways to tile the grid using L shaped bricks. A L brick has one side of length three units while other of length 2 units. All empty squares in the grid should be covered by exactly one of the L shaped tiles, and blocked squares should not be covered by any tile. The bricks can be used in any orientation (they can be rotated or flipped). Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains N and M on the first line, followed by N lines describing each row of the grid. Constraints 1 <= T <= 50  1 <= N <= 20  1 <= M <= 8  Each grid square will be either '.' or '#'. Output Format Output the number of ways to tile the grid. Output each answer modulo 1000000007. Sample Input 3   2 4   ....   ....   3 3   ...   .#.   ...   2 2   ##   ##  Sample Output 2   4   1  Explanation NOTE:  If all points in the grid are blocked the number of ways is 1, as in the last sample testcase.
__label__Strings James found a love letter that his friend Harry has written to his girlfriend. James is a prankster, so he decides to meddle with the letter. He changes all the words in the letter into palindromes.    To do this, he follows two rules:   He can only reduce the value of a letter by , i.e. he can change d to c, but he cannot change c to d or d to b.   The letter a may not be reduced any further.   Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations required to convert a given string into a palindrome. For example, given the string , the following two operations are performed:  cde → cdd → cdc.   Function Description  Complete the theLoveLetterMystery function in the editor below.  It should return the integer representing the minimum number of operations needed to make the string a palindrome.   theLoveLetterMystery has the following parameter(s):   s: a string Input Format The first line contains an integer , the number of queries.  The next  lines will each contain a string . Constraints    | s |   All strings are composed of lower case English letters, *ascii[a-z], with no spaces. Output Format A single line containing the minimum number of operations corresponding to each test case. Sample Input 4 abc abcba abcd cba  Sample Output 2 0 4 2  Explanation For the first test case, abc → abb → aba. For the second test case, abcba is already a palindromic string. For the third test case, abcd → abcc → abcb → abca → abba. For the fourth test case, cba → bba → aba.
__label__Array __label__Hash-Table Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();
__label__Data-Structures __label__Advanced-Data-Structures A Sumo wrestling championship is scheduled to be held this winter in the HackerCity where N wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K,  (i.e) wrestler A and wrestler B can fight if and only if |height(A)-height(B)|<=K.    Given an array H[], where H[i] represents the height of the ith fighter, for a given l, r where 0 <= l <= r < N, can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game? 0 <= l <= r < N Input Format  The first line contains an integer N and K  separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K.  The second line contains N integers separated by a single space, representing their heights H[0] H[1] ... H[N - 1].  The third line contains Q, the number of queries. This is followed by Q lines each having two integers l and r separated by a space.   Output Format  For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that K.   Constraints  1 <= N <= 100000  0 <= K <= 109  0 <= H[i] <= 109  1 <= Q <= 100000  0 <= l <= r < N   Sample Input Sample Output  Explanation  Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1.  Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| <=2. Hence output is 3.  Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.   Timelimits Timelimits are given here
__label__Data-Structures __label__Advanced-Data-Structures Natural numbers from 1 to N have been placed in an increasing order over some helix ( a circular structure ). When the helix starts rotating, it is easy to find out  The position of a given number The number located at a given position.  The helix has numbers arranged in the following fashion:   [1, 2, 3, ..., N]  Due to some malfunction, the helix has started rotating in a weird manner. Right now, every possible contiguous interval can be rotated, and hence, locating a particular number or identifying the number at a given position is almost impossible. For example, if at some particular instant, the integer list is like this: [1, 2, 3, 4, 5, ..., N]  rotating the interval [5...N] will leave the list like this: [1, 2, 3, 4, N, N - 1, N - 2, ..., 5]  We need a software to handle this. Can you help us? Input Format  The first line of the input consists of two space separated integers, N, Q. N signifies that initially our list contains numbers from 1 to N, placed in an increasing order. Q lines follow and contain input in one of the following formats:   1 A B  indicating that the helix rotated circularly in the interval [A..B] ( both inclusive); 2 A  indicating that we are interested in knowing the current position of the number A   3 A  indicating that we are interested in knowing the number at position A.   Output Format  For each line in the input of the form 2 A  2 A output a line saying  element A is at position x  where A is the number we are interested in and x is its current position. For each line of the form 3 A 3 A output a line saying  element at position A is x  where A is the position we are interested in and x is the integer located at this position.  Constraints  1 ≤ N, Q ≤ 105  positions are 1-indexed.    Sample Input 5 10 1 1 3 2 3 3 3 1 3 5 1 2 4 3 1 3 5 2 4 1 5 5 2 2  Sample Output element 3 is at position 1 element at position 3 is 1 element at position 1 is 3 element at position 5 is 1 element 4 is at position 2 element 2 is at position 4  Explanation Initially elements are placed like this: [1, 2, 3, 4, 5]  after the first rotation, they are placed like this: [3, 2, 1, 4, 5]  and that's how we get the first 2 results (first 2 lines in the output). After second rotation, they are placed like this: [3, 2, 5, 4, 1]  and third one does this: [3, 4, 5, 2, 1]  In the last rotation (1 5 5), it's easy to see that output matches the initial positions of the elements. Last rotation doesn't change the positions of the elements.
__label__Array Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]  Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]  Notes:  1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1
__label__Dynamic-Programming Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.    Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? Credits: Special thanks to @pbrother for adding this problem and creating all test cases.
__label__Array __label__Two-Pointers Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:  The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output: [1,2,2,3,5,6]
__label__Binary-Search Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note:  1 <= w.length <= 10000 1 <= w[i] <= 10^5 pickIndex will be called at most 10000 times.  Example 1: Input:  ["Solution","pickIndex"] [[[1]],[]] Output: [null,0]   Example 2: Input:  ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Dynamic-Programming A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between  and  inclusive, are lucky? For example,  and .  Each number is tested below:           digit   digit   squares value   sum     squares sum  20      2       4,0     4 21      3       4,1     5 22      4       4,4     8 23      5       4,9     13 24      6       4,16    20 25      7       4,25    29  We see that two numbers, ,  and  are lucky. Note: These lucky numbers are not to be confused with Lucky Numbers Function Description  Complete the luckyNumbers function in the editor below.  It should return an integer that represents the number of lucky numbers in the given range.   luckyNumbers has the following parameter(s):   a: an integer, the lower range bound   b: an integer, the higher range bound   Input Format The first line contains the number of test cases .  Each of the next  lines contains two space-separated integers,  and . Constraints     Output Format Output T lines, one for each test case in the order given. Sample Input 2   1 20   120 130  Sample Output 4   1  Explanation For the first case, the lucky numbers are , and .  For the second case, the only lucky number is .
__label__Two-Pointers Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5
__label__Game-Theory __label__Game-Theory Two players are playing a game on a  chessboard. The rules of the game are as follows: The game starts with a single coin located at some  coordinates. The coordinates of the upper left cell are , and of the lower right cell are . The game starts with a single coin located at some  coordinates. The coordinates of the upper left cell are , and of the lower right cell are . In each move, a player must move the coin from cell  to one of the following locations:        Note: The coin must remain inside the confines of the board. In each move, a player must move the coin from cell  to one of the following locations:        Note: The coin must remain inside the confines of the board. Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game. Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game. The figure below shows all four possible moves using an  board for illustration:  Given the initial coordinates of the players' coins, assuming optimal play, determine which player will win the game.  Function Description Complete the chessboardGame function in the editor below.  It should return a string, either First or Second. First Second chessboardGame has the following parameter(s):   x: an integer that represents the starting column position    y: an integer that represents the starting row position   Input Format The first line contains an integer , the number of test cases.  Each of the next  lines contains  space-separated integers  and . Constraints   Output Format On a new line for each test case, print  if the first player is the winner.  Otherwise, print . Sample Input 3 5 2 5 3 8 8  Sample Output Second First First  Explanation In the first case, player1 starts at the red square and can move to any of the blue squares.  Regardless of which one is chosen, the player 2 can move to one of the green squares to win the game.  In the second case, player 1 starts at the red square and can move to any of the blue squares or the purple one.  Moving to the purple one limits player 2 to the yellow square.  From the yellow square, player 1 moves to the green square and wins.
__label__Data-Structures Meera teaches a class of  students, and every day in her classroom is an adventure. Today is drawing day! The students are sitting around a round table, and they are numbered from  to  in the clockwise direction. This means that the students are numbered , and students  and  are sitting next to each other. After letting the students draw for a certain period of time, Meera starts collecting their work to ensure she has time to review all the drawings before the end of the day. However, some of her students aren't finished drawing! Each student  needs  extra minutes to complete their drawing.  Meera collects the drawings sequentially in the clockwise direction, starting with student ID , and it takes her exactly  minute to review each drawing. This means that student  gets  extra minutes to complete their drawing, student  gets  extra minute, student  gets  extra minutes, and so on. Note that Meera will still spend  minute for each student even if the drawing isn't ready.  Given the values of , help Meera choose the best possible  to start collecting drawings from, such that the number of students able to complete their drawings is maximal. Then print  on a new line. If there are multiple such IDs, select the smallest one. Input Format The first line contains a single positive integer, , denoting the number of students in the class.  The second line contains  space-separated integers describing the respective amounts of time that each student needs to finish their drawings (i.e., ). Constraints   Subtasks  for  of the maximum score. Output Format Print an integer denoting the ID number, , where Meera should start collecting the drawings such that a maximal number of students can complete their drawings. If there are multiple such IDs, select the smallest one.
__label__Dynamic-Programming __label__Graph-Algorithms You have N soldiers numbered from 1 to N. Each of your soldiers is either a liar or a truthful person. You have M sets of information about them. Each set of information tells you the number of liars among a certain range of your soldiers. Let L be the total number of your liar soldiers. Since you can't find the exact value of L, you want to find the minimum and maximum value of L. Input Format  The first line of the input contains two integers N and M.   Each of next M lines contains three integers:  A B C where the set of soldiers numbered as {A, A+1, A+2, ..., B}, exactly C of them are liars. (1 <= Ai <= Bi <= n) and (0 <= Ci <= Bi-Ai). Note: N and M are not more than 101, and it is guaranteed the given informations is satisfiable. Output Format  Print two integers Lmin and Lmax to the output. Sample Input #1  3 2 1 2 1 2 3 1  Sample Output #1 1 2  Sample Input #2  20 11 3 8 4 1 9 6 1 13 9 5 11 5 4 19 12 8 13 5 4 8 4 7 9 2 10 13 3 7 16 7 14 19 4  Sample Output #2 13 14  Explanation  In the first input, the initial line is "3 2", i.e. that there are 3 soldiers and we have 2 sets of information. The next line says there is one liar in the set of soldiers {1, 2}. The final line says there is one liar in the set {2,3}. There are two possibilities for this scenario: Soldiers number 1 and 3 are liars or soldier number 2 is liar.  So the minimum number of liars is 1 and maximum number of liars is 2. Hence the answer, 1 2.
__label__Mathematics Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.
__label__Data-Structures This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson. If you're new to linked lists, this is a great exercise for learning about them. Given a pointer to the head node of a linked list, print its elements in order, one element per line. If the head pointer is null (indicating the list is empty), don’t print anything. Input Format The first line of input contains , the number of elements in the linked list.  The next  lines contain one element each, which are the elements of the linked list. Note: Do not read any input from stdin/console. Complete the printLinkedList function in the editor below. Constraints   , where  is the  element of the linked list. Output Format Print the integer data for each element of the linked list to stdout/console (e.g.: using printf, cout, etc.). There should be one element per line. Sample Input 2 16 13  Sample Output 16 13  Explanation There are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each in a new line.
__label__Dynamic-Programming You have a pile of  stones that you want to split into multiple piles, as well as a set, , of  distinct integers. We define a move as follows: First, choose a pile of stones. Let's say that the chosen pile contains  stones.  Next, look for some  such that  and  is divisible by  (i.e.,  is a factor of ); if such an  exists, you can split the pile into  equal smaller piles. You are given  queries where each query consists of  and . For each query, calculate the maximum possible number of moves you can perform and print it on a new line. Input Format The first line contains an integer, , denoting the number of queries. The  subsequent lines describe each query in the following format: The first line contains two space-separated integers describing the respective values of  (the size of the initial pile in the query) and  (the size of the set in the query). The second line contains  distinct space-separated integers describing the values in set . Constraints      Subtask  for  of the maximum score. Output Format For each query, calculate the maximum possible number of moves you can perform and print it on a new line. Sample Input 0 Sample Output 0 Explanation 0 Initially there is a pile with  stones:   You can make a maximal  moves, described below: Select  from  and split it into  equal piles of size  to get:    Select  from  and split a pile of size  into  equal piles of size  to get:   Select  from  and split a pile of size  into  equal piles of size  to get:   Repeat the previous move again on another pile of size  to get:   Repeat the previous move again on another pile of size  to get:   Repeat the move again on the last pile of size  to get:   As there are no more available moves, we print  (the number of moves) on a new line.
__label__Game-Theory Nim is a famous game in which two players take turns removing items from  distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player removes the last item from the last non-empty pile. John and Kate modified Nim by adding the following rule, which they call a Zero-Move: For each non-empty pile, either player can remove  items from that pile and have it count as their move; however, this move can only be performed once per pile by either player. For example, let's say pile  initially has  items in it. If John decides to use a Zero-Move on pile , then neither John nor Kate can perform another Zero-Move on pile ; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet. John and Kate play  games of Zero-Move Nim. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print W on a new line if John can win; otherwise, print L instead. W L Input Format The first line contains an integer, , denoting the number of games. The  subsequent lines describe each game over two lines: The first line contains an integer, , denoting the number of heaps. The second line contains  space-separated integers describing .  Constraints       Subtasks  For  of the test cases,   For  of the test cases,  Output Format For each game, print W on a new line if John will win; otherwise, print L instead. W L Sample Input 0 Sample Output 0 Explanation 0 John and Kate play the following  games: We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. W John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. L
__label__Dynamic-Programming Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
__label__Depth-first-Search Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].
__label__Mathematics Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.
__label__Mathematics Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.
__label__Array For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1]. Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.      Example 1: Input: A = [1,2,0,0], K = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234   Example 2: Input: A = [2,7,4], K = 181 Output: [4,5,5] Explanation: 274 + 181 = 455   Example 3: Input: A = [2,1,5], K = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021   Example 4: Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1 Output: [1,0,0,0,0,0,0,0,0,0,0] Explanation: 9999999999 + 1 = 10000000000    Note：  1 <= A.length <= 10000 0 <= A[i] <= 9 0 <= K <= 10000 If A.length > 1, then A[0] != 0
__label__Strings Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.
__label__Tree __label__Data-Structures Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit.  If they are on the left side of the tree, they will be a 0 (zero).  If on the right, they'll be a 1 (one).  Only the leaves will contain a letter and its frequency count.  All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters. For instance, consider the string ABRACADABRA.  There are a total of  characters in the string.  This number should match the count in the ultimately determined root of the tree.  Our frequencies are  and .  The two smallest frequencies are for  and , both equal to , so we'll create a tree with them.  The root node will contain the sum of the counts of its descendants, in this case .  The left node will be the first character encountered, , and the right will contain .  Next we have  items with a character count of :  the tree we just created, the character  and the character .  The tree came first, so it will go on the left of our new root node.   will go on the right.  Repeat until the tree is complete, then fill in the 's and 's for the edges.  The finished graph looks like:    Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL).  We can determine that our values for characters are:   A - 0 B - 111 C - 1100 D - 1101 R - 10  Our Huffman encoded string is: A B    R  A C     A D     A B    R  A 0 111 10 0 1100 0 1101 0 111 10 0 or 01111001100011010111100  To avoid ambiguity, Huffman encoding is a prefix free encoding technique.  No codeword appears as a prefix of any other codeword.   To decode the encoded string, follow the zeros and ones to a leaf and return the character there.   You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string. Function Description Complete the function decode_huff in the editor below.  It must return the decoded string. decode_huff has the following parameters:   root: a reference to the root node of the Huffman tree s: a Huffman encoded string Input Format There is one line of input containing the plain string, .  Background code creates the Huffman tree then passes the head node and the encoded string to the function. Constraints  Output Format Output the decoded string on a single line. Sample Input   s="1001011"  Sample Output ABACA  Explanation S="1001011" Processing the string from left to right. S[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[1]='0' : we move to the left child.  S[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string. We move back to the root.  S[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[4]='0' : we move to the left child.  S[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string. We move back to the root.   S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  Decoded String = "ABACA"
__label__Graph-Algorithms During the Steam Summer Sale, Jim's  friends have purchased  games, which are numbered from  to . The games are multiplayer. Jim has invited his friends to his basement where they will play by making a LAN-Party.  Each friend has already decided the game he would like to play for the rest of the day. So there will be a group of friends who will play the same game together. But then, they face a problem: Currently, none of the friends' PCs are connected. So they have to be connected using the available  wires. Jim decides to connect friends  and  with the th wire one by one. So he starts with wire 1, then with wire 2 and so on.  A group can start playing their game, only if all the members are connected (if not directly, then there must exist a path connecting them). They want to start playing as soon as possible.  For each game, find out the wire after adding which the group can start playing. It is also possible that a group will never get connected. In such a case, this group starts crying and you should display -1. -1 Input Format On the first line there will be ,  and  each separated by a single space. On the second line we will give you  integers separated by a single space: The -th integer denotes the game friend  wants to play (all between  and ). The next  lines will denote  wires: ith line denotes ith wire and is denoted by  and  pairs each separated by a single space.  Constraints  For each game , the number of players playing  will be positive.    Note Each game is chosen by at least one player. If a group consists of only one member, then print 0, since this lucky (?) lone player can start right away! 0 Output Format Print on the th line the answer for the th game.  Sample Input 5 2 4 1 2 2 2 1 1 2  2 3 1 5 4 5   Sample Output 3 4  Explanation The group with the game 1 can play after the 3rd wire is added. The group with game 2 can play only after the 4th wire has been added because after adding the 4th wire, a path between (2,3) (3,4) and (2,4) gets created.
__label__Hash-Table __label__Mathematics Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |        o |     o |  o   +-------------> 0  1  2  3  4  Example 2: Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o |     o        o |        o |  o        o +-------------------> 0  1  2  3  4  5  6  NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Binary-Search __label__Dynamic-Programming table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
__label__Strings Under a grammar given below, strings can represent a set of lowercase words.  Let's use R(expr) to denote the set of words the expression represents. Grammar can best be understood through simple examples:  Single letters represent a singleton set containing that word. 	 R("a") = {"a"} R("w") = {"w"}   When we take a comma delimited list of 2 or more expressions, we take the union of possibilities. 	 R("{a,b,c}") = {"a","b","c"} R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains each word at most once)   When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. 	 R("{a,b}{c,d}") = {"ac","ad","bc","bd"} R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}    Formally, the 3 rules for our grammar:  For every lowercase letter x, we have R(x) = {x} For expressions e_1, e_2, ... , e_k with k >= 2, we have R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ... For expressions e_1 and e_2, we have R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}, where + denotes concatenation, and × denotes the cartesian product.  Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.    Example 1: Input: "{a,b}{c,{d,e}}" Output: ["ac","ad","ae","bc","bd","be"]   Example 2: Input: "{{a,z},a{b,c},{ab,z}}" Output: ["a","ab","ac","z"] Explanation: Each distinct word is written only once in the final answer.    Constraints:  1 <= expression.length <= 50 expression[i] consists of '{', '}', ','or lowercase English letters. The given expression represents a set of words based on the grammar given in the description.
__label__Hash-Table Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.
__label__Tree __label__Data-Structures Complete the postOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your postOrder function. Constraints 1 Nodes in the tree   500 Output Format Print the tree's postorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4  Sample Output 4 3 6 5 2 1
__label__Hash-Table __label__Tree Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Array Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000
__label__Strings Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.
__label__Dynamic-Programming Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days. Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy? For example, if you know that prices for the next two days are , you should buy one share day one, and sell it day two for a profit of .  If they are instead , no profit can be made so you don't buy or sell stock those days.   Function Description  Complete the stockmax function in the editor below.  It must return an integer that represents the maximum profit achievable.   stockmax has the following parameter(s):   prices: an array of integers that represent predicted daily stock prices     Input Format The first line contains the number of test cases . Each of the next  pairs of lines contain:  - The first line contains an integer , the number of predicted prices for WOT.  - The next line contains n space-separated integers , each a predicted stock price for day .   Constraints     Output Format Output  lines, each containing the maximum profit which can be obtained for the corresponding test case. Sample Input 3 3 5 3 2 3 1 2 100 4 1 3 1 2  Sample Output 0 197 3  Explanation For the first case, you cannot obtain any profit because the share price never rises.  For the second case, you can buy one share on the first two days and sell both of them on the third day.  For the third case, you can buy one share on day 1, sell one on day 2, buy one share on day 3, and sell one share on day 4.
__label__Mathematics A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.   Example 1: Input: [[1,1],[2,3],[3,2]] Output: true   Example 2: Input: [[1,1],[2,2],[3,3]] Output: false    Note:  points.length == 3 points[i].length == 2 0 <= points[i][j] <= 100
__label__Tree Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.
__label__Tree __label__Depth-first-Search Given a binary tree struct Node {   int val;   Node *left;   Node *right;   Node *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.   Example:  Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":null,"next":null,"right":{"$id":"6","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}  Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":null,"right":null,"val":7},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"6","left":null,"next":null,"right":{"$ref":"5"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"6"},"val":1}  Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.    Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__Binary-Search __label__Tree Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
__label__Data-Structures __label__Advanced-Data-Structures White Falcon has a tree with  nodes. Each node contains a linear function. Let's denote by  the linear function contained in the node .   Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   White Falcon also has  queries. They are in the following format:       . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .     . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .    . Calculate  modulo     . Calculate  modulo  Input Format The first line contains , the number of nodes. The following  lines each contain two integers  and  that describe the function .   Following  lines contain edges of the tree.  The next line contains , the number of queries. Each subsequent line contains one of the queries described above. Output Format For every query of the second kind, print one line containing an integer, the answer for that query.   Constraints   (Number of nodes)   (Number of queries)   Sample Input 2 1 1 1 2 1 2 2 1 2 2 1 1 2 1 2 1  Sample Output 3  Explanation
__label__Game-Theory __label__Game-Theory Alice and Bob are playing a game, defined below: There is an undirected tree graph with  nodes that has the following properties:  Each node has  golden coins.  Node  is root of the tree.  The parent node of some node  is defined as . Each node has  golden coins.  Node  is root of the tree.  The parent node of some node  is defined as . Moves Players move in turns.  During a move, a player can select a node  and move one or more coins to .  If the current player can't make any move, they lose the game. Players move in turns.  During a move, a player can select a node  and move one or more coins to .  If the current player can't make any move, they lose the game. The game quickly becomes boring because the result is determined by the tree's configuration and the number of coins in each node (assuming that both players play optimally). Alice decides to instead challenge Bob by asking him  questions. For each question : Alice picks a node  and removes the edge between  and .  She picks another node  and draws a new undirected edge between  and . So now . Bob must determine if the first player has a winning strategy for the new tree or not. It's possible that after Alice draws the new edge, the graph will no longer be a tree; if that happens, the question is invalid. Each question is independent, so the answer depends on the initial state of the graph (and not on previous questions). Given the tree and the number of coins in each node, can you help Bob answer all  questions? Input Format The first line contains an integer,  (the number of nodes).  The second line contains  space-separated integers, , describing the number of coins in each node.  Each of the  subsequent lines contains  space-separated integers denoting an undirected edge between nodes  and , respectively.  The next line contains an integer,  (the number of questions Alice asks).  Each of the  subsequent lines contains  space-separated integers,  and , respectively. Constraints    For each question:    Output Format On a new line for each question, print  if the first player has a winning strategy, print  if they do not, or print  if the question is not valid. Sample Input 6 0 2 2 1 3 2 1 2 1 3 3 4 3 5 4 6 3 6 2 4 1 3 6  Sample Output NO YES INVALID  Explanation Initally the tree looks like this:  After the first question (), the tree looks like this:  Alice removes the edge conecting node  to  and makes  the new parent node of . Because this configuration does not result in a winning strategy, we print  on a new line. After the second question (), the tree looks like this:  Alice removes the edge conecting node  to  and makes  the new parent node of . Because this configuration results in a winning strategy, we print  on a new line. After the third question (), the graph is no longer a tree:  Alice removes the edge conecting node  to  and makes  the new parent node of . The graph is now partitioned into two separate subgraphs (one of which is also not a tree); because the game must be played on a single undirected tree graph, we print  on a new line.
__label__Dynamic-Programming Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.
__label__Dynamic-Programming You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.
__label__Data-Structures A left rotation operation on an array of size  shifts each of the array's elements  unit to the left. For example, if  left rotations are performed on array , then the array would become . Given an array of  integers and a number, , perform  left rotations on the array. Then print the updated array as a single line of space-separated integers. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of integers) and  (the number of left rotations you must perform).  The second line contains  space-separated integers describing the respective elements of the array's initial state. Constraints      Output Format Print a single line of  space-separated integers denoting the final state of the array after performing  left rotations. Sample Input 5 4 1 2 3 4 5  Sample Output 5 1 2 3 4  Explanation When we perform  left rotations, the array undergoes the following sequence of changes:    Thus, we print the array's final state as a single line of space-separated values, which is 5 1 2 3 4. 5 1 2 3 4
__label__Array Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.
__label__Depth-first-Search An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].
__label__Array Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000
__label__Game-Theory Nim is the most famous two-player algorithm game. The basic rules for this game are as follows: The game starts with a number of piles of stones.  The number of stones in each pile may not be equal. The players alternately pick up  or more stones from  pile The player to remove the last stone wins. For example, there are  piles of stones having  stones in them.  Play may proceed as follows: Player  Takes           Leaving                         pile=[3,2,4] 1       2 from pile[1]  pile=[3,4] 2       2 from pile[1]  pile=[3,2] 1       1 from pile[0]  pile=[2,2] 2       1 from pile[0]  pile=[1,2] 1       1 from pile[1]  pile=[1,1] 2       1 from pile[0]  pile=[0,1] 1       1 from pile[1]  WIN  Given the value of  and the number of stones in each pile, determine the game's winner if both players play optimally. Function Desctription  Complete the nimGame function in the editor below.  It should return a string, either First or Second.   First Second nimGame has the following parameter(s):   pile: an integer array that represents the number of stones in each pile   Input Format The first line contains an integer, , denoting the number of games they play. Each of the next  pairs of lines is as follows:   The first line contains an integer , the number of piles. The next line contains  space-separated integers , the number of stones in each pile. Constraints    Player 1 always goes first. Output Format For each game, print the name of the winner on a new line (i.e., either First or Second). First Second Sample Input 2 2 1 1 3 2 1 4  Sample Output Second First  Explanation In the first case, there are  piles of  stones.  Player  has to remove one pile on the first move.  Player  removes the second for a win. In the second case, there are  piles of  stones.  If player  removes any one pile, player  can remove all but one of another pile and force a win.  If player  removes less than a pile, in any case, player  can force a win as well, given optimal play.
__label__Graph-Algorithms __label__Bit __label__Graph-Algorithms Consider an undirected graph containing  nodes and  edges. Each edge  has an integer cost, , associated with it. The penalty of a path is the bitwise OR of every edge cost in the path between a pair of nodes,  and . In other words, if a path contains edges , then the penalty for this path is  OR  OR ... OR . Given a graph and two nodes,  and , find the path between  and  having the minimal possible penalty and print its penalty; if no such path exists, print  to indicate that there is no path from  to . Note: Loops and multiple edges are allowed. The bitwise OR operation is known as or in Pascal and as | in C++ and Java. Input Format The first line contains two space-separated integers,  (the number of nodes) and  (the number of edges), respectively. Each line  of the  subsequent lines contains three space-separated integers , , and , respectively, describing edge  connecting the nodes  and  and its associated penalty (). The last line contains two space-separated integers,  (the starting node) and  (the ending node), respectively. Constraints       Output Format Print the minimal penalty for the optimal path from node  to node ; if no path exists from node  to node , print . Sample Input 3 4 1 2 1 1 2 1000 2 3 3 1 3 100 1 3  Sample Output 3  Explanation The optimal path is .   and .  The penalty for this path is:  OR , so we print .
__label__Strings Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.   Example 1: Input: "cdadabcc" Output: "adbc"   Example 2: Input: "abcd" Output: "abcd"   Example 3: Input: "ecbacba" Output: "eacb"   Example 4: Input: "leetcode" Output: "letcod"    Note:  1 <= text.length <= 1000 text consists of lowercase English letters.
__label__Dynamic-Programming Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.
__label__Graph-Algorithms Jack has just moved to a new city called Rapture. He wants to use the public public transport system. The fare rules are as follows:   Each pair of connected stations has a fare assigned to it regardless of direction of travel.   If a passenger travels from station A to station B, he only has to pay the  difference between the fare from A to B and the cumulative fare that he has paid to reach station A [fare(A,B) - total fare to reach station A].  If the difference is negative, he can travel free of cost from A to B.   Jack is low on cash and needs your help to figure out the most cost efficient way to go from the first station to the last station. Given the number of stations  (numbered from  to ), and the fare between the  pairs of stations that are connected, determine the lowest fare from station  to station .   For example, there are  stations with undirected connections at the costs indicated:     Travel from station  costs  for the first segment () then the cost differential, an additional  for the remainder.  The total cost is .  Travel from station  costs  for the first segment, then an additional  for the remainder, a total cost of .  The lower priced option costs .   Complete the program in the editor below.  It should print the cost of the lowest priced route from station  to station .  If there is no route, print NO PATH EXISTS.   NO PATH EXISTS Function Description  Complete the getCost function in the editor below.  It should print the cost of the lowest priced route from station  to station , or if there is no route, print NO PATH EXISTS.  There is no expected return value from the function. NO PATH EXISTS getCost has the following parameters: : an integer that represents the number of stations in the network   : an array of integers that represent end stations of a bidirectional connection   : an array of integers that represent end stations of a bidirectional connection, where  is connected to   at cost   : an array of integers that represent the cost of travel between associated stations   Input Format The first line contains two space-separated integers,  and , the number of stations and the number of connections between them.  Each of the next  lines contains three space-separated integers,  and , the starting and ending stations that are connected and the fare between them.   Constraints       Output Format The minimum fare to be paid to reach station  from station . If the station  cannot be reached from station , print NO PATH EXISTS NO PATH EXISTS
__label__Strings For two strings A and B, we define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings "abc" and "abd" is 2, while the similarity of strings "aaa" and "aaab" is 3. Calculate the sum of similarities of a string S with each of it's suffixes. Input Format The first line contains the number of test cases t.  Each of the next t lines contains a string to process, . Constraints      is composed of characters in the range ascii[a-z]   Output Format Output t lines, each containing the answer for the corresponding test case. Sample Input 2 ababaa   aa  Sample Output 11   3  Explanation For the first case, the suffixes of the string are "ababaa", "babaa", "abaa", "baa", "aa" and "a". The similarities of these strings with the string "ababaa" are 6,0,3,0,1, & 1 respectively. Thus, the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11. For the second case, the answer is 2 + 1 = 3.
__label__Mathematics __label__Tree __label__Data-Structures __label__Advanced-Data-Structures A subsequence of a sequence is a sequence which is obtained by deleting zero or more elements from the sequence.  You are given a sequence A in which every element is a pair of integers  i.e  A = [(a1, w1), (a2, w2),..., (aN, wN)]. A A For a subseqence B = [(b1, v1), (b2, v2), ...., (bM, vM)] of the given sequence :  B We call it increasing if for every i (1 <= i < M ) , bi < bi+1. Weight(B) = v1 + v2 + ... + vM.   Task:  Given a sequence, output the maximum weight formed by an increasing subsequence. Input:  The first line of input contains a single integer T. T test-cases follow. The first line of each test-case contains an integer N. The next line contains a1, a2 ,... , aN separated by a single space. The next line contains w1, w2, ..., wN separated by a single space. Output:  For each test-case output a single integer: The maximum weight of increasing subsequences of the given sequence.   Constraints:  1 <= T <= 5  1 <= N <= 150000  1 <= ai <= 109, where i ∈ [1..N]  1 <= wi <= 109, where i ∈ [1..N]  Sample Input: 2   4   1 2 3 4   10 20 30 40   8   1 2 3 4 1 2 3 4   10 20 30 40 15 15 15 50  Sample Output: 100   110  Explanation:  In the first sequence, the maximum size increasing subsequence is 4, and there's only one of them. We choose B = [(1, 10), (2, 20), (3, 30), (4, 40)], and we have Weight(B) = 100. B = [(1, 10), (2, 20), (3, 30), (4, 40)] Weight(B) = 100 In the second sequence, the maximum size increasing subsequence is still 4, but there are now 5 possible subsequences: 1 2 3 4   10 20 30 40  1 2 3 4   10 20 30 50  1 2 3 4   10 20 15 50  1 2 3 4   10 15 15 50  1 2 3 4   15 15 15 50  Of those, the one with the greatest weight is B = [(1, 10), (2, 20), (3, 30), (4, 50)], with Weight(B) = 110. B = [(1, 10), (2, 20), (3, 30), (4, 50)] Weight(B) = 110 Please note that this is not the maximum weight generated from picking the highest value element of each index. That value, 115, comes from [(1, 15), (2, 20), (3, 30), (4, 50)], which is not a valid subsequence because it cannot be created by only deleting elements in the original sequence.
__label__Two-Pointers Given a string s that consists of only uppercase English letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character. Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104. Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.
__label__Strings Amanda has a string of lowercase letters that she wants to copy to a new string.  She can perform the following operations with the given costs. She can perform them any number of times to construct a new string : Append a character to the end of string  at a cost of  dollar.  Choose any substring of  and append it to the end of  at no charge. Given  strings , find and print the minimum cost of copying each  to  on a new line. For example, given a string , it can be copied for  dollars.  Start by copying ,  and  individually at a cost of  dollar per character.  String  at this time.  Copy  to the end of  at no cost to complete the copy.   Function Description  Complete the stringConstruction function in the editor below.  It should return the minimum cost of copying a string.   stringConstruction has the following parameter(s):   s: a string   Input Format The first line contains a single integer , the number of strings.  Each of the next  lines contains a single string, . Constraints     Subtasks  for  of the maximum score. Output Format For each string  print the minimum cost of constructing a new string  on a new line. Sample Input 2 abcd abab  Sample Output 4 2  Explanation Query 0: We start with  and . Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Because the total cost of all operations is  dollars, we print  on a new line. Query 1: We start with  and . Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append substring  to  at no cost, .  Because the total cost of all operations is  dollars, we print  on a new line. Note A substring of a string  is another string  that occurs "in"  (Wikipedia). For example, the substrings of the string "" are "", "" ,"", "", "", and "".
