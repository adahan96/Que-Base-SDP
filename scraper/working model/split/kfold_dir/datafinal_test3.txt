__label__Array __label__Two-Pointers Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.   Note: 0 < nums.length <= 50000. 0 < nums[i] < 1000. 0 <= k < 10^6.
__label__Dynamic-Programming A new gangster is trying to take control of the city. He makes a list of his  adversaries (e.g. gangster , gangster , ... gangster , gangster ) and plans to get rid of them.  mercenaries are willing to do the job. The gangster can use any number of these mercenaries. But he has to honor one condition set by them: they have to be assigned in such a way that they eliminate a consecutive group of gangsters in the list, e.g. gangster , gangster , ..., gangster , gangster , where the following is true: . While our new gangster wants to kill all of them, he also wants to pay the least amount of money. All mercenaries charge a different amount to kill different people. So he asks you to help him minimize his expenses.   Input Format The first line contains two space-separated integers,   and . Then  lines follow, each containing  integers as follows: The th number on the th line is the amount charged by the th mercenary for killing the th gangster on the list. Constraints     Output Format Just one line, the minimum cost for killing the  gangsters on the list. Sample Input 3 2 1 4 1 2 2 2  Sample Output  5  Explanation The new gangster can assign mercenary 1 to kill gangster 1, and mercenary 2 to kill gangster 2 and gangster 3.
__label__Array Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle. Note that the row index starts from 0.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1]  Follow up: Could you optimize your algorithm to use only O(k) extra space?
__label__Hash-Table __label__Strings Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format: "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]    Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.    Follow-up beyond contest:  Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive?
__label__Strings __label__Dynamic-Programming Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')
__label__Search __label__Dynamic-Programming You have a rectangular board consisting of  rows, numbered from  to , and  columns, numbered from  to . The top left is  and the bottom right is . Initially - at time  - there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:   *: Exactly one of your cells has letter '*'. *: Exactly one of your cells has letter '*'. U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . When the coin reaches a cell that has letter '*', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time  the coin will reach the cell having letter '*'. In each operation you can select a cell with some letter other than '*' and change the letter to 'U', 'L', 'R' or 'D'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations.  For example, given a grid of  rows and  columns: the goal is to get from  to  in as few steps as possible.  As the grid stands, it cannot be done because of the U in the cell at .  If  is changed to D, the path  is available.  It could also be changed to R which would make the path  available.  Either choice takes  change operation, which is the value sought if .  A lower value of  would result in a return value of  because the shortest path is  steps, starting from .   U D R Function Description  Complete the coinOnTheTable function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or  if it is not possible.   coinOnTheTable has the following parameters:   m: an integer, the number of columns on the board   k: an integer, the maximum time to reach the goal   board: an array of strings where each string represents a row of the board   Input Format The first line of input contains three integers, , , and , the number of rows, the number of columns and the maximum time respectively.   The next  lines contain  letters each, describing your board.    Constraints     Output Format Print an integer which represents the minimum number of operations required to achieve your goal. If you cannot achieve your goal, print . Sample Input 2 2 3   RD   *L  Sample output : 0  Sample input : 2 2 1   RD   *L  Sample output : 1  Explanation : In the first example, a valid path exists without making any changes.  In the second example, the letter of cell (1,1) must be changed to 'D' to make a valid path.  In each example, a path length  is available.
__label__Mathematics Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number. In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:  <IntegerPart> (e.g. 0, 12, 123) <IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001) <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))  The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example: 1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66) Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.   Example 1: Input: S = "0.(52)", T = "0.5(25)" Output: true Explanation: Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.   Example 2: Input: S = "0.1666(6)", T = "0.166(66)" Output: true   Example 3: Input: S = "0.9(9)", T = "1." Output: true Explanation:  "0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.] "1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".     Note:  Each part consists only of digits. The <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.) 1 <= <IntegerPart>.length <= 4  0 <= <NonRepeatingPart>.length <= 4  1 <= <RepeatingPart>.length <= 4
__label__Array Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75    Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].
__label__Array In a list of songs, the i-th song has a duration of time[i] seconds.  Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i < j with (time[i] + time[j]) % 60 == 0.   Example 1: Input: [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60   Example 2: Input: [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60.     Note:  1 <= time.length <= 60000 1 <= time[i] <= 500
__label__Dynamic-Programming You are given an array A = [1, 2, 3, ..., n]:      How many sequences (S1) can you get after exact k adjacent swaps on A?  How many sequences (S1) can you get after exact k adjacent swaps on A?  How many sequences (S2) can you get after at most k swaps on A?   How many sequences (S2) can you get after at most k swaps on A?   An adjacent swap can be made between two elements of the Array A, A[i] and A[i+1] or A[i] and A[i-1].  A swap otherwise can be between any two elements of the array A[i] and A[j] ∀ 1 ≤ i, j ≤ N, i ≠ j. Input Format First and only line contains n and k separated by space.     Constraints 1 ≤ n ≤ 2500  1 ≤ k ≤ 2500       Output Format Output S1 % MOD and S2 % MOD in one line, where MOD = 1000000007.     MOD = 1000000007 Sample Input 3 2  Sample Output 3 6  Explanation Original array: [1, 2, 3] 1. After 2 adjacent swaps: We can get [1, 2, 3], [2, 3, 1], [3, 1, 2] ==> S1 == 3  2. After at most 2 swaps: 1) After 0 swap: [1, 2, 3] 2) After 1 swap: [2, 1, 3], [3, 2, 1], [1, 3, 2]. 3) After 2 swaps: [1, 2, 3], [2, 3, 1], [3, 1, 2] ==> S2 == 6
__label__Array Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].   Example 1: Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1    Constraints:  1 <= dominoes.length <= 40000 1 <= dominoes[i][j] <= 9
__label__Dynamic-Programming We call a sequence of N natural numbers (a1, a2, ..., aN) a P-sequence, if the product of any two adjacent numbers in it is not greater than P. In other words, if a sequence (a1, a2, ..., aN) is a P-sequence, then ai * ai+1 ≤ P ∀ 1 ≤ i < N N P You are given N and P. Your task is to find the number of such P-sequences of N integers modulo 109+7. N P N Input Format The first line of input consists of N  The second line of the input consists of P.  N P Constraints 2 ≤ N ≤ 103  1 ≤ P ≤ 109  1 ≤ ai  Output Format Output the number of P-sequences of N integers modulo 109+7. N Sample Input 0 Sample Output 0 Explanation 0 3 such sequences are {1,1},{1,2} and {2,1}
__label__Array We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].
__label__Tree __label__Depth-first-Search Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
__label__Binary-Search Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.  Note:  K will be an integer in the range [0, 10^9].
__label__Tree __label__Depth-first-Search Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6
__label__Tree Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them.   Example 1: Input:               5              / \             4   5            / \   \           1   1   5  Output: 2   Example 2: Input:               1              / \             4   5            / \   \           4   4   5  Output: 2   Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.
__label__Mathematics Given a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and N only contains the digit 1. Return the length of N.  If there is no such N, return -1.   Example 1: Input: 1 Output: 1 Explanation: The smallest answer is N = 1, which has length 1. Example 2: Input: 2 Output: -1 Explanation: There is no such positive integer N divisible by 2. Example 3: Input: 3 Output: 3 Explanation: The smallest answer is N = 111, which has length 3.   Note:  1 <= K <= 10^5
__label__Hash-Table __label__Binary-Search Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.) Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is "".)   Example 1: Input: "banana" Output: "ana"  Example 2: Input: "abcd" Output: ""    Note:  2 <= S.length <= 10^5 S consists of lowercase English letters.
__label__Array __label__Greedy-Algorithms Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.
__label__Array __label__Two-Pointers Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.    Example 1: Input: [-4,-1,0,3,10] Output: [0,1,9,16,100]   Example 2: Input: [-7,-3,2,3,11] Output: [4,9,9,49,121]    Note:  1 <= A.length <= 10000 -10000 <= A[i] <= 10000 A is sorted in non-decreasing order.
__label__Strings You have two strings,  and . Find a string, , such that:  can be expressed as  where  is a non-empty substring of  and  is a non-empty substring of .  is a palindromic string. The length of  is as long as possible. For each of the  pairs of strings ( and ) received as input, find and print string  on a new line. If you're able to form more than one valid string , print whichever one comes first alphabetically. If there is no valid answer, print  instead. Input Format The first line contains a single integer, , denoting the number of queries. The subsequent lines describe each query over two lines: The first line contains a single string denoting . The second line contains a single string denoting . Constraints      and  contain only lowercase English letters. Sum of |a| over all queries does not exceed  Sum of |b| over all queries does not exceed  Output Format For each pair of strings ( and ), find some  satisfying the conditions above and print it on a new line. If there is no such string, print  instead. Sample Input 3 bac bac abc def jdfh fds  Sample Output aba -1 dfhfd  Explanation We perform the following three queries: Concatenate  with  to create . We're given  and ; because both strings are composed of unique characters, we cannot use them to form a palindromic string. Thus, we print . Concatenate  with  to create . Note that we chose these particular substrings because the length of string  must be maximal.
__label__Array __label__Mathematics An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.
__label__Depth-first-Search We are stacking blocks to form a pyramid. Each block has a color which is a one letter string. We are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple. We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3. Return true if we can build the pyramid all the way to the top, otherwise false. Example 1: Input: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"] Output: true Explanation: We can stack the pyramid like this:     A    / \   G   E  / \ / \ B   C   D  We are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.   Example 2: Input: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"] Output: false Explanation: We can't stack the pyramid to the top. Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.    Note:  bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}.
__label__Data-Structures __label__Advanced-Data-Structures In Burger Town new burger restaurants will be opened! Concretely,  restaurants will open in  days, while restaurant  will be opened on day  and will be located at . The town should be imagined as an one dimensional line in which every object's location can be described by the  coordinate. Tim has just recently arrived the town after a very bad result in a programming contest. Thus he wants to cheer himself up by starting a trip to try out some new burgers.  Every burger restaurant  is associated with two integers  and . If Tim eats a burger from , then his happiness will increase by , which can also be negative, depending on the deliciousness of the burger. On the other hand, if Tim looks through the window of an opened restaurant , from which he will not eat a burger, then his happiness decreases by , since Tim gets sad by only seeing the burgers.  Tim's journey can start from any day  at the burger restaurant  and eats a burger from there. On each subsequent day , Tim has the following options: Stay at the previous restaurant .  Or go to the new restaurant  to eat a burger from there. If he decides for the latter option, then on the path from  to  he will look through all the windows that are on his path and maybe lose some happiness. Concretely, if , then he will look through the window of every opened restaurant , having . Similar for the case . Since Tim is a very good friend of yours you should help him finding a trip that will maximize his happiness. If he should stay at home since no trip would cheer him up, then print 0.  0 Note: Tim's happiness is 0 at the beginning of the trip and is allowed to be negative throughout the time.  Input Format  will be given on the first line, then  lines will follow, describing the restaurants numbered from 1 to  accordingly. Restaurant  will be described by ,  and  separated by a single space. Output Format Output the maximium happiness on one line. Constraints         and no two restaurants will have the same  coordinates.  and no two restaurants will have the same  coordinates. Sample Input  3  2 -5 1  1 5 1  3 5 1  Sample Output 8  Sample Input  4  4 10 0  1 -5 0  3 0 10  2 10 0  Sample Output  15  Sample Input  3  1 -1 0  2 -2 0  3 -3 0  Sample Output  0  First testcase: His trip starts on day 2 at restaurant 2 located at . He gains  happiness points there by eating a burger. On the next day he goes from restaurant 2 to 3, but will look through the window of restaurant 2 and 1. Therefore he loses  and  points on the way to restaurant 3. There he eats a burger and gains another  points. In total his happiness is equal to  8 and this is optimal. 8 Second testcase: His trip starts on day 1 at restaurant 1. Then his actions on day 2, 3 and 4 will be go to restaurant 2, stay at restaurant 2 and go to restaurant 4 respectively. The happiness of this optimal trip is equal to  15. 15 Third testcase: It's not worth to start the trip from any of the restaurant since he will only have negative happiness. That's why he should stay at home and 0 should be printed.  0
__label__Graph-Algorithms Detective Rust is investigating a homicide and he wants to chase down the murderer. The murderer knows he would definitely get caught if he takes the main roads for fleeing, so he uses the village roads (or side lanes) for running away from the crime scene. Rust knows that the murderer will take village roads and he wants to chase him down. He is observing the city map, but it doesn't show the village roads (or side lanes) on it and shows only the main roads.  The map of the city is a graph consisting  nodes (labeled  to ) where a specific given node  represents the current position of Rust and the rest of the nodes denote other places in the city, and an edge between two nodes is a main road between two places in the city. It can be suitably assumed that an edge that doesn't exist/isn't shown on the map is a village road (side lane). That means, there is a village road between two nodes  and  iff(if and only if) there is no city road between them.   In this problem, distance is calculated as number of village roads (side lanes) between any two places in the city. Rust wants to calculate the shortest distance from his position (Node ) to all the other places in the city if he travels only using the village roads (side lanes). Note: The graph/map of the city is ensured to be a sparse graph. Input Format The first line contains , denoting the number of test cases.  testcases follow.  First line of each test case has two integers , denoting the number of cities in the map and , denoting the number of roads in the map.  The next  lines each consist of two space-separated integers  and  denoting a main road between city  and city .  The last line has an integer , denoting the current position of Rust.  Constraints         Note  No nodes will have a road to itself.  There will not be multiple edges between any pair of nodes i.e. there is at most one undirected edge between them.  Graph is guaranteed to be sparse.  It is guranteed that there will be a path between any pair of nodes using the side lanes. Output Format For each of T test cases, print a single line consisting of N-1 space separated integers, denoting the shortest distances of the remaining N-1 places from Rust's position (that is all distances, except the source node to itself) using the village roads/side lanes in ascending order based on vertex number.   Sample Input 0 Sample Output 0 Explanation 0 The graph in the first testcase can be shown as:  Here the source node is 1 (marked S).  The distance from 1 to 2 is 3. Path: 1 -> 3 -> 4 -> 2  The distance from 1 to 3 is 1. Path: 1 -> 3  The distance from 1 to 4 is 2. Path: 1 -> 3 -> 4
__label__Array Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [   [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]
__label__Greedy-Algorithms Mark and Jane are very happy after having their first child. Their son loves toys, so Mark wants to buy some. There are a number of different toys lying in front of him, tagged with their prices.  Mark has only a certain amount to spend, and he wants to maximize the number of toys he buys with this money. Given a list of prices and an amount to spend, what is the maximum number of toys Mark can buy?  For example, if  and Mark has  to spend, he can buy items  for , or  for  units of currency.  He would choose the first group of  items. Function Description Complete the function maximumToys in the editor below.  It should return an integer representing the maximum number of toys Mark can purchase.   maximumToys has the following parameter(s):   prices:  an array of integers representing toy prices   k:  an integer, Mark's budget Input Format The first line contains two integers,  and , the number of priced toys and the amount Mark has to spend.  The next line contains  space-separated integers   Constraints       A toy can't be bought multiple times. Output Format An integer that denotes the maximum number of toys Mark can buy for his son. Sample Input 7 50 1 12 5 111 200 1000 10  Sample Output 4  Explanation He can buy only  toys at most. These toys have the following prices: .
__label__Graph-Algorithms Recall that a tree is an undirected, connected acyclic graph. We have a weighted tree, , with  vertices; let  be the total sum of edge weights on the path between nodes  and . Let's consider all the matrices, , such that:    for each  and  We consider the total value of matrix  to be:   Calculate and print the maximum total value of  for a given tree, . Input Format The first line contains a single positive integer, , denoting the number of vertices in tree .  Each line  of the  subsequent lines contains three space-separated positive integers denoting the respective , , and  values defining an edge connecting nodes  and  (where ) with edge weight . Constraints   Test cases with  have  of total score Test cases with  have  of total score  Output Format Print a single integer denoting the maximum total value of matrix  satisfying the properties specified in the Problem Statement above. Sample Input 3 1 2 2 1 3 1  Sample Output 3  Explanation In the sample case, matrix  is:   The sum of the elements of the first row is equal to .
__label__Dynamic-Programming __label__Graph-Algorithms You are situated in an  dimensional grid at position . The dimensions of the grid are . In one step, you can walk one step ahead or behind in any one of the  dimensions. This implies that there are always  possible moves if movements are unconstrained by grid boundaries. How many ways can you take  steps without leaving the grid at any point? You leave the grid if at any point , either  or . For example, you start off in a 3 dimensional grid at position .  The dimensions of the grid are , so each of your axes will be numbered from  to .  If you want to move  step, you can move to the following coordinates: .       If we started at  in the same grid, our new paths would lead to .  Other moves are constrained by . Function Description Complete the gridWalking function in the editor below.  It should return an integer that represents the number of possible moves, modulo . gridWalking has the following parameter(s): m: an integer that represents the number of steps   x: an integer array where each  represents a coordinate in the  dimension where  D: an integer array where each  represents the upper limit of the axis in the  dimension   Input Format The first line contains an integer , the number of test cases. Each of the next  sets of lines is as follows: The first line contains two space-separated integers,  and .   The next line contains  space-separated integers .   The third line of each test contains  space-separated integers .   Constraints          Output Format Output one line for each test case. Since the answer can be really huge, output it modulo .   Sample Input 1 2 3 1 1 2 3  Sample Output 12  Explanation We are starting from (1, 1) in a  2-D grid, and need to count the number of possible paths with length equal to .  Here are the  paths:
__label__Dynamic-Programming In a project, you have a list of required skills req_skills, and a list of people.  The i-th person people[i] contains a list of skills that person has. Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill.  We can represent these teams by the index of each person: for example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3]. Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.  It is guaranteed an answer exists.   Example 1: Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]] Output: [0,2] Example 2: Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]] Output: [1,2]    Constraints:  1 <= req_skills.length <= 16 1 <= people.length <= 60 1 <= people[i].length, req_skills[i].length, people[i][j].length <= 16 Elements of req_skills and people[i] are (respectively) distinct. req_skills[i][j], people[i][j][k] are lowercase English letters. Every skill in people[i] is a skill in req_skills. It is guaranteed a sufficient team exists.
__label__Hash-Table __label__Two-Pointers __label__Binary-Search Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
__label__Dynamic-Programming __label__Mathematics Alex has two arrays defined as  and . He created an  matrix, , where  for each  in . Recall that  is the greatest common divisor of  and .  For example, if  and , he builds  like so: Alex's friend Kiara loves matrices, so he gives her  questions about matrix  where each question is in the form of some submatrix of  with its upper-left corner at  and its bottom-right corner at . For each question, find and print the number of distinct integers in the given submatrix on a new line. Input Format The first line contains three space-separated integers describing the respective values of  (the size of array ),  (the size of array ), and  (Alex's number of questions).  The second line contains  space-separated integers describing .  The third line contains  space-separated integers describing .  Each line  of the  subsequent lines contains four space-separated integers describing the respective values of , , , and  for the  question (i.e., defining a submatrix with upper-left corner  and bottom-right corner ). Constraints           Scoring   for  of score.    for  of score.   Output Format For each of Alex's questions, print the number of distinct integers in the given submatrix on a new line. Sample Input 0 Sample Output 0 Explanation 0 Given  and , we build the following : The diagram below depicts the submatrices for each of the  questions in green:  For the submatrix between  and , the set of integers is . The number of distinct integers is . For the submatrix between  and , the set of integers is . The number of distinct integers is . For the submatrix between  and , the set of integers is . The number of distinct integers is .
__label__Search King Richard is leading a troop of  knights into battle! Being very organized, he labels his knights  and arranges them in an  square formation, demonstrated below:  Before the battle begins, he wants to test how well his knights follow instructions. He issues  drill commands, where each command follows the format ai bi di and is executed like so: ai bi di All knights in the square having the top-left corner at location  and the bottom-right corner at location  rotate  in the clockwise direction. Recall that some location  denotes the cell located at the intersection of row  and column . For example:  You must follow the commands sequentially. The square for each command is completely contained within the square for the previous command. Assume all knights follow the commands perfectly. After performing all  drill commands, it's time for battle! King Richard chooses knights  for his first wave of attack; however, because the knights were reordered by the drill commands, he's not sure where his chosen knights are! As his second-in-command, you must find the locations of the knights. For each knight , , print the knight's row and column locations as two space-separated values on a new line.   Input Format This is broken down into three parts: The first line contains a single integer, .        The second line contains a single integer, .  Each line  of the  subsequent lines describes a command in the form of three space-separated integers corresponding to , , and , respectively.   Each line  of the  subsequent lines describes a command in the form of three space-separated integers corresponding to , , and , respectively.   The next line contains a single integer, .  Each line  of the  subsequent lines describes a knight the King wants to find in the form of a single integer corresponding to .   Each line  of the  subsequent lines describes a knight the King wants to find in the form of a single integer corresponding to .   Constraints         and    and       Subtask   for  of the maximum score.   Output Format Print  lines of output, where each line  contains two space-separated integers describing the respective row and column values where knight  is located.   Sample Input 7 4 1 2 4 2 3 3 3 4 1 3 4 0 7 0 6 9 11 24 25 48  Sample Output 1 1 1 7 4 6 3 4 2 5 2 4 7 7  Explanation The following diagram demonstrates the sequence of commands:  Click here to download a larger image. In the final configuration: Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location
__label__Two-Pointers __label__Strings Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".
__label__Mathematics Given two numbers arr1 and arr2 in base -2, return the result of adding them together. Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1. Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.   Example 1: Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1] Output: [1,0,0,0,0] Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.    Note:  1 <= arr1.length <= 1000 1 <= arr2.length <= 1000 arr1 and arr2 have no leading zeros arr1[i] is 0 or 1 arr2[i] is 0 or 1
__label__Data-Structures A queue is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed. A basic queue has the following operations: Enqueue: add a new element to the end of the queue. Dequeue: remove the element from the front of the queue and return it. In this challenge, you must first implement a queue using two stacks. Then process  queries, where each query is one of the following  types:  1 x: Enqueue element  into the end of the queue. 1 x 2: Dequeue the element at the front of the queue. 2 3: Print the element at the front of the queue. 3 Input Format The first line contains a single integer, , denoting the number of queries.  Each line  of the  subsequent lines contains a single query in the form described in the problem statement above. All three queries start with an integer denoting the query , but only query  is followed by an additional space-separated value, , denoting the value to be enqueued. Constraints       It is guaranteed that a valid answer always exists for each query of type . Output Format For each query of type , print the value of the element at the front of the queue on a new line.  Sample Input 10 1 42 2 1 14 3 1 28 3 1 60 1 78 2 2  Sample Output 14 14  Explanation We perform the following sequence of actions: Enqueue ; . Dequeue the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Enqueue ; . Dequeue the value at the head of the queue, ; . Dequeue the value at the head of the queue, ; .
__label__Bit Let a and b be binary numbers of length n (MSB to the left). The following commands may be performed: set_a idx x: Set  to , where  and   is  least significant bit of .   set_a idx x set_b idx x: Set  to , where  and   is  least significant bit of .   set_b idx x get_c idx: Print , where  and .   get_c idx Given , and a list of commands, create a string made of the results of each  call, the only command that produces output.  For example,  and  so the length of the numbers is .  Print an answer string that contains the results of all commands on one line.  A series of commands and their results follow:  Starting  ans = '' (empty string)  a   b  000 111  set_a 1 1  010 111  set_b 0 1  010 111  get_c 3  a + b = 1001  ans = '1'  010 111  get_c 4  a + b = 01001  ans = '10'    Starting  ans = '' (empty string)  a   b  000 111  set_a 1 1  010 111  set_b 0 1  010 111  get_c 3  a + b = 1001  ans = '1'  010 111  get_c 4  a + b = 01001  ans = '10'   Note: When the command is get_c 4,   had to be padded to the left with a  to be long enough to return a value.   get_c 4 Function Description  Complete the changeBits function in the editor below.  For each get_c command, it should print either a 0 or a 1 without a newline until all commands have been processed. At that point, add a newline.    get_c 0 1 changeBits has the following parameters:  - a, b: two integers represented as binary strings  - queries[queries[0]-queries[n-1]]: an array of query strings in the format described   Input Format The first line of input contains two space-separated integers,  and , the length of the binary representations of  and , and the number of commands, respectively.  The second and third lines each contain a string representation of  and .  The following  lines each contain a command string  as described above.   Constraints     Output Format For each query of the type , output a single digit 0 or 1. Output must be placed on a single line. Sample Input 0 Sample Output 0 Explanation 0 set_a 0 1 sets 00000 to 00001 C = A + B = 00001 + 11111 = 100000, so get_c[5] = 1 from the above computation get_c[1] = 0 set_b 2 0 sets 11111 to 11011 C = A + B = 00001 + 11011 = 011100, so get_c[5]  = 0 The output is hence concatenation of 1, 0 and 0  = 100
__label__Hash-Table __label__Strings Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]  An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".  Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"]. The format of the output is as follows:  For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c". Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed. An example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]  Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of "0" has an output of [].  Examples: Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1] Output: ["-1*a","14"]  Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12] Output: ["-1*pressure","5"]  Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = [] Output: ["1*e*e","-64"]  Input: expression = "7 - 7", evalvars = [], evalints = [] Output: []  Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = [] Output: ["5*a*b*c"]  Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = [] Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]  Note:  expression will have length in range [1, 250]. evalvars, evalints will have equal lengths in range [0, 100].
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?
__label__Dynamic-Programming __label__Mathematics Consider an array, , of length . We can split  into contiguous segments called pieces and store them as another array, . For example, if , we have the following arrays of pieces:  contains three -element pieces.  contains two pieces, one having  elements and the other having  element.  contains two pieces, one having  element and the other having  elements.  contains one -element piece. We consider the value of a piece in some array  to be , and we consider the total value of some array  to be the sum of the values for all pieces in that . For example, the total value of  is . Given , find the total values for all possible 's, sum them together, and print this sum modulo  on a new line. Input Format The first line contains a single integer, , denoting the size of array .  The second line contains  space-separated integers describing the respective values in  (i.e., ). Constraints   Output Format Print a single integer denoting the sum of the total values for all piece arrays ('s) of , modulo . Sample Input 0 3 1 3 6  Sample Output 0 73  Explanation 0  Given , our piece arrays are: , and . , and . , and . , and . When we sum all the total values, we get . Thus, we print the result of  on a new line. Sample Input 1 5 4 2 9 10 1  Sample Output 1 971
__label__Dynamic-Programming Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.
__label__Mathematics Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321  Example 2: Input: -123 Output: -321  Example 3: Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
__label__Mathematics Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false
__label__Greedy-Algorithms You are given an unordered array of unique integers incrementing from .  You can swap any two elements a limited number of times.  Determine the largest lexicographical value array that can be created by executing no more than the limited number of swaps.   For example, if  and the maximum swaps , the following arrays can be formed by swapping the  with the other elements:   The highest value of the four (including the original) is .  If , we can swap to the highest possible value: . Function Description  Complete the largestPermutation function in the editor below.  It must return an array that represents the highest value permutation that can be formed.   largestPermutation has the following parameter(s):   k: an integer that represents the limit of swaps   arr: an array of integers   Input Format The first line contains two space-separated integers  and , the length of  and the maximum swaps that can be performed. The second line contains  unique space-separated integers  where . Constraints     Output Format Print the lexicographically largest permutation you can make with at most  swaps.  Sample Input 0  5 1 4 2 3 5 1  Sample Output 0  5 2 3 4 1  Explanation 0  You can swap any two numbers in  and see the largest permutation is  Sample Input 1 3 1 2 1 3  Sample Output 1  3 1 2  Explanation 1  With 1 swap we can get ,  and .  Of these,  is the largest permutation.   Sample Input 2 2 1 2 1  Sample Output 2  2 1  Explanation 2  We can see that  is already the largest permutation.  We don't make any swaps.
__label__Strings Palindromes are strings that read the same from the left or right, for example madam or 0110.   You will be given a string representation of a number and a maximum number of changes you can make.  Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes.  The length of the string may not be altered, so you must consider 's left of all higher digits in your tests.  For example  is valid,  is not.   Given a string representing the starting number and a maximum number of changes allowed, create the largest palindromic string of digits possible or the string -1 if it's impossible to create a palindrome under the contstraints.   Function Description  Complete the highestValuePalindrome function in the editor below.  It should return a string representing the largest value palindrome achievable, or -1.   -1 highestValuePalindrome has the following parameter(s):   s: a string representation of an integer     n: an integer that represents the length of the integer string   k: an integer that represents the maximum number of changes allowed   Input Format The first line contains two space-separated integers,  and , the number of digits in the number and the maximum number of changes allowed.  The second line contains an -digit string of numbers.   Constraints   Each character  in the number is an integer where . Output Format Print a single line with the largest number that can be made by changing no more than  digits. If this is not possible, print -1. -1 Sample Input 0 4 1 3943  Sample Output 0 3993  Sample Input 1 6 3 092282  Sample Output 1 992299  Sample Input 2 4 1 0011  Sample Output 2 -1  Explanation Sample 0 There are two ways to make  a palindrome by changing no more than  digits:   , so we print .
__label__Array __label__Two-Pointers You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element. Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.   Example 1: Input: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.  Example 2: Input: [-1,2] Output: false Explanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.  Example 3: Input: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction.   Note:  -1000 ≤ nums[i] ≤ 1000 nums[i] ≠ 0 1 ≤ nums.length ≤ 5000    Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?
__label__Greedy-Algorithms Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.     Example 1: Input: [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.  Example 2: Input: [[1,2],[1,2],[1,2]] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.  Example 3: Input: [[1,2],[2,3]] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping.    Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
__label__Graph-Algorithms __label__Tree There are  points on a plane.  Each point  is described by , where . There are three types of queries needed:  X i j Reflect all points in the inclusive range between points  and  along the -axis.   X i j Y i j Reflect all points in the inclusive range between points  and  along the -axis.  Y i j C i j Count the number of points in the inclusive range between points  and  in each of the  quadrants. Then print a single line of four space-separated integers describing the respective numbers of points in the first, second, third, and fourth quadrants in that order.  C i j As a reminder, the four quadrants of a graph are labeled as follows:   Given a set of  points and  queries, perform each query in order. For example, given points  and .  Initially the points are in quadrants  and .  The first query says to reflect points with indices from  to  along the -axis.  After the query,  and quadrants are  and .  The next query prints the number of points in each quadrant: 0 1 0 1.  The third query says to reflect the point with index  to  along the -axis, so now .  The points now lie in quadrants  and , so the fourth query output is 0 1 1 0. 0 1 0 1 0 1 1 0 Note: Points may sometimes share the same coordinates.   Function Description  Complete the quadrants function in the editor below.  It should print the results of each C type query on a new line.   C quadrants has the following parameters:  - p[p[1]...p[n]]: a 2-dimensional array of integers where each element  contains two integers   and   - queries[queries[1]...queries[n]: an array of strings   Input Format The first line contains a single integer, , that denotes the number of points.  Each line  of the  subsequent lines contains two space-separated integers that describe the respective  and  values for point  .  The next line contains a single integer, , that denotes the number of queries.  Each of the  subsequent lines contains three space-separated values that describe a query in one of the three forms defined above.   Constraints    No point lies on the  or  axes.  In all queries, . Output Format For each query of type C i j, print four space-separated integers that describe the number of points having indices in the inclusive range between  and  in the first, second, third, and fourth graph quadrants in that order. C i j Sample Input 4 1 1 -1 1 -1 -1 1 -1 5 C 1 4 X 2 4 C 3 4 Y 1 2 C 1 3  Sample Output 1 1 1 1 1 1 0 0 0 2 0 1  Explanation Initially,  so there is one point in each of the four quadrants.  The first query results in printing 1 1 1 1. 1 1 1 1 The second query, X 2 4, reflects the points in the inclusive range between indices  and  along the -axis. Now . X 2 4 The query C 3 4 requires that the number of points considering  through  be printed: 1 1 0 0 C 3 4 1 1 0 0 The third query, Y 1 2 requires reflection of  along the -axis.  Now .   Y 1 2 The last query, C 1 3 requires that the number of points considering  through  be printed: 0 2 0 1 C 1 3 0 2 0 1
__label__Array Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.   If there are multiple answers, print any of them.  Example 1: Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.   Example 2: Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.   Note:  The n and k are in the range 1 <= k < n <= 104.
__label__Strings Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2. One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index i to index j (i<=j) and asked them to find their strength. i j The strength of the group of students from i to j is defined as: strength(i , j) {     if a[i] = 0         return 0; //If first child has value 0 in the group, strength of group is zero     value = 0;     for k from i to j         value = value*10 + a[k]     return value; }   Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof. Input Format First line contains number of test cases T  Next T line contains the numbers of number plates the students were having when standing in the row in the form of a string A. Constraints 1 ≤ T ≤ 100  1 ≤ len(A) ≤ 105  0 ≤ A[i] ≤ 9 Output Format Output the total number of strengths of the form 2x such that 0 ≤ x ≤ 800.  Sample Input 0 Sample Output 0 Explanation 0 In following explanations group i-j is group of student from index i to index j (1-based indexing) In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In third case 65536 is only number in required form. It is strength of group 1-5 In third case 65536 is only number in required form. It is strength of group 1-5 In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fifth case, None of the group has strength of required form.   In fifth case, None of the group has strength of required form.
__label__Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__Graph-Algorithms After completing her final semester, Savita is back home. She is excited to meet all her friends. Her  friends live in different houses spread across the city.     There are  roads connecting the houses. The road network formed is connected and does not contain self loops and multiple roads between same pair of houses. Savita and Friends decide to meet.   Savita wants to choose a point(not necessarily an integer)  on the road numbered , such that, the maximum of  for all  is minimised,  where  is the shortest distance between the 'th friend and .     If 'th road connects friend  and friend  you should print distance of chosen point from . Also, print the  for all . If there is more than one solution, print the one in which the point  is closest to .      Note:  Use scanf/printf instead of cin/cout. Large input files. Order of  and  as given in the input must be maintained. If P is at a distance of 8 from  and 2 from , you should print 8 and not 2.   Input Format First line contain , the number of testcases.  T testcases follow.  First Line of each testcase contains 3 space separated integers  .  Next  lines contain description of the th road : three space separated integers , where  is the length of road connecting  and .       Constraints             Output Format For each testcase, print two space separated values in one line. The first value is the distance of  from the point  and the second value is the maximum of all the possible shortest paths between  and all of Savita's and her friends' houses. Round both answers to  decimal digits and print exactly  digits after the decimal point.    Sample Input 2 2 1 1 1 2 10 4 4 1 1 2 10 2 3 10 3 4 1 4 1 5  Sample Output 5.00000 5.00000 2.00000 8.00000  Explanation First testcase:  As  = 1, they will meet at the point  on the road that connects friend  with friend . If we choose mid point then distance for both of them will be . In any other position the maximum of distance will be more than . Second testcase:  As  = 1, they will meet at a point  on the road connecting friend  and friend . If we choose point at a distance of  from friend : Friend  will have to travel distance .  Friend  will have to travel distance .  Friend  will have to travel distance .  Friend  will have to travel distance .  So, the maximum will be .  In any other position of point choosen, the maximum distance will be more than .    Timelimits Timelimits for this problem is 2 times the environment limit.
__label__Array Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either:  Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...  Return the minimum number of moves to transform the given array nums into a zigzag array.   Example 1: Input: nums = [1,2,3] Output: 2 Explanation: We can decrease 2 to 0 or 3 to 1.  Example 2: Input: nums = [9,6,1,6,2] Output: 4    Constraints:  1 <= nums.length <= 1000 1 <= nums[i] <= 1000
__label__Greedy-Algorithms Sean invented a game involving a  matrix where each cell of the matrix contains an integer. He can reverse any of its rows or columns any number of times.  The goal of the game is to maximize the sum of the elements in the  submatrix located in the upper-left quadrant of the matrix. Given the initial configurations for  matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.   For example, given the matrix: It is  so we want to maximize the top left  matrix.  Reverse row : And now reverse column : The maximal sum is . Function Description  Complete the flippingMatrix function in the editor below.  It should return an integer that represents the maximum sum possible for the top  matrix.   flippingMatrix has the following parameters:  - matrix: a  array of integers   Input Format The first line contains an integer , the number of queries.    The next  sets of lines are in the following format: The first line of each query contains an integer, .  Each of the next  lines contains  space-separated integers  in row  of the matrix.   Constraints     , where . Output Format You must print  lines of output. For each query, print the maximum possible sum of the elements in the matrix's upper-left quadrant. Sample Input 1 2 112 42 83 119 56 125 56 49 15 78 101 43 62 98 114 108  Sample Output 414  Explanation We start out with the following  matrix:   We can perform the following operations to maximize the sum of the  submatrix in the upper-left corner: Reverse column  (), resulting in the matrix:   Reverse row  (), resulting in the matrix:   When we sum the values in the  submatrix in the upper-left quadrant, we get .
__label__Tree A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:  CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree.       Example 1: Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]]   Example 2: Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]]     Note:  The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000.
__label__Depth-first-Search Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land) A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.   Example 1: Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation:  There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary. Example 2: Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation:  All 1s are either on the boundary or can reach the boundary.    Note:  1 <= A.length <= 500 1 <= A[i].length <= 500 0 <= A[i][j] <= 1 All rows have the same size.
__label__Dynamic-Programming Given an integer array arr and an integer k, modify the array by repeating it k times. For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0. As the answer can be very large, return the answer modulo 10^9 + 7.   Example 1: Input: arr = [1,2], k = 3 Output: 9  Example 2: Input: arr = [1,-2,1], k = 5 Output: 2  Example 3: Input: arr = [-1,-2], k = 7 Output: 0    Constraints:  1 <= arr.length <= 10^5 1 <= k <= 10^5 -10^4 <= arr[i] <= 10^4
__label__Game-Theory __label__Game-Theory Poker Nim is another -player game that's a simple variation on a Nim game. The rules of the games are as follows: The game starts with  piles of chips indexed from  to . Each pile  (where ) has  chips. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. To ensure that the game ends in finite time, a player cannot add chips to any pile  more than  times. The player who removes the last chip wins the game. Given the values of , , and the numbers of chips in each of the  piles, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: Two space-separated integers,  (the number of piles) and  (the maximum number of times an individual player can add chips to some pile ), respectively.  space-separated integers, , where each  describes the number of chips at pile . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either  or ). Sample Input 2 2 5 1 2 3 5 2 1 3  Sample Output First Second
__label__Game-Theory __label__Game-Theory Two people are playing Nimble! The rules of the game are: The game is played on a line of  squares, indexed from  to . Each square  (where ) contains  coins. For example:   The players move in alternating turns. During each move, the current player must  remove exactly  coin from square  and move it to square  if and only if . The game ends when all coins are in square  and nobody can make a move. The first player to have no available move loses the game. Given the value of  and the number of coins in each square, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of squares.  space-separated integers, , where each  describes the number of coins at square . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either  or ). Sample Input 2 5 0 2 3 0 6 4 0 0 0 0  Sample Output First Second  Explanation Explanation for  testcase:  The first player will shift one coin from  to . Hence, the second player is left with the squares . Now whatever be his/her move is, the first player can always nullify the change by shifting a coin to the same square where he/she shifted it. Hence the last move is always played by the first player, so he wins.  Exlanation for  testcase:  There are no coins in any of the squares so the first player cannot make any move, hence second player wins.
__label__Dynamic-Programming You are given a hexagonal grid consisting of two rows, each row consisting of  cells. The cells of the first row are labelled  and the cells of the second row are labelled .   For example, for :  (Note that the  is connected with .) Your task is to tile this grid with  tiles that look like the following:  As you can see above, there are three possible orientations in which a tile can be placed. Your goal is to tile the whole grid such that every cell is covered by a tile, and no two tiles occupy the same cell. To add to the woes, certain cells of the hexagonal grid are blackened. No tile must occupy a blackened cell. Is it possible to tile the grid? Here's an example. Suppose we want to tile this grid:  Then we can do the tiling as follows:  Input Format The first line contains a single integer , the number of test cases.   The first line of each test case contains a single integer  denoting the length of the grid.  The second line contains a binary string of length . The  character describes whether cell  is blackened.  The third line contains a binary string of length . The  character describes whether cell  is blackened.  A 0 corresponds to an empty cell and a 1 corresponds to blackened cell.   0 1 Constraints     Output Format For each test case, print YES if there exists at least one way to tile the grid, and NO otherwise. YES NO Sample Input 0 Sample Output 0 Explanation 0 The first test case in the sample input describes the example given in the problem statement above.  For the second test case, there are two ways to fill it: either place two diagonal tiles side-by-side or place two horizontal tiles.
__label__Dynamic-Programming __label__Depth-first-Search In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.
__label__Search There are  bikers present in a city (shaped as a grid) having  bikes. All the bikers want to participate in the HackerRace competition, but unfortunately only  bikers can be accommodated in the race. Jack is organizing the HackerRace and wants to start the race as soon as possible. He can instruct any biker to move towards any bike in the city. In order to minimize the time to start the race, Jack instructs the bikers in such a way that the first  bikes are acquired in the minimum time. Every biker moves with a unit speed and one bike can be acquired by only one biker. A biker can proceed in any direction. Consider distance between bikes and bikers as Euclidean distance. Jack would like to know the square of required time to start the race as soon as possible.  Input Format The first line contains three integers, , , and , separated by a single space.  The following  lines will contain  pairs of integers denoting the co-ordinates of  bikers. Each pair of integers is separated by a single space. The next  lines will similarly denote the co-ordinates of the  bikes. Constraints       ,   Output Format A single line containing the square of required time. Sample Input 3 3 2 0 1 0 2 0 3 100 1 200 2  300 3  Sample Output 40000  Explanation There's need for two bikers for the race. The first biker (0,1) will be able to reach the first bike (100,1) in 100 time units. The second biker (0,2) will be able to reach the second bike (200,2) in 200 time units. This is the most optimal solution and will take 200 time units. So output will be 2002 = 40000.
__label__Array Today, the bookstore owner has a store open for customers.length minutes.  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute. On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied. The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once. Return the maximum number of customers that can be satisfied throughout the day.   Example 1: Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes.  The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.    Note:  1 <= X <= customers.length == grumpy.length <= 20000 0 <= customers[i] <= 1000 0 <= grumpy[i] <= 1
__label__Mathematics Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].
__label__Array Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.
__label__Graph-Algorithms __label__Tree The kingdom of Zion has cities connected by bidirectional roads.  There is a unique path between any pair of cities. Morpheus has found out that the machines are planning to destroy the whole kingdom.  If two machines can join forces, they will attack.  Neo has to destroy roads connecting cities with machines in order to stop them from joining forces.  There must not be any path connecting two machines. Each of the roads takes an amount of time to destroy, and only one can be worked on at a time.  Given a list of edges and times, determine the minimum time to stop the attack. For example, there are  cities called .  Three of them have machines and are colored red.  The time to destroy is shown next to each road.  If we cut the two green roads, there are no paths between any two machines.  The time required is .     Function Description Complete the function minTime in the editor below.  It must return an integer representing the minimum time to cut off access between the machines. minTime has the following parameter(s): roads: a two-dimensional array of integers, each  where cities are connected by a road that takes  to destroy   machines: an array of integers representing cities with machines   Input Format The first line of the input contains two space-separated integers,  and , the number of cities and the number of machines.   Each of the following  lines contains three space-separated integers, , and .  There is a bidirectional road connecting  and , and to destroy this road it takes  units. Each of the last  lines contains an integer, , the label of a city with a machine.    Constraints       Output Format Return an integer representing the minimum time required to disrupt the connections among all machines. Sample Input 5 3 2 1 8 1 0 5 2 4 5 1 3 4 2 4 0  Sample Output 10  Explanation  The machines are located at the cities ,  and . Neo can destroy the green roads resulting in a time of .  Destroying the road between cities  and  instead of between  and  would work, but it's not minimal.
__label__Binary-Search __label__Dynamic-Programming You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
__label__Greedy-Algorithms A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.
__label__Tree __label__Depth-first-Search Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input:     1  /   \ 2     3  \   5  Output: ["1->2->5", "1->3"]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3
__label__Array Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000
__label__Tree __label__Depth-first-Search Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.
__label__Mathematics Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square. Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].   Example 1: Input: [1,17,8] Output: 2 Explanation:  [1,8,17] and [17,8,1] are the valid permutations.  Example 2: Input: [2,2,2] Output: 1    Note:  1 <= A.length <= 12 0 <= A[i] <= 1e9
__label__Strings Jane loves strings more than anything. She has a string  with her, and value of string  over function  can be calculated as given below:   Jane wants to know the maximum value of  among all the substrings  of string . Can you help her? Input Format  A single line containing string  . Output Format  Print the maximum value of  among all the substrings  of string . Constraints    The string consists of lowercase English alphabets.   Sample Input 0  aaaaaa  Sample Output 0  12  Explanation 0  f('a') = 6 f('aa') = 10 f('aaa') = 12 f('aaaa') = 12 f('aaaaa') = 10 f('aaaaaa') = 6  Sample Input 1  abcabcddd  Sample Output 1  9  Explanation 1 f values of few of the substrings are shown below: f("a") = 2 f("b") = 2 f("c") = 2 f("ab") = 4 f("bc") = 4 f("ddd") = 3 f("abc") = 6 f("abcabcddd") = 9  Among the function values 9 is the maximum one.
__label__Array Implement a SnapshotArray that supports the following interface:  SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0. void set(index, val) sets the element at the given index to be equal to val. int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1. int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id    Example 1: Input: ["SnapshotArray","set","snap","set","get"] [[3],[0,5],[],[0,6],[0,0]] Output: [null,null,0,null,5] Explanation:  SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3 snapshotArr.set(0,5);  // Set array[0] = 5 snapshotArr.snap();  // Take a snapshot, return snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5   Constraints:  1 <= length <= 50000 At most 50000 calls will be made to set, snap, and get. 0 <= index < length 0 <= snap_id < (the total number of times we call snap()) 0 <= val <= 10^9
__label__Search Ron and Hermione are deep in the Forbidden Forest collecting potion ingredients, and they've managed to lose their way. The path out of the forest is blocked, so they must make their way to a portkey that will transport them back to Hogwarts.   Consider the forest as an  grid. Each cell is either empty (represented by .) or blocked by a tree (represented by ). Ron and Hermione can move (together inside a single cell) LEFT, RIGHT, UP, and DOWN through empty cells, but they cannot travel through a tree cell. Their starting cell is marked with the character , and the cell with the portkey is marked with a . The upper-left corner is indexed as .  .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX.  In example above, Ron and Hermione are located at index  and the portkey is at . Each cell is indexed according to Matrix Conventions.     Hermione decides it's time to find the portkey and leave. They start along the path and each time they have to choose a direction, she waves her wand and it points to the correct direction. Ron is betting that she will have to wave her wand exactly  times. Can you determine if Ron's guesses are correct? The map from above has been redrawn with the path indicated as a series where  is the starting point (no decision in this case),  indicates a decision point and  is just a step on the path: .X.X.10000X .X*0X0XXX0X .XX0X0XM01. ...100XXXX.  There are three instances marked with  where Hermione must use her wand. Note: It is guaranteed that there is only one path from the starting location to the portkey.   Function Description  Complete the countLuck function in the editor below.  It should return a string, either  if Ron is correct or  if he is not.   countLuck has the following parameters:   matrix: a list of strings, each one represents a row of the matrix   k: an integer that represents Ron's guess   Input Format The first line contains an integer , the number of test cases. Each test case is described as follows:  The first line contains  space-separated integers  and , the number of forest matrix rows and columns.  Each of the next  lines contains a string of length  describing a row of the forest matrix.  The last line contains an integer , Ron's guess as to how many times Hermione will wave her wand. Constraints       There will be exactly one  and one  in the forest.   Exactly one path exists between  and . Output Format On a new line for each test case, print  if Ron impresses Hermione by guessing correctly.  Otherwise, print . Sample Input 3 2 3 *.M .X. 1 4 11 .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX. 3 4 11 .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX. 4  Sample Output Impressed Impressed Oops!  Explanation For each test case,  denotes the number of times Hermione waves her wand.     Case 0: Hermione waves her wand at , giving us . Because , we print  on a new line.  Case 1: Hermione waves her wand at , , and , giving us . Because , we print  on a new line.  Case 2: Hermione waves her wand at , , and , giving us . Because  and ,  and we print  on a new line.
__label__Binary-Search __label__Tree Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes with every node being colored. A color is represented by an integer ranging from 1 to 109. Can you find the number of distinct colors available in a subtree rooted at the node s?  Input Format  The first line contains three space separated integers representing the number of nodes in the tree (N), number of queries to answer (M) and the root of the tree.  In each of the next N-1 lines, there are two space separated integers(a b) representing an edge from node a to Node b and vice-versa.    N lines follow: N+ith line contains the color of the ith node. M lines follow: Each line containg a single integer s. Output Format  Output exactly M lines, each line containing the output of the ith query. Constraints  0 <= M <= 105 1 <= N <= 105 1 <= root <= N 1 <= color of the Node <= 109 Example Sample Input 4 2 1 1 2 2 4 2 3 10 20 20 30 1 2  Sample Output 3 2  Explanation Query 1-Subtree rooted at 1 is the entire tree and colors used are 10 20 20 30 , so the answer is 3(10,20 and 30) Query 2-Subtree rooted at 2 contains color 20 20 30, so the answer is 2(20 and 30)
__label__Array __label__Hash-Table Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order.    Example 1: Input: ["bella","label","roller"] Output: ["e","l","l"]   Example 2: Input: ["cool","lock","cook"] Output: ["c","o"]    Note:  1 <= A.length <= 100 1 <= A[i].length <= 100 A[i][j] is a lowercase letter
__label__Graph-Algorithms __label__Graph-Algorithms John lives in HackerLand, a country with  cities and  bidirectional roads. Each of the roads has a distinct length, and each length is a power of two (i.e.,  raised to some exponent). It's possible for John to reach any city from any other city. Given a map of HackerLand, can you help John determine the sum of the minimum distances between each pair of cities? Print your answer in binary representation.  Input Format The first line contains two space-seperated integers denoting  (the number of cities) and  (the number of roads), respectively.  Each line  of the  subsequent lines contains the respective values of , , and  as three space-separated integers. These values define a bidirectional road between cities  and  having length . Constraints   ,   If , then . Output Format Find the sum of minimum distances of each pair of cities and print the answer in binary representation.  Sample Input 5 6 1 3 5 4 5 0 2 1 3 3 2 1 4 3 4 4 2 2  Sample Output 1000100  Explanation In the sample, the country looks like this:  Let  be the minimum distance between city  and city .
__label__Dynamic-Programming In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.    Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”    Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
__label__Graph-Algorithms In the magical kingdom of Kasukabe, people strive to possess skillsets. Higher the number of skillset present among the people, the more content people will be.   There are  types of skill set present and initially there exists  people possessing  skill set, where .  There are  wizards in the kingdom and they have the ability to transform the skill set of a person into another skill set. Each of the these wizards has two lists of skill sets associated with them,  and . He can only transform the skill set of person whose initial skill set belongs to the list  to one of the final skill set which belongs to the list . That is, if  and  then following transformation can be done by that trainer.   Once a transformation is done, both skill is removed from the respective lists. In the above example, if he perform   transformation on a person, list  will be updated to  and list  will be . This updated list will be used for further transformations. Few points to note are: One person can possess only one skill set. A wizard can perform zero or more transformation as long as they satisfies the above criteria.  A person can go through multiple transformation of skill set. Same class transformation is also possible. That is a person' skill set can be transformed into his current skill set. Eg.  in the above example. Your goal is to design a series of transformation which results into maximum number of skill set with non-zero number of people knowing it. Input Format The first line contains two numbers, , where  represent the number of skill set and  represent the number of wizards.  Next line contains  space separated integers, ,  where  represents the number of people with  skill. Then follows  lines, where each pair of line represent the configuration of each wizard.  First line of the pair will start with the length of list  and followed by list  in the same line. Similarly second line of the pair starts with the length of list  and then the list .  Constraints                  Output Format The output must consist of one number, the maximum number of distinct skill set that can the people of country learn, after making optimal transformation steps. Sample Input 3 3 3 0 0 1 1 2 2 3 1 2 1 3 1 1 1 2   Sample Output 2    Explanation There are  types of skill sets present along with  wizards. Initially, all three people know the  skill set but no one knows the  and  skill sets.   The  wizard's initial lists are:  and . Suppose, he performs  transformation one any one of person with the  skill set, then it's list  will be updated to an empty list  and list  will be .  Now, we have two people knowing the  skill set and one person knowing the  skill set.   The  wizard's initial lists are:  and . He will use the transformation  one of the person with the  skill set, then it's lists will also be updated to an empty lists A:  and : .    Now, we have 1 person with  skillset and and 2 people knowing the  skillset.   The  wizard's initial lists are:  and . He will transform one of the person with  skillset to  one using the transformation . It's lists will also be updated to an empty lists A:  and : .  At this point, no further transformations are possible and we have achieved our maximum possible answer. Thus, each of the skill set, is known by  person.. This means there are three skill sets available in the kingdom.
__label__Mathematics __label__Tree In an infinite binary tree where every node has two children, the nodes are labelled in row order. In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.  Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.   Example 1: Input: label = 14 Output: [1,3,4,14]  Example 2: Input: label = 26 Output: [1,2,6,10,26]    Constraints:  1 <= label <= 10^6
__label__Hash-Table Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.
__label__Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]
__label__Dynamic-Programming Nikita just came up with a new array game. The rules are as follows: Initially, Nikita has an array of integers. Initially, Nikita has an array of integers. In each move, Nikita must partition the array into  non-empty contiguous parts such that the sum of the elements in the left partition is equal to the sum of the elements in the right partition. If Nikita can make such a move, she gets  point; otherwise, the game ends. In each move, Nikita must partition the array into  non-empty contiguous parts such that the sum of the elements in the left partition is equal to the sum of the elements in the right partition. If Nikita can make such a move, she gets  point; otherwise, the game ends. After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array . After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array . Nikita loves this game and wants your help getting the best score possible. Given , can you find and print the maximum number of points she can score? For example, Nikita starts with the array .  She first splits it into  and , then discards .  .  Discard  leaving .  This cannot be further split, so Nikita scored .    Function Description  Complete the arraySplitting function in the editor below.  It should return an integer that reperesents the number of times Nikita can split the array.   arraySplitting has the following parameter(s):   arr: an array of integers   Input Format The first line contains an integer , the number of test cases.  Each of the next  pairs of lines is as follows:   The first line contains an integer , the size of array . The next line contains  space-separated integers .   Constraints    Scoring   for  of the test data  for  of the test data  for  of the test data Output Format For each test case, print Nikita's maximum possible score on a new line. Sample Input 3 3 3 3 3 4 2 2 2 2 7 4 1 0 1 1 0 1  Sample Output 0 2 3  Explanation Test Case 0:  Nikita cannot partition  into  parts having equal sums. Therefore, her maximum possible score is  and we print  on a new line. Test Case 1:  Initially,  looks like this:   She splits the array into  partitions having equal sums, and then discards the left partition:     She then splits the new array into  partitions having equal sums, and then discards the left partition:        At this point the array only has  element and can no longer be partitioned, so the game ends. Because Nikita successfully split the array twice, she gets  points and we print  on a new line. Test Case 2: The answer is .
__label__Strings We are given that the string "abc" is valid. From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V.  (X or Y may be empty.)  Then, X + "abc" + Y is also valid. If for example S = "abc", then examples of valid strings are: "abc", "aabcbc", "abcabc", "abcabcababcc".  Examples of invalid strings are: "abccba", "ab", "cababc", "bac". Return true if and only if the given string S is valid.   Example 1: Input: "aabcbc" Output: true Explanation:  We start with the valid string "abc". Then we can insert another "abc" between "a" and "bc", resulting in "a" + "abc" + "bc" which is "aabcbc".   Example 2: Input: "abcabcababcc" Output: true Explanation:  "abcabcabc" is valid after consecutive insertings of "abc". Then we can insert "abc" before the last letter, resulting in "abcabcab" + "abc" + "c" which is "abcabcababcc".   Example 3: Input: "abccba" Output: false   Example 4: Input: "cababc" Output: false      Note:  1 <= S.length <= 20000 S[i] is 'a', 'b', or 'c'
__label__Greedy-Algorithms Given an array of stick lengths, use  of them to construct a non-degenerate triange with the maximum possible perimeter. Print the lengths of its sides as  space-separated integers in non-decreasing order. If there are several valid triangles having the maximum perimeter:  Choose the one with the longest maximum side.  If more than one has that maximum, choose from them the one with the longest minimum side.  If more than one has that maximum as well, print any one them. If no non-degenerate triangle exists, print -1. -1 For example, assume there are stick lengths .  The triplet  will not form a triangle.  Neither will  or , so the problem is reduced to  and .  The longer perimeter is .   Function Description  Complete the maximumPerimeterTriangle function in the editor below.  It should return an array of  integers that represent the side lengths of the chosen triangle in non-decreasing order.   maximumPerimeterTriangle has the following parameter(s):   sticks: an integer array that represents the lengths of sticks available   Input Format The first line contains single integer , the size of array .  The second line contains  space-separated integers , each a stick length. Constraints   Output Format Print the lengths of the  chosen sticks as space-separated integers in non-decreasing order. If no non-degenerate triangle can be formed, print -1. -1 Sample Input 0 Sample Output 0 Explanation 0 There are  possible unique triangles:     The second triangle has the largest perimeter, so we print its side lengths on a new line in non-decreasing order. Sample Input 1 Sample Output 1 Explanation 1 The triangle  is degenerate and thus can't be constructed, so we print -1 on a new line. -1 Sample Input 2 Sample Output 2 Explanation 2 The triangle (1,1,1) is the only valid triangle.
__label__Greedy-Algorithms You are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.) Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle's initial location. Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.    Example 1: Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false   Example 2: Input: trips = [[2,1,5],[3,3,7]], capacity = 5 Output: true   Example 3: Input: trips = [[2,1,5],[3,5,7]], capacity = 3 Output: true   Example 4: Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11 Output: true               Constraints:  trips.length <= 1000 trips[i].length == 3 1 <= trips[i][0] <= 100 0 <= trips[i][1] < trips[i][2] <= 1000 1 <= capacity <= 100000
__label__Dynamic-Programming __label__Tree __label__Depth-first-Search Given a binary tree, we install cameras on the nodes of the tree.  Each camera at a node can monitor its parent, itself, and its immediate children. Calculate the minimum number of cameras needed to monitor all nodes of the tree.   Example 1:   Input: [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown.   Example 2:  Input: [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.   Note:  The number of nodes in the given tree will be in the range [1, 1000]. Every node has value 0.
__label__Data-Structures You are given a square grid with some cells open (.) and some blocked (X).  Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell.  Given a grid, a start and an end position, determine the number of moves it will take to get to the end position.   For example, you are given a grid with sides  described as follows: ... .X. ...  Your starting position  so you start in the top left corner.  The ending position is .  The path is .  It takes  moves to get to the goal. Function Description  Complete the minimumMoves function in the editor.  It must print an integer denoting the minimum moves required to get from the starting position to the goal. minimumMoves has the following parameter(s): grid: an array of strings representing the rows of the grid   startX: an integer   startY: an integer   goalX: an integer   goalY: an integer   Input Format The first line contains an integer , the size of the array grid.  Each of the next  lines contains a string of length .  The last line contains four space-separated integers,   Constraints   Output Format Print an integer denoting the minimum number of steps required to move the castle to the goal position. Sample Input 3 .X. .X. ... 0 0 0 2  Sample Output 3  Explanation Here is a path that one could follow in order to reach the destination in  steps: .
__label__Greedy-Algorithms At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.
__label__Dynamic-Programming You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.
__label__Binary-Search Given a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order. If there is a tie,  the smaller elements are always preferred.  Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]   Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]   Note:  The value k is positive and will always be smaller than the length of the sorted array.  Length of the given array is positive and will not exceed 104  Absolute value of elements in the array and x will not exceed 104     UPDATE (2017/9/19): The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.
__label__Greedy-Algorithms Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.
__label__Mathematics Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1: Input: 5 Output: 2 Explanation: 5 = 5 = 2 + 3 Example 2: Input: 9 Output: 3 Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Note: 1 <= N <= 10 ^ 9.
__label__Tree Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Array __label__Tree __label__Depth-first-Search Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7
__label__Dynamic-Programming Watson gave Sherlock a collection of arrays . Here each  is an array of variable length. It is guaranteed that if you merge the arrays into one single array, you'll get an array, , of  distinct integers in the range .  Watson asks Sherlock to merge  into a sorted array. Sherlock is new to coding, but he accepts the challenge and writes the following algorithm:  (an empty array).  (an empty array).  number of arrays in the collection .  number of arrays in the collection . While there is at least one non-empty array in :  (an empty array) and . While : If  is not empty: Remove the first element of  and push it to . . While  is not empty: Remove the minimum element of  and push it to . While there is at least one non-empty array in :  (an empty array) and . While : If  is not empty: Remove the first element of  and push it to . . While : If  is not empty: Remove the first element of  and push it to . Remove the first element of  and push it to . . While  is not empty: Remove the minimum element of  and push it to . While  is not empty: Remove the minimum element of  and push it to . Return  as the output. Return  as the output. Let's see an example. Let V be .  The image below demonstrates how Sherlock will do the merging according to the algorithm:  Sherlock isn't sure if his algorithm is correct or not. He ran Watson's input, , through his pseudocode algorithm to produce an output, , that contains an array of  integers. However, Watson forgot the contents of  and only has Sherlock's  with him! Can you help Watson reverse-engineer  to get the original contents of ? Given , find the number of different ways to create collection  such that it produces  when given to Sherlock's algorithm as input. As this number can be quite large, print it modulo . Notes: Two collections of arrays are different if one of the following is true: Their sizes are different. Their sizes are the same but at least one array is present in one collection but not in the other. Two collections of arrays are different if one of the following is true: Their sizes are different. Their sizes are the same but at least one array is present in one collection but not in the other. Two arrays,  and , are different if one of the following is true: Their sizes are different. Their sizes are the same, but there exists an index  such that . Two arrays,  and , are different if one of the following is true: Their sizes are different. Their sizes are the same, but there exists an index  such that . Input Format The first line contains an integer, , denoting the size of array .  The second line contains  space-separated integers describing the respective values of . Constraints     Output Format Print the number of different ways to create collection , modulo . Sample Input 0 Sample Output 0 Explanation 0 There are four distinct possible collections:     . Thus, we print the result of  as our answer. Sample Input 1 Sample Output 1 Explanation 1 The only distinct possible collection is , so we print the result of  as our answer.
__label__Tree In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.   Example 1:  Input: root = [1,2,3,4], x = 4, y = 3 Output: false   Example 2:  Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true   Example 3:  Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false     Note:  The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100.
__label__Dynamic-Programming Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing. In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j]. If there is no way to make arr1 strictly increasing, return -1.   Example 1: Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4] Output: 1 Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].  Example 2: Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1] Output: 2 Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].  Example 3: Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3] Output: -1 Explanation: You can't make arr1 strictly increasing.   Constraints:  1 <= arr1.length, arr2.length <= 2000 0 <= arr1[i], arr2[i] <= 10^9
__label__Bit Consider the following pseudocode, run on an array  of length : Given the values of  and array , compute and print the final value of  after the pseudocode above terminates; if the loop will never terminate, print -1 instead. -1 Input Format The first line contains a single integer, , denoting the length of array .  The second line contains  space-separated integers describing the respective values of . Constraints    Output Format Print the final value of  after the pseudocode terminates; if the loop will never terminate, print -1 instead. -1 Sample Input 0 Sample Output 0 Explanation 0 After the first loop,  becomes . After the second loop, the array only contains 's and 's. After the third loop, the array only contains 's. After the fourth loop, the array is empty. Because the value of  is incremented after each loop,  at the time the loop terminates. Thus, we print 4 as our answer. 4
__label__Strings __label__Bit The SuperBowl Lottery is about to commence, and there are several lottery tickets being sold, and each ticket is identified with a ticket ID. In one of the many winning scenarios in the Superbowl lottery, a winning pair of tickets is: Concatenation of the two ticket IDs in the pair, in any order, contains each digit from  to  at least once. For example, if there are  distinct tickets with ticket ID  and ,  is a winning pair.  NOTE: The ticket IDs can be concantenated in any order. Digits in the ticket ID can occur in any order.  Your task is to find the number of winning pairs of distinct tickets, such that concatenation of their ticket IDs (in any order) makes for a winning scenario. Complete the function winningLotteryTicket which takes a string array of ticket IDs as input, and return the number of winning pairs.  winningLotteryTicket Input Format The first line contains  denoting the total number of lottery tickets in the super bowl.  Each of the next  lines contains a string, where string on a  line denotes the ticket id of the  ticket. Constraints   length of   sum of lengths of all  Each ticket id consists of digits from  Output Format Print the number of pairs in a new line. Sample Input 0 Sample Output 0 Explanation 0 Pairs of distinct tickets that make for a winning scenario are :  Notice that each winning pair has digits from  to  atleast once, and the digits in the ticket ID can be of any order. Thus, the number of winning pairs is .
__label__Graph-Algorithms Jenna is playing a computer game involving a large map with  cities numbered sequentially from  to  that are connected by  bidirectional roads. The game's objective is to travel to as many cities as possible without visiting any city more than once. The more cities the player visits, the more points they earn. As Jenna's fellow student at Hackerland University, she asks you for help choosing an optimal path. Given the map, can you help her find a path that maximizes her score? Note: She can start and end her path at any two distinct cities. Input Format The first line contains two space-separated integers describing the respective values of  (the number of cities) and  (the number of roads).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing a bidirectional road between cities  and . Map Generation Algorithm  The graph representing the map was generated randomly in the following way: Initially, the graph was empty. Permutations  were chosen uniformly at random among all  permutations. For each , edge  was added to the graph. An additional  edges were chosen uniformly at random among all possible sets of  edges which don't intersect with edges added during step . Constraints    For  of test  and . For  of test  and . For  of test  and . It's guaranteed that a valid path of length  always exists.  Scoring A valid path of length  earns  of a test case's available points. The total score will be rounded to next . Output Format Print the following two lines of output: The first line must contain a single integer, , denoting the length of the path. The second line must contain  distinct space-separated integers describing Jenna's path in the same order in which she visited each city. Sample Input 0 Sample Output 0 Explanation 0 The diagrams below depict the city's initial map, an optimal path that would earn a full score, and an alternative path that would earn a partial score:  In the optimal path (center image), Jenna walks the path . This answer earns  of the maximum score because the path length, , is equal to  (i.e., she was able to visit every city exactly once).  In the alternative path (right image), Jenna walks the path  for  of the maximum score.
__label__Array __label__Binary-Search A conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.   Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation:  A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10  Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.   Example 2: Input: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation:  A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4  Example 3: Input: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation:  1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1    Note:  1 <= D <= weights.length <= 50000 1 <= weights[i] <= 500
__label__Depth-first-Search There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.
__label__Mathematics Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
__label__Mathematics We distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies.   Example 1: Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].  Example 2: Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation:  On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3].    Constraints:  1 <= candies <= 10^9 1 <= num_people <= 1000
__label__Tree __label__Data-Structures __label__Mathematics __label__Advanced-Data-Structures Shashank loves trees and math. He has a rooted tree, , consisting of  nodes uniquely labeled with integers in the inclusive range . The node labeled as  is the root node of tree , and each node in  is associated with some positive integer value (all values are initially ).  Let's define  as the  Fibonacci number. Shashank wants to perform  types of operations over his tree, :    Update the subtree rooted at node  such that the node at level  in subtree  (i.e., node ) will have  added to it, all the nodes at level  will have  added to them, and so on. More formally, all the nodes at a distance  from node  in the subtree of node  will have the  Fibonacci number added to them.    Find the sum of all values associated with the nodes on the unique path from  to . Print your sum modulo  on a new line. Given the configuration for tree  and a list of  operations, perform all the operations efficiently. Note: . Input Format The first line contains  space-separated integers,  (the number of nodes in tree ) and  (the number of operations to be processed), respectively.  Each line  of the  subsequent lines contains an integer, , denoting the parent of the  node.  Each of the  subsequent lines contains one of the two types of operations mentioned in the Problem Statement above. Constraints    Output Format For each operation of type  (i.e., ), print the required answer modulo  on a new line. Sample Input 5 10 1 1 2 2 Q 1 5 U 1 1 Q 1 1 Q 1 2 Q 1 3 Q 1 4 Q 1 5 U 2 2 Q 2 3 Q 4 5  Sample Output 0 1 2 2 4 4 4 10  Explanation Intially, the tree looks like this:  After update operation , it looks like this:  After update operation , it looks like this:
__label__Mathematics __label__Binary-Search Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2  Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since               the decimal part is truncated, 2 is returned.
__label__Dynamic-Programming You are given a tree that has N vertices and N-1 edges. Your task is to mark as small number of vertices as possible, such that, the maximum distance between two unmarked vertices is less than or equal to K. Output this value. Distance between two vertices i and j is defined as the minimum number of edges you have to pass in order to reach vertex i from vertex j.   Input Format  The first line of input contains two integers N and K. The next N-1 lines contain two integers (ui,vi) each, where 1 <= ui,vi <= N. Each of these lines specifies an edge.  N is no more than 100. K is less than N.   Output Format  Print an integer that denotes the result of the test. Sample Input: 5 1   1 2   1 3   1 4   1 5  Sample Output: 3  Sample Input: 5 2   1 2   1 3   1 4   1 5  Sample Output: 0  Explanation: In the first case you have to mark at least 3 vertices, and in the second case you don't need to mark any vertices.
__label__Strings A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found here.   You are given n strings w[1], w[2], ......, w[n]. Let S[i] denote the set of all unique substrings of the string w[i]. Let , that is, S is a set of strings that is the union of all substrings in all sets S[1], S[2], ..... S[n]. There will be many queries.  For each query you will be given an integer 'k'. Your task is to find the kth element of the -indexed lexicographically ordered set of substrings in the set S.  If there is no element , return INVALID.   For example, your strings are .  All of the substrings are  and .  Combine the two sets and sort them to get .  So, for instance if , we return 'a'.  If , we return 'bc'.  If  though, there is not an  so we return INVALID. Function Description  Complete the findStrings function in the editor below.  It should return array of strings.   findStrings has the following parameter(s):   w: an array of strings   queries: an array of integers   Input Format The first line contains an integer n, the number of strings in the array .  Each of the next n lines consists of a string .  The next line contains an integer q, the number of queries.  Each of the next q lines consists of a single integer k. Constraints         Each character of   Output Format Return an array of q strings where the ith string is the answer to the ith query. If a  is invalid, return "INVALID" for that case. Sample Input 2  aab  aac  3  3  8  23   Sample Output aab  c  INVALID   Explanation For the sample test case, we have 2 strings "aab" and "aac".  S1 = {"a", "aa", "aab", "ab", "b"} . These are the 5 unique substrings of "aab".  S2 = {"a", "aa", "aac",  "ac", "c" } . These are the 5 unique substrings of "aac".  Now, S = {S1 U S2} = {"a", "aa", "aab", "aac", "ab", "ac", "b", "c"}. Totally, 8 unique strings are present in the set S.  The lexicographically 3rd smallest string in S is "aab" and the lexicographically 8th smallest string in S is "c". Since there are only 8 distinct substrings, the answer to the last query is "INVALID".
__label__Strings Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.
__label__Strings For strings S and T, we say "T divides S" if and only if S = T + ... + T  (T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2.   Example 1: Input: str1 = "ABCABC", str2 = "ABC" Output: "ABC"  Example 2: Input: str1 = "ABABAB", str2 = "ABAB" Output: "AB"  Example 3: Input: str1 = "LEET", str2 = "CODE" Output: ""    Note:  1 <= str1.length <= 1000 1 <= str2.length <= 1000 str1[i] and str2[i] are English uppercase letters.
__label__Depth-first-Search On a 2-dimensional grid, there are 4 types of squares:  1 represents the starting square.  There is exactly one starting square. 2 represents the ending square.  There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over.  Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.    Example 1: Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths:  1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)  Example 2: Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths:  1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)  Example 3: Input: [[0,1],[2,0]] Output: 0 Explanation:  There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid.       Note:  1 <= grid.length * grid[0].length <= 20
__label__Graph-Algorithms You are given  unweighted, undirected graphs, , , and , with  vertices each, where the  graph has  edges and the vertices in each graph are numbered from  through . Find the number of ordered triples , where , , such that there is an edge  in , an edge  in , and an edge  in . Input Format The first line contains single integer, , denoting the number of vertices in the graphs. The subsequent lines define , , and . Each graph is defined as follows: The first line contains an integer, , describing the number of edges in the graph being defined. Each line  of the  subsequent lines (where ) contains  space-separated integers describing the respective nodes,  and  connected by edge . Constraints  , and  Each graph contains no cycles and any pair of directly connected nodes is connected by a maximum of  edge. Output Format Print a single integer denoting the number of distinct  triples as described in the Problem Statement above. Sample Input 3 2 1 2 2 3 3 1 2 1 3 2 3 2 1 3 2 3  Sample Output 3  Explanation There are three possible triples in our Sample Input:     Thus, we print  as our output.
__label__Hash-Table Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.
__label__Greedy-Algorithms We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score.      Example 1: Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]]. 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39   Note:  1 <= A.length <= 20 1 <= A[0].length <= 20 A[i][j] is 0 or 1.
