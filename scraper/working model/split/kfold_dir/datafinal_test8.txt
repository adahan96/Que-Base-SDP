__label__Tree __label__Data-Structures You are given a pointer to the root of a binary tree. You need to print the level order traversal of this tree. In level order traversal, we visit the nodes level by level from left to right.  You only have to complete the function.  For example:      1       \        2         \          5         /  \        3    6         \          4    For the above tree, the level order traversal is 1 -> 2 -> 5 -> 3 -> 6 -> 4. Input Format You are given a function, void levelOrder(Node * root) {  }  Constraints 1 Nodes in the tree   500 Output Format Print the values in a single line separated by a space. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 5 3 6 4 Explanation We need to print the nodes level by level. We process each level from left to right.  Level Order Traversal: 1 -> 2 -> 5 -> 3 -> 6 -> 4.
__label__Graph-Algorithms A tree of  nodes is an un-directed connected graph having  edges. Let us denote  as the root node. If  is a node such that it is at a distance of  from , and  is a node such that it is at at distance of  from   and  is connected to , then we call  as the parent of .  Similarly, if  is at a distance of  from  and  is at a distance of  from  and there is a path of length  from  to , then we call  as the th parent of .  Susan likes to play with graphs and Tree data structure is one of her favorites. She has designed a problem and wants to know if anyone can solve it. Sometimes she adds or removes a leaf node. Your task is to figure out the th parent of a node at any instant. Input Format The first line contain an integer  denoting the number of test cases.  test cases follow. First line of each test case contains an integer , the number of nodes in the tree.  lines follows each containing two integers  and  separated by a single space denoting  as the parent of . If  is , then X is the root node of the tree.  ( is for namesake and is not in the tree).  The next line contains an integer , the number of queries.   lines follow each containing a query.       :  is added as a new leaf node whose parent is  .  is not in the tree while  is in.        : This tells that leaf node  is removed from the tree.  is a leaf in the tree.       : In this query output the th parent of  .  is a node in the tree.  Note  Each node index is any number between 1 and 105 i.e., a tree with a single node can have its root indexed as 105 Constraints             Output Format For each query of type , output the th parent of . If th parent doesn't exist, output  and if the node doesn't exist, output . Sample Input 2 7 2 0 5 2 3 5 7 5 9 8 8 2 6 8 10 0 5 15 2 15 2 1 3 0 15 20 0 20 13 2 13 4 2 13 3 2 6 10 2 11 1 2 9 1 1 10000 0 3 0 10000 4 1 4 2 4 1  Sample Output 2 2 5 0 0 8 0  Explanation There are 2 test cases. The first test case has 7 nodes with 2 as its root. There are 10 queries 0 5 15 -> 15 is added as a leaf node to 5.  2 15 2 -> 2nd parent of 15 is 15->5->2 is 2.  1 3 -> leaf node 3 is removed from the tree.  0 15 20 -> 20 is added as a leaf node to 15.  0 20 13 -> 13 is added as a leaf node to 20. 2 13 4 -> 4th parent of 13 is 2.  2 13 3 -> 3rd parent of 13 is 5. 2 6 10 -> there is no 10th parent of 6 and hence 0.  2 11 1 -> 11 is not a node in the tree, hence 0. 2 9 1 -> 9's parent is 8.   the second testcase has a tree with only 1 node (10000).  0 10000 4 -> 4 is added as a leaf node to 10000. 1 4 -> 4 is removed.  2 4 1 -> as 4 is already removed, answer is 0.
__label__Data-Structures Transforming data into some other data is typical of a programming job. This problem is about a particular kind of transformation which we'll call the max transform. Let  be a zero-indexed array of integers. For , let  denote the subarray of  from index  to index , inclusive. Let's define the max transform of  as the array obtained by the following procedure: Let  be a list, initially empty. For  from  to : For  from  to : Let .   Append  to the end of .   For  from  to : Let .   Append  to the end of .   Let .   Append  to the end of .   Return .   The returned array is defined as the max transform of . We denote it by .  Complete the function solve that takes an integer array  as input. solve Given an array , find the sum of the elements of , i.e., the max transform of the max transform of . Since the answer may be very large, only find it modulo .   Input Format The first line of input contains a single integer  denoting the length of .   The second line contains  space-separated integers  denoting the elements of .   Constraints     Subtasks  For  of the total score,   Output Format Print a single line containing a single integer denoting the answer.   Sample Input 0 Sample Output 0 Explanation 0 In the sample case, we have:   Therefore, the sum of the elements of  is .
__label__Hash-Table Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1: Input:  words = ["w","wo","wor","worl", "world"] Output: "world" Explanation:  The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".   Example 2: Input:  words = ["a", "banana", "app", "appl", "ap", "apply", "apple"] Output: "apple" Explanation:  Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".   Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30].
__label__Array The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0,   F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N > 1.  Given N, calculate F(N).   Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.  Example 2: Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.  Example 3: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.    Note: 0 ≤ N ≤ 30.
__label__Dynamic-Programming __label__Strings Steve loves playing with palindromes. He has a string, , consisting of  lowercase English alphabetic characters (i.e., a through z). He wants to calculate the number of ways to insert exactly  lowercase character into string  such that the length of the longest palindromic subsequence of  increases by at least . Two ways are considered to be different if either of the following conditions are satisfied: a z The positions of insertion are different. The inserted characters are different.  This means there are at most  different ways to insert exactly  character into a string of length . Given  queries consisting of , , and , print the number of different ways of inserting exactly  new lowercase letter into string  such that the length of the longest palindromic subsequence of  increases by at least . Input Format The first line contains a single integer, , denoting the number of queries. The  subsequent lines describe each query over two lines: The first line of a query contains two space-separated integers denoting the respective values of  and .    The second line contains a single string denoting . Constraints    It is guaranteed that  consists of lowercase English alphabetic letters (i.e., a to z) only. a z Subtasks  for  of the maximum score.  for  of the maximum score. Output Format On a new line for each query, print the number of ways to insert exactly  new lowercase letter into string  such that the length of the longest palindromic subsequence of  increases by at least . Sample Input 3 1 1 a 3 2 aab 3 0 aba  Sample Output 2 1 104  Explanation We perform the following  queries: The length of the longest palindromic subsequence of  a is . There are two ways to increase this string's length by at least : Insert an a at the start of string , making it aa. Insert an a at the end of string , making it aa.       Both methods result in aa, which has a longest palindromic subsequence of length  (which is longer than the original longest palindromic subsequence's length by ). Because there are two such ways, we print  on a new line. The length of the longest palindromic subsequence of  a is . There are two ways to increase this string's length by at least : a Insert an a at the start of string , making it aa. a aa Insert an a at the end of string , making it aa.       a aa Both methods result in aa, which has a longest palindromic subsequence of length  (which is longer than the original longest palindromic subsequence's length by ). Because there are two such ways, we print  on a new line. aa The length of the longest palindromic subsequence of  aab is . There is one way to increase the length by at least : Insert a b at the start of string , making it baab.    We only have one possible string, baab, and the length of its longest palindromic subsequence is  (which is longer than the original longest palindromic subsequence's length by ). Because there is one such way, we print  on a new line. The length of the longest palindromic subsequence of  aab is . There is one way to increase the length by at least : aab Insert a b at the start of string , making it baab.    b baab We only have one possible string, baab, and the length of its longest palindromic subsequence is  (which is longer than the original longest palindromic subsequence's length by ). Because there is one such way, we print  on a new line. baab
__label__Dynamic-Programming __label__Mathematics Given an integer, , find the smallest integer  such that  is divisible by  (i.e.,  is a factor of ) and satisfies the following properties:  must not contain zeroes in its decimal representation.  The sum of 's digits must be greater than or equal to the product of 's digits.  Given , find  and print the number of digits in 's decimal representation.  Input Format A single integer denoting . Constraints   is not divisible by . Time Limits The time limits for this challenge are available here. Output Format Print the number of digits in the decimal representation of the smallest possible . Sample Input 0 Sample Output 0 Explanation 0  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in  (which also happens to be ) as our answer. Sample Input 1 Sample Output 1 Explanation 1  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in , which is , as our answer.
__label__Strings The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I
__label__Data-Structures Consider an array of integers, . We define the absolute difference between two elements,  and  (where ), to be the absolute value of . Given an array of integers, find and print the minimum absolute difference between any two elements in the array.  For example, given the array  we can create  pairs of numbers:  and .  The absolute differences for these pairs are ,  and .  The minimum absolute difference is . Function Description  Complete the minimumAbsoluteDifference function in the editor below.  It should return an integer that represents the minimum absolute difference between any pair of elements.   minimumAbsoluteDifference has the following parameter(s):   n: an integer that represents the length of arr  arr: an array of integers   Input Format The first line contains a single integer , the size of .  The second line contains  space-separated integers .    Constraints     Output Format Print the minimum absolute difference between any two elements in the array. Sample Input 0 Sample Output 0 Explanation 0 With  integers in our array, we have three possible pairs: , , and . The absolute values of the differences between these pairs are as follows:       Notice that if we were to switch the order of the numbers in these pairs, the resulting absolute values would still be the same. The smallest of these possible absolute differences is . Sample Input 1 Sample Output 1 Explanation 1 The smallest absolute difference is . Sample Input 2 Sample Output 2 Explanation 2 The minimum absolute difference is .
__label__Array Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10
__label__Mathematics Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion?
__label__Array __label__Hash-Table Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true
__label__Graph-Algorithms You are given a table, , with  rows and  columns. The top-left corner of the table has coordinates , and the bottom-right corner has coordinates . The  cell contains integer . A path in the table is a sequence of cells  such that for each , cell  and cell  share a side.  The weight of the path  is defined by  where  is the weight of the cell . You must answer  queries. In each query, you are given the coordinates of two cells,  and . You must find and print the minimum possible weight of a path connecting them. Note: A cell can share sides with at most  other cells. A cell with coordinates  shares sides with , ,  and . Input Format The first line contains  space-separated integers,  (the number of rows in ) and  (the number of columns in ), respectively.  Each of  subsequent lines contains  space-separated integers. The  integer in the  line denotes the value of .  The next line contains a single integer, , denoting the number of queries.  Each of the  subsequent lines describes a query in the form of  space-separated integers: , , , and , respectively.  Constraints     For each query:   Output Format On a new line for each query, print a single integer denoting the minimum possible weight of a path between  and . Sample Input 3 5 0 0 0 0 0 1 9 9 9 1 0 0 0 0 0 3 0 0 2 4 0 3 2 3 1 1 1 3  Sample Output 1 1 18  Explanation The input table looks like this:  The first two queries are explained below: In the first query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is . In the first query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is . In the second query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is .
__label__Hash-Table On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp. Initially, some number of lamps are on.  lamps[i] tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess). For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0. After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).) Return an array of answers.  Each value answer[i] should be equal to the answer of the i-th query queries[i].   Example 1: Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]] Output: [1,0] Explanation:  Before performing the first query we have both lamps [0,0] and [4,4] on. The grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner: 1 1 1 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1 Then the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this: 1 0 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 1 1 Before performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.    Note:  1 <= N <= 10^9 0 <= lamps.length <= 20000 0 <= queries.length <= 20000 lamps[i].length == queries[i].length == 2
__label__Data-Structures Given two numbers  and .  indicates the number of elements in the array  and  indicates number of queries. You need to perform two types of queries on the array .   You are given  queries. Queries can be of two types, type 1 and type 2.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.   1 i j Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.   2 i j Your task is to simply print  of the resulting array after the execution of  queries followed by the resulting array.   Note While adding at back or front the order of elements is preserved.   Input Format First line consists of two space-separated integers,  and .  Second line contains  integers, which represent the elements of the array.   queries follow. Each line contains a query of either type 1 or type 2 in the form   Constraints       Output Format Print the absolute value i.e.  in the first line.  Print elements of the resulting array in the second line. Each element should be seperated by a single space. Sample Input 8 4 1 2 3 4 5 6 7 8 1 2 4 2 3 5 1 4 7 2 1 4  Sample Output 1 2 3 6 5 7 8 4 1  Explanation Given array is .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  After execution of query , the array becomes .  Now  is  i.e.  and the array is
__label__Strings __label__Greedy-Algorithms Given a string, , we define some operations on the string as follows: a.  denotes the string obtained by reversing string . Example:    b.  denotes any string that's a permutation of string . Example:    c.  denotes any string that's obtained by interspersing the two strings  & , maintaining the order of characters in both. For example,  & , one possible result of  could be , another could be , another could be  and so on.   Given a string  such that  for some string , find the lexicographically smallest . For example, .  We can split it into two strings of .  The reverse is  and we need to find a string to shuffle in to get .  The middle two characters match our reverse string, leaving the  and  at the ends.  Our shuffle string needs to be .  Lexicographically , so our answer is .   Function Description Complete the reverseShuffleMerge function in the editor below.  It must return the lexicographically smallest string fitting the criteria.   reverseShuffleMerge has the following parameter(s): s: a string Input Format A single line containing the string . Constraints  contains only lower-case English letters, ascii[a-z]    Output Format Find and return the string which is the lexicographically smallest valid . Sample Input 0 Sample Output 0 Explanation 0 Split "eggegg" into strings of like character counts: "egg", "egg"  reverse("egg") = "gge"  shuffle("egg") can be "egg"  "eggegg" belongs to the merge of ("gge", "egg") The merge is: gge. 'egg' < 'gge' Sample Input 1 Sample Output 1 Explanation 1 Split the string into two strings with like characters:  and .  Reverse  =   Shuffle  can be   Merge to bcdefga  Sample Input 2 Sample Output 2 Explanation 2 Split the string into groups of like characters:   Reverse  =   These merge to uoiea
__label__Array We have an array A of integers, and an array queries of queries. For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A. (Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.) Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.   Example 1: Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation:  At the beginning, the array is [1,2,3,4]. After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6. After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2. After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.    Note:  1 <= A.length <= 10000 -10000 <= A[i] <= 10000 1 <= queries.length <= 10000 -10000 <= queries[i][0] <= 10000 0 <= queries[i][1] < A.length
__label__Dynamic-Programming __label__Strings String  is called a Super String if and only if:  contains only letters ; For any  and ,  has lower ascii code than , where  Given a set of Super Strings , a Hyper String is a string that can be constructed by concatenation of some Super Strings of the set . We can use each Super String as many times as we want. Given set , you have to compute the number of Hyper Strings with length no greater than .   Input Format The first line of input contains two integers,  (the number of Super Strings in ) and . The next  lines describe the Super Strings in set .   Constraints  and  are not greater than . Output Format Output an integer which is the number of possible Hyper Strings that can be derived. Since it may not fit in  bit integer, print the output module . (i.e. answer = answer % ) Sample Input 2 3   a   ab  Sample Output 7  Explanation In the example all the Hyper Strings are : "" (empty string), "", "", "", "", "", and "".
__label__Tree Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its preorder traversal as: [1,3,5,6,2,4].   Note: Recursive solution is trivial, could you do it iteratively?
__label__Greedy-Algorithms Alice gives Bob a board composed of  wooden squares and asks him to find the minimum cost of breaking the board back down into its individual squares. To break the board down, Bob must make cuts along its horizontal and vertical lines.  To reduce the board to squares, Bob makes horizontal and vertical cuts across the entire board.  Each cut has a given cost,  or  for each cut along a row or column across one board, so the cost of a cut must be multiplied by the number of segments it crosses.  The cost of cutting the whole board down into  squares is the sum of the costs of each successive cut.    Can you help Bob find the minimum cost?  The number may be large, so print the value modulo . For example, you start with a  board.  There are two cuts to be made at a cost of  for the horizontal and  for the vertical.  Your first cut is across  piece, the whole board.  You choose to make the horizontal cut between rows  and  for a cost of .  The second cuts are vertical through the two smaller boards created in step  between columns  and .  Their cost is .  The total cost is  and . Function Description  Complete the boardCutting function in the editor below.  It should return an integer.   boardCutting has the following parameter(s):   cost_x: an array of integers, the costs of vertical cuts   cost_y: an array of integers, the costs of horizontal cuts   Input Format The first line contains an integer , the number of queries. The following  sets of lines are as follows: The first line has two positive space-separated integers  and , the number of rows and columns in the board.     The second line contains  space-separated integers cost_y[i], the cost of a  horizontal cut between rows  and  of one board. The third line contains  space-separated integers cost_x[j], the cost of a vertical cut between columns  and  of one board. Constraints       Output Format For each of the  queries, find the minimum cost () of cutting the board into  squares and print the value of . Sample Input 0 1 2 2 2 1  Sample Output 0 4  Explanation 0  We have a  board, with cut costs  and . Our first cut is horizontal between  and , because that is the line with the highest cost (). Our second cut is vertical, at . Our first cut has a  of  because we are making a cut with cost  across  segment, the uncut board. The second cut also has a  of  but we are making a cut of cost  across  segments. Our answer is . Sample Input 1 1 6 4 2 1 3 1 4 4 1 2  Sample Output 1  42  Explanation 1  Our sequence of cuts is: , , , , , ,  and .  Cut 1: Horizontal with cost  across  segment. .  Cut 2: Vertical with cost  across  segments. .  Cut 3: Horizontal with cost  across  segments. .  Cut 4: Horizontal with cost  across  segments. .  Cut 5: Vertical with cost  across  segments. .  Cut 6: Horizontal with cost  across  segments. .  Cut 7: Horizontal with cost  across  segments. .  Cut 8: Vertical with cost  across  segments. .       . We then print the value of .
__label__Array Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000
__label__Hash-Table Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.
__label__Dynamic-Programming We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.
__label__Data-Structures Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value  and insert it into a sorted linked list while maintaining the sort. Function Description Complete the sortedInsert function in the editor below. It must return a reference to the head of your modified DoublyLinkedList. sortedInsert has two parameters: head: A reference to the head of a doubly-linked list of DoublyLinkedListNode objects. data: An integer denoting the value of the  field for the DoublyLinkedListNode you must insert into the list. Note: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.  Input Format The first line contains an integer , the number of test cases. Each of the test case is in the following format:   The first line contains an integer , the number of elements in the linked list.   Each of the next  lines contains an integer, the data for each node of the linked list.   The last line contains an integer  which needs to be inserted into the sorted doubly-linked list. Constraints      Output Format Do not print anything to stdout. Your method must return a reference to the  of the same list that was passed to it as a parameter. The ouput is handled by the code in the editor and is as follows:  For each test case, print the elements of the sorted doubly-linked list separated by spaces on a new line.   Sample Input 1 4 1 3 4 10 5  Sample Output 1 3 4 5 10  Explanation The initial doubly linked list is:  .  The doubly linked list after insertion is:
__label__Dynamic-Programming HackerRank-city is an acyclic connected graph (or tree). Its not an ordinary place, the construction of the whole tree takes place in  steps. The process is described below: It initially has  node. At each step, you must create  duplicates of the current tree, and create  new nodes to connect all  copies in the following H shape: H  At each  step, the tree becomes  times bigger plus  new nodes, as well as  new edges connecting everything together. The length of the new edges being added at step  is denoted by input . Calculate the sum of distances between each pair of nodes; as these answers may run large, print your answer modulo . Input Format The first line contains an integer,  (the number of steps). The second line contains  space-separated integers describing  , . Constraints   Subtask  For  score  Output Format Print the sum of distances between each pair of nodes modulo . Sample Input 0 1 1  Sample Output 0 29  Sample Input 1 2 2 1  Sample Output 1 2641  Explanation Sample 0 In this example, our tree looks like this:  Let  denote the distance between nodes  and .    .      We print the result of  as our answer. Sample 1 In this example, our tree looks like this:  We calculate and sum the distances between nodes in the same manner as Sample 0 above, and print the result of our , which is .
__label__Hash-Table Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0. Return the maximum number of rows that have all values equal after some number of flips.      Example 1: Input: [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal.   Example 2: Input: [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values.   Example 3: Input: [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values.    Note:  1 <= matrix.length <= 300 1 <= matrix[i].length <= 300 All matrix[i].length's are equal matrix[i][j] is 0 or 1
__label__Graph-Algorithms __label__Tree It has been a prosperous year for King Charles and he is rapidly expanding his empire. In fact, he recently invaded his neighboring country and set up a new kingdom! This kingdom has many cities connected by one-way roads. To ensure higher connectivity, two cities are sometimes directly linked by more than one road. In the new kingdom, King Charles has made one of the cities his financial capital and another city his warfare capital. He wants a better connectivity between these two capitals. The connectivity of a pair of cities,  and , is defined as the number of different paths from city  to city . A path may use a road more than once if possible. Two paths are considered different if they do not use the same sequence of roads the same number of times. There are  cities numbered  to  in the new kingdom and  one-way roads. City  is the financial capital and city  is the warfare capital.  Determine the number of different paths between cities  and . Since the number may be large, print the result modulo  or .    Note: Two roads may connect the same cities, but they are still considered distinct for path connections.  For example, there are  cities connected by  roads as shown in the following graph:   There are two direct paths and one cyclic path.  Direct paths are  and  and 4 \rightarrow 53 \leftrightarrow 44 \rightarrow 3$ did not exist, there would be only the two direct paths. Function Description Complete the countPaths function in the editor below.  It should print your result, modulo  if there are limited paths or INFINITE PATHS if they are unlimited. There is no expected return value.    INFINITE PATHS countPaths has the following parameters:  - n: the integer number of cities  - edges: a 2D integer array where  is the source city and  is the destination city for the directed road   Input Format The first line contains two integers  and .  Each of the following  lines contains two space-separated integers that represent source and destination cities for a directed connection. Constraints       Output Format Print the number of different paths from city  to city  modulo . If there are infinitely many different paths, print INFINITE PATHS. INFINITE PATHS Sample Input Sample Input 0  5 5   1 2   2 4   2 3   3 4   4 5  Sample Output 0  2  Explanation 0  There are two possible paths from city  to city :      Sample Input 1  5 5   1 2   4 2   2 3   3 4   4 5  Sample Output 1  INFINITE PATHS   Explanation 1   The cycle in the graph can be traversed an infinite number of times on the way to city .
__label__Strings Given a string s, return the last substring of s in lexicographical order.   Example 1: Input: "abab" Output: "bab" Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".  Example 2: Input: "leetcode" Output: "tcode"    Note:  1 <= s.length <= 4 * 10^5 s contains only lowercase English letters.
__label__Data-Structures Kundu is true tree lover. Tree is a connected graph having N vertices and N-1  edges. Today when he got a tree, he colored each edge with one of either red(r) or black(b) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex a to b, vertex b to c and vertex c to a . Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet.  r b If the answer is greater than 109 + 7, print the answer modulo (%) 109 + 7. Input Format  The first line contains an integer N, i.e., the number of vertices in tree.  The next N-1 lines represent edges:  2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(r) or black(b).   r b Output Format  Print a single number i.e. the number of triplets.   Constraints  1 ≤ N ≤ 105  A node is numbered between 1 to N.   Sample Input  5 1 2 b 2 3 r 3 4 r 4 5 b  Sample Output  4  Explanation Given tree is something like this.  (2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color. (2,3,5), (1,3,4) and (1,3,5) are other such triplets.  Note that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.
__label__Array Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.
__label__Mathematics __label__Binary-Search Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false
__label__Hash-Table __label__Binary-Search Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
__label__Mathematics __label__Greedy-Algorithms On a broken calculator that has a number showing on its display, we can perform two operations:  Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display.  Initially, the calculator is displaying the number X. Return the minimum number of operations needed to display the number Y.   Example 1: Input: X = 2, Y = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.  Example 2: Input: X = 5, Y = 8 Output: 2 Explanation: Use decrement and then double {5 -> 4 -> 8}.  Example 3: Input: X = 3, Y = 10 Output: 3 Explanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.  Example 4: Input: X = 1024, Y = 1 Output: 1023 Explanation: Use decrement operations 1023 times.    Note:  1 <= X <= 10^9 1 <= Y <= 10^9
__label__Array __label__Mathematics Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6    Example 2: Input: [1,2,3,4] Output: 24    Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.
__label__Dynamic-Programming You are given a sequence of integers a1,a2,a3.....an. You are free to replace any integer with any other positive integer. How many integers must be replaced to make the resulting sequence strictly increasing?  Input Format  The first line of the test case contains an integer  - the number of entries in the sequence.  The next line contains  space separated integers where the  integer is . Output Format  Output the minimal number of integers that should be replaced to make the sequence strictly increasing. Constraints      Sample Input #00 3 4 10 20  Sample Output #00 0  Sample Input #01 6 1 7 10 2 20 22  Sample Output #01 1  Sample Input #02 5 1 2 2 3 4   Sample Output #02 3  Explanation  In the first sample input, we need not replace anything, hence the output is 0.  In the second sample input, we can replace 2 with any integer between 11 and 19 to make the sequence strictly increasing, hence the output is 1.  In the third sample input, we can obtain 1, 2, 3, 4, 5 by changing the last three elements of the sequence.
__label__Dynamic-Programming Tim is visiting his grandma for two days and is bored due to the lack of the electricity over there. That's why he starts to play with grandma's colorful candle collection. He aligned the  candles from left to right. The th candle from the left has the height  and the color , an integer ranged from 1 to a given , the number of colors.  Now he stares at the sequence of candles and wonders, how many strictly increasing ( in height ) colorful subsequences are there? A subsequence is considered as colorful if every of the  colors appears at least one times in the subsequence.  As the number of subsequences fulfilling the requirement can be large, print the result modulo . Input Format On the first line you will be given  and , then  lines will follow. On the th line you will be given two integers  and .  Constraints    Output Format Print the number of strictly increasing colorful subsequences modulo .  Sample Input 4 3 1 1 3 2 2 2 4 3  Sample Output 2  Explanation In the first sample the only two valid subsequences are (1, 2, 4) and (1, 3, 4).
__label__Array Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".  Note:  All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].
__label__Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.
__label__Mathematics Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701
__label__Graph-Algorithms __label__Graph-Algorithms Dave is a die-hard fan of a show called "HackerRank", in which a young programmer uses her problem-solving abilities to solve crimes. He splurged on a Digital Video Recorder (DVR) so that he can record HackerRank episodes and watch them later. Luckily, Dave managed to get his hands on schedules for all the episodes in each upcoming season. Each season has  episodes numbered from  to . Each episode airs twice; the first time it's called "live", and the second time it's called "repeat". So, for each episode, we have  integers,  and  for the live airing and  and  for the repeat airing, where  is episode's start time and and  is its end time. All times are given as integers representing the number of minutes passed since the start of the season. Episodes broadcast on multiple channels, so some of the air times overlap and the episodes may not broadcast sequentially. It's possible that both the live and repeat broadcasts of some episode  are held before episode , even though . In addition, live and repeat broadcasts of the same episode may differ in length due to the number of advertisements during the broadcast.  Dave only has one TV with a DVR attached to it, and the DVR is capable of recording one episode at a time. For each episode in a season, Dave first decides whether or not he will record it. If he decides to record it, he will either record it during  or . Dave will only ever record one of the two airings of an episode, and he always records full episodes. This means that once he starts recording an episode, he will always record it until the end (i.e., he never records partial episodes).  Dave realizes that it might not be possible for him to record all episodes successfully, so instead of focusing on recording all episodes of HackerRank (which may be impossible), he decides to record all consecutively airing episodes whose episode number occurs in some inclusive  interval such that  (i.e., the number of consecutive episodes recorded) is as large as possible.    Given the programming schedule for each season, find  and  episode numbers for largest range of consecutive episodes Dave can record during that season and print these respective values as two space-separated integers on a new line. If two or more such intervals exist, choose the one having the smallest  value. Input Format The first line contains a single positive integer, , denoting number of seasons of HackerRank.  The subsequent lines describe each of the  seasons in the following format: The first line contains an integer, , denoting the number of episodes in the season. Each line  of the  subsequent line contains four space-separated integers describing the respective values of , , , and . Constraints       Output Format On a new line for each season, print two space-separated integers denoting the respective  and  (inclusive) values for the maximum possible range of consecutive episodes Dave can record such that  is as large as possible. If more than one such interval exists, choose the interval having the smallest . Sample Input 3 3 10 20 30 40 20 35 21 35 14 30 35 50 1 10 20 30 40 3 11 19 31 39 12 38 13 37 10 20 30 40  Sample Output 1 2 1 1 1 1  Explanation For the first season, Dave records the live airing of episode  and the repeat airing of episode . Note that it is not possible to record episodes ,  and  simultaneously. For the second season, there is only one episode so Dave records from episode  to episode  and we print 1 1 on a new line. 1 1 For the third season, Dave must choose to record either episode  or episode  (episode  starts while episode  is still airing and ends after episode  starts); he cannot record both, because he only wants to record consecutive episodes. Thus, we pick the episode with the smallest  value, which is episode , and print 1 1 as we are only recording episode . 1 1
__label__Depth-first-Search There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.
__label__Array __label__Binary-Search Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.  Example 1: Input: nums = [1,3,1] k = 1 Output: 0  Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.   Note:  2 <= len(nums) <= 10000. 0 <= nums[i] < 1000000. 1 <= k <= len(nums) * (len(nums) - 1) / 2.
__label__Hash-Table __label__Strings Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.
__label__Greedy-Algorithms You have an initial power P, an initial score of 0 points, and a bag of tokens. Each token can be used at most once, has a value token[i], and has potentially two ways to use it.  If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point. If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.  Return the largest number of points we can have after playing any number of tokens.      Example 1: Input: tokens = [100], P = 50 Output: 0   Example 2: Input: tokens = [100,200], P = 150 Output: 1   Example 3: Input: tokens = [100,200,300,400], P = 200 Output: 2    Note:  tokens.length <= 1000 0 <= tokens[i] < 10000 0 <= P < 10000
__label__Search Quality Blimps Inc. is looking to expand their sales to other cities (), so they hired you as a salesman to fly to other cities to sell blimps. Blimps can be expensive to travel with, so you will need to determine how many blimps to take along with you on each trip and when to return to headquarters to get more. Quality Blimps has an unlimited supply of blimps.  You will be able to sell only one blimp in each city you visit, but you do not need to visit every city, since some have expensive travel costs. Each city has an initial price that blimps sell for, but this goes down by a certain percentage as more blimps are sold (and the novelty wears off). Find a good route that will maximize profits.  Details Blimp Decline  - The blimps will decline () in price every time you visit  of the cities (the number of cities will always be a multiple of ). For example, if  is  and there are  cities, then for every city you visit (except headquarters), the price of blimps will be multiplied by . So after  visits, every city's blimp price will be about  of the initial value (). Note that if the price declines after you visit some city, then it will only happen after you made the sale on that city, so your sale on that city will not be affected. In particular, each blimp you sell in the first  of the cities will always be sold at their corresponding city's initial price. Input Format The first line of input for each test case will contain three parameters: number of cities ()  blimp cost per mile ()  blimp factor of decline ()  This will be followed by  lines, which will each contain three integers , the city location (x and y coordinates the grid, in miles) and the initial blimp sales price, respectively.   Constraints         The city locations will be distinct Output Format On each line, output the x and y coordinates of the next city you are visiting. When leaving the headquarters, also output the number of blimps you are taking with you for that part of the trip. You do not need to return to headquarters when you finish your sales.  You can only visit each city at most once. Sample Input 10 3 0.95 1 1 30 2 2 35 0 8 50 7 2 20 7 3 25 10 7 90 9 8 35 5 15 10 8 18 15 1 9 60  Sample Output 1 1 2 2 2 0 0 10 7 2 9 8 0 0 0 8 2 1 9  Explanation The salesman first travels a distance of √2 dollars to (1,1) carrying 2 blimps. This will cost him √2 dollars for his own travel and 6√2 dollars for the 2 blimps. He will then earn 30 dollars selling 1 blimp. He then continues to (2,2) with only 1 blimp, which will cost him 1√2 dollars for his travel and 3√2 dollars for his blimp. He will then earn 33.25 dollars selling the blimp, since the prices have declined by 5%. After his return to HQ (a distance of 2√2) he will have earned an approximate profit of 44.87 dollars. Scoring The goal of this challenge is to achieve the maximum profit on each test case. Your profits for each test case will be: Total Blimp Sales - Total Travel Costs You will receive a score for each test case based on the ratio of your profit to the estimated maximum profit. Your total score for this challenge will be a weighted sum of your scores for each test case. If your profit is negative, you'll receive a zero score.
__label__Dynamic-Programming __label__Strings You are given a string, , consisting of lowercase English letters. A string is beautiful with respect to  if it can be derived from  by removing exactly  characters. Find and print the number of different strings that are beautiful with respect to . Input Format A single string of lowercase English letters denoting . Constraints   holds for test cases worth at least  of the problem's score.  holds for test cases worth at least  of the problem's score. Output Format Print the number of different strings that are beautiful with respect to . Sample Input abba  Sample Output 4  Explanation   The following strings can be derived by removing  characters from : . This gives us our set of unique beautiful strings, . As , we print .
__label__Game-Theory Two players (numbered  and ) are playing a game of Tower Breakers! The rules of the game are as follows: Player  always moves first. Initially there are  towers of various heights. The players move in alternating turns. In each turn, a player must choose a tower of height  and break it down into  towers, each of height . The numbers  and  must satisfy  and .   If the current player is unable to make any move, they lose the game. Given the value of  and the respective height values for all towers, can you determine who will win, assuming both players always move optimally? If the first player wins, print ; otherwise, print . Input Format The first line contains an integer, , denoting the number of test cases.  The  subsequent lines define the test cases. Each test case is described by two lines: An integer, , denoting the number of towers.  space-separated integers, , where each  describes the height of tower . Constraints    Output Format For each test case, print a single integer denoting the winner (i.e., either  or ) on a new line. Sample Input 2 2  1 2 3  1 2 3  Sample Output 1 2  Explanation In the first test case, the first player simply breaks down the second tower of height  into two towers of height  and wins. In the second test case, there are only two possible moves: Break the second tower into  towers of height . Break the third tower into  towers of height .  Whichever move player  makes, player  can make the other move and win the game.
__label__Depth-first-Search Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.   Example 1:  Input: [[0,0,0],  [0,1,0],  [0,0,0]]  Output: [[0,0,0],  [0,1,0],  [0,0,0]]  Example 2:  Input: [[0,0,0],  [0,1,0],  [1,1,1]]  Output: [[0,0,0],  [0,1,0],  [1,2,1]]    Note:  The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right.
__label__Hash-Table Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.
__label__Array __label__Greedy-Algorithms Given an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.   Example 1: Input: [3,2,1] Output: [3,1,2] Explanation: Swapping 2 and 1.  Example 2: Input: [1,1,5] Output: [1,1,5] Explanation: This is already the smallest permutation.  Example 3: Input: [1,9,4,6,7] Output: [1,7,4,6,9] Explanation: Swapping 9 and 7.  Example 4: Input: [3,1,1,3] Output: [1,3,1,3] Explanation: Swapping 1 and 3.    Note:  1 <= A.length <= 10000 1 <= A[i] <= 10000
__label__Dynamic-Programming Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:  Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.    Note:  The n will be in the range [1, 1000].
__label__Strings Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.   Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1 Example 4: Input: version1 = "1.01", version2 = "1.001" Output: 0 Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1” Example 5: Input: version1 = "1.0", version2 = "1.0.0" Output: 0 Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"   Note:  Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes.  Version strings do not start or end with dots, and they will not be two consecutive dots.
__label__Array __label__Strings Given a string s, we make queries on substrings of s. For each query queries[i] = [left, right, k], we may rearrange the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter.  If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false. Return an array answer[], where answer[i] is the result of the i-th query queries[i]. Note that: Each letter is counted individually for replacement so if for example s[left..right] = "aaa", and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)   Example : Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] Output: [true,false,false,true,true] Explanation: queries[0] : substring = "d", is palidrome. queries[1] : substring = "bc", is not palidrome. queries[2] : substring = "abcd", is not palidrome after replacing only 1 character. queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab". queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.    Constraints:  1 <= s.length, queries.length <= 10^5 0 <= queries[i][0] <= queries[i][1] < s.length 0 <= queries[i][2] <= s.length s only contains lowercase English letters.
__label__Array Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.) Formally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:  0 <= i < i + L - 1 < j < j + M - 1 < A.length, or 0 <= j < j + M - 1 < i < i + L - 1 < A.length.       Example 1: Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2 Output: 20 Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.   Example 2: Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2 Output: 29 Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.   Example 3: Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3 Output: 31 Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.    Note:  L >= 1 M >= 1 L + M <= A.length <= 1000 0 <= A[i] <= 1000
__label__Array __label__Tree __label__Depth-first-Search Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7
__label__Dynamic-Programming Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = "sea", s2 = "eat" Output: 231 Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum. Deleting "t" from "eat" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.   Example 2: Input: s1 = "delete", s2 = "leet" Output: 403 Explanation: Deleting "dee" from "delete" to turn the string into "let", adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum. At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403. If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.   Note: 0 < s1.length, s2.length <= 1000. All elements of each string will have an ASCII value in [97, 122].
__label__Greedy-Algorithms For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants.  Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is  where , there exists another team member whose skill level is . Note that a contestant can write buggy code and thus can have a negative skill level. The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible. For example, there are  contestants with skill levels .  There are many ways teams could be formed, e.g. [-1], [0],...,[3].  At the other end of the spectrum, we could form  and .  We're looking for the largest smaller team size though.  Two sets that meet the criteria are  and .  The largest smaller team size possible is . Note: There is an edge case where  contestants have registered.  As no teams are to be created, the largest team created will have  members. Input Format The first line contains an integer , the number of test cases.   Each of the next  lines contains a string of space-separated integers,  followed by  integers , a list of the contestants' skill levels. Constraints       Output Format For each test case, print the size of largest possible smallest team on a separate line. Sample Input 4   7 4 5 2 3 -4 -3 -5   1 -4   4 3 2 3 1   7 1 -2 -3 -4 2 0 -1    Sample Output 3 1 1 7  Explanation For the first case, Roy can form two teams: one with contestants with skill levels {-4,-3,-5} and the other one with {4,5,2,3}. The first group containing 3 members is the smallest.   {-4,-3,-5} {4,5,2,3} 3 In the second case, the only team is {-4}  {-4} In the third case, the teams are {3} , {1,2,3}, the size of the smaller group being 1. {3} {1,2,3} 1 In the last case, you can build one group containing all of the contestants. The size of the group equals the total number of contestants. Time limits  Time limits for this challenge are given here Note  If n = 0, print 0.
__label__Game-Theory __label__Game-Theory Two players called  and  are playing a game with a starting number of stones. Player  always plays first, and the two players move in alternating turns. The game's rules are as follows: In a single move, a player can remove either , , or  stones from the game board.  If a player is unable to make a move, that player loses the game. Given the starting number of stones, find and print the name of the winner.   is named First and  is named Second.  Each player plays optimally, meaning they will not make a move that causes them to lose the game if a winning move exists. First Second For example, if ,  can make the following moves:    removes  stones leaving .  will then remove  stones and win.  removes  stones leaving .  cannot move and loses.  would make the second play and win the game. Function Description Complete the gameOfStones function in the editor below.  It should return a string, either First or Second.   First Second gameOfStones has the following parameter(s): n: an integer that represents the starting number of stones Input Format The first line contains an integer , the number of test cases.  Each of the next  lines contains an integer , the number of stones in a test case. Constraints  Output Format On a new line for each test case, print First if the first player is the winner.  Otherwise print Second. First Second Sample Input 8 1 2 3 4 5 6 7 10  Sample Output Second First First First First First Second First  Explanation In the sample, we have  testcases.   If ,  can't make any moves and loses the game. If ,  removes  stones and wins the game. If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes all  stones from the game board, winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  can make any of the following three moves: Remove  stones, leaving  stones on the board.  then removes  stones, winning the game.   Remove  stones, leaving  stones on the board.  then removes  stones, leaving  stone left on the board and winning the game.   Remove  stones, leaving  stones on the board.  then removes the  remaining stones and wins the game.   All possible moves result in  winning. If ,  can remove either  or  stones to win the game.
__label__Dynamic-Programming __label__Mathematics A company needs random numbers for its operation.  random numbers have been generated using  numbers as seeds and the following recurrence formula:   The numbers used as seeds are .  is the  term of the recurrence. Due to a failure on the servers, the company lost its seed numbers. Now they just have the recurrence formula and the previously generated  random numbers. The company wants to recover the numbers used as seeds, so they have hired you for doing this task. Input Format The first line contains two space-separated integers,  and , respectively.  The second line contains the space-separated integers describing  (all these numbers are non-negative integers ).  The third line contains the space-separated coefficients of the recurrence formula, . All of these coefficients are positive integers . Constraints    Output Format The output must be one line containing the space-separated seeds of the random numbers - . Sample Input 2 6 13 8 1 1  Sample Output 1 1   Explanation This is the classic Fibonacci recurrence. We have the  and  terms, and, of course, the seeds are the numbers  and .
__label__Dynamic-Programming __label__Graph-Algorithms Nikita is making a graph as a birthday gift for her boyfriend, a fellow programmer! She drew an undirected connected graph with  nodes numbered from  to  in her notebook. Each node is shaded in either white or black. We define  to be the number of white nodes, and  to be the number of black nodes. The graph is drawn in such a way that: No  adjacent nodes have same coloring. The value of , which we'll call , is minimal. Nikita's mischievous little brother erased some of the edges and all of the coloring from her graph! As a result, the graph is now decomposed into one or more components. Because you're her best friend, you've decided to help her reconstruct the graph by adding  edges such that the aforementioned graph properties hold true. Given the decomposed graph, construct and shade a valid connected graph such that the difference  between its shaded nodes is minimal. Input Format The first line contains  space-separated integers,  (the number of nodes in the original graph) and  (the number of edges in the decomposed graph), respectively.  The  subsequent lines each contain  space-separated integers,  and , describing a bidirectional edge between nodes  and  in the decomposed graph. Constraints   It is guaranteed that every edge will be between  distinct nodes, and there will never be more than  edge between any  nodes. Your answer must meet the following criteria: The graph is connected and no  adjacent nodes have the same coloring. The value of  is minimal.  The graph is connected and no  adjacent nodes have the same coloring. The value of  is minimal.  Output Format You must have  lines of output.  The first line contains  space-separated integers:  (the minimum possible value of ) and  (the number of edges you've added to the graph), respectively.  Each of the  subsequent lines contains  space-separated integers,  and , describing a newly-added bidirectional edge in your final graph (i.e.: new edge ).  You may print any  of the possible reconstructions of Nikita's graph such that the value of  in the reconstructed shaded graph is minimal. Sample Input 0  8 8  1 2  2 3  3 4  4 1  1 5  2 6  3 7  4 8  Sample output 0 0 0  Sample Input 1  8 6  1 2  3 4  3 5  3 6  3 7  3 8  Sample Output 1 4 1 1 5  Sample Input 2  5 4  1 2  2 3  3 4  4 1  Sample Output 2   1 2   2 5   4 5  Explanation In the figure below, the solid lines show the decomposed graph after Nikita's brother erased the edges, and the dotted lines show one possible correct answer:  In Sample , no additional edges are added and . Because  and , we get . Thus, we print  on a new line (there is only  line of output, as ). In Sample , the only edge added is , so . Here,  and , so . Thus, we print  on the first line. Next, we must print  lines describing each edge added; because , we print a single line describing the  space-separated nodes connected by our new edge: . In Sample , we can either add  edge  or , or both of them. In both cases we get  and , so . Thus  and  or  both are correct.
__label__Array Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].  Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.   Note:  1 <= A.length <= 30000 1 <= A[i] <= 30000
__label__Mathematics __label__Data-Structures __label__Advanced-Data-Structures In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have N space-fighters.  Initially the ith fighter is located at (xi, yi). All of the space-fighters move with constant velocity V units/sec in the positive X direction.  i.e., fighter at (xi, yi) moves to (xi+V, yi) in 1 second.  The ith space-fighter broadcasts enemy information at a frequency fi. The republic is not scared of the artificially intelligent droid force as they have Yoda. Yoda has a special power, at any time T he can choose a region of the droid army and block one specific frequency F. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across X axis (refer image below for clarity). If a frequency (F) is blocked all the space-fighters in the region having the frequency F can’t communicate.  Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form: YU YD T where YU, YD are the bounds on y-axis inside which YODA can block a frequency at time T.  In the region described by the query, after a time T seconds from the start, if Yoda can chose one frequency (F) he wishes to, what is the maximum number of communications he can block? Input Format  Each test case is described as follows; the first line contains 3 space separated integers N - the number of space-fighters, Q - the number of queries you have to answer, and V - the velocity of the space-fighters separated by a single space.  N lines follow, each containing 3 space separated integers xi, yi, and fi, denoting the x co-ordinate, y co-ordinate and the frequency at which the ith ship broadcasts respectively. Each of the next Q lines contain 3 space separated integers representing YU, YD, T respectively. Refer the figure for more clarity Note: Points on the boundaries should be counted as well. Output Format  For each query you are to output a single integer denoting the result. Constraints  1 <= N <= 50000 1 <= Q <= 30000 1 <= V <= 10000 -109 <= xi <= 109 -109 <= yi <= 109 1 <= fi <= 109 -109 <= YU <= 109 -109 <= YD <= 109 1 <= T <= 10000 YU >= YD Sample Input 5 5 82 -4 1 4 -3 -2 2 -3 5 1 0 -5 2 1 -1 2 1 -1 57 -2 -5 11 5 -5 40 -1 -5 16 5 -1 93  Sample Output 1 2 3 3 1  Explanation Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.
__label__Dynamic-Programming Alex and Lee continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.  Alex and Lee take turns, with Alex starting first.  Initially, M = 1. On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). The game continues until all the stones have been taken. Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get.   Example 1: Input: piles = [2,7,9,4,4] Output: 10 Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger.     Constraints:  1 <= piles.length <= 100 1 <= piles[i] <= 10 ^ 4
__label__Depth-first-Search Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].
__label__Graph-Algorithms Consider an undirected graph where each edge is the same weight.  Each of the nodes is labeled consecutively. You will be given a number of queries.  For each query, you will be given a list of edges describing an undirected graph.  After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the breadth-first search algorithm (BFS).  Distances are to be reported in node number order, ascending.  If a node is unreachable, print  for that node.  Each of the edges weighs 6 units of distance. For example, given a graph with  nodes and  edges, , a visual representation is:     The start node for the example is node .  Outputs are calculated for distances to nodes  through : .  Each edge is  units, and the unreachable node  has the required return distance of .   Function Description  Complete the bfs function in the editor below.  It must return an array of integers representing distances from the start node to each other node in node ascending order.  If a node is unreachable, its distance is .   bfs has the following parameter(s):   n: the integer number of nodes   m: the integer number of edges   edges: a 2D array of start and end nodes for edges s: the node to start traversals from Input Format The first line contains an integer , the number of queries.  Each of the following  sets of lines has the following format: The first line contains two space-separated integers  and , the number of nodes and edges in the graph.   Each line  of the  subsequent lines contains two space-separated integers,  and , describing an edge connecting node  to node .   The last line contains a single integer, , denoting the index of the starting node. Constraints         Output Format For each of the  queries, print a single line of  space-separated integers denoting the shortest distances to each of the  other nodes from starting position . These distances should be listed sequentially by node number (i.e., ), but should not include node . If some node is unreachable from , print  as the distance to that node. Sample Input 2 4 2 1 2 1 3 1 3 1 2 3 2  Sample Output 6 6 -1 -1 6  Explanation We perform the following two queries: The given graph can be represented as:    where our start node, , is node . The shortest distances from  to the other nodes are one edge to node , one edge to node , and an infinite distance to node  (which it's not connected to). We then print node 's distance to nodes , , and  (respectively) as a single line of space-separated integers: 6, 6, -1.   The given graph can be represented as:    where our start node, , is node . The shortest distances from  to the other nodes are one edge to node , one edge to node , and an infinite distance to node  (which it's not connected to). We then print node 's distance to nodes , , and  (respectively) as a single line of space-separated integers: 6, 6, -1.   6, 6, -1 The given graph can be represented as:    where our start node, , is node . There is only one edge here, so node  is unreachable from node  and node  has one edge connecting it to node . We then print node 's distance to nodes  and  (respectively) as a single line of space-separated integers: -1 6.  The given graph can be represented as:    where our start node, , is node . There is only one edge here, so node  is unreachable from node  and node  has one edge connecting it to node . We then print node 's distance to nodes  and  (respectively) as a single line of space-separated integers: -1 6.  -1 6 Note: Recall that the actual length of each edge is , and we print  as the distance to any node that's unreachable from .
__label__Array __label__Two-Pointers __label__Binary-Search Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example:  Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
__label__Bit Given two integers,  and , find the maximal value of  xor , written , where  and  satisfy the following condition:   For example, if  and , then        Our maximum value is .   Function Description Complete the maximizingXor function in the editor below.  It must return an integer representing the maximum value calculated.   maximizingXor has the following parameter(s): l: an integer, the lower bound, inclusive   r: an integer, the upper bound, inclusive   Input Format The first line contains the integer .  The second line contains the integer .     Constraints 3  Output Format Return the maximal value of the xor operations for all permutations of the integers from  to , inclusive. Sample Input 0 Sample Output 0 Explanation 0 The input tells us that  and . All the pairs which comply to above condition are the following:                                            Here two pairs (10, 13) and (11, 12) have maximum xor value 7, and this is the answer.  Sample Input 1 Sample Output 1
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures You are given an unrooted tree of  nodes numbered from  to . Each node  has a color, .  Let  be the number of different colors in the path between node  and node . For each node , calculate the value of , defined as follows:   Your task is to print the value of  for each node . Input Format The first line contains a single integer, , denoting the number of nodes.  The second line contains  space-separated integers, , where each  describes the color of node .  Each of the  subsequent lines contains  space-separated integers,  and , defining an undirected edge between nodes  and . Constraints   Output Format Print  lines, where the  line contains a single integer denoting . Sample Input 5 1 2 3 2 3 1 2 2 3 2 4 1 5  Sample Output 10 9 11 9 12  Explanation The Sample Input defines the following tree:  Each  is calculated as follows:
__label__Dynamic-Programming Return the largest possible k such that there exists a_1, a_2, ..., a_k such that:  Each a_i is a non-empty string; Their concatenation a_1 + a_2 + ... + a_k is equal to text; For all 1 <= i <= k,  a_i = a_{k+1 - i}.    Example 1: Input: text = "ghiabcdefhelloadamhelloabcdefghi" Output: 7 Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".  Example 2: Input: text = "merchant" Output: 1 Explanation: We can split the string on "(merchant)".  Example 3: Input: text = "antaprezatepzapreanta" Output: 11 Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".  Example 4: Input: text = "aaa" Output: 3 Explanation: We can split the string on "(a)(a)(a)".    Constraints:  text consists only of lowercase English characters. 1 <= text.length <= 1000
__label__Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.
__label__Dynamic-Programming In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)
__label__Tree __label__Depth-first-Search Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.
__label__Tree __label__Depth-first-Search An undirected, connected tree with N nodes labelled 0...N-1 and N-1 edges are given. The ith edge connects nodes edges[i][0] and edges[i][1] together. Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes. Example 1: Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation:  Here is a diagram of the given tree:   0  / \ 1   2    /|\   3 4 5 We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.  Note: 1 <= N <= 10000
__label__Dynamic-Programming __label__Tree Given an array arr of positive integers, consider all binary trees such that:  Each node has either 0 or 2 children; The values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.) The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.  Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.   Example 1: Input: arr = [6,2,4] Output: 32 Explanation: There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.      24            24    /  \          /  \   12   4        6    8  /  \               / \ 6    2             2   4    Constraints:  2 <= arr.length <= 40 1 <= arr[i] <= 15 It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).
__label__Array __label__Greedy-Algorithms Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9
__label__Hash-Table We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].    Note: The length of the input array will not exceed 20,000.
__label__Strings Given an integer n, find the closest integer (not including itself), which is a palindrome.  The 'closest' is defined as absolute difference minimized between two integers. Example 1: Input: "123" Output: "121"   Note:  The input n is a positive integer represented by string, whose length will not exceed 18. If there is a tie, return the smaller one as answer.
__label__Search __label__Bit You will be given an array of integers.  All of the integers except one occur twice.  That one is unique in the array. Given an array of integers, find and print the unique element.   For example, , the unique element is .   Function Description  Complete the lonelyinteger function in the editor below.  It should return the integer which occurs only once in the input array.   lonelyinteger has the following parameter(s):   a: an array of integers   Input Format The first line contains a single integer, , denoting the number of integers in the array.  The second line contains  space-separated integers describing the values in . Constraints   It is guaranteed that  is an odd number and that there is one unique element.   , where . Output Format Print the unique integer in the array. Sample Input 0 Sample Output 0 Explanation 0 There is only one element in the array, thus it is unique. Sample Input 1 Sample Output 1 Explanation 1 We have two 's, and  is unique.  Sample Input 2 Sample Output 2 Explanation 2 We have two 's, two 's, and one .   is unique.
__label__Mathematics Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime?
__label__Strings Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]
__label__Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]    Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.    Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.
__label__Mathematics Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024
__label__Search Consider a matrix where each cell contains either a  or a .  Any cell containing a  is called a filled cell. Two cells are said to be connected if they are adjacent to each other horizontally, vertically, or diagonally.  In the following grid, all cells marked X are connected to the cell marked Y. X Y XXX XYX   XXX      If one or more filled cells are also connected, they form a region. Note that each cell in a region is connected to zero or more cells in the region but is not necessarily directly connected to all the other cells in the region. Given an  matrix, find and print the number of cells in the largest region in the matrix. Note that there may be more than one region in the matrix. For example, there are two regions in the following  matrix.  The larger region at the top left contains  cells.  The smaller one at the bottom right contains .   110 100 001  Function Description  Complete the connectedCell function in the editor below.  It should return an integer that denotes the area of the largest region.   connectedCell has the following parameter(s):  - matrix: a 2D array of integers where  represents the  row of the matrix   Input Format The first line contains an integer , the number of rows in the matrix.  The second line contains an integer , the number of columns in the matrix.  Each of the next  lines contains  space-separated integers . Constraints  Output Format Print the number of cells in the largest region in the given matrix. Sample Input 4 4 1 1 0 0 0 1 1 0 0 0 1 0 1 0 0 0  Sample Output 5  Explanation The diagram below depicts two regions of the matrix; for each region, the component cells forming the region are marked with an X: X X X 0 0     1 1 0 0 0 X X 0     0 1 1 0 0 0 X 0     0 0 1 0 1 0 0 0     X 0 0 0  The first region has five cells and the second region has one cell. We print the size of the largest region.
__label__Array Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2
__label__Graph-Algorithms __label__Tree You are given a tree (a simple connected graph with no cycles).  Find the maximum number of edges you can remove from the tree to get a forest such that each connected component of the forest contains an even number of nodes. As an example, the following tree with  nodes can be cut at most  time to create an even forest.     Function Description  Complete the evenForest function in the editor below.  It should return an integer as described.   evenForest has the following parameter(s):   t_nodes: the number of nodes in the tree   t_edges: the number of undirected edges in the tree   t_from: start nodes for each edge   t_to: end nodes for each edge, (Match by index to t_from.)   Input Format The first line of input contains two integers  and , the number of nodes and edges.  The next  lines contain two integers  and  which specify nodes connected by an edge of the tree. The root of the tree is node . Constraints     Note: The tree in the input will be such that it can always be decomposed into components containing an even number of nodes.  is the set of positive even integers. Output Format Print the number of removed edges.
__label__Binary-Search We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6
__label__Array __label__Strings Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
__label__Hash-Table All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]
__label__Hash-Table __label__Mathematics Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
__label__Data-Structures Alice was given the  integers from  to . She wrote all possible permutations in increasing lexicographical order, and wrote each permutation in a new line. For example, for , there are  possible permutations:       She then chose one permutation among them as her favorite permutation. After some time, she forgot some elements of her favorite permutation. Nevertheless, she still tried to write down its elements. She wrote a  in every position where she forgot the true value. She wants to know the sum of the line numbers of the permutations which could possibly be her favorite permutation, i.e., permutations which can be obtained by replacing the s. Can you help her out?  Since the sum can be large, find it modulo . Input Format The first line contains a single integer . The next line contains  space-separated integers  denoting Alice's favorite permutation with some positions replaced by .   Constraints   The positive values appearing in  are distinct. Subtask  For ~33% of the total points,   Output Format Print a single line containing a single integer denoting the sum of the line numbers of the permutations which could possibly be Alice's favorite permutation. Sample Input 0 Sample Output 0 Explanation 0 The possible permutations are  and . The permutation  occurs on line  and the permutation  occurs on line . Therefore the sum is . Sample Input 1 Sample Output 1 Explanation 1 There is no missing number in the permutation. Therefore, the only possible permutation is , and it occurs on line . Therefore the sum is .
__label__Search You will be given an array of integers and a target value.  Determine the number of pairs of array elements that have a difference equal to a target value.   For example, given an array of [1, 2, 3, 4] and a target value of 1, we have three values meeting the condition: , , and . Function Description Complete the pairs function below.  It must return an integer representing the number of element pairs having the required difference. pairs has the following parameter(s): k: an integer, the target difference arr: an array of integers Input Format The first line contains two space-separated integers  and , the size of  and the target value.  The second line contains  space-separated integers of the array . Constraints       each integer  will be unique Output Format An integer representing the number of pairs of integers whose difference is .   Sample Input 5 2   1 5 3 4 2    Sample Output 3  Explanation There are 3 pairs of integers in the set with a difference of 2: [5,3], [4,2] and [3,1] .
__label__Dynamic-Programming Roy is helping the police department of his city in crime fighting. Today, they informed him about a new planned operation. Think of the city as a  plane. The road along the -axis is very crime prone, because  criminals live there. No two criminals live at the same position. To catch these criminals, the police department has to recruit some police officers and give each of them USD  as wages. A police officer can start his operation from any point , drive his car to point  in a straight line, and catch all the criminals who live on this way. The cost of fuel used by the officer's car is equal to the square of the euclidean distance between points  and  (Euclidean distance between points  and  equals to  ). The police department asks Roy to plan this operation. So Roy has to tell them the number of officers to recruit and the routes these officers should take in order to catch all the criminals. Roy has to provide this information while minimizing the total expenses of this operation. Find out the minimum amount of money required to complete the operation. Input Format The first line contains two integers  , number of criminals, and  , the cost of recruiting a police officer. The next line contains  space separated integers. The  integer indicates the position of the  criminal on -axis (in other words, if the  integer is , then location of the  criminal is ). The value of the positions are between  and  and are given in increasing order in the input. Output Format Print the minimum amount of money required to complete the operation. Sample Input 5 10 1 4 5 6 9  Sample Output 34  Explanation For the sample test case, police department recruits  officers who get paid . The first officer starts at point  and catches the criminal there. So he does not use any fuel. The second officer catches criminals at points ,  and . He burns fuel worth USD . The third officer catches the criminal at point . He also does not burn any fuel. The total money spent by the department is, . Timelimits  Timelimits for this challenge are given here
__label__Array Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them. The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots.   Example 1: Input: [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11    Note:  2 <= A.length <= 50000 1 <= A[i] <= 1000
__label__Game-Theory __label__Greedy-Algorithms __label__Game-Theory Kyle and Mike are bored on a rainy day and decide to pass the time by creating a new game having the following rules: The game starts with two -sized integer arrays,  and , and is played by two players,  and .  The players move in alternating turns, with  always moving first. During each move, the current player must choose an integer, , such that . If the current player is , then  receives  points; if the current player is , then  receives  points. Each value of  can be chosen only once. That is, if a value of  is already chosen by some player, none of the player can re-use it. So, game always ends after  moves. The player with the maximum number of points wins. The arrays A and B are accessible to both the players P1 and P2. So the players make a optimal move at every turn.  Given the values of , , and , can you determine the outcome of the game? Print  if  will win,  if  will win, or  if they will tie. Assume both players always move optimally. Input Format The first line of input contains a single integer, , denoting the number of test cases. Each of the  subsequent lines describes a test case. A single test case is defined over the following three lines: An integer, , denoting the number of elements in arrays  and .  space-separated integers, , where each  describes the element at index  of array .  space-separated integers, , where each  describes the element at index  of array . Constraints       Output Format For each test case, print one of the following predicted outcomes of the game on a new line: Print  if  will win. Print  if  will win. Print  if the two players will tie. Sample Input 3 3 1 3 4 5 3 1 2 1 1 1 1 2 2 2 3 3  Sample Output First Tie Second  Explanation Test Case 0: ,  The players make the following  moves:  chooses  and receives  points.  chooses  and receives  points. Note that  will not choose , because this would cause  to win.  chooses  (which is the only remaining move) and receives  points. As all  moves have been made, the game ends. 's score is  points and 's score is  points, so  is the winner and we print  on a new line. Test Case 1: ,  Because both players will only make  move and all possible point values are , the players will end the game with equal scores. Thus, we print  on a new line. Test Case 1: ,   Because both players will only make  move and all the possible point values for  are greater than all the possible point values for ,  will win the game. Thus, we print  on a new line.
__label__Array __label__Binary-Search Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2  Example 2: Input: [1,3,5,6], 2 Output: 1  Example 3: Input: [1,3,5,6], 7 Output: 4  Example 4: Input: [1,3,5,6], 0 Output: 0
__label__Depth-first-Search Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.   Example:  Input: {"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}  Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3.    Note:  The number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph.
__label__Tree __label__Data-Structures An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree.  In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. We define balance factor for each node as : balanceFactor = height(left subtree) - height(right subtree)  The balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.  (https://en.wikipedia.org/wiki/AVL_tree)         You are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.  Input Format  You are given a function, node *insert(node * root,int new_val) {   }  'node' is defined as : struct node { int val;            //value struct node* left;  //left child struct node* right; //right child int ht;             //height of the node } node;  You only need to complete the function.      Note: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.  Output Format  Insert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced. Sample Input      3   /  \  2    4        \         5  The value to be inserted is 6. Sample Output     3   /  \  2    5      / \     4   6  Explanation After inserting 6 in the tree. the tree becomes:     3 (Balance Factor = -2)   /  \  2    4 (Balance Factor = -2)        \         5 (Balance Factor = -1)          \           6 (Balance Factor = 0)  Balance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree. After performing the rotation, the tree becomes :                                3 (Balance Factor = -1)                             /   \       (Balance Factor = 0) 2     5 (Balance Factor = 0)                                 / \            (Balance Factor = 0)4   6 (Balance Factor = 0)
__label__Depth-first-Search Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.
__label__Greedy-Algorithms Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending.  Determine if the columns are also in ascending alphabetical order, top to bottom.  Return YES if they are or NO if they are not. YES NO For example, given: a b c a d e e f g  The rows are already in alphabetical order.  The columns a a e, b d f and c e g are also in alphabetical order, so the answer would be YES.  Only elements within the same row can be rearranged.  They cannot be moved to a different row. a a e b d f c e g YES Function Description  Complete the gridChallenge function in the editor below.  It should return a string, either YES or NO.   YES NO gridChallenge has the following parameter(s):   grid: an array of strings   Input Format The first line contains , the number of testcases.    Each of the next  sets of lines are described as follows:  - The first line contains , the number of rows and columns in the grid.  - The next  lines contains a string of length  Constraints     Each string consists of lowercase letters in the range ascii[a-z]  Output Format For each test case, on a separate line print YES if it is possible to rearrange the grid alphabetically ascending in both its rows and columns, or NO otherwise. YES NO Sample Input 1 5 ebacd fghij olmkn trpqs xywuv  Sample Output YES  Explanation The x grid in the  test case can be reordered to  abcde fghij klmno pqrst uvwxy  This fulfills the condition since the rows 1, 2, ..., 5 and the columns 1, 2, ..., 5 are all lexicographically sorted.
__label__Strings A regular expression is used to describe a set of strings. For this problem the alphabet is limited to 'a' and 'b'. We define  to be a valid regular expression if:  1)  is "" or "".  2)  is of the form "", where  and  are regular expressions.  3)  is of the form "" where  and  are regular expressions.  4)  is of the form "" where  is a regular expression. Regular expressions can be nested and will always have have two elements in the parentheses. ('' is an element, '' is not; basically, there will always be pairwise evaluation) Additionally, '' will always be the second element; '' is invalid.   The set of strings recognized by  are as follows:  1) If  is "", then the set of strings recognized .  2) If  is "", then the set of strings recognized .  3) If  is of the form "" then the set of strings recognized = all strings which can be obtained by a concatenation of strings  and , where  is recognized by  and  by .  4) If  is of the form "" then the set of strings recognized = union of the set of strings recognized by  and .  5) If  is of the form "" then the the strings recognized are the empty string and the concatenation of an arbitrary number of copies of any string recognized by . Task  Given a regular expression and an integer, , count how many strings of length  are recognized by it. Input Format The first line contains the number of test cases .  test cases follow.  Each test case contains a regular expression, , and an integer, . Constraints      It is guaranteed that  will conform to the definition provided above. Output Format Print  lines, one corresponding to each test case containing the required answer for the corresponding test case. As the answers can be very big, output them modulo . Sample Input 3   ((ab)|(ba)) 2   ((a|b)*) 5   ((a*)(b(a*))) 100  Sample Output 2   32   100  Explanation For the first case, the only strings recognized are "" and "". Of the  possible strings of length ,  of them fit that expression.  For the second case, the RegEx recognizes any string of any length containing only 's and 's. The number of strings of length  recognized by this expression is .  For the third case, the RegEx recognizes any string having one , preceeded and followed by any number of 's. There are  strings of length  which have a single  in them.
__label__Mathematics __label__Strings Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.
__label__Search You are given a number of sticks of varying lengths.  You will iteratively cut the sticks into smaller sticks, discarding the shortest pieces until there are none left.  At each iteration you will determine the length of the shortest stick remaining, cut that length from each of the longer sticks and then discard all the pieces of that shortest length.  When all the remaining sticks are the same length, they cannot be shortened so discard them. Given the lengths of  sticks, print the number of sticks that are left before each iteration until there are none left. For example, there are  sticks of lengths .  The shortest stick length is , so we cut that length from the longer two and discard the pieces of length .  Now our lengths are .  Again, the shortest stick is of length , so we cut that amount from the longer stick and discard those pieces.  There is only one stick left, , so we discard that stick.  Our lengths are .   Function Description  Complete the cutTheSticks function in the editor below.  It should return an array of integers representing the number of sticks before each cut operation is performed.   cutTheSticks has the following parameter(s):   arr: an array of integers representing the length of each stick   Input Format  The first line contains a single integer , the size of .  The next line contains  space-separated integers, each an  where each value represents the length of the  stick. Output Format  For each operation, print the number of sticks that are present before the operation on separate lines.   Constraints    Sample Input 0 6 5 4 4 2 2 8  Sample Output 0 6 4 2 1  Explanation 0 Sample Input 1 8 1 2 3 4 3 3 2 1  Sample Output 1 8 6 4 1  Explanation 1
__label__Search __label__Dynamic-Programming Queens on Board You have an N * M chessboard on which some squares are blocked out. In how many ways can you place one or more queens on the board, such that, no two queens attack each other? Two queens attack each other, if one can reach the other by moving horizontally, vertically, or diagonally without passing over any blocked square. At most one queen can be placed on a square. A queen cannot be placed on a blocked square. Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains integers N and M on the first line. The following N lines contain M characters each, and represent a board. A '#' represents a blocked square and a '.' represents an unblocked square. Constraints 1 <= T <= 100  1 <= N <= 50  1 <= M <= 5 Output Format Output T lines containing the required answer for each test case. As the answers can be really large, output them modulo 109+7. Sample Input 4   3 3   ...   ...   ...   3 3   .#.   .#.   ...   2 4   .#..   ....   1 1   #  Sample Output 17   18   14   0
__label__Hash-Table In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: Input: dict = ["cat", "bat", "rat"] sentence = "the cattle was rattled by the battery" Output: "the cat was rat by the bat"    Note:  The input will only have lower-case letters. 1 <= dict words number <= 1000 1 <= sentence words number <= 1000 1 <= root length <= 100 1 <= sentence words length <= 1000
__label__Bit Suppose that  is a list of  numbers  and  is a permutation of these numbers, we say B is K-Manipulative if and only if:  is not less than , where  represents the XOR operator. You are given . Find the largest  such that there exists a K-manipulative permutation . Input: The first line is an integer . The second line contains  space separated integers - .   Output:  The largest possible , or  if there is no solution. Constraints:      Sample Input 0 Sample Output 0 Explanation 0 Here the list  is . One possible permutation . Here   .  So there exists a permutation  of  such that  is not less than . However there does not exist any permutation  of  such that  is not less than . So the maximum possible value of  is . Sample Input 1 Sample Output 1 Explanation 1 Here the list  is . One possible permutation . Here   .  So there exists a permutation  of  such that  is not less than . However there does not exist any permutation  of  such that  is not less than . So the maximum possible value of  is .
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool Given pointers to the head nodes of  linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL. In the diagram below, the two lists converge at Node x: x [List #1] a--->b--->c                      \                       x--->y--->z--->NULL                      /      [List #2] p--->q  Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge.  int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) Input Format Do not read any input from stdin/console. The findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) method has two parameters,  and , which are the non-null head Nodes of two separate linked lists that are guaranteed to converge.   findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) Constraints The lists will merge.  .   .  Output Format Do not write any output to stdout/console.  Each Node has a data field containing an integer.  Return the integer data for the Node where the two lists merge.   Sample Input The diagrams below are graphical representations of the lists that input Nodes  and  are connected to. Recall that this is a method-only challenge; the method only has initial visibility to those  Nodes and must explore the rest of the Nodes using some algorithm of your own design. Test Case 0  1   \    2--->3--->NULL   /  1  Test Case 1 1--->2       \        3--->Null       /      1  Sample Output 2 3  Explanation Test Case 0: As demonstrated in the diagram above, the merge Node's data field contains the integer .  Test Case 1: As demonstrated in the diagram above, the merge Node's data field contains the integer .
__label__Array __label__Dynamic-Programming A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right
__label__Tree __label__Depth-first-Search Given a rooted binary tree, return the lowest common ancestor of its deepest leaves. Recall that:  The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1. The lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.    Example 1: Input: root = [1,2,3] Output: [1,2,3] Explanation:  The deepest leaves are the nodes with values 2 and 3. The lowest common ancestor of these leaves is the node with value 1. The answer returned is a TreeNode object (not an array) with serialization "[1,2,3]".  Example 2: Input: root = [1,2,3,4] Output: [4]  Example 3: Input: root = [1,2,3,4,5] Output: [2,4,5]    Constraints:  The given tree will have between 1 and 1000 nodes. Each node of the tree will have a distinct value between 1 and 1000.
__label__Graph-Algorithms HackerLand is a country with  beautiful cities and  undirected roads. Like every other beautiful country, HackerLand has traffic jams. Each road has a crowd value. The crowd value of a path is defined as the maximum crowd value for all roads in the path. For example, if the crowd values for all roads are , then the crowd value for the path will be . Each city  has a type value, , denoting the type of buildings in the city. David just started his vacation in HackerLand. He wants to travel from city  to city . He also wants to see at least  different types of buildings along the path from  to . When choosing a path from city  to city  that has at least  different types of buildings along the path, David always selects the one with the minimum crowd value. You will be given  queries. Each query takes the form of  space-separated integers, , , and , denoting the respective values for starting city, destination city, and minimum number of unique buildings that David wants to see along the way. For each query, you must print the minimum crowd value for a path between  and  that has at least  different buildings along the route. If there is no such path, print -1. -1 Note: A path may contain cycles (i.e., the same roads or cities may be traveled more than once). Input Format The first line contains  space-separated integers denoting the respective values for  (the number of cities),  (the number of roads), and  (the number of queries).  The second line contains  space-separated integers describing the respective building type for each city in array  (where the -th value is  and ).     Each of the  subsequent lines defines a road in the form of  space-separated integers, , , and , defining an undirected road with crowd value  that connects cities  and .   Each of the  subsequent lines defines a query in the form of  space-separated integers, , , and  (where ), respectively.  Constraints    Each road connect  distinct cities, meaning no road starts and ends in the same city. Output Format For each query, print its answer on a new line. Sample Input 7 6 1 1 1 4 5 1 3 2 1 2 3 2 6 2 2 3 4 3 4 3 2 4 9 5 7 9 1 2 4  Sample Output 4  Explanation The diagram below depicts the country given as Sample Input. Different values of  are shown in different colors.  The path for the last query (1 2 4) will be . David sees his first type of building in cities  and , his second type of building in city , his third type of building in city , and his fourth type of building in city . The crowd values for each road traveled on this path are ; the maximum of these values is . Thus, we print  on a new line. 1 2 4
__label__Dynamic-Programming __label__Tree King Arthur has a large kingdom that can be represented as a tree, where nodes correspond to cities and edges correspond to the roads between cities. The kingdom has a total of  cities numbered from  to .  The King wants to divide his kingdom between his two children, Reggie and Betty, by giving each of them  or more cities; however, they don't get along so he must divide the kingdom in such a way that they will not invade each other's cities. The first sibling will invade the second sibling's city if the second sibling has no other cities directly connected to it. For example, consider the kingdom configurations below:  Given a map of the kingdom's  cities, find and print the number of ways King Arthur can divide it between his two children such that they will not invade each other. As this answer can be quite large, it must be modulo . Input Format The first line contains a single integer denoting  (the number of cities in the kingdom).  Each of the  subsequent lines contains two space-separated integers,  and , describing a road connecting cities  and .  Constraints   It is guaranteed that all cities are connected. Subtasks  for  of the maximum score. Output Format Print the number of ways to divide the kingdom such that the siblings will not invade each other, modulo . Sample Input 5 1 2 1 3 3 4 3 5  Sample Output 4  Explanation In the diagrams below, red cities are ruled by Betty and blue cities are ruled by Reggie. The diagram below shows a division of the kingdom that results in war between the siblings:  Because cities  and  are not connected to any other red cities, blue city  will cut off their supplies and declare war on them. That said, there are four valid ways to divide the kingdom peacefully:  We then print the value of  as our answer.
__label__Dynamic-Programming There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.
__label__Mathematics Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes. If there isn't any rectangle, return 0.   Example 1:  Input: [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.   Example 2:  Input: [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.   Example 3:  Input: [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points.   Example 4:  Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.       Note:  1 <= points.length <= 50 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct. Answers within 10^-5 of the actual value will be accepted as correct.
__label__Dynamic-Programming We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].
__label__Data-Structures Jesse loves cookies. He wants the sweetness of all his cookies to be greater than value . To do this, Jesse repeatedly mixes two cookies with the least sweetness. He creates a special combined cookie with: sweetness  Least sweet cookie   2nd least sweet cookie). He repeats this procedure until all the cookies in his collection have a sweetness  .  You are given Jesse's cookies. Print the number of operations required to give the cookies a sweetness  . Print   if this isn't possible.  Input Format The first line consists of integers , the number of cookies and , the minimum required sweetness, separated by a space.  The next line contains  integers describing the array  where  is the sweetness of the  cookie in Jesse's collection. Constraints       Output Format Output the number of operations that are needed to increase the cookie's sweetness .  Output  if this isn't possible.  Sample Input 6 7 1 2 3 9 10 12  Sample Output 2  Explanation Combine the first two cookies to create a cookie with sweetness  =   After this operation, the cookies are .  Then, combine the cookies with sweetness  and sweetness , to create a cookie with resulting sweetness  =   Now, the cookies are .  All the cookies have a sweetness .   Thus,  operations are required to increase the sweetness.
__label__Mathematics You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.
__label__Game-Theory Manasa loves the nim game, in which there are  buckets, each having  balls. Two players play alternately. Each turn consists of removing some non-zero number of balls from one of the bucket. A player with lack of moves looses. But, Manasa having played it so many times, she gets bored one day. So she wants to change the rules of the game. She loves prime numbers, so she makes a new rule: any player can only remove a prime number of balls from a bucket. But there are infinite number prime numbers. So to keep the game simple, a player can only remove  balls from a bucket if  belongs to the set   The whole game can now be described as follows:    There are  buckets, and the  bucket contains  balls. A player can choose a bucket and remove  balls from that bucket where  belongs to . A player loses if there are no more available moves. Manasa plays the first move against Sandy. Who will win if both of them play optimally? Input Format The first line contains an integer , the number of test cases.  Each test case consists of two lines. The first line contains a single integer . The second line contain  space-separated integers .   Constraints       Output Format Print a single line containing the name of the winner: Manasa or Sandy. Manasa Sandy Sample Input 0 Sample Output 0 Explanation 0 For the first testcase: Since both the buckets have same number of balls, Manasa can choose any one of them for her first move. If Manasa selects to remove  or  balls to remove from first bucket. Now, Sandy  can always counter her move by removing  balls from first bucket if it's left with  balls respectively. Now, there are no valid moves left for first bucket. The same thing repeats for second bucket and Sandy wins. For the second testcase: Manasa removes  balls from the third bucket. Now, if Sandy choose the remove  balls from second bucket Manasa will empty the first bucket and if Sandy choose the remove  balls from first bucket, Manasa will empty second one. Hence, Manasa wins.
__label__Dynamic-Programming You are using at most A number of 1s and at most B number of 2s. How many different evaluation results are possible when they are formed in an expression containing only addition + sign and multiplication * sign are allowed? + * Note that, multiplication takes precedence over addition. For example, if A=2 and B=2, then we have the following expressions: 1, 1*1 = 1 1 1*1 2, 1*2, 1*1*2, 1+1 = 2 2 1*2 1*1*2 1+1 1+2, 1+1*2 = 3 1+2 1+1*2 2+2, 2*2, 1+1+2, 1*2*2, 1*1*2*2, 1*2+1*2, 1*1*2+2, 1*2+2 = 4 2+2 2*2 1+1+2 1*2*2 1*1*2*2 1*2+1*2 1*1*2+2 1*2+2 1+2+2, 1+1*2+2 = 5 1+2+2 1+1*2+2 1+1+2+2,  1+1+2*2 = 6 1+1+2+2 1+1+2*2 So there are 6 unique results that can be formed if A = 2 and B = 2.  Input Format The first line contains the number of test cases T, T testcases follow each in a newline.  Each testcase contains 2 integers A and B separated by a single space.   Constraints 1 <= T <= 105  0<=A<=1000000000  0<=B<=1000   Output Format Print the number of different evaluations modulo (%) (109+7.) Sample Input 4 0 0 2 2 0 2 2 0  Sample Output 0 6 2 2  Explanation When A = 0, B = 0, there are no expressions, hence 0.  When A = 2, B = 2, as explained in the problem statement above, expressions leads to 6 possible solutions.  When A = 0, B = 2, we have 2, 2+2 or 2*2, hence 2.  2 2+2 2*2 When A = 2, B = 0, we have 1 or 1*1, 1+1 hence 2.  1 1*1 1+1
__label__Dynamic-Programming There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones. A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles. Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.    Example 1: Input: stones = [3,2,4,1], K = 2 Output: 20 Explanation:  We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible.   Example 2: Input: stones = [3,2,4,1], K = 3 Output: -1 Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.   Example 3: Input: stones = [3,5,1,2,6], K = 3 Output: 25 Explanation:  We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible.    Note:  1 <= stones.length <= 30 2 <= K <= 30 1 <= stones[i] <= 100
__label__Strings DNA is a nucleic acid present in the bodies of living things. Each piece of DNA contains a number of genes, some of which are beneficial and increase the DNA's total health. Each gene has a health value, and the total health of a DNA is the sum of the health values of all the beneficial genes that occur as a substring in the DNA. We represent genes and DNA as non-empty strings of lowercase English alphabetic letters, and the same gene may appear multiple times as a susbtring of a DNA. Given the following: An array of beneficial gene strings, . Note that these gene sequences are not guaranteed to be distinct. An array of gene health values, , where each  is the health value for gene . A set of  DNA strands where the definition of each strand has three components, , , and , where string  is a DNA for which genes  are healthy. Find and print the respective total healths of the unhealthiest (minimum total health) and  healthiest (maximum total health) strands of DNA as two space-separated values on a single line. Input Format The first line contains an integer, , denoting the total number of genes.  The second line contains  space-separated strings describing the respective values of  (i.e., the elements of ).  The third line contains  space-separated integers describing the respective values of  (i.e., the elements of ).  The fourth line contains an integer, , denoting the number of strands of DNA to process.  Each of the  subsequent lines describes a DNA strand in the form start end d, denoting that the healthy genes for DNA strand  are  and their respective correlated health values are . start end d Constraints        the sum of the lengths of all genes and DNA strands   It is guaranteed that each  consists of lowercase English alphabetic letters only (i.e., a to z). a z Output Format Print two space-separated integers describing the respective total health of the unhealthiest and the healthiest strands of DNA. Sample Input 0 Sample Output 0 Explanation 0 In the diagrams below, the ranges of beneficial genes for a specific DNA on the left are highlighed in green and individual instances of beneficial genes on the right are bolded. The total healths of the  strands are:    The total health of caaab is . caaab   The total health of xyz is , because it contains no beneficial genes. xyz   The total health of bcdybc is . bcdybc The unhealthiest DNA strand is xyz with a total health of , and the healthiest DNA strand is caaab with a total health of . Thus, we print 0 19 as our answer. xyz caaab 0 19
