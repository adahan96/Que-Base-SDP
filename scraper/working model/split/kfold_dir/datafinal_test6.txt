__label__Mathematics __label__Greedy-Algorithms Sherlock Holmes suspects his archenemy Professor Moriarty is once again plotting something diabolical. Sherlock's companion, Dr. Watson, suggests Moriarty may be responsible for MI6's recent issues with their supercomputer, The Beast.  Shortly after resolving to investigate, Sherlock receives a note from Moriarty boasting about infecting The Beast with a virus.  He also gives him a clue:  an integer. Sherlock determines the key to removing the virus is to find the largest Decent Number having that number of digits. A Decent Number has the following properties: Its digits can only be 3's and/or 5's. The number of 3's it contains is divisible by 5. The number of 5's it contains is divisible by 3. It is the largest such number for its length.  Moriarty's virus shows a clock counting down to The Beast's destruction, and time is running out fast. Your task is to help Sherlock find the key before The Beast is destroyed! For example, the numbers  and  are both decent numbers because there are  's and  's in the first, and  's in the second.  They are the largest values for those length numbers that have proper divisibility of digit occurrences.   Function Description Complete the decentNumber function in the editor below.  It should print the decent number for the given length, or  if a decent number of that length cannot be formed.   decentNumber has the following parameter(s):   n: the integer length of the decent number to create Input Format The first line is an integer, , denoting the number of test cases.  The next  lines each contain an integer , the number of digits in the number. Constraints     Output Format Print the Decent Number having  digits; if no such number exists, tell Sherlock by printing -1. -1 Sample Input 4 1 3 5 11  Sample Output -1 555 33333 55555533333  Explanation For , there is no Decent Number having  digit (so we print ).  For ,  is the only possible number. (Decent Number Property 3).  For ,  is the only possible number. (Decent Number Property 2).  For ,  is the Decent Number.  All other permutations of these digits are not decent (Decent Number Property 4).
__label__Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.
__label__Hash-Table __label__Tree Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. The lists are equal only if they have the same number of nodes and corresponding nodes contain the same data. Either head pointer given may be null meaning that the corresponding list is empty. Input Format You have to complete the int CompareLists(Node* headA, Node* headB) method which takes two arguments - the heads of the two linked lists to compare. You should NOT read any input from stdin/console. int CompareLists(Node* headA, Node* headB) The input is handled by the code in the editor and the format is as follows:  The first line contains , the number of test cases. The format for each test case is as follows:   The first line contains an integer , denoting the number of elements in the first linked list.  The next  lines contain an integer each, denoting the elements of the first linked list.  The next line contains an integer , denoting the number of elements in the second linked list.  The next  lines contain an integer each, denoting the elements of the second linked list.   Constraints     , where  is the  element in the list.   Output Format Compare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout/console. return return The output is handled by the code in the editor and it is as follows:   For each test case, in a new line, print  if the two lists are equal, else print .   Sample Input 2 2 1 2 1 1 2 1 2 2 1 2  Sample Output 0 1  Explanation In the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL In the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL
__label__Array __label__Greedy-Algorithms Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Hash-Table __label__Greedy-Algorithms We have a set of items: the i-th item has value values[i] and label labels[i]. Then, we choose a subset S of these items, such that:  |S| <= num_wanted For every label L, the number of items in S with label L is <= use_limit.  Return the largest possible sum of the subset S.    Example 1: Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1 Output: 9 Explanation: The subset chosen is the first, third, and fifth item.   Example 2: Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2 Output: 12 Explanation: The subset chosen is the first, second, and third item.   Example 3: Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1 Output: 16 Explanation: The subset chosen is the first and fourth item.   Example 4: Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2 Output: 24 Explanation: The subset chosen is the first, second, and fourth item.    Note:  1 <= values.length == labels.length <= 20000 0 <= values[i], labels[i] <= 20000 1 <= num_wanted, use_limit <= values.length
__label__Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000
__label__Search Watson gives Sherlock an array of integers.  His challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right.  For instance, given the array ,  is between two subarrays that sum to .  If your starting array is , that element satisfies the rule as left and right sum to . You will be given arrays of integers and must determine whether there is an element that meets the criterion. Function Description  Complete the balancedSums function in the editor below.  It should return a string, either YES if there is an element meeting the criterion or NO otherwise.   YES NO balancedSums has the following parameter(s):   arr: an array of integers   Input Format The first line contains , the number of test cases.   The next  pairs of lines each represent a test case.  - The first line contains , the number of elements in the array .  - The second line contains  space-separated integers  where .   Constraints        Output Format For each test case print YES if there exists an element in the array, such that the sum of the elements on its left is equal to the sum of the elements on its right; otherwise print NO.   YES NO Sample Input 0 Sample Output 0 Explanation 0 For the first test case, no such index exists.  For the second test case, , therefore index  satisfies the given conditions. Sample Input 1 Sample Output 1 Explanation 1 In the first test case,  is between two subarrays summing to .  In the second case,  is between two subarrays summing to .  In the third case,  is between two subarrays summing to .
__label__Greedy-Algorithms You will be given a list of integers, , and a single integer .  You must create an array of length  from elements of  such that its unfairness is minimized. Call that array .  Unfairness of an array is calculated as   Where:  - max denotes the largest integer in   - min denotes the smallest integer in   As an example, consider the array  with a  of .  Pick any two elements, test .    Testing for all pairs, the solution  provides the minimum unfairness. Note: Integers in  may not be unique.  Function Description Complete the maxMin function in the editor below.  It must return an integer that denotes the minimum possible value of unfairness.   maxMin has the following parameter(s): k:  an integer, the number of elements in the array to create arr:  an array of integers .  Input Format The first line contains an integer , the number of elements in array .  The second line contains an integer .  Each of the next  lines contains an integer  where .    Constraints       Output Format An integer that denotes the minimum possible value of unfairness. Sample Input 0 Sample Output 0 Explanation 0 Here ; selecting the  integers , unfairness equals   max(10,20,30) - min(10,20,30) = 30 - 10 = 20  Sample Input 1 Sample Output 1 Explanation 1 Here ; selecting the  integers , unfairness equals   max(1,2,3,4) - min(1,2,3,4) = 4 - 1 = 3  Sample Input 2 Sample Output 2 Explanation 2 Here .   or  give the minimum unfairness of .
__label__Binary-Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].
__label__Dynamic-Programming __label__Depth-first-Search There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100.
__label__Tree __label__Depth-first-Search Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin.    Example 1:  Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.   Example 2:  Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.   Example 3:  Input: [1,0,2] Output: 2   Example 4:  Input: [1,0,0,null,3] Output: 4    Note:  1<= N <= 100 0 <= node.val <= N
__label__Mathematics __label__Dynamic-Programming Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.   Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.  Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.    Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
__label__Dynamic-Programming Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order.   Example 1: Input: N = 3, K = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes.   Example 2: Input: N = 2, K = 1 Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]    Note:  1 <= N <= 9 0 <= K <= 9
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You’re given the pointer to the head node of a linked list, an integer to add to the list and the position at which the integer must be inserted. Create a new node with the given integer, insert this node at the desired position and return the head node.   A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.   As an example, if your list starts as  and you want to insert a node at position  with , your new list should be  Function Description Complete the function insertNodeAtPosition in the editor below.  It must return a reference to the head node of your finished list. insertNodeAtPosition has the following parameters: head: a SinglyLinkedListNode pointer to the head of the list data: an integer value to insert as data in your new node position: an integer position to insert the new node, zero based indexing Input Format The first line contains an integer , the number of elements in the linked list.  Each of the next  lines contains an integer SinglyLinkedListNode[i].data.  The next line contains an integer  denoting the data of the node that is to be inserted.  The last line contains an integer . Constraints   , where  is the  element of the linked list.   .   Output Format Return a reference to the list head.  Locked code prints the list for you. Sample Input 3 16 13 7 1 2  Sample Output 16 13 1 7  Explanation The initial linked list is 16 13 7. We have to insert  at the position  which currently has  in it. The updated linked list will be 16 13 1 7 16 13 7 16 13 1 7
__label__Greedy-Algorithms Consider two -element arrays of integers,  and . You want to permute them into some  and  such that the relation  holds for all  where . For example, if , , and , a valid  satisfying our relation would be  and ,  and . You are given  queries consisting of , , and . For each query, print YES on a new line if some permutation ,  satisfying the relation above exists.  Otherwise, print NO.   YES NO Function Description  Complete the twoArrays function in the editor below.  It should return a string, either YES or NO.   YES NO twoArrays has the following parameter(s):   k: an integer   A: an array of integers   B: an array of integers   Input Format The first line contains an integer , the number of queries.  The next  sets of  lines are as follows: The first line contains two space-separated integers  and , the size of both arrays  and , and the relation variable. The second line contains  space-separated integers . The third line contains  space-separated integers . Constraints     Output Format For each query, print YES on a new line if valid permutations exist.  Otherwise, print NO. YES NO Sample Input 2 3 10 2 1 3 7 8 9 4 5 1 2 2 1 3 3 3 4  Sample Output YES NO  Explanation We perform the following two queries: , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  , , and . We permute these into  and  so that the following statements are true:      Thus, we print YES on a new line.  YES , , and . To permute  and  into a valid  and , we would need at least three numbers in  to be greater than ; as this is not the case, we print NO on a new line. NO
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You’re given the pointer to the head node of a linked list. Change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty. next Input Format You have to complete the SinglyLinkedListNode reverse(SinglyLinkedListNode head) method which takes one argument - the head of the linked list. You should NOT read any input from stdin/console. SinglyLinkedListNode reverse(SinglyLinkedListNode head) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases.  Each test case is of the following format:   The first line contains an integer , denoting the number of elements in the linked list.  The next  lines contain an integer each, denoting the elements of the linked list.   Constraints     , where  is the  element in the list. Output Format Change the next pointers of the nodes that their order is reversed and return the head of the reversed linked list. Do NOT print anything to stdout/console. next return The output is handled by the code in the editor. The output format is as follows: For each test case, print in a new line the elements of the linked list after reversing it, separated by spaces. Sample Input 1 5 1 2 3 4 5  Sample Output 5 4 3 2 1   Explanation The initial linked list is: 1 -> 2 -> 3 -> 4 -> 5 -> NULL The reversed linked list is: 5 -> 4 -> 3 -> 2 -> 1 -> NULL
__label__Graph-Algorithms Markov takes out his Snakes and Ladders game, stares at the board and wonders:   "If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?"    Rules The game is played with a cubic die of  faces numbered  to . Starting from square , land on square  with the exact roll of the die.  If moving the number rolled would place the player beyond square , no move is made. Starting from square , land on square  with the exact roll of the die.  If moving the number rolled would place the player beyond square , no move is made. If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only. If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only. If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only. If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only. Function Description  Complete the quickestWayUp function in the editor below.  It should return an integer that represents the minimum number of moves required.   quickestWayUp has the following parameter(s):   ladders: a 2D integer array where each  contains the start and end cell numbers of a ladder    snakes: a 2D integer array where each  contains the start and end cell numbers of a snake   Input Format The first line contains the number of tests, .    For each testcase:  - The first line contains , the number of ladders.  - Each of the next  lines contains two space-separated integers, the start and end of a ladder.  - The next line contains the integer , the number of snakes.  - Each of the next  lines contains two space-separated integers, the start and end of a snake. Constraints     The board is always  with squares numbered  to .  Neither square  nor square  will be the starting point of a ladder or snake.  A square will have at most one endpoint from either a snake or a ladder.   Output Format For each of the t test cases, print the least number of rolls to move from start to finish on a separate line.  If there is no solution, print -1. -1 Sample Input 2 3 32 62 42 68 12 98 7 95 13 97 25 93 37 79 27 75 19 49 47 67 17 4 8 52 6 80 26 42 2 72 9 51 19 39 11 37 29 81 3 59 5 79 23 53 7 43 33 77 21   Sample Output 3 5  Explanation For the first test:  The player can roll a  and a  to land at square .  There is a ladder to square .  A roll of  ends the traverse in  rolls.   For the second test:  The player first rolls  and climbs the ladder to square .  Three rolls of  get to square .  A final roll of  lands on the target square in  total rolls.
__label__Dynamic-Programming Given a tree T with n nodes, how many subtrees (T') of T have at most K edges connected to (T - T')?  Input Format The first line contains two integers n and K followed by n-1 lines each containing two integers a & b denoting that there's an edge between a & b. Constraints 1 <= K <= n <= 50  Every node is indicated by a distinct number from 1 to n. Output Format A single integer which denotes the number of possible subtrees. Sample Input 3 1 2 1 2 3  Sample Output 6  Explanation There are 2^3 possible sub-trees:    {} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3} But:  the sub-trees {2} and {1,3} are not valid.  {2} isn't valid because it has 2 edges connecting to it's complement {1,3} whereas K = 1 in the sample test-case {1,3} isn't valid because, well, it's not a sub-tree. The nodes aren't connected.
__label__Data-Structures __label__Advanced-Data-Structures Given a rooted tree of  nodes, where each node is uniquely numbered in between [1..N]. The node 1 is the root of the tree. Each node has an integer value which is initially 0. You need to perform the following two kinds of queries on the tree: add t value: Add value to all nodes in subtree rooted at t max a b: Report maximum value on the path from a to b Input Format First line contains N, number of nodes in the tree. Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, the number of queries to process.  Next Q lines follow with either add or max query per line. Constraints           Output Format For each max query output the answer in a separate line. Sample Input 5 1 2 2 3 2 4 5 1 6 add 4 30 add 5 20 max 4 5 add 2 -20 max 4 5 max 3 4  Sample Output 30 20 10  Explanation In the test case we have the following tree:  Initially all node values are zero.  Queries are performed in the following way: add 4 30 // add 30 to node 4  add 5 20 // add 20 to node 5  max 4 5 // maximum of nodes 4,2,1,5 is 30  add 2 -20 // subtract 20 from nodes 2,3,4  max 4 5 // maximum of nodes 4,2,1,5 is 20  max 3 4 // maximum of nodes 3,2,4 is 10
__label__Graph-Algorithms You are given an array with  -bit integers: . BIT(x, i) = (x >> i) & 1. (where  is the  lower bit of  in binary form.) If we regard every bit as a vertex of a graph G, there exists one undirected edge between vertex  and vertex  if there exists at least one k such that BIT(d[k], i) == 1 && BIT(d[k], j) == 1. For every subset of the input array, how many  connected-components are there in that graph? The number of connected-components in a graph are the sets of nodes, which are accessible to each other, but not to/from the nodes in any other set.   For example if a graph has six nodes, labelled . And contains the edges . There are three connected-components: ,  and . Because  can be accessed from each other through one or more edges,  can access each other and  is isolated from everone else.   You only need to output the sum of the number of connected-component() in every graph. Input Format n d[0] d[1] ... d[n - 1]  Constraints    Output Format Print the value of .
__label__Dynamic-Programming An Introduction to the Longest Increasing Subsequence Problem  The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in strictly ascending order. This is called the Longest Increasing Subsequence (LIS) problem. For example, the length of the LIS for  is  since the longest increasing subsequence is .   Here's a great YouTube video of a lecture from MIT's Open-CourseWare covering the topic.     This is one approach which solves this in quadratic time using dynamic programming. A more efficient algorithm which solves the problem in  time is available here.  Given a sequence of integers, find the length of its longest strictly increasing subsequence. Function Description  Complete the longestIncreasingSubsequence function in the editor below.  It should return an integer that denotes the array's LIS.   longestIncreasingSubsequence has the following parameter(s):   arr: an unordered array of integers   Input Format The first line contains a single integer , the number of elements in .  Each of the next  lines contains an integer,  Constraints     Output Format Print a single line containing a single integer denoting the length of the longest increasing subsequence. Sample Input 0 Sample Output 0 Explanation 0 In the array , the longest increasing subsequence is .  It has a length of . Sample Input 1 Sample Output 1 Explanation 1 The LIS of  is .
__label__Strings Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?  Example 1: Input: S = "11011000" Output: "11100100" Explanation: The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.   Note: S has length at most 50. S is guaranteed to be a special binary string as defined above.
__label__Mathematics You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.
__label__Depth-first-Search There are N network nodes, labelled 1 to N. Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target. Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.   Example 1:  Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2 Output: 2    Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.
__label__Search __label__Mathematics Sunny and Johnny like to pool their money and go to the ice cream parlor.  Johnny never buys the same flavor that Sunny does.  The only other rule they have is that they spend all of their money. Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.   For example, they have  to spend and there are flavors costing .  The two flavors costing  and  meet the criteria.  Using -based indexing, they are at indices  and .   Function Description Complete the icecreamParlor function in the editor below.  It should return an array containing the indices of the prices of the two flavors they buy, sorted ascending.   icecreamParlor has the following parameter(s):   m: an integer denoting the amount of money they have to spend   cost: an integer array denoting the cost of each flavor of ice cream   Input Format The first line contains an integer, , denoting the number of trips to the ice cream parlor.   The next  sets of lines each describe a visit.  Each trip is described as follows: The integer , the amount of money they have pooled.  The integer , the number of flavors offered at the time.   space-separated integers denoting the cost of each flavor: .   Note:  The index within the cost array represents the flavor of the ice cream purchased.   Constraints       , ∀   There will always be a unique solution. Output Format For each test case, print two space-separated integers denoting the indices of the two flavors purchased, in ascending order.   Sample Input 2 4 5 1 4 5 3 2 4 4 2 2 4 3  Sample Output 1 4 1 2  Explanation Sunny and Johnny make the following two trips to the parlor: The first time, they pool together  dollars. Of the five flavors available that day, flavors  and  have a total cost of .   The second time, they pool together  dollars. TOf the four flavors available that day, flavors  and  have a total cost of .
__label__Dynamic-Programming On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.
__label__Array __label__Two-Pointers Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
__label__Mathematics Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.   Example 1: Input: date = "2019-01-09" Output: 9 Explanation: Given date is the 9th day of the year in 2019.  Example 2: Input: date = "2019-02-10" Output: 41  Example 3: Input: date = "2003-03-01" Output: 60  Example 4: Input: date = "2004-03-01" Output: 61    Constraints:  date.length == 10 date[4] == date[7] == '-', and all other date[i]'s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.
__label__Hash-Table Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].
__label__Tree __label__Data-Structures For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements: The  value of every node in a node's left subtree is less than the data value of that node. The  value of every node in a node's right subtree is greater than the data value of that node. Given the root node of a binary tree, can you determine if it's also a binary search tree?  Complete the function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge. Input Format You are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument. Constraints  Output Format You are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line. Sample Input  Sample Output No
__label__Array __label__Mathematics Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000
__label__Graph-Algorithms The member states of the UN are planning to send  people to the moon. They want them to be from different countries.  You will be given a list of pairs of astronaut ID's.  Each pair is made of astronauts from the same country.  Determine how many pairs of astronauts from different countries they can choose from. For example, we have the following data on 2 pairs of astronauts, and 4 astronauts total, numbered  through . 1   2 2   3  Astronauts by country are  and .  There are  pairs to choose from:  and . Function Description  Complete the journeyToMoon function in the editor below.  It should return an integer that represents the number of valid pairs that can be formed.   journeyToMoon has the following parameter(s):   n: an integer that denotes the number of astronauts   astronaut: a 2D array where each element  is a  element integer array that represents the ID's of two astronauts from the same country   Input Format The first line contains two integers  and , the number of astronauts and the number of pairs.  Each of the next  lines contains  space-separated integers denoting astronaut ID's of two who share the same nationality.  Constraints     Output Format An integer that denotes the number of ways to choose a pair of astronauts from different coutries. Sample Input 0 Sample Output 0 Explanation 0 Persons numbered  belong to one country, and those numbered  belong to another. The UN has  ways of choosing a pair:    Sample Input 1 Sample Output 1 Explanation 1 Persons numbered   belong to the same country, but persons  and  don't share countries with anyone else.  The UN has  ways of choosing a pair:
__label__Dynamic-Programming We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["babca","bbazb"] and deletion indices {0, 1, 4}, then the final array after deletions is ["bc","az"]. Suppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in lexicographic order. For clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on. Return the minimum possible value of D.length.    Example 1: Input: ["babca","bbazb"] Output: 3 Explanation: After deleting columns 0, 1, and 4, the final array is A = ["bc", "az"]. Both these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]). Note that A[0] > A[1] - the array A isn't necessarily in lexicographic order.   Example 2: Input: ["edcba"] Output: 4 Explanation: If we delete less than 4 columns, the only row won't be lexicographically sorted.   Example 3: Input: ["ghi","def","abc"] Output: 0 Explanation: All rows are already lexicographically sorted.       Note:  1 <= A.length <= 100 1 <= A[i].length <= 100
__label__Strings Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].
__label__Dynamic-Programming An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Time Limits C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5 Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions: Any pair of servers within the network should be directly connected by at most 1 link. Each link is controlled by some specific network administrator. No server has more than 2 links connected to it, that are controlled by the same administrator. For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers) Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software.  Operations performed by the directives are: Change the administrator assigned to some particular link. Place some number of security devices along a particular link. Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers. Input Format  Input begins with a line containing 4 integers  separated by a single whitespace, denoting the number of servers, links, network administrators and transformations, respectively.  lines follow each one with 3 integers  and , saying that there is a link between server  and server , and that link is controlled by administrator . Initially, network topology fulfills the restrictions described above and there is no security device along any link. Remaining  lines in the input follow one the next formats:     meaning that link between server  and server   is requested to be assigned to administrator      meaning that the number of security devices along the link between server  and server   will be fixed to  , removing any existing devices on this link before the operation. The involved link will always exist.       meaning that directives want to know the number of security devices placed along the path between server  and server , just considering links controlled by administrator . Output Format  For each network transformation in the form     you should output: "Wrong link" if there is no direct link between server  and server . "Already controlled link" if the requested link does exist, but it is already controlled by administrator . "Server overload" if administrator  already controls 2 links connected to one of the involved servers. "Network redundancy" if the requested assignment creates no new connection considering just the links controlled by . "Assignment done" if none of the above conditions holds. In this case, link directly connecting  with  is assigned to . For each network transformation in the form     you should output: "No connection" if there is no path between the requested servers considering just the links controlled by . " security devices placed" where D is the number of security devices placed so far on the existing connection between the requested servers considering just the links controlled by .  Constraints           Sample Input: 4 5 3 15 1 2 1 2 3 1 3 4 2 1 4 2 1 3 3 2 3 4 49 1 1 2 3 2 1 4 64 3 1 4 2 1 1 2 3 3 4 2 3 3 1 3 3 1 1 4 3 3 3 4 2 3 2 4 1 2 1 4 13 2 1 3 21 2 2 3 24 1 2 3 3 1 2 4 3  Sample Output: Assignment done 64 security devices placed Already controlled link No connection 0 security devices placed Server overload 49 security devices placed No connection Network redundancy Wrong link
__label__Array On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move.   Example 1:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  In this example the rook is able to capture all the pawns.  Example 2:  Input: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 0 Explanation:  Bishops are blocking the rook to capture any pawn.  Example 3:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  The rook can capture the pawns at positions b5, d6 and f5.    Note:  board.length == board[i].length == 8 board[i][j] is either 'R', '.', 'B', or 'p' There is exactly one cell with board[i][j] == 'R'
__label__Hash-Table Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
__label__Dynamic-Programming Let's consider a permutation P = {p1, p2, ..., pN} of the set of N = {1, 2, 3, ..., N} elements .   P is called a magic set if it satisfies both of the following constraints:   Given a set of K integers, the elements in positions a1, a2, ..., aK are less than their adjacent elements, i.e., pai-1 > pai < pai+1 Given a set of L integers, elements in positions b1, b2, ..., bL are  greater than their adjacent elements, i.e., pbi-1 < pbi > pbi+1 How many such magic sets are there? Input Format  The first line of input contains three integers N, K, L separated by a single space.  The second line contains K integers, a1, a2, ... aK each separated by single space.  the third line contains L integers, b1, b2, ... bL each separated by single space.  Output Format  Output the answer modulo 1000000007 (109+7). Constraints  3 <= N <= 5000  1 <= K, L <= 5000  2 <= ai, bj <= N-1, where i ∈ [1, K] AND j ∈ [1, L]   Sample Input #00  4 1 1 2 3  Sample Output #00  5  Explanation #00 Here, N = 4 a1 = 2 and b1 = 3. The 5 permutations of {1,2,3,4} that satisfy the condition are  2 1 4 3 3 2 4 1 4 2 3 1 3 1 4 2 4 1 3 2 Sample Input #01 10 2 2 2 4 3 9  Sample Output #01 161280
__label__Array __label__Binary-Search Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true  Example 2: Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false
__label__Hash-Table __label__Strings Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed.   Example 1:  Input: text = "nlaebolko" Output: 1  Example 2:  Input: text = "loonbalxballpoon" Output: 2  Example 3: Input: text = "leetcode" Output: 0    Constraints:  1 <= text.length <= 10^4 text consists of lower case English letters only.
__label__Strings __label__Greedy-Algorithms Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.
__label__Depth-first-Search There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network. A critical connection is a connection that, if removed, will make some server unable to reach some other server. Return all critical connections in the network in any order.   Example 1:  Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output: [[1,3]] Explanation: [[3,1]] is also accepted.    Constraints:  1 <= n <= 10^5 n-1 <= connections.length <= 10^5 connections[i][0] != connections[i][1] There are no repeated connections.
__label__Mathematics __label__Binary-Search __label__Dynamic-Programming You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000
__label__Depth-first-Search Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3
__label__Data-Structures __label__Advanced-Data-Structures A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves. Change the number of books in one of the shelves. Change the number of books in one of the shelves. Obtain the number of books on the shelf having the kth rank within  the range of shelves.  Obtain the number of books on the shelf having the kth rank within  the range of shelves.  A shelf is said to have the kth rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order. Can you write a program to simulate the above queries? Input Format  The first line contains a single integer T, denoting the number of test cases.  The first line of each test case contains an integer N denoting the number of shelves in the library.  The next line contains N space separated integers where the ith integer represents the number of books on the ith shelf where 1<=i<=N.  The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query.  Queries can be of two types: 1 x k - Update the number of books in the xth shelf to k (1 <= x <= N). 0 x y k - Find the number of books on the shelf between the shelves x and y  (both inclusive) with the kth rank (1 <= x <= y <= N, 1 <= k <= y-x+1). Output Format  For every test case, output the results of the queries in a new line. Constraints  1 <= T <= 5  1 <= N <= 104  1 <= Q <= 104  The number of books on each shelf is always guaranteed to be between 1 and 1000. Sample Input 2 2 1 2 2 0 1 2 1 0 1 2 2 4 4 3 2 1 4 0 1 1 1 1 1 1 0 1 1 1 0 1 4 3  Sample Output 1 2 4 1 2  Explanation  There are two test cases : The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2. The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2.
__label__Strings Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note:  The length of both num1 and num2 is < 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__Array A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n. The bus goes along both directions i.e. clockwise and counterclockwise. Return the shortest distance between the given start and destination stops.   Example 1:  Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.   Example 2:  Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.    Example 3:  Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.    Constraints:  1 <= n <= 10^4 distance.length == n 0 <= start, destination < n 0 <= distance[i] <= 10^4
__label__Dynamic-Programming A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7    A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N. A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A. The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.    Example: Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]
__label__Graph-Algorithms __label__Graph-Algorithms It's almost summertime, so Big Cat and Little Cat are getting in shape. They decide the core of their fitness plan is to start jogging every day. Their city consists of  intersections connected by  bidirectional roads. The cats decide that their jogging route should be cyclic (i.e., starting and ending at the same intersection) and consist of  different roads. The cats also love exploring new places, so each day they want to choose a new route to jog on that is not equal to any of their previous routes. Two routes are considered to be equal if their sets of component roads are equal. Given a map of the city, can you help our heroic cats determine the maximum number of days they can go jogging so that every route traveled is different?  Input Format The first line contains a pair of space-separated integers,  (the number of intersections) and  (the number of roads), respectively. Each line  of the  subsequent lines contains a pair of space-separated integers,  and , defining a bidirectional road connecting intersections  and . Constraints    Each bidirectional road connects  distinct intersections (i.e., no road connects an intersection to itself). Each pair of intersections is directly connected by no more than  road. Output Format Print the maximum number of days for which the cats can go jogging without repeating a route. Sample Input 4 6 1 2 2 3 3 4 4 1 1 3 2 4  Sample Output 3  Explanation There are  different routes:    Recall that each route is a set of intersections forming a cycle, so each unique route is the same regardless of which city on the route the cats start out at. Thus, we print  (the number of routes) as our answer.
__label__Game-Theory __label__Game-Theory Two players are playing a game on a  chessboard. The rules of the game are as follows: The game starts with  coins located at one or more  coordinates on the board (a single cell may contain more than one coin). The coordinate of the upper left cell is , and the coordinate of the lower right cell is . In each move, a player must move a single coin from some cell  to one of the following locations:       .  Note: The coin must remain inside the confines of the board. In each move, a player must move a single coin from some cell  to one of the following locations:       .  Note: The coin must remain inside the confines of the board. The players move in alternating turns. The first player who is unable to make a move loses the game. The players move in alternating turns. The first player who is unable to make a move loses the game. The figure below shows all four possible moves:  Note: While the figure shows a  board, this game is played on a  board. Given the value of  and the initial coordinate(s) of  coins, determine which player will win the game. Assume both players always move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is defined as follows over the subsequent lines: The first line contains an integer, , denoting the number of coins on the board. Each line  (where ) of the  subsequent lines contains  space-separated integers describing the respective values of  and  of the coordinate where coin  is located. Note: Recall that a cell can have more than one coin (i.e., any cell can have  to  coins in it at any given time). Constraints   , where . Output Format On a new line for each test case, print  if the first player is the winner; otherwise, print . Sample Input 2 3 5 4 5 8 8 2 6 7 1 7 2 7 3 7 4 7 4 7 4  Sample Output First Second
__label__Two-Pointers __label__Greedy-Algorithms A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.  Example 1: Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.   Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only.
__label__Data-Structures __label__Advanced-Data-Structures Alexey is playing with an array, , of  integers. His friend, Ivan, asks him to calculate the sum of the maximum values for all subsegments of . More formally, he wants Alexey to find . Alexey solved Ivan's challenge faster than expected, so Ivan decides to add another layer of difficulty by having Alexey answer  queries. The  query contains subsegment , and he must calculate the sum of maximum values on all subsegments inside subsegment .  More formally, for each query , Alexey must calculate the following function: . Can you help Alexey solve this problem? Input Format The first line contains  space-separated positive integers,  (the length of array ) and  (number of queries), respectively.  The second line contains  space-separated integers,  describing each element  (where ) in array .  Each of the  subsequent lines contains  space-separated positive integers describing the respective values for  and  in query  (where ). Constraints    Output Format For each query  (where ), print its answer on a new line. Sample Input 3 6 1 3 2 1 1 1 2 1 3 2 2 2 3 3 3  Sample Output 1 7 15 3 8 2  Explanation The answer for the second query is shown below:   The answer for the third query is shown below:
__label__Dynamic-Programming Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.
__label__Dynamic-Programming We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.
__label__Data-Structures We're going to make our own Contacts application! The application must perform two types of operations: add name, where  is a string denoting a contact name. This must store  as a new contact in the application.   add name find partial, where  is a string denoting a partial name to search the application for. It must count the number of contacts starting with  and print the count on a new line. find partial Given  sequential add and find operations, perform each operation in order. Input Format The first line contains a single integer, , denoting the number of operations to perform.  Each line  of the  subsequent lines contains an operation in one of the two forms defined above.   Constraints       It is guaranteed that  and  contain lowercase English letters only. The input doesn't have any duplicate  for the  operation. Output Format For each find partial operation, print the number of contact names starting with  on a new line. find partial Sample Input 4 add hack add hackerrank find hac find hak  Sample Output 2 0  Explanation We perform the following sequence of operations: Add a contact named hack. hack Add a contact named hackerrank. hackerrank Find and print the number of contact names beginning with hac. There are currently two contact names in the application and both of them start with hac, so we print  on a new line. hac hac Find and print the number of contact names beginning with hak. There are currently two contact names in the application but neither of them start with hak, so we print  on a new line. hak hak
__label__Mathematics __label__Two-Pointers We sampled integers between 0 and 255, and stored the results in an array count:  count[k] is the number of integers we sampled equal to k. Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers.  The mode is guaranteed to be unique. (Recall that the median of a sample is:  The middle element, if the elements of the sample were sorted and the number of elements is odd; The average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)    Example 1: Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,3.00000,2.37500,2.50000,3.00000] Example 2: Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,4.00000,2.18182,2.00000,1.00000]    Constraints:  count.length == 256 1 <= sum(count) <= 10^9 The mode of the sample that count represents is unique. Answers within 10^-5 of the true value will be accepted as correct.
__label__Dynamic-Programming In this challenge, you will be given an array  and must determine an array .  There is a special rule:  For all , .  That is,  can be any number you choose such that .  Your task is to select a series of  given  such that the sum of the absolute difference of consecutive pairs of  is maximized.  This will be the array's cost, and will be represented by the variable  below.  The equation can be written:   For example, if the array , we know that , , and .  Arrays meeting those guidelines are: Our calculations for the arrays are as follows: The maximum value obtained is . Function Description Complete the cost function in the editor below.  It should return the maximum value that can be obtained.   cost has the following parameter(s):   B: an array of integers   Input Format The first line contains the integer , the number of test cases.  Each of the next  pairs of lines is a test case where:  - The first line contains an integer , the length of   - The next line contains  space-separated integers   Constraints     Output Format For each test case, print the maximum sum on a separate line.    Sample Input 1 5 10 1 10 1 10  Sample Output 36  Explanation The maximum sum occurs when A[1]=A[3]=A[5]=10 and A[2]=A[4]=1.  That is .
__label__Graph-Algorithms The travelling salesman has a map containing m*n squares. He starts from the top left corner and visits every cell exactly once and returns to his initial position (top left). The time taken for the salesman to move from a square to its neighbor might not be the same. Two squares are considered adjacent if they share a common edge and the time taken to reach square b from square a and vice-versa are the same. Can you figure out the shortest time in which the salesman can visit every cell and get back to his initial position?  Input Format The first line of the input is 2 integers m and n separated by a single space. m and n are the number of rows and columns of the map.  Then m lines follow, each of which contains (n – 1) space separated integers. The jth integer of the ith line is the travel time from position (i,j) to (i,j+1) (index starts from 1.)  Then (m-1) lines follow, each of  which contains n space integers. The jth integer of the ith line is the travel time from position (i,j) to (i + 1, j).  Constraints 1 ≤ m, n ≤ 10  Times are non-negative integers no larger than 10000.   Output Format Just an integer contains the minimal time to complete his task. Print 0 if its not possible to visit each cell exactly once.  Sample Input 2 2 5 8 6 7  Sample Output 26  Explanation As its a 2*2 square, all cells are visited. 5 + 7 + 8 + 6 = 26
__label__Hash-Table Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.
__label__Binary-Search Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]    Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?
__label__Hash-Table __label__Strings On an alphabet board, we start at position (0, 0), corresponding to character board[0][0]. Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.  We may make the following moves:  'U' moves our position up one row, if the position exists on the board; 'D' moves our position down one row, if the position exists on the board; 'L' moves our position left one column, if the position exists on the board; 'R' moves our position right one column, if the position exists on the board; '!' adds the character board[r][c] at our current position (r, c) to the answer.  (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.   Example 1: Input: target = "leet" Output: "DDR!UURRR!!DDD!" Example 2: Input: target = "code" Output: "RR!DDRR!UUL!R!"    Constraints:  1 <= target.length <= 100 target consists only of English lowercase letters.
__label__Graph-Algorithms There are  colors of beads. You have  beads of the  color. You want to make an ornament by joining all the beads together. You create the ornament by using the following algorithm: Step # Arrange all the beads in any order such that beads of the same color are placed together. Step # Arrange all the beads in any order such that beads of the same color are placed together. Step # The ornament initially consists of only the first bead from the arrangement. Step # The ornament initially consists of only the first bead from the arrangement. Step # For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament. Step # For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament. All beads are distinct, even if they have the same color. How many different ornaments can be formed by following the above algorithm? Two ornaments are considered different if two beads are joined by a thread in one configuration, but not in the other. Update/clarification Think of the bead formation as a tree and not as a straight line. Any number of beads can be connected to a bead. Input Format The first line contains the number of test cases .  test cases follow. Each test case contains  on the first line - the number of colors of beads. The next line contains  integers, where the  integer  denotes the number of beads of the  color. Constraints    Output Format Output  lines, one for each test case. All answers should be output modulo . Sample Input 5 2 2 1 2 2 2 1 4 2 3 1 5 1 1 1 1 1  Sample Output Explanation Testcase 1: Let us label the beads A1,A2 and B1. Initially, they can be arranged in  ways - "A1,A2,B1", "A2,A1,B1", "B1,A1,A2", and "B1,A2,A1".  For each of the first two arrangements, an ornament can be formed in  ways (A1-A2-B1 or B1-A1-A2 from the first one and A2-A1-B1 or B1-A2-A1 from the second one).  For each of the last two arrangements, an ornament can be formed in  way.  However, of the total  possible ornaments, there are only  unique ones : A1 - A2 - B1, and A2 - A1 - B1. Testcase 2: The possible unique ornaments are A1 - A2 - B1 - B2, A1 - A2 - B2 - B1, A2 - A1 - B1 - B2, and A2 - A1 - B2 - B1. Testcase 3: For the third test-case, it might be easier to see there are only  types of graphs on  vertices: the path or the star. It's not hard to see that there are  paths and  stars (explanation courtesy: zlangley) Testcase 5: For the fifth test-case, a lot of people claimed that the total number of possible ways is . But that is wrong. The correct answer is . Here's the hint: Once again, you've to think of it as a tree.  So one possible arrangement can be: A is a root node and has two edges (A-B and A-C). Now, think of B as a sub-root node with two edges (B-D and B-E). Similarly, you can figure out the other possible bead arrangements. This will lead you to the correct answer.
__label__Tree __label__Data-Structures The height of a binary tree is the number of edges between the tree's root and its furthest leaf.  For example, the following binary tree is of height :   Function Description Complete the getHeight or height function in the editor.  It must return the height of a binary tree as an integer. getHeight or height has the following parameter(s): root: a reference to the root of a binary tree.     Note -The Height of binary tree with single node is taken as zero.   Input Format The first line contains an integer , the number of nodes in the tree.  Next line contains  space separated integer where th integer denotes node[i].data. Note:  Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function.  In a binary search tree, all nodes on the left branch of a node are less than the node value.  All values on the right branch are greater than the node value. Constraints    Output Format Your function should return a single integer denoting the height of the binary tree. Sample Input  Sample Output 3  Explanation The longest root-to-leaf path is shown below:  There are  nodes in this path that are connected by  edges, meaning our binary tree's .
__label__Bit Jack and Daniel are friends.  They want to encrypt their conversations so that they can save themselves from interception by a detective agency so they invent a new cipher.   Every message is encoded to its binary representation. Then it is written down  times, shifted by  bits. Each of the columns is XORed together to get the final encoded string. If  and  it looks like so:   1001011     shift 0  01001011    shift 1 001001011   shift 2 0001001011  shift 3 ---------- 1110101001  <- XORed/encoded string s  Now we have to decode the message.  We know that .  The first digit in  so our output string is going to start with .  The next two digits are also , so they must have been XORed with .  We know the first digit of our  shifted string is a  as well.  Since the  digit of  is , we XOR that with our  and now know there is a  in the  position of the original string.  Continue with that logic until the end. Then the encoded message  and the key  are sent to Daniel.    Jack is using this encoding algorithm and asks Daniel to implement a decoding algorithm.  Can you help Daniel implement this?   Function Description  Complete the cipher function in the editor below.  It should return the decoded string.   cipher has the following parameter(s):   k: an integer that represents the number of times the string is shifted  s: an encoded string of binary digits Input Format The first line contains two integers  and , the length of the original decoded string and the number of shifts.  The second line contains the encoded string  consisting of  ones and zeros.   Constraints       It is guaranteed that  is valid.   Output Format Return the decoded message of length , consisting of ones and zeros.   Sample Input 0 Sample Output 0 Explanation 0 1001010  1001010   1001010    1001010 ---------- 1110100110  Sample Input 1 Sample Output 1 Explanation 1 101111  101111 ------- 1110001  Sample Input 2 Sample Output 2 Explanation 2 10000101 010000101 1110011011
__label__Dynamic-Programming You are given two positive integers  and  in binary representation. You should find the following sum modulo :   where operation  means exclusive OR operation, operation  means binary shift to the left. Please note, that we consider ideal model of binary integers. That is there is infinite number of bits in each number, and there are no disappearings (or cyclic shifts) of bits. Input Format The first line contains number   in binary representation. The second line contains number   in the same format. All the numbers do not contain leading zeros. Output Format Output a single integer  the required sum modulo . Sample Input 10 1010  Sample Output 489429555
__label__Strings Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "
__label__Data-Structures You have an empty sequence, and you will be given  queries. Each query is one of these three types: 1 x  -Push the element x into the stack. 2    -Delete the element present at the top of the stack. 3    -Print the maximum element in the stack.  Input Format The first line of input contains an integer, . The next  lines each contain an above mentioned query. (It is guaranteed that each query is valid.) Constraints       Output Format For each type  query, print the maximum element in the stack on a new line. Sample Input 10 1 97 2 1 20 2 1 26 1 20 2 3 1 91 3  Sample Output 26 91
__label__Strings Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period "." with "[.]".   Example 1: Input: address = "1.1.1.1" Output: "1[.]1[.]1[.]1" Example 2: Input: address = "255.100.50.0" Output: "255[.]100[.]50[.]0"    Constraints:  The given address is a valid IPv4 address.
__label__Mathematics Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.
__label__Data-Structures __label__Advanced-Data-Structures Consider a permutation, , of integers from  to . Let's determine the  of  to be the minimum absolute difference between any  consecutive integers in :    Generate a lexicographically sorted list of all permutations of length  having a maximal distance between all permutations of the same length. Print the lexicographically  permutation. Input Format The first line contains an integer,  (the number of test cases). The  subsequent lines each contain two space-separated integers,  (the permutation length) and  (the 1-based index in the list of permutations having a maximal distance), respectively. The  line corresponds to the  test case.  Note: It is guaranteed that the sum of all  does not exceed . Constraints    Output Format For each test case: if the list of permutations having maximal distance has at least  elements, print the  permutation as sequential (i.e.: from  to ) space-separated integers on a new line; otherwise, print . Sample Input 3 3 5 4 2 4 3  Sample Output 3 1 2 3 1 4 2 -1  Explanation For  and :              Each of the  permutations has distance . We choose the fifth one (because ), and print 3 1 2 on a new line. 3 1 2 For  and :  The maximal distance in the list of permutations of integers from  to  is , and the only permutations having that distance are  and . We choose the second one (because ), and print 3 1 4 2 on a new line. 3 1 4 2
__label__Binary-Search __label__Greedy-Algorithms A string is a valid parentheses string (denoted VPS) if and only if it consists of "(" and ")" characters only, and:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are VPS's, or It can be written as (A), where A is a VPS.  We can similarly define the nesting depth depth(S) of any VPS S as follows:  depth("") = 0 depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's depth("(" + A + ")") = 1 + depth(A), where A is a VPS.  For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.   Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length). Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.   Example 1: Input: seq = "(()())" Output: [0,1,1,1,1,0]  Example 2: Input: seq = "()(())()" Output: [0,0,0,1,1,0,1,1]    Constraints:  1 <= seq.size <= 10000
__label__Strings Jimmy loves playing with strings. He thinks string  is similar to string  if the following conditions are satisfied: Both strings have the same length (i.e.,  and ).  For each valid pair of indices, , in the strings,  and  or  and .   For example, string  and  are similar as for ,  and  and for all other  pairs  as well as .   He has a string, , of size  and gives you  queries to answer where each query is in the form of a pair of integers . For each substring , find the number of substrings  where substring  is similar to substring  and print this number on a new line. Note: Substring  is the contiguous sequence of characters from index  to index . For example, if  abcdefgh, then  cdef.  abcdefgh cdef Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains string .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for query . Constraints    Output Format For each query, print the number of similar substrings on a new line. Sample Input 8 4 giggabaj 1 1 1 2 1 3 2 4  Sample Output 8 6 2 1  Explanation We perform the following sequence of queries: Strings with length  are all similar, so our answer is . gi, ig, ga, ab, ba, and aj are similar, so our answer is . gi ig ga ab ba aj gig and aba are similar, so our answer is . gig aba igg has no similar string, so our answer is . igg
__label__Array On an infinite number line, the position of the i-th stone is given by stones[i].  Call a stone an endpoint stone if it has the smallest or largest position. Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions. When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]   Example 1: Input: [7,4,9] Output: [1,2] Explanation:  We can move 4 -> 8 for one move to finish the game. Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.   Example 2: Input: [6,5,4,3,10] Output: [2,3] We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.   Example 3: Input: [100,101,104,102,103] Output: [0,0]     Note:  3 <= stones.length <= 10^4 1 <= stones[i] <= 10^9 stones[i] have distinct values.
__label__Mathematics __label__Game-Theory __label__Game-Theory After their success in coming up with Fun Game, Kyle and Mike invented another game having the following rules: The game starts with an -element sequence, , and is played by two players,  and .  The players move in alternating turns, with  always moving first. During each move, the current player chooses one of the asterisks () in the above sequence and changes it to either a + (plus) or a - (minus) sign.   + - The game ends when there are no more asterisks () in the expression. If the evaluated value of the sequence is divisible by , then  wins; otherwise,  wins. Given the value of , can you determine the outcome of the game? Print  if  will win, or  if  will win. Assume both players always move optimally. Input Format The first line of input contains a single integer , denoting the number of test cases. Each line  of the  subsequent lines contains an integer, , denoting the maximum exponent in the game's initial sequence. Constraints   Output Format For each test case, print either of the following predicted outcomes of the game on a new line: Print  if  will win. Print  if  will win. Sample Input 1 2    Sample Output First  Explanation In this case, it doesn't matter in which order the asterisks are chosen and altered. There are  different courses of action and, in each one, the final value is not divisible by  (so  always loses and we print  on a new line).  Possible options:
__label__Array We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).   Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.   Example 2: Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.   Note: 1 <= len(bits) <= 1000. bits[i] is always 0 or 1.
__label__Array In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.   You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.   If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.  Example 1: Input:  nums =  [[1,2],  [3,4]] r = 1, c = 4 Output:  [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.   Example 2: Input:  nums =  [[1,2],  [3,4]] r = 2, c = 4 Output:  [[1,2],  [3,4]] Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.   Note:  The height and width of the given matrix is in range [1, 100]. The given r and c are all positive.
__label__Tree __label__Depth-first-Search Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
__label__Dynamic-Programming Shaka and his brother have created a boring game which is played like this:   They take a word composed of lowercase English letters and try to get the maximum possible score by building exactly 2 palindromic subsequences. The score obtained is the product of the length of these 2 subsequences. Let's say  and  are two subsequences from the initial string. If  &  are the smallest and the largest positions (from the initial word) respectively in  ; and  &  are the smallest and the largest positions (from the initial word) respectively in , then the following statements hold true:  ,  , &  .  i.e., the positions of the subsequences should not cross over each other.  Hence the score obtained is the product of lengths of subsequences  & . Such subsequences can be numerous for a larger initial word, and hence it becomes harder to find out the maximum possible score. Can you help Shaka and his brother find this out? Input Format Input contains a word  composed of lowercase English letters in a single line.   Constraints   each character will be a lower case english alphabet.   Output Format Output the maximum score the boys can get from . Sample Input eeegeeksforskeeggeeks  Sample Output 50  Explanation A possible optimal solution is eee-g-ee-ksfor-skeeggeeks being eeeee the one subsequence and skeeggeeks the other one. We can also select eegee in place of eeeee, as both have the same length.
__label__Search Given an array of integers, you must answer a number of queries. Each query consists of a single integer, , and is performed as follows: Add  to each element of the array, permanently modifying it for any future queries. Find the absolute value of each element in the array and print the sum of the absolute values on a new line. Tip: The Input/Output for this challenge is very large, so you'll have to be creative in your approach to pass all test cases. Function Description  Complete the playingWithNumbers function in the editor below.  It should return an array of integers that represent the responses to each query.   playingWithNumbers has the following parameter(s):   arr: an array of integers   queries: an array of integers   Input Format The first line contains an integer  the number of elements in .  The second line contains  space-separated integers .  The third line contains an integer , the number of queries.  The fourth line contains  space-separated integers  where .     Constraints     , where . , where  Output Format For each query, print the sum of the absolute values of all the array's elements on a new line. Sample Input 3 -1 2 -3 3 1 -2 3   Sample Output 5 7 6  Explanation Query 0:   Array:   The sum of the absolute values of the updated array's elements is .     Query 1:   Array:   The sum of the absolute values of the updated array's elements is .    Query 2:   Array:   The sum of the absolute values of the updated array's elements is .
__label__Array A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15
__label__Mathematics __label__Game-Theory There are  piles of stones where the ith pile has  stones in it. Alice and Bob play the following game: Alice starts, and they alternate turns. Alice starts, and they alternate turns. In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .  In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:  or .  The player who cannot make a move (because all the remaining piles are indivisible) loses the game. The player who cannot make a move (because all the remaining piles are indivisible) loses the game. Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)? Input Format The first line contains the number of test cases .  test cases follow. The first line for each test case contains , the number of piles initially. The next line contains  space delimited numbers, the number of stones in each of the piles. Constraints     Output Format Output  lines, one corresponding to each test case containing ALICE if Alice wins the game and BOB otherwise. ALICE BOB Sample Input 4   1   4   2   1 2   3   1 3 4   1   8  Sample Output BOB   BOB   ALICE   BOB  Explanation For the first case, the only possible move for Alice is (4) -> (1,3). Now Bob breaks up the pile with 3 stones into (1,2). At this point Alice cannot make any move and has lost.
__label__Mathematics __label__Dynamic-Programming Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).  For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions:  The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happens before addition and subtraction. It's not allowed to use the unary negation operator (-).  For example, "x - x" is a valid expression as it only uses subtraction, but "-x + x" is not because it uses negation.  We would like to write an expression with the least number of operators such that the expression equals the given target.  Return the least number of operators used.    Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.  Example 2:  Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.   Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100.  The expression contains 3 operations.      Note:  2 <= x <= 100 1 <= target <= 2 * 10^8
__label__Tree __label__Depth-first-Search Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false
__label__Hash-Table __label__Binary-Search Create a timebased key-value store class TimeMap, that supports two operations. 1. set(string key, string value, int timestamp)  Stores the key and value, along with the given timestamp.  2. get(string key, int timestamp)  Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string ("").     Example 1: Input: inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]] Output: [null,null,"bar","bar",null,"bar2","bar2"] Explanation:    TimeMap kv;    kv.set("foo", "bar", 1); // store the key "foo" and value "bar" along with timestamp = 1    kv.get("foo", 1);  // output "bar"    kv.get("foo", 3); // output "bar" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie "bar"    kv.set("foo", "bar2", 4);    kv.get("foo", 4); // output "bar2"    kv.get("foo", 5); //output "bar2"       Example 2: Input: inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]] Output: [null,null,null,"","high","high","low","low"]      Note:  All key/value strings are lowercase. All key/value strings have length in the range [1, 100] The timestamps for all TimeMap.set operations are strictly increasing. 1 <= timestamp <= 10^7 TimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case.
__label__Strings The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"
__label__Array __label__Dynamic-Programming __label__Greedy-Algorithms Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.   Note: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.
__label__Dynamic-Programming __label__Strings Square Subsequences A string is called a square string if it can be obtained by concatenating two copies of the same string. For example, "abab", "aa" are square strings, while "aaa", "abba" are not. Given a string, how many (non-empty) subsequences of the string are square strings? A subsequence of a string can be obtained by deleting zero or more characters from it, and maintaining the relative order of the remaining characters. Input Format The first line contains the number of test cases, .   test cases follow. Each case contains a string, . Output Format Output  lines, one for each test case, containing the required answer modulo 1000000007. Constraints:     will have at most  lowercase characters ('a' - 'z'). Sample Input 3  aaa  abab  baaba Sample Output 3  3  6 Explanation For the first case, there are 3 subsequences of length 2, all of which are square strings.  For the second case, the subsequences "abab", "aa", "bb" are square strings.  Similarly, for the third case, "bb", "baba" (twice), and "aa" (3 of them) are the square subsequences.
__label__Array Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.    Example 1: Input: A = [1,1], B = [2,2] Output: [1,2]   Example 2: Input: A = [1,2], B = [2,3] Output: [1,2]   Example 3: Input: A = [2], B = [1,3] Output: [2,3]   Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4]    Note:  1 <= A.length <= 10000 1 <= B.length <= 10000 1 <= A[i] <= 100000 1 <= B[i] <= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer.
__label__Dynamic-Programming You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths. Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7]. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.   Example 1: Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10 Output: 3 Explanation:  We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].  Example 2: Input: clips = [[0,1],[1,2]], T = 5 Output: -1 Explanation:  We can't cover [0,5] with only [0,1] and [0,2].  Example 3: Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9 Output: 3 Explanation:  We can take clips [0,4], [4,7], and [6,9].  Example 4: Input: clips = [[0,4],[2,8]], T = 5 Output: 2 Explanation:  Notice you can have extra video after the event ends.    Note:  1 <= clips.length <= 100 0 <= clips[i][0], clips[i][1] <= 100 0 <= T <= 100
__label__Search __label__Greedy-Algorithms A group of friends want to buy a bouquet of flowers.  The florist wants to maximize his number of new customers and the money he makes.  To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus .  The first flower will be original price, , the next will be  and so on.   Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers. For example, if there are  friends that want to buy  flowers that cost  each will buy one of the flowers priced  at the original price.  Having each purchased  flower, the first flower in the list, , will now cost .  The total cost will be .   Function Description Complete the getMinimumCost function in the editor below.  It should return the minimum cost to purchase all of the flowers.   getMinimumCost has the following parameter(s): c: an array of integers representing the original price of each flower k: an integer, the number of friends Input Format The first line contains two space-separated integers  and , the number of flowers and the number of friends.  The second line contains  space-separated positive integers , the original price of each flower. Constraints        Output Format Print the minimum cost to buy all  flowers. Sample Input 0 Sample Output 0 Explanation 0 There are  flowers with costs  and  people in the group. If each person buys one flower, the total cost of prices paid is  dollars. Thus, we print  as our answer.   Sample Input 1 Sample Output 1 Explanation 1 There are  flowers with costs  and  people in the group. We can minimize the total purchase cost like so: The first person purchases  flowers in order of decreasing price; this means they buy the more expensive flower () first at price  dollars and the less expensive flower () second at price  dollars.  The second person buys the most expensive flower at price  dollars.  We then print the sum of these purchases, which is , as our answer. Sample Input 2 Sample Output 2 Explanation 2 The friends buy flowers for ,  and ,  and  for a cost of .
__label__Depth-first-Search Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.) A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit. Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.   Example 1:  Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1  Output: [1,2,3,4,null,null,7,8,9,null,14]   Example 2:  Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22  Output: [5,4,8,11,null,17,4,7,null,null,null,5]   Example 3:  Input: root = [1,2,-3,-5,null,4,null], limit = -1  Output: [1,null,-3,4]    Note:  The given tree will have between 1 and 5000 nodes. -10^5 <= node.val <= 10^5 -10^9 <= limit <= 10^9
__label__Two-Pointers In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps:  Add one piece of fruit from this tree to your baskets.  If you cannot, stop. Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop. You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each. What is the total amount of fruit you can collect with this procedure?   Example 1: Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1].   Example 2: Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1].   Example 3: Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2].   Example 4: Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits.       Note:  1 <= tree.length <= 40000 0 <= tree[i] < tree.length
__label__Strings Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.    Example 1: Input: "USA" Output: True    Example 2: Input: "FlaG" Output: False    Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.
__label__Dynamic-Programming Let's play Fairy Chess! You have an  chessboard. An -leaper is a chess piece which can move from some square  to some square  if ; however, its movements are restricted to up (), down (), left (), and right () within the confines of the chessboard, meaning that diagonal moves are not allowed. In addition, the leaper cannot leap to any square that is occupied by a pawn. Given the layout of the chessboard, can you determine the number of ways a leaper can move  times within the chessboard? Note:  refers to the absolute value of some integer, . Input Format The first line contains an integer, , denoting the number of queries. Each query is described as follows: The first line contains three space-separated integers denoting , , and , respectively. Each line  of the  subsequent lines contains  characters. The  character in the  line describes the contents of square  according to the following key: . indicates the location is empty. P indicates the location is occupied by a pawn. L indicates the location of the leaper. . indicates the location is empty. . P indicates the location is occupied by a pawn. P L indicates the location of the leaper. L Constraints   There will be exactly one L character on the chessboard. L The -leaper can move up (), down (), left (), and right () within the confines of the chessboard. It cannot move diagonally. Output Format For each query, print the number of ways the leaper can make  moves on a new line. Because this value can be quite large, your answer must be modulo . Sample Input 0 Sample Output 0 Explanation 0 You must perform two queries, outlined below. The green cells denote a cell that was leaped to by the leaper, and coordinates are defined as . The leaper can leap to the following locations:    Observe that the leaper cannot leap to the square directly underneath it because it's occupied by a pawn. Thus, there are  ways to make  move and we print  on a new line.  The leaper can leap to the following locations:    Thus, we print  on a new line. Note: Don't forget that your answer must be modulo .
__label__Data-Structures Given an array  of  distinct elements. Let  and  be the smallest and the next smallest element in the interval  where .   .   where , are the bitwise operators ,  and  respectively.  Your task is to find the maximum possible value of . Input Format First line contains integer .  Second line contains  integers, representing elements of the array .   Constraints      Output Format Print the value of maximum possible value of .    Sample Input 5 9 6 3 5 2  Sample Output 15  Explanation Consider the interval  the result will be maximum.
__label__Two-Pointers We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]
__label__Mathematics Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) Since the answer may be large, return the answer modulo 10^9 + 7.   Example 1: Input: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.  Example 2: Input: n = 100 Output: 682289015    Constraints:  1 <= n <= 100
__label__Array __label__Dynamic-Programming On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].
__label__Mathematics __label__Binary-Search You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤  Because the 3rd row is incomplete, we return 2.   Example 2: n = 8  The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  Because the 4th row is incomplete, we return 3.
__label__Dynamic-Programming Given an array of integers A, find the number of triples of indices (i, j, k) such that:  0 <= i < A.length 0 <= j < A.length 0 <= k < A.length A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.    Example 1: Input: [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 & 2 & 1 (i=0, j=1, k=0) : 2 & 1 & 2 (i=0, j=1, k=1) : 2 & 1 & 1 (i=0, j=1, k=2) : 2 & 1 & 3 (i=0, j=2, k=1) : 2 & 3 & 1 (i=1, j=0, k=0) : 1 & 2 & 2 (i=1, j=0, k=1) : 1 & 2 & 1 (i=1, j=0, k=2) : 1 & 2 & 3 (i=1, j=1, k=0) : 1 & 1 & 2 (i=1, j=2, k=0) : 1 & 3 & 2 (i=2, j=0, k=1) : 3 & 2 & 1 (i=2, j=1, k=0) : 3 & 1 & 2    Note:  1 <= A.length <= 1000 0 <= A[i] < 2^16
__label__Hash-Table Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
__label__Dynamic-Programming __label__Depth-first-Search There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].
__label__Mathematics Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
__label__Array __label__Strings Let's define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = "dcce" then f(s) = 2 because the smallest character is "c" and its frequency is 2. Now, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) < f(W), where W is a word in words.   Example 1: Input: queries = ["cbd"], words = ["zaaaz"] Output: [1] Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").  Example 2: Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"] Output: [1,2] Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").    Constraints:  1 <= queries.length <= 2000 1 <= words.length <= 2000 1 <= queries[i].length, words[i].length <= 10 queries[i][j], words[i][j] are English lowercase letters.
__label__Greedy-Algorithms Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each of the array element between two given indices, inclusive.  Once all operations have been performed, return the maximum value in your array.   For example, the length of your array of zeros .  Your list of queries is as follows:   Add the values of  between the indices  and  inclusive: The largest value is  after all operations are performed.   Function Description  Complete the function arrayManipulation in the editor below.  It must return an integer, the maximum value in the resulting array.   arrayManipulation has the following parameters: n - the number of elements in your array   queries - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.   Input Format The first line contains two space-separated integers  and , the size of the array and the number of operations.  Each of the next  lines contains three space-separated integers ,  and , the left index, right index and summand.   Constraints         Output Format Return the integer maximum value in the finished array. Sample Input 5 3 1 2 100 2 5 100 3 4 100  Sample Output 200  Explanation After the first update list will be  100 100 0 0 0.  After the second update list will be  100 200 100 100 100.  After the third update list will be  100 200 200 200 100.  The required answer will be .   100 100 0 0 0 100 200 100 100 100 100 200 200 200 100
__label__Mathematics __label__Dynamic-Programming Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9.
__label__Data-Structures People connect with each other in a social network. A connection between Person  and Person  is represented as . When two persons belonging to different communities connect, the net effect is the merger of both communities which  and  belongs to.  At the beginning, there are  people representing  communities. Suppose person  and  connected and later  and  connected, then ,, and  will belong to the same community. There are two type of queries:  communities containing person  and  merged (if they belong to different communities).  communities containing person  and  merged (if they belong to different communities).  print the size of the community to which person  belongs.   print the size of the community to which person  belongs.  Input Format The first line of input will contain integers  and , i.e. the number of people and the number of queries. The next  lines will contain the queries. Constraints :   Output Format The output of the queries. Sample Input 3 6 Q 1 M 1 2 Q 2 M 2 3 Q 3 Q 2  Sample Output 1 2 3 3  Explanation Initial size of each of the community is .
__label__Strings __label__Data-Structures Consider an array of numeric strings where each string is a positive number with anywhere from  to  digits. Sort the array's elements in non-decreasing, or ascending order of their integer values and print each element of the sorted array on a new line. Function Description  Complete the bigSorting function in the editor below.  It should return the sorted string array.   bigSorting has the following parameter(s):   unsorted: an unsorted array of integers as strings   Input Format The first line contains an integer, , denoting the number of strings in .  Each of the  subsequent lines contains an integer string . Constraints  Each string is guaranteed to represent a positive integer without leading zeros. The total number of digits across all strings in  is between  and  (inclusive). Output Format Print each element of the sorted array on a new line. Sample Input 0 Sample Output 0 Explanation 0 The initial array of strings is . When we order each string by the real-world integer value it represents, we get:   We then print each value on a new line, from smallest to largest. Sample Input 1 Sample Output 1
__label__Array Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.   Example 1: Input: day = 31, month = 8, year = 2019 Output: "Saturday"  Example 2: Input: day = 18, month = 7, year = 1999 Output: "Sunday"  Example 3: Input: day = 15, month = 8, year = 1993 Output: "Sunday"    Constraints:  The given dates are valid dates between the years 1971 and 2100.
__label__Strings __label__Dynamic-Programming A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
__label__Graph-Algorithms Chinese   Fedor is a research scientist, who has recently found a road map of Ancient Berland. Ancient Berland consisted of N cities that were connected by M bidirectional roads. The road builders weren't knowledgable. Hence, the start city and the end city for each road were always chosen randomly and independently. As a result, there were more than one road between some pairs of cities. Nevertheless, by luck, the country remained connected (i.e. you were able to get from one city to another via these M roads). And for any road, the start and the end city were not the same. Moreover, each road had it's own value of importance. This value was assigned by the Road Minister of Ancient Berland. The Road Minister also was not knowledgable, so these numbers were assigned to the roads randomly and independently from the other roads. When there was a war with the neighboring countries (usually it was with Ancient Herland), it was important to estimate separation number for some pairs of cities. The separation number for a pair of cities - let's call these cities A and B - is explained below:  Consider a set of roads that were built. The subset of this set is good, if after removing all roads from this set, there's no longer a way from A to B. The minimal possible sum of roads' value of importance of any good subset is a separation number for the pair of cities (A, B). For a research, Fedor would like to know the product of separation values over all unordered pairs of cities. Please, find this number. It can be huge, so we ask you to output its product modulo 109+7. Input Format The first line of input consist of two integers N and M, separated by a single space.  Then, M lines follow. Each of these lines consist of three integers Xi, Yi, Zi separated by a single space.  It means that there was a road between the city Xi and the city Yi with a value of importance equal to Zi. Constraints 3 ≤ N ≤ 500  3 ≤ M ≤ 104  1 ≤ value of importance ≤ 105  The cities are indexed from 1 to N. Scoring In the 25% of the test data N = 50 and M = 300. In another 25% of the test data N = 200 and M = 10000 In the rest of the test data N = 500 and M = 10000   Output Format An integer that represents the value, Fedor needs, modulo 109+7.
__label__Search __label__Tree __label__Data-Structures The median of  numbers is defined as the middle number after sorting them in order if  is odd. Or it is the average of the middle two numbers if  is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median. Example:  For a set of  numbers  the median is the third number in the sorted set , which is . Similarly, for a set of  numbers, , the median is the average of the second and the third element in the sorted set , which is .   Input:  The first line is an integer, , that indicates the number of operations. Each of the next  lines is either a x or r x. a x indicates that  is added to the set, and r x indicates that  is removed from the set. Output:  For each operation: If the operation is add, output the median after adding  in a single line. If the operation is remove and the number  is not in the list, output Wrong! in a single line. If the operation is remove and the number  is in the list, output the median after deleting  in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.) Note  If your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong! Constraints:    For each a x or r x,  will always be a signed integer (which will fit in 32 bits). Sample Input:  7   r 1   a 1   a 2   a 1   r 1   r 2   r 1    Sample Output:  Wrong!   1   1.5   1   1.5   1   Wrong!  Note: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!.
__label__Mathematics __label__Strings Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__Dynamic-Programming __label__Strings Megan is playing a string game with the following rules: It starts with a string, . During each turn, she performs the following move: Choose an index in . The chosen index must be strictly greater than any index chosen in a prior move.  Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index. For example, let's say  abcdefjghi. During our move, we choose to do three right rotations of the suffix starting at index :    Note that this counts as one move. During each turn, she performs the following move: Choose an index in . The chosen index must be strictly greater than any index chosen in a prior move.  Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index. For example, let's say  abcdefjghi. During our move, we choose to do three right rotations of the suffix starting at index :    Note that this counts as one move. abcdefjghi The goal of the game is to convert  into the lexicographically smallest possible string in as few moves as possible. In other words, we want the characters to be in alphabetical order. Megan plays this game  times, starting with a new string  each time. For each game, find the minimum number of moves necessary to convert  into the lexicographically smallest string and print that number on a new line. Input Format The first line contains an integer, , denoting the number of games.  Each of the  subsequent lines contains a single string denoting the initial value of string  for a game. Constraints    consists of lowercase English alphabetic letters only. Output Format For each game, print an integer on a new line denoting the minimum number of moves required to convert  into the lexicographically smallest string possible. Sample Input 0 Sample Output 0 Explanation 0 We play the following  games: In the first game, abcdefghij is already as lexicographically small as possible (each sequential letter is in alphabetical order). Because we don't need to perform any moves, we print  on a new line. abcdefghij In the second game, we rotate the suffix starting at index , so acab becomes aabc. Because the string is lexicographically smallest after one move, we print  on a new line. acab aabc In the third game, we perform the following moves: Rotate the suffix starting at index  (i.e., the entire string), so baba becomes abab.  Rotate the suffix starting at index , so abab becomes aabb. Because the string is lexicographically smallest after two moves, we print  on a new line. In the third game, we perform the following moves: Rotate the suffix starting at index  (i.e., the entire string), so baba becomes abab.  baba abab Rotate the suffix starting at index , so abab becomes aabb. abab aabb Because the string is lexicographically smallest after two moves, we print  on a new line.
__label__Mathematics A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.
__label__Mathematics __label__Bit Some scientists are working on protein recombination, and during their research, they have found a remarkable fact: there are 4 proteins in the protein ring that mutate after every second according to a fixed pattern. For simplicity, proteins are called  (you know, protein names can be very complicated). A protein mutates into another one depending on itself and the protein right after it. Scientists determined that the mutation table goes like this:       A   B   C   D     _   _   _   _ A|  A   B   C   D B|  B   A   D   C C|  C   D   A   B D|  D   C   B   A  Here rows denote the protein at current position, while columns denote the protein at the next position. And the corresponding value in the table denotes the new protein that will emerge. So for example, if protein i is A, and protein i + 1 is B, protein i will change to B. All mutations take place simultaneously. The protein ring is seen as a circular list, so last protein of the list mutates depending on the first protein.  Using this data, they have written a small simulation software to get mutations second by second. The problem is that the protein rings can be very long (up to 1 million proteins in a single ring) and they want to know the state of the ring after upto  seconds. Thus their software takes too long to report the  results. They ask you for your help.   Input Format Input contains 2 lines.  First line has 2 integers  and ,  being the length of the protein ring and  the desired number of seconds.  Second line contains a string of length  containing uppercase letters ,,  or  only, describing the ring.  Constraints     Output Format Output a single line with a string of length , describing the state of the ring after  seconds. Sample Input 0 Sample Output 0 Explanation 0 The complete sequence of mutations is: AAADD AADAD ADDDD DAAAD DAADA DADDD DDAAA ADAAD DDADD ADDAA DADAA DDDAD AADDA ADADA DDDDA
__label__Hash-Table __label__Binary-Search Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.
