__label__Mathematics On an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:  "G": go straight 1 unit; "L": turn 90 degrees to the left; "R": turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.   Example 1: Input: "GGLLGG" Output: true Explanation:  The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0). When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.  Example 2: Input: "GG" Output: false Explanation:  The robot moves north indefinitely.  Example 3: Input: "GL" Output: true Explanation:  The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...    Note:  1 <= instructions.length <= 100 instructions[i] is in {'G', 'L', 'R'}
__label__Dynamic-Programming Chloe is fascinated by prime numbers. She came across the number  on a sign and, though the number is not prime, found some primes hiding in it by using the following rules:   Every three consecutive digits sum to a prime:  Every four consecutive digits sum to a prime:  Every five consecutive digits sum to a prime:  You must answer  queries, where each query consists of an integer, . For each , find and print the number of positive -digit numbers, modulo , that satisfy all three of Chloe's rules (i.e., every three, four, and five consecutive digits sum to a prime). Input Format The first line contains an integer, , denoting the number of queries.  Each of the  subsequent lines contains an integer denoting the value of  for a query.   Constraints     Output Format For each query, print the number of -digit numbers satisfying Chloe's rules, modulo , on a new line.    Sample Input 0 Sample Output 0 Explanation 0 There are  six-digit numbers satisfying the property above, where the respective first and last ones are  and .
__label__Binary-Search Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Bit Alice and Bob are playing the game of Nim with  piles of stones with sizes . If Alice plays first, she loses if and only if the 'xor sum' (or 'Nim sum') of the piles is zero, i.e., . Since Bob already knows who will win (assuming optimal play), he decides to cheat by removing some stones in some piles before the game starts. However, to reduce the risk of suspicion, he must keep at least one pile unchanged. Your task is to count the number of ways Bob can remove the stones to force Alice into losing the game. Since the number can be very large, output the number of ways modulo . Assume that both players will try to optimize their strategy and try to win the game. Input Format The first line of the input contains an integer  denoting the number of piles. The next line contains  space-separated integers  indicating the sizes of the stone piles. Constraints     Output Format Print a single integer denoting the number of ways Bob can force Alice to lose the game, modulo .   Sample Input 0 Sample Output 0 Explanation 0 The answer is . The four possible resulting lists of piles is:         Note that  is not allowed since he must keep one pile unchanged. Sample Input 1 Sample Output 1
__label__Mathematics A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.
__label__Greedy-Algorithms Watson gives Sherlock an array of integers.  Given the endpoints of an integer range, for all  in that inclusive range, determine the minimum( abs(arr[i]-M) for all ) ).  Once that has been determined for all integers in the range, return the  which generated the maximum of those values.  If there are multiple 's that result in that value, return the lowest one.   For example, your array  and your range is from  to  inclusive. We look at the Min column and see the maximum of those three values is .  Two 's result in that answer so we choose the lower value, . Min Function Description  Complete the sherlockAndMinimax function in the editor below.  It should return an integer as described.   sherlockAndMinimax has the following parameters:  - arr: an array of integers  - p: an integer that represents the lowest value of the range for   - q: an integer that represents the highest value of the range for   Input Format The first line contains an integer , the number of elements in .  The next line contains  space-separated integers .  The third line contains two space-separated integers  and , the inclusive endpoints for the range of .        Constraints       Output Format Print the value of  on a line. Sample Input 3 5 8 14 4 9  Sample Output 4  Explanation  For , or , the result is . Since we have to output the smallest of the multiple solutions, we print .
__label__Strings Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]
__label__Depth-first-Search In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.
__label__Array Students are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)   Example 1: Input: [1,1,4,2,1,3] Output: 3 Explanation:  Students with heights 4, 3 and the last 1 are not standing in the right positions.    Note:  1 <= heights.length <= 100 1 <= heights[i] <= 100
__label__Binary-Search Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.
__label__Graph-Algorithms __label__Mathematics __label__Data-Structures One day Bob drew a tree, , with  nodes and  edges on a piece of paper. He soon discovered that parent of a node depends on the root of the tree. The following images shows an example of that:  Learning the fact, Bob invented an exciting new game and decided to play it with Alice. The rules of the game is described below: Bob picks a random node to be the tree's root and keeps the identity of the chosen node a secret from Alice. Each node has an equal probability of being picked as the root. Alice then makes a list of  guesses, where each guess is in the form u v and means Alice guesses that  is true. It's guaranteed that an undirected edge connecting  and  exists in the tree.  u v For each correct guess, Alice earns one point. Alice wins the game if she earns at least  points (i.e., at least  of her guesses were true). Alice and Bob play  games. Given the tree, Alice's guesses, and the value of  for each game, find the probability that Alice will win the game and print it on a new line as a reduced fraction in the format p/q. p/q Input Format The first line contains an integer, , denoting the number of different games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of nodes in the tree. The  subsequent lines contain two space-separated integers,  and , defining an undirected edge between nodes  and .  The next line contains two space-separated integers describing the respective values of  (the number of guesses) and  (the minimum score needed to win). Each of the  subsequent lines contains two space-separated integers,  and , indicating Alice guesses . Constraints     The sum of  over all test cases won't exceed . No two guesses will be identical.  Scoring For  of the maximum score, . For  of the maximum score, . Output Format Print the probability as a reduced fraction in the format p/q. p/q Note: Print 0/1 if the probability is  and print 1/1 if the probability is . 0/1 1/1 Sample Input 0 Sample Output 0 Explanation 0 Alice and Bob play the following  games: Alice makes two guesses,  and , meaning she guessed that  and . To win the game, at least  of her guesses must be true. In the diagrams below, you can see that at least  guesses are true if the root of the tree is either node  or :  There are  nodes in total and the probability of picking node  or  as the root is , which reduces to . Alice makes two guesses,  and , meaning she guessed that  and . To win the game, at least  of her guesses must be true. In the diagrams below, you can see that at least  guesses are true if the root of the tree is either node  or :  There are  nodes in total and the probability of picking node  or  as the root is , which reduces to . In this game, Alice only wins if node  is the root of the tree. There are  nodes in total, and the probability of picking node  as the root is .
__label__Array __label__Greedy-Algorithms In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the i-th domino, so that A[i] and B[i] swap values. Return the minimum number of rotations so that all the values in A are the same, or all the values in B are the same. If it cannot be done, return -1.   Example 1:  Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2] Output: 2 Explanation:  The first figure represents the dominoes as given by A and B: before we do any rotations. If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.  Example 2: Input: A = [3,5,1,2,3], B = [3,6,3,3,4] Output: -1 Explanation:  In this case, it is not possible to rotate the dominoes to make one row of values equal.    Note:  1 <= A[i], B[i] <= 6 2 <= A.length == B.length <= 20000
__label__Tree __label__Data-Structures Complete the preOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your preOrder function. Constraints  Nodes in the tree   Output Format Print the tree's preorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 5 3 4 6
__label__Data-Structures __label__Advanced-Data-Structures You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  Initially all node values are zero.   The update query is of the format a1 d1 a2 d2 A B  This means you'd have to add  in all nodes in the path from A to B where  is the distance between the node and A. The retrieval query is of the format i j  You need to return the sum of the node values lying in the path from node i to node j modulo 1000000007.  Note:    First all update queries are given and then all retrieval queries.   Distance between 2 nodes is the shortest path length between them taking each edge weight as 1.   Input Format  The first line contains two integers (N and R respectively) separated by a space.   In the next N-1 lines, the ith line describes the ith edge: a line with two integers x y separated by a single space denotes an edge between nodes x and y.   The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.   U lines follow. Each of the next U lines contains 6 space separated integers (a1,d1,a2,d2,A and B respectively). Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 105  2 <= R <= 109  1 <= U <= 105  1 <= Q <= 105  1 <= a1,a2,d1,d2 <= 108  1 <= x, y, i, j, A, B  <= N   Note  For the update operation, x can be equal to y and for the query operation, i can be equal to j.   Sample Input  7 2 1 2 1 3 2 4 2 6 4 5 6 7 1 4 1 1 1 1 4 6 4 5 2 7 4 7 5 3  Sample Output 1 44 45 9  Explanation The node values after updation becomes :   0 8 0 1 0 36 0  Answer to Query #1: 1+0 = 1    Answer to Query #2: 8+36+0 = 44 Answer to Query #3: 1+8+36+0 = 45 Answer to Query #4: 0+1+8+0+0 = 9
__label__Greedy-Algorithms Quibdó in Colombia is one among the cities that receive maximum rainfall in the world. All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you.  Every cloud covers all towns located at a certain distance from it. A town is said to be in darkness if there exists at least one cloud such that the town is within the cloud's range. Otherwise, it is said to be sunny.  The city council has determined that they have enough money to remove exactly one cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud? Note: If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer. Complete the function maximumPeople which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud. maximumPeople Input Format The first line of input contains a single integer , the number of towns. The next line contains  space-separated integers . The  integer in this line denotes the population of the  town.   The next line contains  space-separated integers  denoting the location of the  town on the one-dimensional line. The next line consists of a single integer  denoting the number of clouds covering the city.   The next line contains  space-separated integers  the  of which denotes the location of the  cloud on the coordinate axis. The next line consists of  space-separated integers  denoting the range of the  cloud.  Note: The range of each cloud is computed according to its location, i.e., the  cloud is located at position  and it covers every town within a distance of  from it. In other words, the  cloud covers every town with location in the range . Constraints    Output Format Print a single integer denoting the maximum number of people that will be in a sunny town by removing exactly one cloud. Sample Input 0 Sample Output 0 Explanation 0 In the sample case, there is only one cloud which covers the first town. Our only choice is to remove this sole cloud which will make all towns sunny, and thus, all  people will live in a sunny town.   As you can see, the only cloud present, is at location  on the number line and has a range , so it covers towns located at ,  and  on the number line. Hence, the first town is covered by this cloud and removing this cloud makes all towns sunny.
__label__Array Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.
__label__Dynamic-Programming Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.   Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.    Note:  1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.
__label__Tree __label__Depth-first-Search We run a preorder depth first search on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  (If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.) If a node has only one child, that child is guaranteed to be the left child. Given the output S of this traversal, recover the tree and return its root.   Example 1:  Input: "1-2--3--4-5--6--7" Output: [1,2,5,3,4,6,7]   Example 2:  Input: "1-2--3---4-5--6---7" Output: [1,2,5,3,null,6,null,4,null,7]      Example 3:  Input: "1-401--349---90--88" Output: [1,401,null,349,88,90]     Note:  The number of nodes in the original tree is between 1 and 1000. Each node will have a value between 1 and 10^9.
__label__Graph-Algorithms Given a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes.  There may be many queries, so efficiency counts.   For example, your graph consists of  nodes as in the following:   A few queries are from node  to node , node  to node , and node  to node .   There are two paths from  to :  at a distance of    at a distance of   In this case we choose path .   There are two paths from  to :  at a distance of    at a distance of   In this case we choose path .   There is no path from  to , so we return .   There is no path from  to , so we return .   There is one path from  to :    at a distance of .   There is one path from  to :    at a distance of .   Input Format The first line has two integers  and , the number of nodes and the number of edges in the graph.  Each of the next  lines contains three space-separated integers   and , the two nodes between which the directed edge  exists, and , the length of the edge.  The next line contains a single integer , the number of queries.  Each of the next  lines contains two space-separated integers  and , denoting the start and end nodes for traversal.   Constraints           The distance from a node to itself is always  and it is always reachable from itself. If there are edges between the same pair of nodes with different weights, the last one (most recent) is to be considered as the only edge between them. Output Format Print  lines, each containing a single integer specifying the shortest distance for the query.   If the destination node is not reachable, return .   Sample Input 4 5 1 2 5 1 4 24 2 4 6 3 4 4 3 2 7 3 1 2 3 1 1 4  Sample Output 5 -1 11  Explanation The graph given in the test case is shown as :  The shortest paths for the 3 queries are : : The direct Path is shortest with weight 5 : The direct Path is shortest with weight 5 : There is no way of reaching node 1 from node 3 : There is no way of reaching node 1 from node 3  The indirect path is shortest with weight (5+6) = 11 units. The direct path is longer with 24 units length.  The indirect path is shortest with weight (5+6) = 11 units. The direct path is longer with 24 units length.
__label__Mathematics In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].
__label__Array Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.    Note:  The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].
__label__Mathematics The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:  "123" "132" "213" "231" "312" "321"  Given n and k, return the kth permutation sequence. Note:  Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.  Example 1: Input: n = 3, k = 3 Output: "213"  Example 2: Input: n = 4, k = 9 Output: "2314"
__label__Strings Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.
__label__Dynamic-Programming In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.
__label__Strings Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5
__label__Mathematics __label__Depth-first-Search There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1. While entering a password, the last n digits entered will automatically be matched against the correct password. For example, assuming the correct password is "345", if you type "012345", the box will open because the correct password matches the suffix of the entered password. Return any password of minimum length that is guaranteed to open the box at some point of entering it.   Example 1: Input: n = 1, k = 2 Output: "01" Note: "10" will be accepted too.  Example 2: Input: n = 2, k = 2 Output: "00110" Note: "01100", "10011", "11001" will be accepted too.    Note:  n will be in the range [1, 4]. k will be in the range [1, 10]. k^n will be at most 4096.
__label__Strings Consider a string of  characters, , of where each character is indexed from  to . You are given  queries in the form of two integer indices:  and . For each query, count and print the number of different substrings of  in the inclusive range between  and .  Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string  aab, substrings  a and  a are the same but substrings  aa and  ab are different. aab a a aa ab Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a single string denoting .  Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  for a query. Constraints   String  consists of lowercase English alphabetic letters (i.e., a to z) only. a z Subtasks  For  of the test cases,   For  of the test cases,   For  of the test cases,   Output Format For each query, print the number of different substrings in the inclusive range between index  and index  on a new line.  Sample Input 0 Sample Output 0 Explanation 0 Given  aabaa, we perform the following  queries: aabaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 0 2: The substrings of aab are a, b, aa, ab, and aab, so we print  on a new line. 0 2 aab a b aa ab aab
__label__Strings Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"
__label__Tree Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Dynamic-Programming __label__Tree Byteland has  cities (numbered from  to ) and  bidirectional roads. A path is comprised of  or more connected roads. It is guaranteed that there is a path from any city to any other city. Steven is a road maintenance worker in Byteland. He is required to maintain exactly  paths on any given workday. He cannot work on the same road twice in one day (so no  paths can contain the same  roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city. Given , help Steven determine how many different possible path sets will allow him to perform his maintenance duties. Then print the answer modulo . Input Format The first line contains  space-separated integers,  (the number of cities) and  (the number of roads to maintain).  Each line  of the  subsequent lines contains  space-separated integers, , describing a bidirectional road between cities  and . Constraints     Output Format Find the number of different path sets that will allow Steven to complete  orders, and print the answer .  Sample Input 4 2 1 2 2 3 2 4  Sample Output 6  Explanation For the following Byteland map:   Steven can maintain  roads using any of the following  routes:  and   and   and   and   and   and  Thus, we print the result of  on a new line, which is .
__label__Game-Theory Stephanie just learned about a game called Nim in which there are two players and  piles of stones. During each turn, a player must choose any non-empty pile and take as many stones as they want. The first player who cannot complete their turn (i.e., because all piles are empty) loses.   Stephanie knows that, for each start position in this game, it's possible to know which player will win (i.e., the first or second player) if both players play optimally. Now she wants to know the number of different games that exist that satisfy all of the following conditions: The game starts with  non-empty piles and each pile contains less than  stones. All the piles contain pairwise different numbers of stones. The first player wins if that player moves optimally. Help Stephanie by finding and printing the number of such games satisfying all the above criteria, modulo . Input Format The first line contains two space-separated integers describing the respective values of  and . Constraints   Output Format Print the number of such games, modulo . Sample Input 0 Sample Output 0 Explanation 0 We want to know the number of games with  piles where each pile contains  stones. There are six such possible games with the following distributions of stones: . Thus, we print the result of  as our answer.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.  You’re given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer, insert this node at the head of the linked list and return the new head node. The head pointer given may be null meaning that the initial list is empty. Input Format You have to complete the SinglyLinkedListNode Insert(SinglyLinkedListNode head, int data) method which takes two arguments - the head of the linked list and the integer to insert. You should NOT read any input from stdin/console.   SinglyLinkedListNode Insert(SinglyLinkedListNode head, int data) The input is handled by code in the editor and is as follows:   The first line contains an integer , denoting the number of elements to be inserted at the head of the list.  The next  lines contain an integer each, denoting the element to be inserted.   Constraints     Output Format Insert the new node at the head and return the head of the updated linked list. Do NOT print anything to stdout/console. return The output is handled by the code in the editor and it is as follows: Print the elements of linked list from head to tail, each in a new line. Sample Input 5 383 484 392 975 321  Sample Output 321 975 392 484 383  Explanation Intially the list in NULL. After inserting 383, the list is 383 -> NULL.  After inserting 484, the list is 484 -> 383 -> NULL.  After inserting 392, the list is 392 -> 484 -> 383 -> NULL.  After inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.  After inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.
__label__Depth-first-Search A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You are given the pointer to the head node of a linked list and you need to print all its elements in reverse order from tail to head, one element per line. The head pointer may be null meaning that the list is empty - in that case, do not print anything! Input Format You have to complete the void reversePrint(SinglyLinkedListNode* head) method which takes one argument - the head of the linked list. You should NOT read any input from stdin/console. void reversePrint(SinglyLinkedListNode* head) The first line of input contains , the number of test cases.  The input of each test case is as follows:   The first line contains an integer , denoting the number of elements in the list.   The next n lines contain one element each, denoting the elements of the linked list in the order. Constraints   , where  is the  element in the list.   Output Format Complete the reversePrint function in the editor below and print the elements of the linked list in the reverse order, each in a new line.  Sample Input 3 5 16 12 4 2 5 3 7 3 9 5 5 1 18 3 13  Sample Output 5 2 4 12 16 9 3 7 13 3 18 1 5  Explanation There are three test cases.  The first linked list has  elements: 16 -> 12 -> 4 -> 2 -> 5. Printing this in reverse order will produce: 5 -> 2 -> 4 -> 12 -> 16.  The second linked list has  elements: 7 -> 3 -> 9. Printing this in reverse order will produce: 9 -> 3 -> 7.  The third linked list has  elements: 5 -> 1 -> 18 -> 3 -> 13. Printing this in reverse order will produce: 13 -> 3 -> 18 -> 1 -> 5.   16 -> 12 -> 4 -> 2 -> 5 5 -> 2 -> 4 -> 12 -> 16 7 -> 3 -> 9 9 -> 3 -> 7 5 -> 1 -> 18 -> 3 -> 13 13 -> 3 -> 18 -> 1 -> 5
__label__Hash-Table We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.
__label__Strings You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.   Example 1: Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"] Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]    Constraints:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.
__label__Greedy-Algorithms We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviest rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:  If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.  At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)   Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation:  We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.   Note:  1 <= stones.length <= 30 1 <= stones[i] <= 1000
__label__Hash-Table __label__Two-Pointers In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.
__label__Game-Theory __label__Game-Theory Two people are playing game of Misère Nim. The basic rules for this game are as follows: The game starts with  piles of stones indexed from  to . Each pile  (where ) has  stones. The players move in alternating turns. During each move, the current player must  remove one or more stones from a single pile.  The player who removes the last stone loses the game. Given the value of  and the number of stones in each pile, determine whether the person who wins the game is the first or second person to move. If the first player to move wins, print First on a new line; otherwise, print Second. Assume both players move optimally.  First Second Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of piles.  space-separated integers, , where each  describes the number of stones at pile . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either First or Second). First Second Sample Input 2 2 1 1 3 2 1 3   Sample Output First Second  Explanation In the first testcase, the first player removes 1 stone from the first pile and then the second player has no moves other than removing the only stone in the second pile. So first wins.   In the second testcase, the series of moves can be depicted as:  In every possible move of first player we see that the last stone is picked by him, so second player wins.
__label__Binary-Search (This problem is an interactive problem.) You may recall that an array A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i] A[i] > A[i+1] > ... > A[A.length - 1]    Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target.  If such an index doesn't exist, return -1. You can't access the mountain array directly.  You may only access the array using a MountainArray interface:  MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array.  Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer.  Also, any solutions that attempt to circumvent the judge will result in disqualification.     Example 1: Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1.    Constraints:  3 <= mountain_arr.length() <= 10000 0 <= target <= 10^9 0 <= mountain_arr.get(index) <= 10^9
__label__Array __label__Binary-Search A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.
__label__Array A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.   Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}    Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].
__label__Array Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].
__label__Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]    Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.  Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.    Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree.
__label__Strings Julius Caesar protected his confidential information by encrypting it using a cipher. Caesar's cipher shifts each letter by a number of letters.  If the shift takes you past the end of the alphabet, just rotate back to the front of the alphabet.  In the case of a rotation by 3, w, x, y and z would map to z, a, b and c. For example, the given cleartext  and the alphabet is rotated by .  The encrypted string is .   Note: The cipher only encrypts letters; symbols, such as -, remain unencrypted.   - Function Description  Complete the caesarCipher function in the editor below.  It should return the encrypted string.   caesarCipher has the following parameter(s): s: a string in cleartext   k: an integer, the alphabet rotation factor   Input Format The first line contains the integer, , the length of the unencrypted string.  The second line contains the unencrypted string, .  The third line contains , the number of letters to rotate the alphabet by. Constraints      is a valid ASCII string without any spaces.    Output Format For each test case, print the encoded string.   Sample Input 11 middle-Outz 2  Sample Output okffng-Qwvb  Explanation Original alphabet:      abcdefghijklmnopqrstuvwxyz Alphabet rotated +2:    cdefghijklmnopqrstuvwxyzab  m -> o i -> k d -> f d -> f l -> n e -> g -    - O -> Q u -> w t -> v z -> b
__label__Tree __label__Data-Structures The square-ten tree decomposition of an array is defined as follows: The lowest () level of the square-ten tree consists of single array elements in their natural order. The  level (starting from ) of the square-ten tree consists of subsequent array subsegments of length  in their natural order. Thus, the  level contains subsegments of length , the  level contains subsegments of length , the  level contains subsegments of length , etc. In other words, every  level (for every ) of square-ten tree consists of array subsegments indexed as:    The image below depicts the bottom-left corner (i.e., the first  array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:  Task  Given the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence  such as  for every , , , where every  belongs to any of the square-ten tree levels and  is minimal amongst all such variants. Input Format The first line contains a single integer denoting .  The second line contains a single integer denoting . Constraints  The numbers in input do not contain leading zeroes. Output Format As soon as array indices are too large, you should find a sequence of  square-ten tree level numbers, , meaning that subsegment  belongs to the  level of the square-ten tree.  Print this sequence in the following compressed format:  On the first line, print the value of  (i.e., the compressed sequence block count).  For each of the  subsequent lines, print  space-separated integers,  and  (, ), meaning that the number  appears consequently  times in sequence . Blocks should be listed in the order they appear in the sequence. In other words,  should be equal to ,  should be equal to , etc. Thus  must be true and  must be true for every . All numbers should be printed without leading zeroes. Sample Input 0 Sample Output 0 Explanation 0 Segment  belongs to level  of the square-ten tree.
__label__Data-Structures __label__Advanced-Data-Structures Consider a binary search tree T which is initially empty. Also, consider the first N positive integers {1, 2, 3, 4, 5, ....., N} and its permutation P {a1, a2, ..., aN}.  N If we start adding these numbers to the binary search tree T, starting from a1, continuing with a2, ... (and so on) ..., ending with aN. After every addition we ask you to output the sum of distances between every pair of T's nodes. Input Format  The first line of the input consists of the single integer N, the size of the list.  The second line of the input contains N single space separated numbers the permutation a1, a2, ..., aN itself. Constraints  1 ≤ N ≤ 250000   Output Format  Output N lines.  On the ith line output the sum of distances between every pair of nodes after adding the first i numbers from the permutation to the binary search tree T  Sample Input #00 8 4 7 3 1 8 2 6 5  Sample Output #00 0 1 4 10 20 35 52 76  Explanation #00  After adding the first element, the distance is 0 as there is only 1 element  0 4  After adding the second element, the distance between 2 nodes is 1.   1 4  \   7  After adding the third element, the distance between every pair of elements is 2+1+1=4 2+1+1=4   4  / \ 3   7      After adding the fourth element, the distance between every pair of elements is 3 + 2 + 1 + 2 + 1 + 1 = 10 3 + 2 + 1 + 2 + 1 + 1 = 10     4    / \   3   7      / 1  After adding the fifth element, the distance between every pair of elements is 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20     4    / \   3   7      /     \ 1       8  After adding the sixth element, the distance between every pair of elements is 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35     4    / \   3   7      /     \ 1       8  \   2  After adding the seventh element, the distance between every pair of elements is 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52     4    / \   3   7      /   / \ 1   6   8  \   2  After adding the final element, the distance between every pair of elements is 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76         4       /   \     3      7      /      /   \  1      6     8   \    /    2  5
__label__Mathematics __label__Dynamic-Programming You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].
__label__Array Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]
__label__Tree __label__Depth-first-Search Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation:     1            <---  /   \ 2     3         <---  \     \   5     4       <---
__label__Dynamic-Programming You have d dice, and each die has f faces numbered 1, 2, ..., f. Return the number of possible ways (out of fd total ways) modulo 10^9 + 7 to roll the dice so the sum of the face up numbers equals target.   Example 1: Input: d = 1, f = 6, target = 3 Output: 1 Explanation:  You throw one die with 6 faces.  There is only one way to get a sum of 3.  Example 2: Input: d = 2, f = 6, target = 7 Output: 6 Explanation:  You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.  Example 3: Input: d = 2, f = 5, target = 10 Output: 1 Explanation:  You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.  Example 4: Input: d = 1, f = 2, target = 3 Output: 0 Explanation:  You throw one die with 2 faces.  There is no way to get a sum of 3.  Example 5: Input: d = 30, f = 30, target = 500 Output: 222616187 Explanation:  The answer must be returned modulo 10^9 + 7.    Constraints:  1 <= d, f <= 30 1 <= target <= 1000
__label__Search Xander Cage has a list of cities he can visit on his new top-secret mission. He represents each city as a tuple of . The values of , , and  are distinct across all cities. We define a mission as a sequence of cities, , that he visits. We define the total  of such a mission to be the sum of the  of all the cities in his mission list. Being eccentric, he abides by the following rules on any mission: He can choose the number of cities he will visit (if any). He can start the mission from any city. He visits cities in order of strictly increasing . The absolute difference in  between adjacent visited cities in his mission must be at most . The absolute difference in  between adjacent visited cities in his mission must be at most . Given , , and the definitions for  cities, find and print the maximum possible total  that Xander can earn on a mission. Input Format The first line contains three space-separated integers describing the respective values of , , and .  Each line  of the  subsequent lines contains four space-separated integers denoting the respective , , , and  for a city. Constraints        Output Format Print a single integer denoting the maximum possible  that Xander can earn on a mission. Sample Input 0 Sample Output 0 Explanation 0 Xander can start at city , then go to city , and then go to city  for a maximum value of total    Note that he cannot go directly from city  to city  as that would violate his rules that the absolute difference in  between adjacent visited cities be  and the absolute difference in  between adjacent visited cities be . Because  and , he cannot directly travel between those cities.
__label__Tree __label__Data-Structures Greg has a tree of nodes containing integer data.  He wants to insert a node with some non-zero integer value somewhere into the tree.  His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount.  This is called a balanced forest.  Being frugal, the data value he inserts should be minimal.  Determine the minimal amount that a new node can have to allow creation of a balanced forest.  If it's not possible to create a balanced forest, return -1. For example, you are given node values  and .  It is the following tree:     The blue node is root, the first number in a node is node number and the second is its value.  Cuts can be made between nodes  and  and nodes  and  to have three trees with sums ,  and .  Adding a new node  of  to the third tree completes the solution.   Function Description Complete the balancedForest function in the editor below.  It must return an integer representing the minimum value of  that can be added to allow creation of a balanced forest, or  if it is not possible.   balancedForest has the following parameter(s): c: an array of integers, the data values for each node   edges: an array of 2 element arrays, the node pairs per edge   Input Format The first line contains a single integer, , the number of queries.   Each of the following  sets of lines is as follows:   The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers describing the respective values of , where each  denotes the value at node . Each of the following  lines contains two space-separated integers,  and , describing edge  connecting nodes  and . Constraints       Each query forms a valid undirected tree.   Subtasks For  of the maximum score:   For  of the maximum score:   Output Format For each query, return the minimum value of the integer .  If no such value exists, return  instead.  Sample Input 2 5 1 2 2 1 1 1 2 1 3 3 5 1 4 3 1 3 5 1 3 1 2  Sample Output 2 -1  Explanation We perform the following two queries: The tree initially looks like this:         Greg can add a new node  with  and create a new edge connecting nodes  and . Then he cuts the edge connecting nodes  and  and the edge connecting nodes  and . We now have a three-tree balanced forest where each tree has a sum of .       In the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .
__label__Strings Jack and Daniel are friends. Both of them like letters, especially upper-case ones.  They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack.  One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack.  Morgan wants to use all of the letters in their collections.   As an example, assume Jack has collected  and Daniel has .  The example shows the top at index  for each stack of letters. Assembling the string would go as follows:   Note the choice when there was a tie at CA and CF. CA CF Function Description  Complete the morganAndString function in the editor below.  It should return the completed string.   morganAndString has the following parameter(s):   a: a string representing Jack's letters, top at index   b: a string representing Daniel's letters, top at index   Input Format The first line contains the an integer , the number of test cases.   The next  pairs of lines are as follows:  - The first line contains string   - The second line contains string .   Constraints      and  contain upper-case letters only, ascii[A-Z]. Output Format Output the lexicographically minimal string  for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA  Sample Output DAJACKNIEL AABABACABACABA  Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string.
__label__Strings Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.
__label__Strings S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.
__label__Strings __label__Dynamic-Programming Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"
__label__Dynamic-Programming In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways:  a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars.  The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days.   Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation:  For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel.   Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation:  For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel.     Note:  1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000
__label__Dynamic-Programming Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not. Since the answer may be very large, the answer should be modulo 109 + 7. Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.    Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.    Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].
__label__Hash-Table __label__Depth-first-Search You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example 1: Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.    Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.
__label__Bit You are given a string , consisting of  small latin letters 'a' and 'b'. You are also given  queries to process. The queries are as follows: a b C   : all the symbols in the string, starting at the , ending at the  become equal to ;   S    : swap two consecutive fragments of the string, where the first is denoted by a substring starting from  ending at  and the second is denoted by a substring starting at  ending at ;    R  : reverse the fragment of the string that starts at the  symbol and ends at the  one;   W  : output the substring of the string that starts at the  symbol and ends at the  one;   H   : output the Hamming distance between the consecutive substrings that starts at  and  respectively and have the length of .   Everything is 1-indexed here. Input Format The first line of input contains a single integer   the length of the string.  The second line contains the initial string  itself.  The third line of input contains a single integer   the number of queries.  Then, there are  lines, each denotes a query of one of the types above.   Constraints     Total number of characters printed in W-type queries will not exceed   For C-type, R-type, W-type queries: ;  equals either a, or b  For S-type queries:   For H-type queries: ; ; .   a b Output Format For each query of the type W or the type H output an answer on the separate line of output. W H Sample Input 0 Sample Output 0 Explanation 0 Initial String - aabbbabbab
__label__Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.
__label__Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.    For example: Given BST [1,null,2,2],    1     \      2     /    2    return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).
__label__Graph-Algorithms Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in  houses in Happy Harbor that are numbered sequentially from  to . There are  roads, and each road  connects two different houses,  and . Each superhero house  (where ) has  dollars stashed away for a rainy day. As long as a superhero is home at house , Killgrave knows they will hand over all of their saved money, . Once he gets money from them, he moves on to the next house. However, the superheroes are cunning; when Killgrave comes to house , every neighbor immediately connected to house  by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road. What is the maximum amount of money Killgrave can collect from the superheroes, and how many different ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different. Note: Killgrave can start at an arbitrary house and doesn't have to only use the roads. Input Format The first line contains two space-separated integers,  (the number of houses) and  (the number of roads), respectively.  The second line contains  space-separated integers, where each integer  describes the amount of money, , at house .  Each line  of the  subsequent lines contains two space-separated integers defining a road connecting houses  and . Every road connects a different pair of houses. Constraints    , where  No unordered pair  will appear more than once. Output Format Print two space-separated integers: The first integer must denote the maximum amount of money Killgrave can get out of the Justice League. The second integer must denote the number of different ways he can collect that amount of money. Sample Input 3 2 6 8 2 1 2 3 2  Sample Output 8 2  Explanation  Killgrave has two possible courses of action: Visit house  and get  dollars. Visit houses  and  and get  dollars.  Both of these options result in  dollars, so we know that this is maximal. Thus, we print the maximum amount of money () followed by the number of ways he can get that amount of money () as two space-separated values on a single line.
__label__Tree You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \     5   -3    / \    \   3   2   11  / \   \ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11
__label__Graph-Algorithms The mayor of Farzville is studying the city's road system to find ways of improving its traffic conditions. Farzville's road system consists of  junctions connected by  bidirectional toll roads, where the  toll road connects junctions  and . In addition, some junctions may not be reachable from others and there may be multiple roads connecting the same pair of junctions.    Each toll road has a toll rate that's paid each time it's used. This rate varies depending on the direction of travel:   If traveling from  to , then the toll rate is .  If traveling from  to , then the toll rate is . It is guaranteed that .    For each digit , the mayor wants to find the number of ordered pairs of  junctions such that  and a path exists from  to  where the total cost of the tolls (i.e., the sum of all toll rates on the path) ends in digit . Given a map of Farzville, can you help the mayor answer this question? For each digit  from  to , print the the number of valid ordered pairs on a new line. Note: Each toll road can be traversed an unlimited number of times in either direction.  Input Format The first line contains two space-separated integers describing the respective values of  (the number of junctions) and  (the number of roads).  Each line  of the  subsequent lines describes a toll road in the form of three space-separated integers, , , and .   Constraints           Output Format Print ten lines of output. Each line  (where ) must contain a single integer denoting the answer for . For example, the first line must contain the answer for , the second line must contain the answer for , and so on. Sample Input 0 Sample Output 0 Explanation 0 The table below depicts the distinct pairs of junctions for each :     Note the following: There may be multiple paths between each pair of junctions.  Junctions and roads may be traversed multiple times. For example, the path  is also valid, and it has total cost of .  An ordered pair can be counted for more than one . For example, the pair  is counted for  and . Each ordered pair must only be counted once for each . For example, the paths  and  both have total costs that end in , but the pair  is only counted once.
__label__Strings Greg wants to build a string,  of length . Starting with an empty string, he can perform  operations: Add a character to the end of  for  dollars. Copy any substring of , and then add it to the end of  for  dollars. Calculate minimum amount of money Greg needs to build . Input Format The first line contains number of testcases .         The  subsequent lines each describe a test case over  lines:  The first contains  space-separated integers, ,  , and , respectively.  The second contains  (the string Greg wishes to build). Constraints     is composed of lowercase letters only. Output Format On a single line for each test case, print the minimum cost (as an integer) to build . Sample Input 2 9 4 5 aabaacaba 9 8 9 bacbacacb  Sample Output 26 42  Explanation Test Case 0:   "";  ""  Append "";  ""; cost is   Append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Summing each cost, we get , so our output for Test Case 1 is . Test Case 1:   "";  ""  Append "";  ""; cost is   Append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Copy and append "";  ""; cost is  Summing each cost, we get , so our output for Test Case 2 is .
__label__Graph-Algorithms Johnny, like every mathematician, has his favorite sequence of distinct natural numbers.  Let’s call this sequence . Johnny was very bored, so he wrote down  copies of the sequence  in his big notebook. One day, when Johnny was out, his little sister Mary erased some numbers(possibly zero) from every copy of  and then threw the notebook out onto the street. You just found it. Can you reconstruct the sequence?   In the input there are  sequences of natural numbers representing the  copies of the sequence  after Mary’s prank. In each of them all numbers are distinct. Your task is to construct the shortest sequence  that might have been the original . If there are many such sequences, return the lexicographically smallest one. It is guaranteed that such a sequence exists. Note  Sequence  is lexicographically less than sequence  if and only if there exists  such that for all . Input Format In the first line, there is one number  denoting the number of copies of .  This is followed by   and in next line a sequence of length  representing one of sequences after Mary's prank. All numbers are separated by a single space.   Constraints      All values in one sequence are distinct numbers in range . Output Format In one line, write the space-separated sequence  - the shortest sequence that might have been the original . If there are many such sequences, return the lexicographically smallest one. Sample Input 2 2 1 3 3 2 3 4  Sample Output  1 2 3 4  Explanation You have 2 copies of the sequence with some missing numbers:  and . There are two candidates for the original sequence , where the first one is lexicographically least.
__label__Greedy-Algorithms We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000
__label__Array Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.
__label__Tree Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its level order traversal as: [   [3],   [9,20],   [15,7] ]
__label__Greedy-Algorithms Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building  and at a height of .  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.   Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:   If the bot's  is less than the height of the building, his   If the bot's  is greater than the height of the building, his   For example, building heights are given as .  If the bot starts with , we get the following table: botEnergy   height  delta 4               2       +2 6               3       +3 9               4       +5 14              3       +11 25              2       +23 48  That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting  in this case is .   Function Description  Complete the chiefHopper function in the editor below.  It should return an integer that represents the minimum starting  that will allow completion of the course.   chiefHopper has the following parameter(s):   arr: an array of integers that represent building heights   Input Format The first line contains an integer , the number of buildings.  The next line contains  space separated integers  representing the heights of the buildings.   Constraints     Output Format Print a single integer representing minimum units of energy required to complete the game. Sample Input 0 Sample Output 0 Explanation 0 If initial energy is 4, after step 1 energy is 5, after step 2 it's 6, after step 3 it's 9 and after step 4 it's 16, finally at step 5 it's 28.  If initial energy were 3 or less, the bot could not complete the course.  Sample Input 1 Sample Output 1 Explanation 1 In the second test case if bot has energy 4, it's energy is changed by (4 - 4 = 0) at every step and remains 4.   Sample Input 2 Sample Output 2 Explanation 2 botEnergy   height  delta 3           1       +2 5           6       -1 4           4       0 4  We can try lower values to assure that they won't work.
__label__Mathematics __label__Binary-Search A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000
__label__Graph-Algorithms __label__Greedy-Algorithms Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:   The subgraph contains all the nodes present in the original graph.   The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.   It is also required that there is exactly one, exclusive path between any two nodes of the subgraph.  One specific node  is fixed as the starting point of finding the subgraph using Prim's Algorithm.  Find the total weight or the sum of all edges in the subgraph.   For example, consider a graph with  nodes.  Possible edges are  weight ,  weight  and  weight .  Starting from node , we select the lower weight path, i.e. , weight .  From node , there is only one path left,  weight .  We have all nodes connected at a cost of .   Function Description Complete the prims function in the editor below.  It should return and integer that represents the minimum weight to connect all nodes in the graph provided.   prims has the following parameter(s):   n: an integer that represents the number of nodes in the graph   edges: a two-dimensional array where each element contains three integers, two nodes numbers that are connected and the weight of that edge   start: an integer that represents the number of the starting node   Input Format The first line has two space-separated integers  and , the number of nodes and edges in the graph.   Each of the next  lines contains three space-separated integers ,  and , the end nodes of , and the edge's weight.  The last line has an integer , denoting the starting node.   Constraints         There may be multiple edges between two nodes. Output Format Print a single integer denoting the total weight of the subgraph.   Sample Input 0 Sample Output 0 Explanation 0 The graph given in the test case is shown as :  The starting node is  (in the given test case) Applying the Prim's algorithm, edge choices available at first are :  (WT. 3)  and  (WT. 4) , out of which  is chosen (smaller weight of edge). Now the available choices are :   (WT. 4) ,  (WT. 5) ,  (WT. 2) and  (WT. 6) , out of which  is chosen by the algorithm.  Following the same method of the algorithm, the next chosen edges , sequentially are :  and . Hence the overall sequence of edges picked up by Prim's are:   and the total weight of the MST (minimum spanning tree) is :
__label__Search __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Let  denote an arithmetic progression (AP) with first term  and common difference , i.e.  denotes an infinite . You are given  APs => . Let  denote the sequence obtained by multiplying these APs. Multiplication of two sequences is defined as follows. Let the terms of the first sequence be , and terms of the second sequence be . The sequence obtained by multiplying these two sequences is    If  are the terms of a sequence, then the terms of the first difference of this sequence are given by  calculated as  respectively. Similarly, the second difference is given by , and so on. We say that the  difference of a sequence is a constant if all the terms of the  difference are equal.   Let  be a sequence defined as =>   Similarly,  is defined as => product of .  Task:  Can you find the smallest  for which the  difference of the sequence  is a constant? You are also required to find this constant value.   You will be given many operations. Each operation is of one of the two forms:   1) 0 i j => 0 indicates a query . You are required to find the smallest  for which the  difference of  is a constant. You should also output this constant value.   0 i j 2) 1 i j v => 1 indicates an update . For all , we update .   1 i j v Input Format  The first line of input contains a single integer , denoting the number of APs.  Each of the next  lines consists of three integers  .  The next line consists of a single integer , denoting the number of operations. Each of the next  lines consist of one of the two operations mentioned above.    Output Format  For each query, output a single line containing two space-separated integers  and .  is the smallest value for which the  difference of the required sequence is a constant.  is the value of this constant. Since  might be large, output the value of  modulo 1000003.   Note:  will always be such that it fits into a signed 64-bit integer. All indices for query and update are 1-based. Do not take modulo 1000003 for . Constraints        For updates of the form 1 i j v,     1 i j v Sample Input  2   1 2 1   5 3 1   3   0 1 2   1 1 1 1   0 1 1    Sample Output  2 12   2 8    Explanation The first sequence given in the input is =>   The second sequence given in the input is =>   For the first query operation, we have to consider the product of these two sequences:  =>   =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 12.   2 12 After the update operation 1 1 1 1, the first sequence becomes =>   i.e =>   For the second query, we consider only the first sequence =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 8 1 1 1 1 2 8
__label__Binary-Search Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0
__label__Dynamic-Programming __label__Tree Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3
__label__Binary-Search You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.
__label__Depth-first-Search There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that:  The items that belong to the same group are next to each other in the sorted list. There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).  Return any solution if there is more than one solution and return an empty list if there is no solution.   Example 1:  Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] Output: [6,3,4,1,5,2,0,7]  Example 2: Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] Output: [] Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.     Constraints:  1 <= m <= n <= 3*10^4 group.length == beforeItems.length == n -1 <= group[i] <= m-1 0 <= beforeItems[i].length <= n-1 0 <= beforeItems[i][j] <= n-1 i != beforeItems[i][j] beforeItems[i] does not contain duplicates elements.
__label__Strings Steve has a string of lowercase characters in range ascii[‘a’..’z’].  He wants to reduce the string to its shortest length by doing a series of operations.  In each operation he selects a pair of adjacent lowercase letters that match, and he deletes them.  For instance, the string aab could be shortened to b in one operation.   ascii[‘a’..’z’] aab b Steve’s task is to delete as many characters as possible using this method and print the resulting string.  If the final string is empty, print Empty String Empty String Function Description Complete the superReducedString function in the editor below.  It should return the super reduced string or Empty String if the final string is empty.   Empty String superReducedString has the following parameter(s):   s: a string to reduce   Input Format A single string, . Constraints  Output Format If the final string is empty, print Empty String; otherwise, print the final non-reducible string. Empty String Sample Input 0 Sample Output 0 Explanation 0 Steve performs the following sequence of operations to get the final string: aaabccddd → abccddd → abddd → abd  Sample Input 1 Sample Output 1 Explanation 1 aa → Empty String  Sample Input 2 Sample Output 2 Explanation 2 baab → bb → Empty String
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You're given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete as few nodes as possible so that the list does not contain any value more than once. The given head pointer may be null indicating that the list is empty. Input Format You have to complete the SinglyLinkedListNode* removeDuplicates(SinglyLinkedListNode* head) method which takes one argument - the head of the sorted linked list. You should NOT read any input from stdin/console. SinglyLinkedListNode* removeDuplicates(SinglyLinkedListNode* head) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases. The format for each test case is as follows:   The first line contains an integer , denoting the number of elements in the linked list.  The next  lines contain an integer each, denoting the elements of the linked list. Constraints     Output Format Delete as few nodes as possible to ensure that no two nodes have the same data. Adjust the next pointers to ensure that the remaining nodes form a single sorted linked list. Then return the head of the sorted updated linked list. Do NOT print anything to stdout/console. next return The output is handled by the code in the editor and the format is as follows: For each test case, print in a new line, the data of the linked list after removing the duplicates separated by space. Sample Input 1 5 1 2 2 3 4  Sample Output 1 2 3 4   Explanation The initial linked list is: 1 -> 2 -> 2 -> 3 -> 4 -> NULL The final linked list is: 1 -> 2 -> 3 -> 4 -> NULL
__label__Data-Structures A linked list is said to contain a cycle if any node is visited more than once while traversing the list.  Complete the function provided for you in your editor. It has one parameter: a pointer to a Node object named  that points to the head of a linked list. Your function must return a boolean denoting whether or not there is a cycle in the list. If there is a cycle, return true; otherwise, return false. Note: If the list is empty,  will be null. Input Format Our hidden code checker passes the appropriate argument to your function. You are not responsible for reading any input from stdin. Constraints  Output Format If the list contains a cycle, your function must return true. If the list does not contain a cycle, it must return false. The binary integer corresponding to the boolean value returned by your function is printed to stdout by our hidden code checker. Sample Input The following linked lists are passed as arguments to your function:       Sample Output 0 1  Explanation The first list has no cycle, so we return false and the hidden code checker prints  to stdout. The second list has a cycle, so we return true and the hidden code checker prints  to stdout.
__label__Dynamic-Programming Mr. Dorsey Dawson recently stole  grams of gold from ACME Jewellers. He is now on a train back home. To avoid getting caught by the police, he has to convert all the gold he has into paper money. He turns into a salesman and starts selling the gold in the train.   There are  passengers who have shown interest in buying the gold. The  passenger agrees to buy  grams of gold by paying  dollars. Dawson wants to escape from the police and also maximize the profit. Can you help him maximize the profit? Note: The  passenger would buy exactly  grams if the transaction is successful. Input Format The first line contains two space separated integers,  and ,  where  is the number of passengers who agreed to buy and  is the stolen amount of gold (in grams).   lines follow. Each line contains two space separated integers -  and , where  is the the value which the  passenger has agreed to pay in exchange for  grams of gold.   Constraints     all 's and 's are less than or equal to  and greater than .   Output Format If it's possible for Dorsey to escape, print the maximum profit he can enjoy, otherwise print Got caught!.   Got caught! Sample Input 0 Sample Output 0 Explanation 0 Selling it to passengers buying 4 grams and 6 grams would lead to 1050 dollars whereas selling it to passengers buying 5 grams gold would lead to 1140 dollars. Hence the answer.  Sample Input 1 Sample Output 1 Explanation 1 There is no way to sell all 9 grams of gold.
__label__Array In a deck of cards, every card has a unique integer.  You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed:  Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1.  Otherwise, stop.  Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck.    Example 1: Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation:  We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom.  The deck is now [13,17]. We reveal 13, and move 17 to the bottom.  The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct.     Note:  1 <= A.length <= 1000 1 <= A[i] <= 10^6 A[i] != A[j] for all i != j
__label__Two-Pointers Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.   Example 1: Input: s1 = "ab" s2 = "eidbaooo" Output: True Explanation: s2 contains one permutation of s1 ("ba").  Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False    Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].
__label__Hash-Table Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = "abcd" t = "abcde"  Output: e  Explanation: 'e' is the letter that was added.
__label__Tree __label__Depth-first-Search Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.    Example 1:     2    / \   1   3  Input: [2,1,3] Output: true  Example 2:     5    / \   1   4      / \     3   6  Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.
__label__Hash-Table Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);
__label__Graph-Algorithms __label__Tree Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day. Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office. Input Format There are N cities numbered 0 to N-1 and M bidirectional roads.   The first line of the input contains two integers N and M.   M lines follow, each containing three space-separated integers u , v and w, where u and v are cities connected by a bi-directional road and w is the length of this road. There is at most one road between any two cities and no road connects a city to itself.   The next line contains two integers S and D. S is the city where Ms. Kox lives and D is the city where her office is located.   The next line contains an integer Q, the number of queries.   Q lines follow, each containing two integers u and v, where the road between u and v has been blocked that day. Constraints          Output Format Output Q lines, with each line containing the minimum distance Ms.Kox has to travel on that day. If there is no path, print "Infinity". Sample Input 6 9   0 1 1   1 2 1   2 3 1   3 4 1   4 5 1   2 4 5   3 5 8   1 3 3   0 2 4   0 5   9   0 1   1 2   2 3   3 4   4 5   2 4   3 5   1 3   0 2  Sample Output 7   6   6   8   11   5   5   5   5
__label__Hash-Table __label__Strings Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word. For a given query word, the spell checker handles two categories of spelling mistakes:  Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.  	 Example: wordlist = ["yellow"], query = "YellOw": correct = "yellow" Example: wordlist = ["Yellow"], query = "yellow": correct = "Yellow" Example: wordlist = ["yellow"], query = "yellow": correct = "yellow"   Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist. 	 Example: wordlist = ["YellOw"], query = "yollow": correct = "YellOw" Example: wordlist = ["YellOw"], query = "yeellow": correct = "" (no match) Example: wordlist = ["YellOw"], query = "yllw": correct = "" (no match)    In addition, the spell checker operates under the following precedence rules:  When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. When the query matches a word up to capitlization, you should return the first such match in the wordlist. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. If the query has no matches in the wordlist, you should return the empty string.  Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].   Example 1: Input: wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"] Output: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]   Note:  1 <= wordlist.length <= 5000 1 <= queries.length <= 5000 1 <= wordlist[i].length <= 7 1 <= queries[i].length <= 7 All strings in wordlist and queries consist only of english letters.
__label__Data-Structures Create a list, , of  empty sequences, where each sequence is indexed from  to . The elements within each of the  sequences also use -indexing. Create an integer, , and initialize it to . The  types of queries that can be performed on your list of sequences () are described below: Query: 1 x y Find the sequence, , at index  in . Append integer  to sequence . Query: 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line Query: 1 x y Find the sequence, , at index  in . Append integer  to sequence . 1 x y Find the sequence, , at index  in . Append integer  to sequence . Query: 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line Task  Given , , and  queries, execute each query. Note:  is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia.  ^ Input Format The first line contains two space-separated integers,  (the number of sequences) and  (the number of queries), respectively.  Each of the  subsequent lines contains a query in the format defined above. Constraints    It is guaranteed that query type  will never query an empty sequence or index. Output Format For each type  query, print the updated value of  on a new line. Sample Input 2 5 1 0 5 1 1 7 1 0 3 2 1 0 2 1 1  Sample Output 7 3  Explanation Initial Values:       = [ ]   = [ ]   Query 0: Append  to sequence .     = [5]   = [ ]      Query 1: Append  to sequence .   = [5]   = [7]   Query 2: Append  to sequence .     = [5, 3]   = [7]    Query 3: Assign the value at index  of sequence  to , print .     = [5, 3]   = [7]   7  Query 4: Assign the value at index  of sequence  to , print .     = [5, 3]   = [7]   3
__label__Dynamic-Programming You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.   As an example, bricks are numbered .  You can remove either ,  or .  For your friend, your moves would leave the options of  to  elements from  leaving  for you (total score = ),  or .  In this case, it will never be optimal for your friend to take fewer than the maximum available number of elements.  Your maximum possible score is , achievable two ways:  first move and  the second, or  in your first move.   Function Description  Complete the bricksGame function in the editor below.  It should return an integer that represents your maximum possible score.   bricksGame has the following parameter(s):   arr:  an array of integers   Input Format The first line will contain an integer , the number of test cases.   Each of the next  pairs of lines are in the following format:  The first line contains an integer , the number of bricks in .  The next line contains  space-separated integers $arr[i].   Constraints       Output Format For each test case, print a single line containing your maximum score. Sample Input 2 5 999 1 1 1 0 5 0 1 1 1 999  Sample Output 1001 999  Explanation In first test case, you will pick 999,1,1. If you play in any other way, you will not get a score of 1001.  In second case, best option will be to pick up the first brick (with 0 score) at first. Then your friend  will choose the next three blocks, and you will get the last brick.
__label__Mathematics __label__Strings A string S of lowercase letters is given.  Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves.    Example 1: Input: S = "cba", K = 1 Output: "acb" Explanation:  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac". In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".   Example 2: Input: S = "baaca", K = 3 Output: "aaabc" Explanation:  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab". In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".    Note:  1 <= K <= S.length <= 1000 S consists of lowercase letters only.
__label__Data-Structures __label__Advanced-Data-Structures Shik loves sorted intervals. But currently he does not have enough time to sort all the numbers. So he decided to use Almost sorted intervals. An Almost sorted interval is a consecutive subsequence in a sequence which satisfies the following property: The first number is the smallest. The last number is the largest. Please help him count the number of almost sorted intervals in this permutation.   Note: Two intervals are different if at least one of the starting or ending indices are different. Input Format  The first line contains an integer N.  The second line contains a permutation from 1 to N. Output Format  Output the number of almost sorted intervals.   Constraints  1 ≤ N ≤ 106  Sample Input  5 3 1 2 5 4  Sample Output  8  Explanation  The subsequences [3], [1], [1 2], [1 2 5], [2], [2 5], [5], [4] are almost sorted intervals.
__label__Strings Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true
__label__Tree __label__Data-Structures We consider metric space to be a pair, , where  is a set and  such that the following conditions hold:     where  is the distance between points  and . Let's define the product of two metric spaces, , to be  such that:  , where , . So, it follows logically that  is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: . For example, , where  is a metric space. , where . In this challenge, we need a tree-space. You're given a tree, , where  is the set of vertices and  is the set of edges. Let the function  be the distance between two vertices in tree  (i.e.,  is the number of edges on the path between vertices  and ). Note that  is a metric space. You are given a tree, , with  vertices, as well as  points in . Find and print the distance between the two furthest points in this metric space! Input Format The first line contains two space-separated positive integers describing the respective values of  (the number of vertices in ) and  (the number of given points).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing edge  in .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for point . Constraints     Scoring This challenge uses binary scoring, so you must pass all test cases to earn a positive score. Output Format Print a single non-negative integer denoting the maximum distance between two of the given points in metric space . Sample Input 0 Sample Output 0 Explanation 0 The distance between points  and  is . Sample Input 1 Sample Output 1 Explanation 1 The best points are  and , which gives us a distance of .
__label__Graph-Algorithms Bitville is a seaside city that has a number of shopping centers connected by bidirectional roads, each of which has a travel time associated with it.  Each of the shopping centers may have a fishmonger who sells one or more kinds of fish.  Two cats, Big Cat and Little Cat, are at shopping center  (each of the centers is numbered consecutively from  to ).  They have a list of fish they want to purchase, and to save time, they will divide the list between them.  Determine the total travel time for the cats to purchase all of the types of fish, finally meeting at shopping center .  Their paths may intersect, they may backtrack through shopping center , and one may arrive at a different time than the other.  The minimum time to determine is when both have arrived at the destination.   For example, there are  shopping centers selling  types of fish.  The following is a graph that shows a possible layout of the shopping centers connected by  paths.  Each of the centers is labeled .  Here  and  represent Big Cat and Little Cat, respectively.  In this example, both cats take the same path, i.e.  and arrive at time  having purchased all three types of fish they want.  Neither cat visits shopping centers  or .     Function Description  Complete the shop function in the editor below.  It should return an integer that represents the minimum time required for their shopping.   shop has the following parameters:  - n: an integer, the number of shopping centers  - k: an integer, the number of types of fish  - centers: an array of strings of space-separated integers where the first integer of each element is the number of types of fish sold at a center and the remainder are the types sold  - roads: a 2-dimensional array of integers where the first two values are the shopping centers connected by the bi-directional road, and the third is the travel time for that road   Input Format The first line contains  space-separated integers:  (the number of shopping centers),  (the number of roads), and  (the number of types of fish sold in Bitville), respectively.         Each line  of the  subsequent lines () describes a shopping center as a line of space-separated integers. Each line takes the following form: The first integer, , denotes the number of types of fish that are sold by the fishmonger at the  shopping center. Each of the  subsequent integers on the line describes a type of fish sold by that fishmonger, denoted by , where  going forward. Each line  of the  subsequent lines () contains  space-separated integers that describe a road. The first two integers,  and , describe the two shopping centers it connects. The third integer, , denotes the amount of time it takes to travel the road. Constraints      All  are different for every fixed .   Each road connectes  distinct shopping centers (i.e., no road connects a shopping center to itself). Each pair of shopping centers is directly connected by no more than  road. It is possible to get to any shopping center from any other shopping center. Each type of fish is always sold by at least one fishmonger. Output Format Print the minimum amount of time it will take for the cats to collectively purchase all  fish and meet up at shopping center . Sample Input 5 5 5 1 1 1 2 1 3 1 4 1 5 1 2 10 1 3 10 2 4 10 3 5 10 4 5 10  Sample Output 30  Explanation    represents a location Big Cat visits,  represents a location where Little Cat visits.   Big Cat can travel  and buy fish at all of the shopping centers on his way. Little Cat can then travel , and buy fish from the fishmonger at the  shopping center only.
__label__Graph-Algorithms Fedya is a seasoned traveller and is planning his trip to Treeland. Treeland is a country with an ancient road system which is in the form of a tree structure.  cities of Treeland are numbered by  positive integers: . Fedya has not yet decided the starting point (city) of his journey and the cities he will visit. But there are a few things you know about Fedya's trip: Fedya is fond of travelling to great distances. So if he is currently located in city , his destination will be a city which is most distant from city . Fedya is fond of travelling to great distances. So if he is currently located in city , his destination will be a city which is most distant from city . There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey. There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey. There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number. There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number. Fedya has prepared a list of  possible journeys. Each one is characterized by two integers - the starting city  and the total number of cities to be visited, . For each of them, he is keen to know the total distance travelled by him. Input Format The first line of input will contain two space separated integers  and  - the number of cities and the number of possible journeys. Then, there will be  lines, each of them will contain two space separated integers  , denoting the bi-directional road between the cities with numbers  and  with the unitary length. Then there will be  lines, each of them will have two space separated integers  and , denoting a journey. Constraints    Output Format For each journey, output the travelled distance on a separate line. Sample Input Sample Output   Explanation The tree in question is given in the picture below.   4 6 indicates that Fedya starts at 4. Now we see that the most distant city from 4 is 8. Fedya now travels to city 8.  From 8, the most distance cities are [4, 3]. As 4 is already visited, he chooses to visit city 3. From city 3, he revisits city 8 and so on. The cities in the order of visit is 4 - > 8 -> 3 -> 8 -> 4 -> 8 -> 3 which sums to 24. Hence, the answer.   4 6 6 3 indicates that Fedya starts at city 6. From 6, the most distant cities are [3,4,8]. In this leg of the journey, no city is visited and hence Fedya chooses to visit the city with the smallest number 3. From 3, he visits 8 and then he ends his trip at city 4 which sums to 3 + 4 + 4 = 11. Hence, the answer.   6 3
__label__Data-Structures There is a collection of input strings and a collection of query strings.  For each query string, determine how many times it occurs in the list of input strings.   For example, given input  and , we find  instances of ',  of '' and  of ''.  For each query, we add an element to our return array, .   Function Description Complete the function matchingStrings in the editor below.  The function must return an array of integers representing the frequency of occurrence of each query string in strings. matchingStrings has the following parameters: strings - an array of strings to search   queries - an array of query strings   Input Format The first line contains and integer , the size of .  Each of the next  lines contains a string .  The next line contains , the size of .  Each of the next  lines contains a string .   Constraints      .  Output Format Return an integer array of the results of all queries in order.
__label__Data-Structures __label__Advanced-Data-Structures You are given a rooted tree with N nodes and the root of the tree, R, is also given. Each node of the tree contains a value, that is initially empty. You have to mantain the tree under two operations: Update Operation Report Operation Update Operation  Each Update Operation begins with the character U. Character U is followed by 3 integers T, V and K. For every node which is the descendent of the node T, update it's value by adding V + d*K, where V and K are the parameters of the query and d is the distance of the node from T. Note that V is added to node T.   U U Report Operation  Each Report Operation begins with the character Q. Character Q is followed by 2 integers, A and B. Output the sum of values of nodes in the path from A to B modulo (109 + 7)  Q Q Input Format  The first Line consists of 3 space separated integers, N E R, where N is the number of nodes present, E is the total number of queries (update + report), and R is root of the tree.   Each of the next N-1 lines contains 2 space separated integers, X and Y (X and Y are connected by an edge). Thereafter, E lines follows: each line can represent either the Update Operation or the Report Operation. Update Operation is of the form : U T V K. Report Operation is of the form : Q A B. Output Format  Output the answer for every given report operation. Constraints  1 ≤ N, E ≤ 105  1 ≤ E ≤ 105  1 ≤ R, X, Y, T, A, B ≤ N  1 ≤ V, K ≤ 109  X ≠ Y Sample Input 7 7 1 1 2 2 3 2 4 2 5 5 6 6 7 U 5 10 2 U 4 5 3 Q 1 7 U 6 7 4 Q 2 7 Q 1 4 Q 2 4  Sample Output 36 54 5 5  Explanation  Values of Nodes after U 5 10 2: [0 0 0 0 10 12 14]. U 5 10 2 [0 0 0 0 10 12 14] Values of Nodes after U 4 5 3: [0 0 0 5 10 12 14].  U 4 5 3 [0 0 0 5 10 12 14] Sum of the Nodes from 1 to 7: 0 + 0 + 10 + 12 + 14 = 36. Values of Nodes after U 6 7 4: [0 0 0 5 10 19 25].   U 6 7 4 Sum of the Nodes from 2 to 7: 0 + 10 + 19 + 25 = 54.  Sum of the Nodes from 1 to 4: 0 + 0 + 5 = 5. Sum of the Nodes from 2 to 4: 0 + 5 = 5.
__label__Strings Return the result of evaluating a given boolean expression, represented as a string. An expression can either be:  "t", evaluating to True; "f", evaluating to False; "!(expr)", evaluating to the logical NOT of the inner expression expr; "&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...; "|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...    Example 1: Input: expression = "!(f)" Output: true  Example 2: Input: expression = "|(f,t)" Output: true  Example 3: Input: expression = "&(t,f)" Output: false  Example 4: Input: expression = "|(&(t,f,t),!(t))" Output: false    Constraints:  1 <= expression.length <= 20000 expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}. expression is a valid expression representing a boolean, as given in the description.
__label__Dynamic-Programming Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000
__label__Tree Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.
__label__Hash-Table With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:  word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. 	For example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage"; while invalid words are "beefed" (doesn't include "a") and "based" (includes "s" which isn't in the puzzle).  Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i].   Example : Input:  words = ["aaaa","asas","able","ability","actt","actor","access"],  puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for "aboveyz" : "aaaa"  1 valid word for "abrodyz" : "aaaa" 3 valid words for "abslute" : "aaaa", "asas", "able" 2 valid words for "absoryz" : "aaaa", "asas" 4 valid words for "actresz" : "aaaa", "asas", "actt", "access" There're no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.    Constraints:  1 <= words.length <= 10^5 4 <= words[i].length <= 50 1 <= puzzles.length <= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] are English lowercase letters. Each puzzles[i] doesn't contain repeated characters.
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1
__label__Dynamic-Programming Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.
__label__Dynamic-Programming In this problem, we'll use the term "longest common substring" loosely.  It refers to substrings differing at some number or fewer characters when compared index by index.  For example, 'abc' and 'adc' differ in one position, 'aab' and 'aba' differ in two.   Given two strings and an integer , determine the length of the longest common substrings of the two strings that differ in no more than  positions.   For example, .  Strings  and .  Check to see if the whole string (the longest substrings) matches.  Given that neither the first nor last characters match and , we need to try shorter substrings.  The next longest substrings are  and .  Two pairs of these substrings only differ in  position:  and .  They are of length .   Function Description Complete the substringDiff function in the editor below.  It should return an integer that represents the length of the longest common substring as defined.   substringDiff has the following parameter(s):   k: an integer that represents the maximum number of differing characters in a matching pair   s1: the first string   s2: the second string   Input Format The first line of input contains a single integer, , the number of test cases follow.  Each of the next  lines contains three space-separated values:  an integer  and two strings,  and . Constraints        All characters in  and . Output Format For each test case, output a single integer which is the length of the maximum length common substrings differing at  or fewer positions. Sample Input Sample Output Explanation First test case: If we take "briz" from the first string, and "orin" from the second string, then the number of mismatches between these two substrings is equal to 2 and their lengths are . First test case: If we take "briz" from the first string, and "orin" from the second string, then the number of mismatches between these two substrings is equal to 2 and their lengths are . Second test case: Since , we should find the longest common substring, standard definition, for the given input strings. We choose "aba" as the result. Second test case: Since , we should find the longest common substring, standard definition, for the given input strings. We choose "aba" as the result. Third test case: We can choose "hellowor" from first string and "yellomar" from the second string.   Third test case: We can choose "hellowor" from first string and "yellomar" from the second string.
__label__Depth-first-Search In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.
__label__Game-Theory Dexter and Debra are playing a game. They have N containers each having one or more chocolates. Containers are numbered from 1 to N, where ith container has A[i] number of chocolates. The game goes like this. First player will choose a container and take one or more chocolates from it. Then, second player will choose a non-empty container and take one or more chocolates from it. And then they alternate turns. This process will continue, until one of the players is not able to take any chocolates (because no chocolates are left). One who is not able to take any chocolates loses the game. Note that player can choose only non-empty container. The game between Dexter and Debra has just started, and Dexter has got the first Chance. He wants to know the number of ways to make a first move such that under optimal play, the first player always wins. Input Format The first line contains an integer N, i.e., number of containers.  The second line contains N integers, i.e., number of chocolates in each of the containers separated by a single space.   Constraints 1 ≤ N ≤ 106  1 ≤ A[i] ≤ 109  Output Format Print the number of ways to make the first move such that under optimal play, the first player always wins. If the first player cannot win under optimal play, print 0.   Sample Input 2 2 3  Sample Output 1  Explanation Only 1 set of moves helps player 1 win.  Player:      1      2      1      2      1 Chocolates: 2 3 -> 2 2 -> 1 2 -> 1 1 -> 0 1
__label__Mathematics Given a number N, return a string consisting of "0"s and "1"s that represents its value in base -2 (negative two). The returned string must have no leading zeroes, unless the string is "0".    Example 1: Input: 2 Output: "110" Explantion: (-2) ^ 2 + (-2) ^ 1 = 2   Example 2: Input: 3 Output: "111" Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3   Example 3: Input: 4 Output: "100" Explantion: (-2) ^ 2 = 4    Note:  0 <= N <= 10^9
__label__Dynamic-Programming You have a warehouse with  containers filled with an infinite number of candies. The containers are arranged in a single row, equally spaced to be  meter apart. You also have  robots that can pick up  piece of candy and transport it between any two containers. The robots take instructions in the form of queries consisting of two integers,  and , respectively. To execute a query, a robot travels to container , picks up  candy, transports it to container , and then stops at  until it receives another query.    Calculate the minimum total distance the robots must travel to execute  queries in order.  Note: You choose which robot executes each query. Input Format The first line contains a single integer,  (the number of test cases); each of the  test cases is described over  lines.      The first line of a test case has two space-separated integers,  (the number of containers) and  (the number of queries).  The  subsequent lines each contain two space-separated integers,  and , respectively; each line  describes the  query. Constraints            Output Format On a new line for each test case, print an integer denoting the minimum total distance that the robots must travel to execute the queries in order. Sample Input 3 5 4 1 5 3 2 4 1 2 4 4 2 1 2 4 3 10 3 2 4 5 4 9 8  Sample Output 11 2 5  Explanation In this explanation, we refer to the two robots as  and , each container  as , and the total distance traveled for each query  as .  Note: For the first query a robot executes, there is no travel distance. For each subsequent query that robot executes, it must travel from the location where it completed its last query. Test Case 0:  The minimum distance traveled is :       Robot:      meters. Robot:      meter.     Robot:      meters.        Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 1:  Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 2:  Robot:      meters. Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line.
__label__Binary-Search Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.
__label__Array __label__Greedy-Algorithms Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.
__label__Tree __label__Depth-first-Search Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.
__label__Dynamic-Programming __label__Greedy-Algorithms Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]
__label__Hash-Table You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.
__label__Array __label__Strings A transaction is possibly invalid if:  the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city.  Each transaction string transactions[i] consists of comma separated values representing the name, time (in minutes), amount, and city of the transaction. Given a list of transactions, return a list of transactions that are possibly invalid.  You may return the answer in any order.   Example 1: Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"] Output: ["alice,20,800,mtv","alice,50,100,beijing"] Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. Example 2: Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"] Output: ["alice,50,1200,mtv"]  Example 3: Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"] Output: ["bob,50,1200,mtv"]    Constraints:  transactions.length <= 1000 Each transactions[i] takes the form "{name},{time},{amount},{city}" Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10. Each {time} consist of digits, and represent an integer between 0 and 1000. Each {amount} consist of digits, and represent an integer between 0 and 2000.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head node of a doubly linked list. Reverse the order of the nodes in the list. The head node might be NULL to indicate that the list is empty.  Change the next and prev pointers of all the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.  Function Description Complete the reverse function in the editor below.  It should return a reference to the head of your reversed list. reverse has the following parameter(s): head: a reference to the head of a DoublyLinkedList Input Format The first line contains an integer , the number of test cases.   Each test case is of the following format: The first line contains an integer , the number of elements in the linked list.   The next  lines contain an integer each denoting an element of the linked list. Constraints       Output Format Return a reference to the head of your reversed list.  The provided code will print the reverse array as a one line of space-separated integers for each test case.   Sample Input 1 4 1 2 3 4  Sample Output 4 3 2 1   Explanation The initial doubly linked list is:   The reversed doubly linked list is:
