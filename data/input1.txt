__label__0 Write a function that takes a string as input and reverse only the vowels of a string.\nExample 1:\nInput: "hello"\nOutput: "holle"\n\n\nExample 2:\nInput: "leetcode"\nOutput: "leotcede"\n\nNote:\nThe vowels does not include the letter "y".
__label__0 The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. \n\n\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n\nExample 1:\nInput: nums = [1,2,2,4]\nOutput: [2,3]\n\n\nNote:\n\nThe given array size will in the range [2, 10000].\nThe given array's numbers won't have any order.
__label__0 Given an integer matrix, find the length of the longest increasing path.\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\nExample 1:\nInput: nums = \n[\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n] \nOutput: 4 \nExplanation: The longest increasing path is [1, 2, 6, 9].\n\nExample 2:\nInput: nums = \n[\n  [3,4,5],\n  [3,2,6],\n  [2,2,1]\n] \nOutput: 4 \nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
__label__0 Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.\nTwo trees are duplicate if they have the same structure with same node values.\nExample 1: \n        1\n       / \\\n      2   3\n     /   / \\\n    4   2   4\n       /\n      4\n\nThe following are two duplicate subtrees:\n      2\n     /\n    4\n\nand\n    4\n\nTherefore, you need to return above trees' root in the form of a list.
__label__0 Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\nFor example, with A = "abcd" and B = "cdabcdab".\nReturn 3, because by repeating A three times (\xe2\x80\x9cabcdabcdabcd\xe2\x80\x9d), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd").\nNote:\nThe length of A and B will be between 1 and 10000.
__label__0 Suppose we have a class:\npublic class Foo {\n\xc2\xa0 public void first() { print("first"); }\n\xc2\xa0 public void second() { print("second"); }\n\xc2\xa0 public void third() { print("third"); }\n}\n\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program\xc2\xa0to ensure that\xc2\xa0second()\xc2\xa0is executed after\xc2\xa0first(), and\xc2\xa0third() is executed after\xc2\xa0second().\n\xc2\xa0\nExample 1:\nInput: [1,2,3]\nOutput: "firstsecondthird"\nExplanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). "firstsecondthird" is the correct output.\n\nExample 2:\nInput: [1,3,2]\nOutput: "firstsecondthird"\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). "firstsecondthird" is the correct output.\n\xc2\xa0\nNote:\nWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seems to imply the ordering. The input format you see is mainly\xc2\xa0to ensure our tests\' comprehensiveness.
__label__0 The Tribonacci sequence Tn is defined as follows:\xc2\xa0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n\xc2\xa0\nExample 1:\nInput: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n\nExample 2:\nInput: n = 25\nOutput: 1389537\n\n\xc2\xa0\nConstraints:\n\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.
__label__0 Given the root of a binary tree, the level of its root is 1,\xc2\xa0the level of its children is 2,\xc2\xa0and so on.\nReturn the smallest level X such that the sum of all the values of nodes at level X is maximal.\n\xc2\xa0\nExample 1:\n\nInput: [1,7,0,7,-8,null,null]\nOutput: 2\nExplanation: \nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the given tree is between 1 and 10^4.\n-10^5 <= node.val <= 10^5
__label__0 A robot on an infinite grid starts at point (0, 0) and faces north.\xc2\xa0 The robot can receive one of three possible types of commands:\n\n-2: turn left 90 degrees\n-1: turn right 90 degrees\n1 <= x <= 9: move forward x units\n\nSome of the grid squares are obstacles.\xc2\xa0\nThe i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])\nIf the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)\nReturn the square of the maximum Euclidean distance that the robot will be from the origin.\n\xc2\xa0\nExample 1:\nInput: commands = [4,-1,3], obstacles = []\nOutput: 25\nExplanation: robot will go to (3, 4)\n\n\nExample 2:\nInput: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\nOutput: 65\nExplanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)\n\n\n\xc2\xa0\nNote:\n\n0 <= commands.length <= 10000\n0 <= obstacles.length <= 10000\n-30000 <= obstacle[i][0] <= 30000\n-30000 <= obstacle[i][1] <= 30000\nThe answer is guaranteed to be less than 2 ^ 31.
__label__0 An encoded string S is given.\xc2\xa0 To find and write the decoded string to a tape, the encoded string is read one character at a time\xc2\xa0and the following steps are taken:\n\nIf the character read is a letter, that letter is written onto the tape.\nIf the character read is a digit (say d), the entire current tape is repeatedly written\xc2\xa0d-1\xc2\xa0more times in total.\n\nNow for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.\n\xc2\xa0\n\nExample 1:\nInput: S = "leet2code3", K = 10\nOutput: "o"\nExplanation: \nThe decoded string is "leetleetcodeleetleetcodeleetleetcode".\nThe 10th letter in the string is "o".\n\n\nExample 2:\nInput: S = "ha22", K = 5\nOutput: "h"\nExplanation: \nThe decoded string is "hahahaha".  The 5th letter is "h".\n\n\nExample 3:\nInput: S = "a2345678999999999999999", K = 1\nOutput: "a"\nExplanation: \nThe decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".\n\n\xc2\xa0\nNote:\n\n2 <= S.length <= 100\nS\xc2\xa0will only contain lowercase letters and digits 2 through 9.\nS\xc2\xa0starts with a letter.\n1 <= K <= 10^9\nThe decoded string is guaranteed to have less than 2^63 letters.
__label__0 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\nExample 1:\nInput:\n  s = "barfoothefoobarman",\n  words = ["foo","bar"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.\nThe output order does not matter, returning [9,0] is fine too.\n\nExample 2:\nInput:\n  s = "wordgoodgoodgoodbestword",\n  words = ["word","good","best","word"]\nOutput: []
__label__0 A boomerang is a set of 3 points that are all distinct and not in a straight line.\nGiven a list\xc2\xa0of three points in the plane, return whether these points are a boomerang.\n\xc2\xa0\nExample 1:\nInput: [[1,1],[2,3],[3,2]]\nOutput: true\n\n\nExample 2:\nInput: [[1,1],[2,2],[3,3]]\nOutput: false\n\n\xc2\xa0\nNote:\n\npoints.length == 3\npoints[i].length == 2\n0 <= points[i][j] <= 100
__label__0 Given an array nums of n integers and an integer target, find three integers in nums\xc2\xa0such that the sum is closest to\xc2\xa0target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nExample:\nGiven array nums = [-1, 2, 1, -4], and target = 1.\n\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
__label__0 A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.)\nGiven a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.\n\xc2\xa0\nExample 1:\nInput: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"\nOutput: [true,false,true,true,false]\nExplanation: \n"FooBar" can be generated like this "F" + "oo" + "B" + "ar".\n"FootBall" can be generated like this "F" + "oot" + "B" + "all".\n"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".\nExample 2:\nInput: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"\nOutput: [true,false,true,false,false]\nExplanation: \n"FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".\n"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".\n\nExample 3:\nInput: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"\nOutput: [false,true,false,false,false]\nExplanation: \n"FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".\n\n\xc2\xa0\nNote:\n\n1 <= queries.length <= 100\n1 <= queries[i].length <= 100\n1 <= pattern.length <= 100\nAll strings consists only of lower and upper case English letters.
__label__0 Given a\xc2\xa0matrix A, return the transpose of A.\nThe transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.\n\xc2\xa0\n\nExample 1:\nInput: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]\n\n\nExample 2:\nInput: [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]\n\n\xc2\xa0\nNote:\n\n1 <= A.length\xc2\xa0<= 1000\n1 <= A[0].length\xc2\xa0<= 1000
__label__0 Every non-negative integer N\xc2\xa0has a binary representation.\xc2\xa0 For example,\xc2\xa05 can be represented as "101"\xc2\xa0in binary, 11 as "1011"\xc2\xa0in binary, and so on.\xc2\xa0 Note that except for N = 0, there are no leading zeroes in any\xc2\xa0binary representation.\nThe complement\xc2\xa0of a binary representation\xc2\xa0is the number in binary you get when changing every 1 to a 0 and 0 to a 1.\xc2\xa0 For example, the complement of "101" in binary is "010" in binary.\nFor a given number N in base-10, return the complement of it\'s binary representation as a\xc2\xa0base-10 integer.\n\xc2\xa0\n\n\n\nExample 1:\nInput: 5\nOutput: 2\nExplanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.\n\n\nExample 2:\nInput: 7\nOutput: 0\nExplanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.\n\n\nExample 3:\nInput: 10\nOutput: 5\nExplanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.\n\n\xc2\xa0\nNote:\n\n0 <= N < 10^9
__label__0 A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven an grid\xc2\xa0of integers, how many 3 x 3 "magic square" subgrids are there?\xc2\xa0 (Each subgrid is contiguous).\n\xc2\xa0\nExample 1:\nInput: [[4,3,8,4],\n        [9,5,1,9],\n        [2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n438\n951\n276\n\nwhile this one is not:\n384\n519\n762\n\nIn total, there is only one magic square inside the given grid.\n\nNote:\n\n1 <= grid.length\xc2\xa0<= 10\n1 <= grid[0].length\xc2\xa0<= 10\n0 <= grid[i][j] <= 15
__label__0 An undirected, connected\xc2\xa0tree with N nodes labelled 0...N-1 and N-1 edges\xc2\xa0are\xc2\xa0given.\nThe ith edge connects nodes\xc2\xa0edges[i][0] and\xc2\xa0edges[i][1]\xc2\xa0together.\nReturn a list ans, where ans[i] is the sum of the distances between node i and all other nodes.\nExample 1:\nInput: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\nOutput: [8,12,6,10,10,10]\nExplanation: \nHere is a diagram of the given tree:\n  0\n / \\\n1   2\n   /|\\\n  3 4 5\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.\n\nNote:\xc2\xa01 <= N <= 10000
__label__0 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\xc2\xa0\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\xc2\xa0\nNote:\nBonus points if you could solve it both recursively and iteratively.
__label__0 Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\nAn example is the root-to-leaf path 1->2->3 which represents the number 123.\nFind the total sum of all root-to-leaf numbers.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nInput: [1,2,3]\n    1\n   / \\\n  2   3\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\nExample 2:\nInput: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n\xc2\xa0/ \\\n5   1\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.
__label__0 Today, the bookstore owner has a store open for customers.length minutes.\xc2\xa0 Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy.\xc2\xa0 If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.\xc2\xa0 When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves\xc2\xa0not grumpy for X\xc2\xa0minutes straight, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.\n\xc2\xa0\nExample 1:\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\nOutput: 16\nExplanation:\xc2\xa0The bookstore owner keeps themselves\xc2\xa0not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n\xc2\xa0\nNote:\n\n1 <= X <=\xc2\xa0customers.length ==\xc2\xa0grumpy.length <= 20000\n0 <=\xc2\xa0customers[i] <= 1000\n0 <=\xc2\xa0grumpy[i] <= 1
__label__0 Given an n-ary tree, return the postorder traversal of its nodes' values.\nFor example, given a 3-ary tree:\n\xc2\xa0\n\n\xc2\xa0\nReturn its postorder traversal as: [5,6,3,2,4,1].\n\xc2\xa0\n\nNote:\nRecursive solution is trivial, could you do it iteratively?
__label__0 Given a string, find the first non-repeating character in it and return it\'s index. If it doesn\'t exist, return -1.\n\nExamples:\ns = "leetcode"\nreturn 0.\n\ns = "loveleetcode",\nreturn 2.\n\n\n\nNote: You may assume the string contain only lowercase letters.
__label__0 Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\nExample 1:\n\nInput: a = 2, b = [3]\nOutput: 8\n\n\nExample 2:\nInput: a = 2, b = [1,0]\nOutput: 1024
__label__0 Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. \n\nExample 1:\nInput: candies = [1,1,2,2,3,3]\nOutput: 3\nExplanation:\nThere are three different kinds of candies (1, 2 and 3), and two candies for each kind.\nOptimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. \nThe sister has three different kinds of candies. \n\n\nExample 2:\nInput: candies = [1,1,2,3]\nOutput: 2\nExplanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. \nThe sister has two different kinds of candies, the brother has only one kind of candies. \n\n\nNote:\n\nThe length of the given array is in range [2, 10,000], and will be even.\nThe number in given array is in range [-100,000, 100,000].
__label__0 Given a binary tree, return the tilt of the whole tree.\nThe tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.\nThe tilt of the whole tree is defined as the sum of all nodes' tilt.\nExample:\nInput: \n         1\n       /   \\\n      2     3\nOutput: 1\nExplanation: \nTilt of node 2 : 0\nTilt of node 3 : 0\nTilt of node 1 : |2-3| = 1\nTilt of binary tree : 0 + 0 + 1 = 1\n\n\nNote:\n\nThe sum of node values in any subtree won't exceed the range of 32-bit integer. \nAll the tilt values won't exceed the range of 32-bit integer.
__label__0 Given an integer n, find the closest integer (not including itself), which is a palindrome. \nThe \'closest\' is defined as absolute difference minimized between two integers.\nExample 1:\nInput: "123"\nOutput: "121"\n\n\nNote:\n\nThe input n is a positive integer represented by string, whose length will not exceed 18.\nIf there is a tie, return the smaller one as answer.
__label__0 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]] \nExplanation: The first 3 pairs are returned from the sequence: \n\xc2\xa0            [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [1,1],[1,1]\nExplanation: The first 2 pairs are returned from the sequence: \n\xc2\xa0            [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\nExample 3:\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [1,3],[2,3]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]
__label__0 Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:\n\nThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\nA closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\nA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\nA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\nA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\nA < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid).\nThe cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>. \nCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. \n\nValid Code Examples:\nInput: "<DIV>This is the first line <![CDATA[<div>]]></DIV>"\nOutput: True\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\n\nInput: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"\nOutput: True\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -> "<DIV>"\nend_tag -> "</DIV>"\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -> ">>  ![cdata[]] "\ncdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>"\ntext2 -> "]]>>]"\n\nThe reason why start_tag is NOT "<DIV>>>" is because of the rule 6.\nThe reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.\n\n\nInvalid Code Examples:\nInput: "<A>  <B> </A>   </B>"\nOutput: False\nExplanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.\n\nInput: "<DIV>  div tag is not closed  <DIV>"\nOutput: False\n\nInput: "<DIV>  unmatched <  </DIV>"\nOutput: False\n\nInput: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>"\nOutput: False\n\nInput: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>"\nOutput: False\n\nInput: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>"\nOutput: False\n\n\nNote:\n\nFor simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, \'<\',\'>\',\'/\',\'!\',\'[\',\']\' and \' \'.
__label__0 Suppose we abstract our file system by a string in the following manner:\nThe string "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext" represents:\ndir\n    subdir1\n    subdir2\n        file.ext\n\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\nThe string "dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext" represents:\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes).\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\nNote:\n\nThe name of a file contains at least a . and an extension.\nThe name of a directory or sub-directory will not contain a ..\n\n\nTime complexity required: O(n) where n is the size of the input string.\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.
__label__0 Given an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).\xc2\xa0 If it cannot be done, then return the same array.\n\xc2\xa0\nExample 1:\nInput: [3,2,1]\nOutput: [3,1,2]\nExplanation: Swapping 2 and 1.\n\nExample 2:\nInput: [1,1,5]\nOutput: [1,1,5]\nExplanation: This is already the smallest permutation.\n\nExample 3:\nInput: [1,9,4,6,7]\nOutput: [1,7,4,6,9]\nExplanation: Swapping 9 and 7.\n\nExample 4:\nInput: [3,1,1,3]\nOutput: [1,3,1,3]\nExplanation: Swapping 1 and 3.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n1 <= A[i] <= 10000
__label__0 Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\nExample:\nX X X X\nX O O X\nX X O X\nX O X X\n\nAfter running your function, the board should be:\nX X X X\nX X X X\nX X X X\nX O X X\n\nExplanation:\nSurrounded regions shouldn\xe2\x80\x99t be on the border, which means that any 'O'\xc2\xa0on the border of the board are not flipped to 'X'. Any 'O'\xc2\xa0that is not on the border and it is not connected to an 'O'\xc2\xa0on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
__label__0 We sampled integers between 0 and 255, and stored the results in an array count:\xc2\xa0 count[k] is the number of integers we sampled equal to k.\nReturn the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers.\xc2\xa0 The mode is guaranteed to be unique.\n(Recall that the median of a sample is:\n\nThe middle element, if the elements of the sample were sorted and the number of elements is odd;\nThe average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)\n\n\xc2\xa0\nExample 1:\nInput: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\nOutput: [1.00000,3.00000,2.37500,2.50000,3.00000]\nExample 2:\nInput: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\nOutput: [1.00000,4.00000,2.18182,2.00000,1.00000]\n\n\xc2\xa0\nConstraints:\n\ncount.length == 256\n1 <= sum(count) <= 10^9\nThe mode of the sample that count represents is unique.\nAnswers within 10^-5 of the true value will be accepted as correct.
__label__0 Two images A and B are given, represented as\xc2\xa0binary, square matrices of the same size.\xc2\xa0 (A binary matrix has only 0s and 1s as values.)\nWe translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.\xc2\xa0 After, the overlap of this translation is the number of positions that have a 1 in both images.\n(Note also that a translation does not include any kind of rotation.)\nWhat is the largest possible overlap?\nExample 1:\nInput: A = [[1,1,0],\n            [0,1,0],\n\xc2\xa0           [0,1,0]]\n\xc2\xa0      B = [[0,0,0],\n\xc2\xa0           [0,1,1],\n\xc2\xa0           [0,0,1]]\nOutput: 3\nExplanation: We slide A to right by 1 unit and down by 1 unit.\nNotes:\xc2\xa0\n\n1 <= A.length = A[0].length = B.length = B[0].length <= 30\n0 <=\xc2\xa0A[i][j], B[i][j] <= 1
__label__0 Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]
__label__0 You are given a perfect binary tree\xc2\xa0where\xc2\xa0all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\xc2\xa0\nExample:\n\nInput: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}\n\nOutput: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}\n\nExplanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.\n\n\xc2\xa0\nNote:\n\nYou may only use constant extra space.\nRecursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__0 There are N rooms and you start in room 0.\xc2\xa0 Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have\xc2\xa0some keys to access the next room.\xc2\xa0\nFormally, each room i\xc2\xa0has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.\xc2\xa0 A key rooms[i][j] = v\xc2\xa0opens the room with number v.\nInitially, all the rooms start locked (except for room 0).\xc2\xa0\nYou can walk back and forth between rooms freely.\nReturn true\xc2\xa0if and only if you can enter\xc2\xa0every room.\n\n\nExample 1:\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n\nExample 2:\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n\nNote:\n\n1 <= rooms.length <=\xc2\xa01000\n0 <= rooms[i].length <= 1000\nThe number of keys in all rooms combined is at most\xc2\xa03000.
__label__0 Return the root node of a binary search tree that matches the given preorder traversal.\n(Recall that a binary search tree\xc2\xa0is a binary tree where for every node, any descendant of node.left has a value <\xc2\xa0node.val, and any descendant of node.right has a value >\xc2\xa0node.val.\xc2\xa0 Also recall that a preorder traversal\xc2\xa0displays the value of the\xc2\xa0node first, then traverses node.left, then traverses node.right.)\n\xc2\xa0\nExample 1:\nInput: [8,5,1,7,10,12]\nOutput: [8,5,10,1,7,null,12]\n\n\n\xc2\xa0\nNote:\xc2\xa0\n\n1 <= preorder.length <= 100\nThe values of preorder are distinct.
__label__0 Find the smallest prime palindrome greater than or equal to N.\nRecall that a\xc2\xa0number is prime if it's only divisors are 1 and itself, and it is greater than 1.\xc2\xa0\nFor example, 2,3,5,7,11 and 13 are\xc2\xa0primes.\nRecall that a number is a palindrome if it reads the same from left to right as it does from right to left.\xc2\xa0\nFor example, 12321 is a palindrome.\n\xc2\xa0\n\nExample 1:\nInput: 6\nOutput: 7\n\n\nExample 2:\nInput: 8\nOutput: 11\n\n\nExample 3:\nInput: 13\nOutput: 101\n\n\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10^8\nThe answer is guaranteed to exist and be less than 2 * 10^8.
__label__0 Given a binary tree, each node has value 0\xc2\xa0or 1.\xc2\xa0 Each root-to-leaf path represents a binary number starting with the most significant bit.\xc2\xa0 For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\nFor all leaves in the tree, consider the numbers represented by the path\xc2\xa0from the root to that leaf.\nReturn the sum of these numbers.\n\xc2\xa0\nExample 1:\n\nInput: [1,0,1,0,1,0,1]\nOutput: 22\nExplanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the tree is between 1 and 1000.\nnode.val is 0 or 1.\nThe answer will not exceed 2^31 - 1.
__label__0 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nExample:\nGiven array nums = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]
__label__0 In a 1 million by 1 million grid, the coordinates of each grid square are (x, y) with 0 <= x, y < 10^6.\nWe start at the source square and want to reach the target square.\xc2\xa0 Each move, we can walk to a 4-directionally adjacent square in the grid that isn't in the given list of blocked squares.\nReturn true if and only if it is possible to reach the target square through a sequence of moves.\n\xc2\xa0\nExample 1:\nInput: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\nOutput: false\nExplanation: \nThe target square is inaccessible starting from the source square, because we can't walk outside the grid.\n\nExample 2:\nInput: blocked = [], source = [0,0], target = [999999,999999]\nOutput: true\nExplanation: \nBecause there are no blocked cells, it's possible to reach the target square.\n\n\xc2\xa0\nNote:\n\n0 <= blocked.length <= 200\nblocked[i].length == 2\n0 <= blocked[i][j] < 10^6\nsource.length == target.length == 2\n0 <= source[i][j], target[i][j] < 10^6\nsource != target
__label__0 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero.\nExample 1:\nInput: dividend = 10, divisor = 3\nOutput: 3\nExample 2:\nInput: dividend = 7, divisor = -3\nOutput: -2\nNote:\n\nBoth dividend and divisor\xc2\xa0will be\xc2\xa032-bit\xc2\xa0signed integers.\nThe divisor will never be 0.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\xe2\x88\x92231, \xc2\xa0231 \xe2\x88\x92 1]. For the purpose of this problem, assume that your function returns 231 \xe2\x88\x92 1 when the division result\xc2\xa0overflows.
__label__0 The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the\xc2\xa0weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\xc2\xa0 (It is guaranteed each person can be carried by a boat.)\n\xc2\xa0\n\nExample 1:\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n\n\nExample 2:\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n\n\nExample 3:\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\nNote:\n\n1 <=\xc2\xa0people.length <= 50000\n1 <= people[i] <=\xc2\xa0limit <= 30000
__label__0 Koko loves to eat bananas.\xc2\xa0 There are N\xc2\xa0piles of bananas, the i-th\xc2\xa0pile has piles[i] bananas.\xc2\xa0 The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K.\xc2\xa0 Each hour, she chooses some pile of bananas, and eats K bananas from that pile.\xc2\xa0 If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\n\xc2\xa0\n\n\n\nExample 1:\nInput: piles = [3,6,7,11], H = 8\nOutput: 4\n\n\nExample 2:\nInput: piles = [30,11,23,4,20], H = 5\nOutput: 30\n\n\nExample 3:\nInput: piles = [30,11,23,4,20], H = 6\nOutput: 23\n\n\xc2\xa0\nNote:\n\n1 <= piles.length <= 10^4\npiles.length <= H <= 10^9\n1 <= piles[i] <= 10^9
__label__0 You are given an array of strings\xc2\xa0words\xc2\xa0and a string\xc2\xa0chars.\nA string is good\xc2\xa0if\xc2\xa0it can be formed by\xc2\xa0characters from chars\xc2\xa0(each character\xc2\xa0can only be used once).\nReturn the sum of lengths of all good strings in words.\n\xc2\xa0\nExample 1:\nInput: words = ["cat","bt","hat","tree"], chars = "atach"\nOutput: 6\nExplanation: \nThe strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.\n\nExample 2:\nInput: words = ["hello","world","leetcode"], chars = "welldonehoneyr"\nOutput: 10\nExplanation: \nThe strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.\n\n\xc2\xa0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length\xc2\xa0<= 100\nAll strings contain lowercase English letters only.
__label__0 Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.\n\xc2\xa0\nExample 1:\nInput: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13\n\nExample 2:\nInput: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20\n\n\xc2\xa0\nConstraints:\n\n2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6
__label__0 A string is a valid parentheses string\xc2\xa0(denoted VPS) if and only if it consists of "(" and ")" characters only, and:\n\nIt is the empty string, or\nIt can be written as\xc2\xa0AB\xc2\xa0(A\xc2\xa0concatenated with\xc2\xa0B), where\xc2\xa0A\xc2\xa0and\xc2\xa0B\xc2\xa0are VPS\'s, or\nIt can be written as\xc2\xa0(A), where\xc2\xa0A\xc2\xa0is a VPS.\n\nWe can\xc2\xa0similarly define the nesting depth depth(S) of any VPS S as follows:\n\ndepth("") = 0\ndepth(A + B) = max(depth(A), depth(B)), where A and B are VPS\'s\ndepth("(" + A + ")") = 1 + depth(A), where A is a VPS.\n\nFor example,\xc2\xa0 "",\xc2\xa0"()()", and\xc2\xa0"()(()())"\xc2\xa0are VPS\'s (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS\'s.\n\xc2\xa0\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that\xc2\xa0A and B are VPS\'s (and\xc2\xa0A.length + B.length = seq.length).\nNow choose any such A and B such that\xc2\xa0max(depth(A), depth(B)) is the minimum possible value.\nReturn an answer array (of length seq.length) that encodes such a\xc2\xa0choice of A and B:\xc2\xa0 answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.\xc2\xa0 Note that even though multiple answers may exist, you may return any of them.\n\xc2\xa0\nExample 1:\nInput: seq = "(()())"\nOutput: [0,1,1,1,1,0]\n\nExample 2:\nInput: seq = "()(())()"\nOutput: [0,0,0,1,1,0,1,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= seq.size <= 10000
__label__0 Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.\nThe length of path between two nodes is represented by the number of edges between them.\n\xc2\xa0\nExample 1:\nInput:\n              5\n             / \\\n            4   5\n           / \\   \\\n          1   1   5\n\nOutput:\xc2\xa02\n\xc2\xa0\nExample 2:\nInput:\n              1\n             / \\\n            4   5\n           / \\   \\\n          4   4   5\n\nOutput:\xc2\xa02\n\xc2\xa0\nNote: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.
__label__0 Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\nExample 1:\nInput: nums = [1,3], n = 6\nOutput: 1 \nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\nExample 2:\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\n\nExample 3:\nInput: nums = [1,2,2], n = 5\nOutput: 0
__label__0 Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.\nExample 1:\nInput: \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 9\n\nOutput: True\n\n\xc2\xa0\nExample 2:\nInput: \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 28\n\nOutput: False
__label__0 For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.\nFormat\nThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\nExample 1 :\nInput: n = 4, edges = [[1, 0], [1, 2], [1, 3]]\n\n        0\n        |\n        1\n       / \\\n      2   3 \n\nOutput: [1]\n\nExample 2 :\nInput: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\n\n     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5 \n\nOutput: [3, 4]\nNote:\n\nAccording to the definition of tree on Wikipedia: \xe2\x80\x9ca tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\xe2\x80\x9d\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.
__label__0 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array\xc2\xa0in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\n\xc2\xa0\n\nExample 1:\nInput: ["h","e","l","l","o"]\nOutput: ["o","l","l","e","h"]\n\n\nExample 2:\nInput: ["H","a","n","n","a","h"]\nOutput: ["h","a","n","n","a","H"]
__label__0 Print a binary tree in an m*n 2D string array following these rules: \n\nThe row number m should be equal to the height of the given binary tree.\nThe column number n should always be an odd number.\nThe root node\'s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don\'t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don\'t need to leave space for both of them. \nEach unused space should contain an empty string "".\nPrint the subtrees following the same rules.\n\nExample 1:\nInput:\n     1\n    /\n   2\nOutput:\n[["", "1", ""],\n ["2", "", ""]]\n\n\nExample 2:\nInput:\n     1\n    / \\\n   2   3\n    \\\n     4\nOutput:\n[["", "", "", "1", "", "", ""],\n ["", "2", "", "", "", "3", ""],\n ["", "", "4", "", "", "", ""]]\n\n\nExample 3:\nInput:\n      1\n     / \\\n    2   5\n   / \n  3 \n / \n4 \nOutput:\n\n[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]\n ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]\n ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]\n ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]\n\n\nNote:\nThe height of binary tree is in the range of [1, 10].
__label__0 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1->2->3->4->5->NULL\nOutput: 1->3->5->2->4->NULL\n\nExample 2:\nInput: 2->1->3->5->6->4->7->NULL\nOutput: 2->3->6->7->1->5->4->NULL\n\nNote:\n\nThe relative order inside both the even and odd groups should remain as it was in the input.\nThe first node is considered odd, the second node even and so on ...
__label__0 Given an integer array nums, find the sum of the elements between indices i and j (i \xe2\x89\xa4 j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val.\nExample:\nGiven nums = [1, 3, 5]\n\nsumRange(0, 2) -> 9\nupdate(1, 2)\nsumRange(0, 2) -> 8\n\nNote:\n\nThe array is only modifiable by the update function.\nYou may assume the number of calls to update and sumRange function is distributed evenly.
__label__0 In English, we have a concept called root, which can be followed by some other words to form another longer word - let\'s call this word successor. For example, the root an, followed by other, which can form another word another.\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\nYou need to output the sentence after the replacement.\nExample 1:\nInput: dict = ["cat", "bat", "rat"]\nsentence = "the cattle was rattled by the battery"\nOutput: "the cat was rat by the bat"\n\n\xc2\xa0\nNote:\n\nThe input will only have lower-case letters.\n1 <= dict words number <= 1000\n1 <= sentence words number <= 1000\n1 <= root length <= 100\n1 <= sentence words length <= 1000
__label__0 Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\nExample 1:\nInput: [1,3,4,2,2]\nOutput: 2\n\nExample 2:\nInput: [3,1,3,4,2]\nOutput: 3\nNote:\n\nYou must not modify the array (assume the array is read only).\nYou must use only constant, O(1) extra space.\nYour runtime complexity should be less than O(n2).\nThere is only one duplicate number in the array, but it could be repeated more than once.
__label__0 Given an N x N grid\xc2\xa0containing only values 0 and 1, where\xc2\xa00 represents water\xc2\xa0and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized and return the distance.\nThe distance used in this problem is the Manhattan distance:\xc2\xa0the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.\nIf no land or water exists in the grid, return -1.\n\xc2\xa0\nExample 1:\n\nInput: [[1,0,1],[0,0,0],[1,0,1]]\nOutput: 2\nExplanation: \nThe cell (1, 1) is as far as possible from all the land with distance 2.\n\nExample 2:\n\nInput: [[1,0,0],[0,0,0],[0,0,0]]\nOutput: 4\nExplanation: \nThe cell (2, 2) is as far as possible from all the land with distance 4.\n\n\xc2\xa0\nNote:\n\n1 <= grid.length == grid[0].length\xc2\xa0<= 100\ngrid[i][j]\xc2\xa0is 0 or 1
__label__0 On an alphabet board, we start at position (0, 0), corresponding to character\xc2\xa0board[0][0].\nHere, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.\n\nWe may make the following moves:\n\n\'U\' moves our position up one row, if the position exists on the board;\n\'D\' moves our position down one row, if the position exists on the board;\n\'L\' moves our position left one column, if the position exists on the board;\n\'R\' moves our position right one column, if the position exists on the board;\n\'!\'\xc2\xa0adds the character board[r][c] at our current position (r, c)\xc2\xa0to the\xc2\xa0answer.\n\n(Here, the only positions that exist on the board are positions with letters on them.)\nReturn a sequence of moves that makes our answer equal to target\xc2\xa0in the minimum number of moves.\xc2\xa0 You may return any path that does so.\n\xc2\xa0\nExample 1:\nInput: target = "leet"\nOutput: "DDR!UURRR!!DDD!"\nExample 2:\nInput: target = "code"\nOutput: "RR!DDRR!UUL!R!"\n\n\xc2\xa0\nConstraints:\n\n1 <= target.length <= 100\ntarget consists only of English lowercase letters.
__label__0 Given an array of integers A, find the sum of min(B), where B ranges over\xc2\xa0every (contiguous) subarray of A.\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\xc2\xa0\nExample 1:\nInput: [3,1,2,4]\nOutput: 17\nExplanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\xc2\xa0 Sum is 17.\n\xc2\xa0\nNote:\n\n1 <= A.length <= 30000\n1 <= A[i] <= 30000
__label__0 In a list of songs, the i-th\xc2\xa0song has a duration of\xc2\xa0time[i] seconds.\xc2\xa0\nReturn the number of pairs of songs for which their total\xc2\xa0duration in seconds is divisible by 60.\xc2\xa0 Formally, we want the number of\xc2\xa0indices i < j with (time[i] + time[j]) % 60 == 0.\n\xc2\xa0\nExample 1:\nInput: [30,20,150,100,40]\nOutput: 3\nExplanation: Three pairs have a total duration divisible by 60:\n(time[0] = 30, time[2] = 150): total duration 180\n(time[1] = 20, time[3] = 100): total duration 120\n(time[1] = 20, time[4] = 40): total duration 60\n\n\nExample 2:\nInput: [60,60,60]\nOutput: 3\nExplanation: All three pairs have a total duration of 120, which is divisible by 60.\n\n\n\xc2\xa0\nNote:\n\n1 <= time.length <= 60000\n1 <= time[i] <= 500
__label__0 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\nExample:\nInput: "23"\nOutput: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.
__label__0 Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its depth = 3.
__label__0 To some string S, we will perform some\xc2\xa0replacement\xc2\xa0operations that replace groups of letters with new ones (not necessarily the same size).\nEach replacement operation has 3 parameters: a starting index i, a source word\xc2\xa0x\xc2\xa0and a target word\xc2\xa0y.\xc2\xa0 The rule is that if x\xc2\xa0starts at position i\xc2\xa0in the original string S, then we will replace that occurrence of\xc2\xa0x\xc2\xa0with\xc2\xa0y.\xc2\xa0 If not, we do nothing.\nFor example, if we have\xc2\xa0S = "abcd"\xc2\xa0and we have some replacement operation\xc2\xa0i = 2, x = "cd", y = "ffff", then because\xc2\xa0"cd"\xc2\xa0starts at position 2\xc2\xa0in the original string S, we will replace it with "ffff".\nUsing another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation\xc2\xa0i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string\xc2\xa0S[2] = \'c\', which doesn\'t match\xc2\xa0x[0] = \'e\'.\nAll these operations occur simultaneously.\xc2\xa0 It\'s guaranteed that there won\'t be any overlap in replacement: for example,\xc2\xa0S = "abc", indexes = [0, 1],\xc2\xa0sources = ["ab","bc"] is not a valid test case.\nExample 1:\nInput: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"]\nOutput: "eeebffff"\nExplanation: "a" starts at index 0 in S, so it\'s replaced by "eee".\n"cd" starts at index 2 in S, so it\'s replaced by "ffff".\n\nExample 2:\nInput: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"]\nOutput: "eeecd"\nExplanation: "ab" starts at index 0 in S, so it\'s replaced by "eee". \n"ec" doesn\'t starts at index 2 in the original S, so we do nothing.\n\nNotes:\n\n0 <=\xc2\xa0indexes.length =\xc2\xa0sources.length =\xc2\xa0targets.length <= 100\n0\xc2\xa0<\xc2\xa0indexes[i]\xc2\xa0< S.length <= 1000\nAll characters in given inputs are lowercase letters.
__label__0 Two strings X\xc2\xa0and Y\xc2\xa0are similar if we can swap two letters (in different positions) of X, so that\xc2\xa0it equals Y.\nFor example, "tars"\xc2\xa0and "rats"\xc2\xa0are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts".\nTogether, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.\xc2\xa0 Notice that "tars" and "arts" are in the same group even though they are not similar.\xc2\xa0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list A of strings.\xc2\xa0 Every string in A is an anagram of every other string in A.\xc2\xa0 How many groups are there?\nExample 1:\nInput: ["tars","rats","arts","star"]\nOutput: 2\nNote:\n\nA.length <= 2000\nA[i].length <= 1000\nA.length * A[i].length <= 20000\nAll words in A\xc2\xa0consist of lowercase letters only.\nAll words in A have the same length and are anagrams of each other.\nThe judging time limit has been increased for this question.
__label__0 Given a non-negative integer\xc2\xa0numRows, generate the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\nExample:\nInput: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]
__label__0 Students are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students not standing in the right positions.\xc2\xa0 (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)\n\xc2\xa0\nExample 1:\nInput: [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nStudents with heights 4, 3 and the last 1 are not standing in the right positions.\n\n\xc2\xa0\nNote:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100
__label__0 In a 2D grid of 0s and 1s, we change at most one 0 to a 1.\nAfter, what is the size of the largest island?\xc2\xa0(An island is a 4-directionally connected group of 1s).\nExample 1:\nInput: [[1, 0], [0, 1]]\nOutput: 3\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\nExample 2:\nInput: [[1, 1], [1, 0]]\nOutput: 4\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\nExample 3:\nInput: [[1, 1], [1, 1]]\nOutput: 4\nExplanation: Can't change any 0 to 1, only one island with area = 4.\n\xc2\xa0\nNotes:\n\n1 <= grid.length = grid[0].length <= 50.\n0 <= grid[i][j] <= 1.
__label__0 In an N by N square grid, each cell is either empty (0) or blocked (1).\nA\xc2\xa0clear\xc2\xa0path from top-left to bottom-right\xc2\xa0has length k if and only if it is composed of cells C_1, C_2, ..., C_k\xc2\xa0such that:\n\nAdjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and\xc2\xa0share an edge or corner)\nC_1 is at location (0, 0) (ie. has value grid[0][0])\nC_k\xc2\xa0is at location (N-1, N-1) (ie. has value grid[N-1][N-1])\nIf C_i is located at\xc2\xa0(r, c), then grid[r][c] is empty (ie.\xc2\xa0grid[r][c] ==\xc2\xa00).\n\nReturn the length of the shortest such clear path from top-left to bottom-right.\xc2\xa0 If such a path does not exist, return -1.\n\xc2\xa0\nExample 1:\nInput: [[0,1],[1,0]]\n\n\nOutput: 2\n\n\n\nExample 2:\nInput: [[0,0,0],[1,1,0],[1,1,0]]\n\n\nOutput: 4\n\n\n\xc2\xa0\n\nNote:\n\n1 <= grid.length == grid[0].length <= 100\ngrid[r][c] is 0 or 1
__label__0 Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\n\nExample 1:\nInput:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nOutput: [3, 14.5, 11]\nExplanation:\nThe average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].\n\n\nNote:\n\nThe range of node's value is in the range of 32-bit signed integer.
__label__0 Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.\n\nExample 1:\nInput: "sea", "eat"\nOutput: 2\nExplanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".\n\n\nNote:\n\nThe length of given words won\'t exceed 500.\nCharacters in given words can only be lower-case letters.
__label__0 Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\n\nExample 1:\nInput: a = 1, b = 2\nOutput: 3\n\n\nExample 2:\nInput: a = -2, b = 3\nOutput: 1
__label__0 Given an integer n, return 1 - n in lexicographical order.\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.
__label__0 Given the coordinates of four points in 2D space, return whether the four points could construct a square.\nThe coordinate (x,y) of a point is represented by an integer array with two integers.\nExample:\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\nOutput: True\n\n\xc2\xa0\nNote:\n\nAll the input integers are in the range [-10000, 10000].\nA valid square has four equal sides with positive length and four equal angles (90-degree angles).\nInput points have no order.
__label__0 Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\nExample 1:\nInput:\n3\n\nOutput:\n3\n\n\nExample 2:\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
__label__0 Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\nExample:\nGiven  a / b = 2.0, b / c = 3.0.\nqueries are:  a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .\nreturn  [6.0, 0.5, -1.0, 1.0, -1.0 ].\nThe input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.\nAccording to the example above:\nequations = [ ["a", "b"], ["b", "c"] ],\nvalues = [2.0, 3.0],\nqueries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. \n\xc2\xa0\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.
__label__0 Given a nested list of integers represented as a string, implement a parser to deserialize it.\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\nNote:\nYou may assume that the string is well-formed:\n\nString is non-empty.\nString does not contain white spaces.\nString contains only digits 0-9, [, - ,, ].\n\n\nExample 1:\nGiven s = "324",\n\nYou should return a NestedInteger object which contains a single integer 324.\n\n\nExample 2:\nGiven s = "[123,[456,[789]]]",\n\nReturn a NestedInteger object containing a nested list with 2 elements:\n\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789.
__label__0 Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.\nExample 1:\nInput:"-1/2+1/2"\nOutput: "0/1"\n\n\nExample 2:\nInput:"-1/2+1/2+1/3"\nOutput: "1/3"\n\n\nExample 3:\nInput:"1/3-1/2"\nOutput: "-1/6"\n\n\nExample 4:\nInput:"5/3+1/3"\nOutput: "2/1"\n\n\nNote:\n\nThe input string only contains \'0\' to \'9\', \'/\', \'+\' and \'-\'. So does the output.\nEach fraction (input and output) has format \xc2\xb1numerator/denominator. If the first input fraction or the output is positive, then \'+\' will be omitted.\nThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\nThe number of given fractions will be in the range [1,10].\nThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.
__label__0 Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. \nYou need to find the shortest such subarray and output its length.\nExample 1:\nInput: [2, 6, 4, 8, 10, 9, 15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n\n\nNote:\n\nThen length of the input array is in range [1, 10,000].\nThe input array may contain duplicates, so ascending order here means <=.
__label__0 We have a set of items: the i-th item has value values[i] and label labels[i].\nThen, we choose\xc2\xa0a subset S of these items, such that:\n\n|S| <= num_wanted\nFor every label L, the number of items in S with\xc2\xa0label L is <= use_limit.\n\nReturn the largest possible sum of the subset S.\n\xc2\xa0\n\nExample 1:\nInput: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1\nOutput: 9\nExplanation: The subset chosen is the first, third, and fifth item.\n\n\nExample 2:\nInput: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2\nOutput: 12\nExplanation: The subset chosen is the first, second, and third item.\n\n\nExample 3:\nInput: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1\nOutput:\xc2\xa016\nExplanation: The subset chosen is the first and fourth item.\n\n\nExample 4:\nInput: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2\nOutput: 24\nExplanation: The subset chosen is the first, second, and fourth item.\n\n\xc2\xa0\nNote:\n\n1 <= values.length == labels.length <= 20000\n0 <= values[i], labels[i]\xc2\xa0<= 20000\n1 <= num_wanted, use_limit\xc2\xa0<= values.length
__label__0 We have jobs: difficulty[i]\xc2\xa0is the difficulty of the\xc2\xa0ith job, and\xc2\xa0profit[i]\xc2\xa0is the profit of the\xc2\xa0ith job.\xc2\xa0\nNow we have some workers.\xc2\xa0worker[i]\xc2\xa0is the ability of the\xc2\xa0ith worker, which means that this worker can only complete a job with difficulty at most\xc2\xa0worker[i].\xc2\xa0\nEvery worker can be assigned at most one job, but one job\xc2\xa0can be completed multiple times.\nFor example, if 3 people attempt the same job that pays $1, then the total profit will be $3.\xc2\xa0 If a worker cannot complete any job, his profit is $0.\nWhat is the most profit we can make?\nExample 1:\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100 \nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.\nNotes:\n\n1 <= difficulty.length = profit.length <= 10000\n1 <= worker.length <= 10000\ndifficulty[i], profit[i], worker[i]\xc2\xa0 are in range\xc2\xa0[1, 10^5]
__label__0 Given a binary tree\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\xc2\xa0\nExample:\n\nInput: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":null,"next":null,"right":{"$id":"6","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}\n\nOutput: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":null,"right":null,"val":7},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"6","left":null,"next":null,"right":{"$ref":"5"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"6"},"val":1}\n\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.\n\n\xc2\xa0\nNote:\n\nYou may only use constant extra space.\nRecursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__0 Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]
__label__0 Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\xc2\xa0 For example, flipping\xc2\xa0[1, 1, 0]\xc2\xa0horizontally results in\xc2\xa0[0, 1, 1].\nTo invert an image means\xc2\xa0that each 0 is replaced by 1, and each 1 is replaced by 0.\xc2\xa0For example, inverting\xc2\xa0[0, 1, 1]\xc2\xa0results in\xc2\xa0[1, 0, 0].\nExample 1:\nInput: [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\nExample 2:\nInput: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\nNotes:\n\n1 <= A.length = A[0].length <= 20\n0 <= A[i][j]\xc2\xa0<=\xc2\xa01
__label__0 Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote:\nThe solution set must not contain duplicate quadruplets.\nExample:\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]
__label__0 A conveyor belt has packages that must be shipped from one port to another within D days.\nThe i-th package on the conveyor belt has a weight of weights[i].\xc2\xa0 Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\n\xc2\xa0\nExample 1:\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\nOutput: 15\nExplanation: \nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \n\nExample 2:\nInput: weights = [3,2,2,4,1,4], D = 3\nOutput: 6\nExplanation: \nA ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\nExample 3:\nInput: weights = [1,2,3,1,1], D = 4\nOutput: 3\nExplanation: \n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\xc2\xa0\nNote:\n\n1 <= D <= weights.length <= 50000\n1 <= weights[i] <= 500
__label__0 Let\'s say a positive integer is a\xc2\xa0superpalindrome\xc2\xa0if it is a palindrome, and it is also the square of a palindrome.\nNow, given two positive\xc2\xa0integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].\n\xc2\xa0\nExample 1:\nInput: L = "4", R = "1000"\nOutput: 4\nExplanation: 4, 9, 121, and 484 are superpalindromes.\nNote that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.\n\xc2\xa0\nNote:\n\n1 <= len(L) <= 18\n1 <= len(R) <= 18\nL and R are strings representing integers in the range [1, 10^18).\nint(L) <= int(R)
__label__0 Consider all the leaves of a binary tree.\xc2\xa0 From\xc2\xa0left to right order, the values of those\xc2\xa0leaves form a leaf value sequence.\n\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar\xc2\xa0if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\n\xc2\xa0\nNote:\n\nBoth of the given trees will have between 1 and 100 nodes.
__label__0 A positive integer\xc2\xa0is magical\xc2\xa0if it is divisible by either A\xc2\xa0or B.\nReturn the N-th magical number.\xc2\xa0 Since the answer may be very large, return it modulo 10^9 + 7.\n\xc2\xa0\n\n\n\nExample 1:\nInput: N = 1, A = 2, B = 3\nOutput: 2\n\n\nExample 2:\nInput: N = 4, A = 2, B = 3\nOutput: 6\n\n\nExample 3:\nInput: N = 5, A = 2, B = 4\nOutput: 10\n\n\nExample 4:\nInput: N = 3, A = 6, B = 4\nOutput: 8\n\n\xc2\xa0\nNote:\n\n1 <= N\xc2\xa0<= 10^9\n2 <= A\xc2\xa0<= 40000\n2 <= B\xc2\xa0<= 40000
__label__0 Given a string s, return the last substring of s in lexicographical order.\n\xc2\xa0\nExample 1:\nInput: "abab"\nOutput: "bab"\nExplanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".\n\nExample 2:\nInput: "leetcode"\nOutput: "tcode"\n\n\xc2\xa0\nNote:\n\n1 <= s.length <= 4\xc2\xa0* 10^5\ns contains only lowercase English letters.
__label__0 Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\nExample:\nAssume that the iterator is initialized to the beginning of the list: [1,2,3].\n\nCall next() gets you 1, the first element in the list.\nNow you call peek() and it returns 2, the next element. Calling next() after that still return 2. \nYou call next() the final time and it returns 3, the last element. \nCalling hasNext() after that should return false.\n\nFollow up: How would you extend your design to be generic and work with all types, not just integer?
__label__0 Additive number is a string whose digits can form additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits \'0\'-\'9\', write a function to determine if it\'s an additive number.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\xc2\xa0\nExample 1:\nInput: "112358"\nOutput: true\nExplanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n\xc2\xa0            1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\nExample 2:\nInput: "199100199"\nOutput: true\nExplanation: The additive sequence is: 1, 99, 100, 199.\xc2\xa0\n\xc2\xa0            1 + 99 = 100, 99 + 100 = 199\n\n\xc2\xa0\nConstraints:\n\nnum\xc2\xa0consists only of digits \'0\'-\'9\'.\n1 <= num.length <= 35\n\nFollow up:\nHow would you handle overflow for very large input integers?
__label__0 Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:\n\nThe root is the maximum number in the array. \nThe left subtree is the maximum tree constructed from left part subarray divided by the maximum number.\nThe right subtree is the maximum tree constructed from right part subarray divided by the maximum number.\n\n\n\nConstruct the maximum tree by the given array and output the root node of this tree.\n\nExample 1:\nInput: [3,2,1,6,0,5]\nOutput: return the tree root node representing the following tree:\n\n      6\n    /   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n\n\nNote:\n\nThe size of the given array will be in the range [1,1000].
__label__0 Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i \xe2\x89\xa4 j), inclusive.\nNote:\nA naive algorithm of O(n2) is trivial. You MUST do better than that.\nExample:\nInput: nums = [-2,5,-1], lower = -2, upper = 2,\nOutput: 3 \nExplanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.
__label__0 Given an array nums\xc2\xa0sorted in ascending order, return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers\xc2\xa0and has length at least 3.\n\xc2\xa0\nExample 1:\nInput: [1,2,3,3,4,5]\nOutput: True\nExplanation:\nYou can split them into two consecutive subsequences : \n1, 2, 3\n3, 4, 5\n\n\nExample 2:\nInput: [1,2,3,3,4,4,5,5]\nOutput: True\nExplanation:\nYou can split them into two consecutive subsequences : \n1, 2, 3, 4, 5\n3, 4, 5\n\n\nExample 3:\nInput: [1,2,3,4,4,5]\nOutput: False\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 10000
__label__0 Design your implementation of the circular double-ended queue (deque).\nYour implementation should support following operations:\n\nMyCircularDeque(k): Constructor, set the size of the deque to be k.\ninsertFront(): Adds an item at the front of Deque. Return true if the operation is successful.\ninsertLast(): Adds an item at the rear of Deque. Return true if the operation is successful.\ndeleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful.\ndeleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful.\ngetFront(): Gets the front item from the Deque. If the deque is empty, return -1.\ngetRear(): Gets the last item from Deque. If the deque is empty, return -1.\nisEmpty(): Checks whether Deque is empty or not.\xc2\xa0\nisFull(): Checks whether Deque is full or not.\n\n\xc2\xa0\nExample:\nMyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3\ncircularDeque.insertLast(1);\t\t\t// return true\ncircularDeque.insertLast(2);\t\t\t// return true\ncircularDeque.insertFront(3);\t\t\t// return true\ncircularDeque.insertFront(4);\t\t\t// return false, the queue is full\ncircularDeque.getRear();  \t\t\t// return 2\ncircularDeque.isFull();\t\t\t\t// return true\ncircularDeque.deleteLast();\t\t\t// return true\ncircularDeque.insertFront(4);\t\t\t// return true\ncircularDeque.getFront();\t\t\t// return 4\n\n\xc2\xa0\nNote:\n\nAll values will be in the range of [0, 1000].\nThe number of operations will be in the range of\xc2\xa0[1, 1000].\nPlease do not use the built-in Deque library.
__label__0 Implementing the class MajorityChecker, which has the following API:\n\nMajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr;\nint query(int left, int right, int threshold)\xc2\xa0has arguments\xc2\xa0such that:\n\t\n0 <= left\xc2\xa0<= right\xc2\xa0< arr.length representing a subarray of arr;\n2 * threshold > right - left + 1, ie. the threshold is always a strict majority of the length of\xc2\xa0the subarray\n\n\n\nEach\xc2\xa0query(...) returns the element in arr[left], arr[left+1], ..., arr[right] that occurs at least threshold times, or -1 if no such element exists.\n\xc2\xa0\nExample:\nMajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);\nmajorityChecker.query(0,5,4); // returns 1\nmajorityChecker.query(0,3,3); // returns -1\nmajorityChecker.query(2,3,2); // returns 2\n\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <=\xc2\xa020000\n1 <= arr[i]\xc2\xa0<=\xc2\xa020000\nFor each query, 0 <= left <= right < len(arr)\nFor each query, 2 * threshold > right - left + 1\nThe number of queries is at most 10000
__label__0 Two players play a turn based game on a binary tree.\xc2\xa0 We are given\xc2\xa0the root of this binary tree, and the number of nodes n\xc2\xa0in the tree.\xc2\xa0 n is odd, and\xc2\xa0each node has a distinct value from 1 to n.\nInitially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x.\xc2\xa0 The first player colors the node with value x red, and the second player colors the node with value y blue.\nThen, the players take turns starting with the first player.\xc2\xa0 In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\nIf (and only if)\xc2\xa0a player cannot choose such a node in this way, they must pass their turn.\xc2\xa0 If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\nYou are the second player.\xc2\xa0 If it is possible to choose such a y\xc2\xa0to ensure you win the game, return true.\xc2\xa0 If it is not possible, return false.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\nOutput: true\nExplanation: The second player can choose the node with value 2.\n\n\xc2\xa0\nConstraints:\n\nroot is the root of a binary tree with n nodes and distinct node values from 1 to n.\nn is odd.\n1 <= x <= n\xc2\xa0<= 100
__label__0 An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array A is monotone increasing if for all i <= j, A[i] <= A[j].\xc2\xa0 An array A is monotone decreasing if for all i <= j, A[i] >= A[j].\nReturn true if and only if the given array A is monotonic.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [1,2,2,3]\nOutput: true\n\n\nExample 2:\nInput: [6,5,4,4]\nOutput: true\n\n\nExample 3:\nInput: [1,3,2]\nOutput: false\n\n\nExample 4:\nInput: [1,2,4,5]\nOutput: true\n\n\nExample 5:\nInput: [1,1,1]\nOutput: true\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 50000\n-100000 <= A[i] <= 100000
__label__0 Starting with an\xc2\xa0undirected graph (the "original graph") with nodes from 0 to N-1, subdivisions are made to some of the edges.\nThe graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph,\nand n is the total number of new nodes on that edge.\xc2\xa0\nThen, the edge (i, j) is deleted from the original graph,\xc2\xa0n\xc2\xa0new nodes (x_1, x_2, ..., x_n) are added to the original graph,\nand n+1 new\xc2\xa0edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)\xc2\xa0are added to the original\xc2\xa0graph.\nNow, you start at node 0\xc2\xa0from the original graph, and in each move, you travel along one\xc2\xa0edge.\xc2\xa0\nReturn how many nodes you can reach in at most M moves.\n\xc2\xa0\nExample 1:\nInput: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3\nOutput: 13\nExplanation: \nThe nodes that are reachable in the final graph after M = 6 moves are indicated below.\n\n\n\nExample 2:\nInput: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4\nOutput: 23\n\xc2\xa0\n\nNote:\n\n0 <= edges.length <= 10000\n0 <= edges[i][0] <\xc2\xa0edges[i][1] < N\nThere does not exist any\xc2\xa0i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1].\nThe original graph\xc2\xa0has no parallel edges.\n0 <= edges[i][2] <= 10000\n0 <= M <= 10^9\n1 <= N <= 3000\nA reachable node is a node that can be travelled to\xc2\xa0using at most\xc2\xa0M moves starting from\xc2\xa0node 0.
__label__0 Given a positive\xc2\xa0integer N, find and return the longest distance between two consecutive 1's in the binary representation of N.\nIf there aren't two consecutive 1's, return 0.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\nExample 1:\nInput: 22\nOutput: 2\nExplanation: \n22 in binary is 0b10110.\nIn the binary representation of 22, there are three ones, and two consecutive pairs of 1's.\nThe first consecutive pair of 1's have distance 2.\nThe second consecutive pair of 1's have distance 1.\nThe answer is the largest of these two distances, which is 2.\n\n\nExample 2:\nInput: 5\nOutput: 2\nExplanation: \n5 in binary is 0b101.\n\n\nExample 3:\nInput: 6\nOutput: 1\nExplanation: \n6 in binary is 0b110.\n\n\nExample 4:\nInput: 8\nOutput: 0\nExplanation: \n8 in binary is 0b1000.\nThere aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.\n\n\xc2\xa0\n\n\n\nNote:\n\n1 <= N <= 10^9
__label__0 Given a positive integer K, you need find the smallest\xc2\xa0positive integer N such that N is divisible by K, and N only contains the digit 1.\nReturn the\xc2\xa0length of N.\xc2\xa0 If there is no such N,\xc2\xa0return -1.\n\xc2\xa0\nExample 1:\nInput: 1\nOutput: 1\nExplanation: The smallest answer is N = 1, which has length 1.\nExample 2:\nInput: 2\nOutput: -1\nExplanation: There is no such positive integer N divisible by 2.\nExample 3:\nInput: 3\nOutput: 3\nExplanation: The smallest answer is N = 111, which has length 3.\n\xc2\xa0\nNote:\n\n1 <= K <= 10^5
__label__0 Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string "".\nExample 1:\nInput: ["flower","flow","flight"]\nOutput: "fl"\n\nExample 2:\nInput: ["dog","racecar","car"]\nOutput: ""\nExplanation: There is no common prefix among the input strings.\n\nNote:\nAll given inputs are in lowercase letters a-z.
__label__0 A valid parentheses string is either empty (""), "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\xc2\xa0 For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\n\xc2\xa0\nExample 1:\nInput: "(()())(())"\nOutput: "()()()"\nExplanation: \nThe input string is "(()())(())", with primitive decomposition "(()())" + "(())".\nAfter removing outer parentheses of each part, this is "()()" + "()" = "()()()".\n\n\nExample 2:\nInput: "(()())(())(()(()))"\nOutput: "()()()()(())"\nExplanation: \nThe input string is "(()())(())(()(()))", with primitive decomposition "(()())" + "(())" + "(()(()))".\nAfter removing outer parentheses of each part, this is "()()" + "()" + "()(())" = "()()()()(())".\n\n\nExample 3:\nInput: "()()"\nOutput: ""\nExplanation: \nThe input string is "()()", with primitive decomposition "()" + "()".\nAfter removing outer parentheses of each part, this is "" + "" = "".\n\n\xc2\xa0\n\n\nNote:\n\nS.length <= 10000\nS[i] is "(" or ")"\nS is a valid parentheses string
__label__0 In a warehouse, there is a row of barcodes, where the i-th barcode is\xc2\xa0barcodes[i].\nRearrange the barcodes so that no two adjacent barcodes are equal.\xc2\xa0 You may return any answer, and it is guaranteed an answer exists.\n\xc2\xa0\nExample 1:\nInput: [1,1,1,2,2,2]\nOutput: [2,1,2,1,2,1]\n\n\nExample 2:\nInput: [1,1,1,1,2,2,3,3]\nOutput: [1,3,1,3,2,1,2,1]\n\n\xc2\xa0\nNote:\n\n1 <= barcodes.length <= 10000\n1 <= barcodes[i] <= 10000
__label__0 You have a set of tiles, where each tile has one letter tiles[i] printed on it.\xc2\xa0 Return the number of possible non-empty sequences of letters you can make.\n\xc2\xa0\nExample 1:\nInput: "AAB"\nOutput: 8\nExplanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".\n\n\nExample 2:\nInput: "AAABBC"\nOutput: 188\n\n\xc2\xa0\n\nNote:\n\n1 <= tiles.length <= 7\ntiles consists of uppercase English letters.
__label__0 We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".\xc2\xa0 Then, we removed\xc2\xa0all commas, decimal points, and spaces, and ended up with the string\xc2\xa0S.\xc2\xa0 Return a list of strings representing\xc2\xa0all possibilities for what our original coordinates could have been.\nOur original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with\xc2\xa0less digits.\xc2\xa0 Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1".\nThe final answer list can be returned in any order.\xc2\xa0 Also note that all coordinates in the final answer\xc2\xa0have exactly one space between them (occurring after the comma.)\nExample 1:\nInput: "(123)"\nOutput: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]\n\nExample 2:\nInput: "(00011)"\nOutput: \xc2\xa0["(0.001, 1)", "(0, 0.011)"]\nExplanation: \n0.0, 00, 0001 or 00.01 are not allowed.\n\nExample 3:\nInput: "(0123)"\nOutput: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]\n\nExample 4:\nInput: "(100)"\nOutput: [(10, 0)]\nExplanation: \n1.0 is not allowed.\n\n\xc2\xa0\nNote: \n\n4 <= S.length <= 12.\nS[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.
__label__0 A character is unique in string S if it occurs exactly once in it.\nFor example, in string S = "LETTER", the only unique characters are "L" and "R".\nLet\'s define UNIQ(S) as the number of unique characters in string S.\nFor example, UNIQ("LETTER") =\xc2\xa0 2.\nGiven a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.\nIf there are two or more equal substrings at different positions in S, we consider them different.\nSince the answer can be very large, return\xc2\xa0the answer\xc2\xa0modulo\xc2\xa010 ^ 9 + 7.\n\xc2\xa0\nExample 1:\nInput: "ABC"\nOutput: 10\nExplanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".\nEvey substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\nExample 2:\nInput: "ABA"\nOutput: 8\nExplanation: The same as example 1, except uni("ABA") = 1.\n\n\xc2\xa0\nNote: 0 <= S.length <= 10000.
__label__0 Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n\nreturn its bottom-up level order traversal as:\n[\n  [15,7],\n  [9,20],\n  [3]\n]
__label__0 Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nGiven the below binary tree and sum = 22,\n      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\    / \\\n7    2  5   1\n\nReturn:\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]
__label__0 Given a string S\xc2\xa0of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence\xc2\xa0[123, 456, 579].\nFormally, a Fibonacci-like sequence is a list\xc2\xa0F of non-negative integers such that:\n\n0 <= F[i] <= 2^31 - 1, (that is,\xc2\xa0each integer fits a 32-bit signed integer type);\nF.length >= 3;\nand F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.\n\nAlso, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\nReturn any Fibonacci-like sequence split from S, or return [] if it cannot be done.\nExample 1:\nInput: "123456579"\nOutput: [123,456,579]\n\nExample 2:\nInput: "11235813"\nOutput: [1,1,2,3,5,8,13]\n\nExample 3:\nInput: "112358130"\nOutput: []\nExplanation: The task is impossible.\n\nExample 4:\nInput: "0123"\nOutput: []\nExplanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.\n\nExample 5:\nInput: "1101111"\nOutput: [110, 1, 111]\nExplanation: The output [11, 0, 11, 11] would also be accepted.\n\nNote: \n\n1 <= S.length\xc2\xa0<= 200\nS contains only digits.
__label__0 Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. \nThe adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.\nExample 1:\nInput: \nA binary tree as following:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\nv = 1\n\nd = 2\n\nOutput: \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5   \n\n\n\nExample 2:\nInput: \nA binary tree as following:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\nv = 1\n\nd = 3\n\nOutput: \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n\n\nNote:\n\nThe given d is in range [1, maximum depth of the given tree + 1].\nThe given binary tree has at least one tree node.
__label__0 We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I'll tell you whether the number is higher or lower.\nYou call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\n-1 : My number is lower\n 1 : My number is higher\n 0 : Congrats! You got it!\n\nExample :\n\nInput: n = 10, pick = 6\nOutput: 6
__label__0 Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\'s permutations is the substring of the second string.\n\xc2\xa0\nExample 1:\nInput: s1 = "ab" s2 = "eidbaooo"\nOutput: True\nExplanation: s2 contains one permutation of s1 ("ba").\n\nExample 2:\nInput:s1= "ab" s2 = "eidboaoo"\nOutput: False\n\n\xc2\xa0\nNote:\n\nThe input strings only contain lower case letters.\nThe length of both given strings is in range [1, 10,000].
__label__0 SQL SchemaThere is a table courses with columns: student and class\nPlease list out all classes which have more than or equal to 5 students.\nFor example, the table:\n+---------+------------+\n| student | class      |\n+---------+------------+\n| A       | Math       |\n| B       | English    |\n| C       | Math       |\n| D       | Biology    |\n| E       | Math       |\n| F       | Computer   |\n| G       | Math       |\n| H       | Math       |\n| I       | Math       |\n+---------+------------+\n\nShould output:\n+---------+\n| class   |\n+---------+\n| Math    |\n+---------+\n\n\xc2\xa0\nNote:\nThe students should not be counted duplicate in each course.
__label__0 Design a data structure that supports all following operations in average O(1) time.\nNote: Duplicate elements are allowed.\n\n\ninsert(val): Inserts an item val to the collection.\nremove(val): Removes an item val from the collection if present.\ngetRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\n\n\nExample:\n// Init an empty collection.\nRandomizedCollection collection = new RandomizedCollection();\n\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\ncollection.insert(1);\n\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\ncollection.insert(1);\n\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\ncollection.insert(2);\n\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\ncollection.getRandom();\n\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\ncollection.remove(1);\n\n// getRandom should return 1 and 2 both equally likely.\ncollection.getRandom();
__label__0 Given an m * n matrix M initialized with all 0's and several update operations.\nOperations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b. \nYou need to count and return the number of maximum integers in the matrix after performing all the operations.\nExample 1:\nInput: \nm = 3, n = 3\noperations = [[2,2],[3,3]]\nOutput: 4\nExplanation: \nInitially, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n\nAfter performing [2,2], M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n\nAfter performing [3,3], M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\n\nSo the maximum integer in M is 2, and there are four of it in M. So return 4.\n\n\nNote:\n\nThe range of m and n is [1,40000].\nThe range of a is [1,m], and the range of b is [1,n].\nThe range of operations size won't exceed 10,000.
__label__0 Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\nFollow up:\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n\nExample:\n// Init a singly linked list [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\nsolution.getRandom();
__label__0 Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.\n\nExample 1:\n\nGiven tree s:\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n\nGiven tree t:\n   4 \n  / \\\n 1   2\n\nReturn true, because t has the same structure and node values with a subtree of s.\n\nExample 2:\n\nGiven tree s:\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n    /\n   0\n\nGiven tree t:\n   4\n  / \\\n 1   2\n\nReturn false.
__label__0 Write a program that outputs the string representation of numbers from 1 to n.\nBut for multiples of three it should output \xe2\x80\x9cFizz\xe2\x80\x9d instead of the number and for the multiples of five output \xe2\x80\x9cBuzz\xe2\x80\x9d. For numbers which are multiples of both three and five output \xe2\x80\x9cFizzBuzz\xe2\x80\x9d.\nExample:\nn = 15,\n\nReturn:\n[\n    "1",\n    "2",\n    "Fizz",\n    "4",\n    "Buzz",\n    "Fizz",\n    "7",\n    "8",\n    "Fizz",\n    "Buzz",\n    "11",\n    "Fizz",\n    "13",\n    "14",\n    "FizzBuzz"\n]
__label__0 Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".\nOne of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.\nYour implementation should support following operations:\n\nMyCircularQueue(k): Constructor, set the size of the queue to be k.\nFront: Get the front item from the queue. If the queue is empty, return -1.\nRear: Get the last item from the queue. If the queue is empty, return -1.\nenQueue(value): Insert an element into the circular queue. Return true if the operation is successful.\ndeQueue(): Delete an element from the circular queue. Return true if the operation is successful.\nisEmpty(): Checks whether the circular queue is empty or not.\nisFull(): Checks whether the circular queue is full or not.\n\n\xc2\xa0\nExample:\nMyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3\ncircularQueue.enQueue(1); \xc2\xa0// return true\ncircularQueue.enQueue(2); \xc2\xa0// return true\ncircularQueue.enQueue(3); \xc2\xa0// return true\ncircularQueue.enQueue(4); \xc2\xa0// return false, the queue is full\ncircularQueue.Rear(); \xc2\xa0// return 3\ncircularQueue.isFull(); \xc2\xa0// return true\ncircularQueue.deQueue(); \xc2\xa0// return true\ncircularQueue.enQueue(4); \xc2\xa0// return true\ncircularQueue.Rear(); \xc2\xa0// return 4\n\n\xc2\xa0\n\nNote:\n\nAll values will be in the range of [0, 1000].\nThe number of operations will be in the range of\xc2\xa0[1, 1000].\nPlease do not use the built-in Queue library.
__label__0 Given a binary tree, flatten it to a linked list in-place.\nFor example, given the following tree:\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n\nThe flattened tree should look like:\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6
__label__0 This problem is an\xc2\xa0interactive problem\xc2\xa0new to the LeetCode platform.\nWe are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.\nYou may call master.guess(word)\xc2\xa0to guess a word.\xc2\xa0 The guessed word should have\xc2\xa0type string\xc2\xa0and must be from the original list\xc2\xa0with 6 lowercase letters.\nThis function returns an\xc2\xa0integer\xc2\xa0type, representing\xc2\xa0the number of exact matches (value and position) of your guess to the secret word.\xc2\xa0 Also, if your guess is not in the given wordlist, it will return -1 instead.\nFor each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess\xc2\xa0and at least one of these guesses was the secret, you pass the testcase.\nBesides the example test case below, there will be 5\xc2\xa0additional test cases, each with 100 words in the word list.\xc2\xa0 The letters of each word in those testcases were chosen\xc2\xa0independently at random from \'a\' to \'z\', such that every word in the given word lists is unique.\nExample 1:\nInput:\xc2\xa0secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]\n\nExplanation:\n\nmaster.guess("aaaaaa") returns -1, because\xc2\xa0"aaaaaa"\xc2\xa0is not in wordlist.\nmaster.guess("acckzz") returns 6, because\xc2\xa0"acckzz" is secret and has all 6\xc2\xa0matches.\nmaster.guess("ccbazz") returns 3, because\xc2\xa0"ccbazz"\xc2\xa0has 3 matches.\nmaster.guess("eiowzz") returns 2, because\xc2\xa0"eiowzz"\xc2\xa0has 2\xc2\xa0matches.\nmaster.guess("abcczz") returns 4, because\xc2\xa0"abcczz" has 4 matches.\n\nWe made 5 calls to\xc2\xa0master.guess and one of them was the secret, so we pass the test case.\n\nNote:\xc2\xa0 Any solutions that attempt to circumvent the judge\xc2\xa0will result in disqualification.
__label__0 Given a positive integer\xc2\xa0N, how many ways can we write it as a sum of\xc2\xa0consecutive positive integers?\nExample 1:\nInput: 5\nOutput: 2\nExplanation: 5 = 5 = 2 + 3\nExample 2:\nInput: 9\nOutput: 3\nExplanation: 9 = 9 = 4 + 5 = 2 + 3 + 4\nExample 3:\nInput: 15\nOutput: 4\nExplanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\nNote:\xc2\xa01 <= N <= 10 ^ 9.
__label__0 Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\nGiven the sorted array: [-10,-3,0,5,9],\n\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5
__label__0 We are given\xc2\xa0head,\xc2\xa0the head node of a linked list containing\xc2\xa0unique integer values.\nWe are also given the list\xc2\xa0G, a subset of the values in the linked list.\nReturn the number of connected components in G, where two values are connected if they appear consecutively in the linked list.\nExample 1:\nInput: \nhead: 0->1->2->3\nG = [0, 1, 3]\nOutput: 2\nExplanation: \n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\nExample 2:\nInput: \nhead: 0->1->2->3->4\nG = [0, 3, 1, 4]\nOutput: 2\nExplanation: \n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\nNote: \n\nIf\xc2\xa0N\xc2\xa0is the\xc2\xa0length of the linked list given by\xc2\xa0head,\xc2\xa01 <= N <= 10000.\nThe value of each node in the linked list will be in the range [0, N - 1].\n1 <= G.length <= 10000.\nG is a subset of all values in the linked list.
__label__0 Given the root\xc2\xa0of a binary tree, consider all root to leaf paths: paths from the root\xc2\xa0to any leaf.\xc2\xa0 (A leaf is a node with no children.)\nA node is insufficient if\xc2\xa0every such root to leaf path intersecting this node has sum strictly less than\xc2\xa0limit.\nDelete all insufficient nodes simultaneously, and return the root of the resulting\xc2\xa0binary tree.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n\nOutput: [1,2,3,4,null,null,7,8,9,null,14]\n\n\nExample 2:\n\nInput: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n\nOutput: [5,4,8,11,null,17,4,7,null,null,null,5]\n\xc2\xa0\nExample 3:\n\nInput: root = [1,2,-3,-5,null,4,null], limit = -1\n\nOutput: [1,null,-3,4]\n\n\xc2\xa0\nNote:\n\nThe given tree will have between 1 and 5000 nodes.\n-10^5\xc2\xa0<= node.val <= 10^5\n-10^9 <= limit\xc2\xa0<= 10^9
__label__0 For strings S and T, we say "T divides S" if and only if S = T + ... + T\xc2\xa0 (T concatenated with itself 1 or more times)\nReturn the largest string X such that X divides str1\xc2\xa0and X divides str2.\n\xc2\xa0\nExample 1:\nInput: str1 = "ABCABC", str2 = "ABC"\nOutput: "ABC"\n\nExample 2:\nInput: str1 = "ABABAB", str2 = "ABAB"\nOutput: "AB"\n\nExample 3:\nInput: str1 = "LEET", str2 = "CODE"\nOutput: ""\n\n\xc2\xa0\nNote:\n\n1 <= str1.length <= 1000\n1 <= str2.length <= 1000\nstr1[i] and str2[i] are English uppercase letters.
__label__0 Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)\nA move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.\nReturn the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.\n\xc2\xa0\nExample 1:\nInput: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 3\nExplanation: \nThere are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary.\nExample 2:\nInput: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\nOutput: 0\nExplanation: \nAll 1s are either on the boundary or can reach the boundary.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 500\n1 <= A[i].length <= 500\n0 <= A[i][j] <= 1\nAll rows have the same size.
__label__0 Roman numerals are represented by seven different symbols:\xc2\xa0I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\xc2\xa0two is written as II\xc2\xa0in Roman numeral, just two one\'s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\xc2\xa0\nX can be placed before L (50) and C (100) to make 40 and 90.\xc2\xa0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\nInput:\xc2\xa0"III"\nOutput: 3\nExample 2:\nInput:\xc2\xa0"IV"\nOutput: 4\nExample 3:\nInput:\xc2\xa0"IX"\nOutput: 9\nExample 4:\nInput:\xc2\xa0"LVIII"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 5:\nInput:\xc2\xa0"MCMXCIV"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__0 Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two\xc2\xa0sightseeing spots i and j\xc2\xa0have distance j - i\xc2\xa0between them.\nThe score\xc2\xa0of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i\xc2\xa0- j) : the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\n\xc2\xa0\nExample 1:\nInput: [8,1,5,2,6]\nOutput: 11\nExplanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n\xc2\xa0\nNote:\n\n2 <= A.length <= 50000\n1 <= A[i] <= 1000
__label__0 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.\nReturn true\xc2\xa0if and only if we can do this in a way such that the resulting number is a power of 2.\n\xc2\xa0\n\n\n\nExample 1:\nInput: 1\nOutput: true\n\n\nExample 2:\nInput: 10\nOutput: false\n\n\nExample 3:\nInput: 16\nOutput: true\n\n\nExample 4:\nInput: 24\nOutput: false\n\n\nExample 5:\nInput: 46\nOutput: true\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10^9
__label__0 On a\xc2\xa0N\xc2\xa0*\xc2\xa0N grid, we place some\xc2\xa01 * 1 * 1\xc2\xa0cubes that are axis-aligned with the x, y, and z axes.\nEach value\xc2\xa0v = grid[i][j]\xc2\xa0represents a tower of\xc2\xa0v\xc2\xa0cubes placed on top of grid cell (i, j).\nNow we view the\xc2\xa0projection\xc2\xa0of these cubes\xc2\xa0onto the xy, yz, and zx planes.\nA projection is like a shadow, that\xc2\xa0maps our 3 dimensional figure to a 2 dimensional plane.\xc2\xa0\nHere, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side.\nReturn the total area of all three projections.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1:\nInput: [[2]]\nOutput: 5\n\n\nExample 2:\nInput: [[1,2],[3,4]]\nOutput: 17\nExplanation: \nHere are the three projections ("shadows") of the shape made with each axis-aligned plane.\n\n\n\nExample 3:\nInput: [[1,0],[0,2]]\nOutput: 8\n\n\nExample 4:\nInput: [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 14\n\n\nExample 5:\nInput: [[2,2,2],[2,1,2],[2,2,2]]\nOutput: 21\n\n\xc2\xa0\n\n\n\nNote:\n\n1 <= grid.length = grid[0].length\xc2\xa0<= 50\n0 <= grid[i][j] <= 50
__label__0 Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.\nExample 1:\nInput: [5,3,6,2,4,null,8,1,null,null,null,7,9]\n\n       5\n      / \\\n    3    6\n   / \\    \\\n  2   4    8\n\xc2\xa0/        / \\ \n1        7   9\n\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n 1\n\xc2\xa0 \\\n\xc2\xa0  2\n\xc2\xa0   \\\n\xc2\xa0    3\n\xc2\xa0     \\\n\xc2\xa0      4\n\xc2\xa0       \\\n\xc2\xa0        5\n\xc2\xa0         \\\n\xc2\xa0          6\n\xc2\xa0           \\\n\xc2\xa0            7\n\xc2\xa0             \\\n\xc2\xa0              8\n\xc2\xa0               \\\n                 9  \nNote:\n\nThe number of nodes in the given tree will be between 1 and 100.\nEach node will have a unique integer value from 0 to 1000.
__label__0 Given an array nums of integers, a move\xc2\xa0consists of choosing any element and decreasing it by 1.\nAn array A is a\xc2\xa0zigzag array\xc2\xa0if either:\n\nEvery even-indexed element is greater than adjacent elements, ie.\xc2\xa0A[0] > A[1] < A[2] > A[3] < A[4] > ...\nOR, every odd-indexed element is greater than adjacent elements, ie.\xc2\xa0A[0] < A[1] > A[2] < A[3] > A[4] < ...\n\nReturn the minimum number of moves to transform the given array nums into a zigzag array.\n\xc2\xa0\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation: We can decrease 2 to 0 or 3 to 1.\n\nExample 2:\nInput: nums = [9,6,1,6,2]\nOutput: 4\n\n\xc2\xa0\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000
__label__0 Given a string text, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters.\n\xc2\xa0\nExample 1:\nInput: text = "ababa"\nOutput: 3\nExplanation: We can swap the first \'b\' with the last \'a\', or the last \'b\' with the first \'a\'. Then, the longest repeated character substring is "aaa", which its length is 3.\n\nExample 2:\nInput: text = "aaabaaa"\nOutput: 6\nExplanation: Swap \'b\' with the last \'a\' (or the first \'a\'), and we get longest repeated character substring "aaaaaa", which its length is 6.\n\nExample 3:\nInput: text = "aaabbaaa"\nOutput: 4\n\nExample 4:\nInput: text = "aaaaa"\nOutput: 5\nExplanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.\n\nExample 5:\nInput: text = "abcdef"\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= text.length <= 20000\ntext consist of lowercase English characters only.
__label__0 Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.\nExample 1:\nInput: [1,12,-5,-6,50,3], k = 4\nOutput: 12.75\nExplanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75\n\n\xc2\xa0\nNote:\n\n1 <= k <= n <= 30,000.\nElements of the given array will be in the range [-10,000, 10,000].
__label__0 Write a program to find the nth super ugly number.\nSuper ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.\nExample:\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32 \nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 \n             super ugly numbers given primes = [2,7,13,19] of size 4.\nNote:\n\n1 is a super ugly number for any given primes.\nThe given numbers in primes are in ascending order.\n0 < k \xe2\x89\xa4 100, 0 < n \xe2\x89\xa4 106, 0 < primes[i] < 1000.\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.
__label__0 Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.\nExample 1:\nInput:\n[[1,1,1],\n [1,0,1],\n [1,1,1]]\nOutput:\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\nExplanation:\nFor the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n\nNote:\n\nThe value in the given matrix is in the range of [0, 255].\nThe length and width of the given matrix are in the range of [1, 150].
__label__0 You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\nOperations allowed:\n\nFill any of the jugs completely with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\n\nExample 1: (From the famous "Die Hard" example)\nInput: x = 3, y = 5, z = 4\nOutput: True\n\nExample 2:\nInput: x = 2, y = 6, z = 5\nOutput: False
__label__0 You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:\n\n0 represents the obstacle can't be reached.\n1 represents the ground can be walked through.\nThe place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.\n\n\xc2\xa0\nYou are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).\nYou will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.\nYou are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.\nExample 1:\nInput: \n[\n [1,2,3],\n [0,0,4],\n [7,6,5]\n]\nOutput: 6\n\n\xc2\xa0\nExample 2:\nInput: \n[\n [1,2,3],\n [0,0,0],\n [7,6,5]\n]\nOutput: -1\n\n\xc2\xa0\nExample 3:\nInput: \n[\n [2,3,4],\n [0,0,5],\n [8,7,6]\n]\nOutput: 6\nExplanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\n\n\xc2\xa0\nHint: size of the given matrix will not exceed 50x50.
__label__0 Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nExample 1:\nInput: "bcabc"\nOutput: "abc"\n\nExample 2:\nInput: "cbacdcbc"\nOutput: "acdb"
__label__0 Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only \'+\', \'-\' operation, the variable x and its coefficient.\n\n\nIf there is no solution for the equation, return "No solution".\n\n\nIf there are infinite solutions for the equation, return "Infinite solutions".\n\n\nIf there is exactly one solution for the equation, we ensure that the value of x is an integer.\n\nExample 1:\nInput: "x+5-3+x=6+x-2"\nOutput: "x=2"\n\n\nExample 2:\nInput: "x=x"\nOutput: "Infinite solutions"\n\n\nExample 3:\nInput: "2x=x"\nOutput: "x=0"\n\n\nExample 4:\nInput: "2x+3x-6x=x+2"\nOutput: "x=-1"\n\n\nExample 5:\nInput: "x=x+2"\nOutput: "No solution"
__label__0 Given a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order.\nIf there is a tie,  the smaller elements are always preferred.\n\nExample 1:\nInput: [1,2,3,4,5], k=4, x=3\nOutput: [1,2,3,4]\n\n\nExample 2:\nInput: [1,2,3,4,5], k=4, x=-1\nOutput: [1,2,3,4]\n\n\nNote:\n\nThe value k is positive and will always be smaller than the length of the sorted array.\n Length of the given array is positive and will not exceed 104\n Absolute value of elements in the array and x will not exceed 104\n\n\n\n\nUPDATE (2017/9/19):\nThe arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.
__label__0 Given an integer, write a function to determine if it is a power of three.\nExample 1:\nInput: 27\nOutput: true\n\nExample 2:\nInput: 0\nOutput: false\nExample 3:\nInput: 9\nOutput: true\nExample 4:\nInput: 45\nOutput: false\nFollow up:\nCould you do it without using any loop / recursion?
__label__0 Given a string date representing a Gregorian\xc2\xa0calendar date formatted as YYYY-MM-DD, return the day number of the year.\n\xc2\xa0\nExample 1:\nInput: date = "2019-01-09"\nOutput: 9\nExplanation: Given date is the 9th day of the year in 2019.\n\nExample 2:\nInput: date = "2019-02-10"\nOutput: 41\n\nExample 3:\nInput: date = "2003-03-01"\nOutput: 60\n\nExample 4:\nInput: date = "2004-03-01"\nOutput: 61\n\n\xc2\xa0\nConstraints:\n\ndate.length == 10\ndate[4] == date[7] == \'-\', and all other date[i]\'s are digits\ndate represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.
__label__0 Consider a directed graph, with nodes labelled 0, 1, ..., n-1.\xc2\xa0 In this graph, each edge is either red or blue, and there could\xc2\xa0be self-edges or parallel edges.\nEach [i, j] in red_edges denotes a red directed edge from node i to node j.\xc2\xa0 Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.\nReturn an array answer\xc2\xa0of length n,\xc2\xa0where each\xc2\xa0answer[X]\xc2\xa0is\xc2\xa0the length of the shortest path from node 0\xc2\xa0to node X\xc2\xa0such that the edge colors alternate along the path (or -1 if such a path doesn't exist).\n\xc2\xa0\nExample 1:\nInput: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []\nOutput: [0,1,-1]\nExample 2:\nInput: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]\nOutput: [0,1,-1]\nExample 3:\nInput: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]\nOutput: [0,-1,-1]\nExample 4:\nInput: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]\nOutput: [0,1,2]\nExample 5:\nInput: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]\nOutput: [0,1,1]\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 100\nred_edges.length <= 400\nblue_edges.length <= 400\nred_edges[i].length == blue_edges[i].length == 2\n0 <= red_edges[i][j], blue_edges[i][j] < n
__label__0 On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.\nHere, the north-west corner of the grid is at the\xc2\xa0first row and column, and the south-east corner of the grid is at the last row and column.\nNow, we walk in a clockwise spiral shape to visit every position in this grid.\xc2\xa0\nWhenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)\xc2\xa0\nEventually, we reach all R * C spaces of the grid.\nReturn a list of coordinates representing the positions of the grid in the order they were visited.\n\xc2\xa0\nExample 1:\nInput: R = 1, C = 4, r0 = 0, c0 = 0\nOutput: [[0,0],[0,1],[0,2],[0,3]]\n\n\n\n\xc2\xa0\nExample 2:\nInput: R = 5, C = 6, r0 = 1, c0 = 4\nOutput: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n\n\n\n\n\xc2\xa0\nNote:\n\n1 <= R <= 100\n1 <= C <= 100\n0 <= r0 < R\n0 <= c0 < C
__label__0 Given a balanced parentheses string S, compute the score of the string based on the following rule:\n\n() has score 1\nAB has score A + B, where A and B are balanced parentheses strings.\n(A) has score 2 * A, where A is a balanced parentheses string.\n\n\xc2\xa0\n\nExample 1:\nInput: "()"\nOutput: 1\n\n\nExample 2:\nInput: "(())"\nOutput: 2\n\n\nExample 3:\nInput: "()()"\nOutput: 2\n\n\nExample 4:\nInput: "(()(()))"\nOutput: 6\n\n\xc2\xa0\nNote:\n\nS is a balanced parentheses string, containing only ( and ).\n2 <= S.length <= 50
__label__0 Given n non-negative integers a1, a2, ..., an\xc2\xa0, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote:\xc2\xa0You may not slant the container and n is at least 2.\n\xc2\xa0\n\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain\xc2\xa0is 49. \n\xc2\xa0\nExample:\nInput: [1,8,6,2,5,4,8,3,7]\nOutput: 49
__label__0 Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i]\xc2\xa0interpreted\xc2\xa0as a binary number (from most-significant-bit to least-significant-bit.)\nReturn a list of booleans\xc2\xa0answer, where answer[i] is true\xc2\xa0if and only if N_i\xc2\xa0is divisible by 5.\nExample 1:\nInput: [0,1,1]\nOutput: [true,false,false]\nExplanation: \nThe input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.\n\nExample 2:\nInput: [1,1,1]\nOutput: [false,false,false]\n\nExample 3:\nInput: [0,1,1,1,1,1]\nOutput: [true,false,false,false,true,false]\n\nExample 4:\nInput: [1,1,1,0,1]\nOutput: [false,false,false,false,false]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 30000\nA[i] is 0 or 1
__label__0 Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates\xc2\xa0where the candidate numbers sums to target.\nThe same repeated number may be chosen from candidates\xc2\xa0unlimited number of times.\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\nExample 1:\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\nExample 2:\nInput: candidates = [2,3,5], target = 8,\nA solution set is:\n[\n\xc2\xa0 [2,2,2,2],\n\xc2\xa0 [2,3,3],\n\xc2\xa0 [3,5]\n]
__label__0 Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing\xc2\xa0them.\nWe repeatedly make duplicate removals on S until we no longer can.\nReturn the final string after all such duplicate removals have been made.\xc2\xa0 It is guaranteed the answer is unique.\n\xc2\xa0\nExample 1:\nInput: "abbaca"\nOutput: "ca"\nExplanation: \nFor example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.\xc2\xa0 The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".\n\n\xc2\xa0\nNote:\n\n1 <= S.length <= 20000\nS consists only of English lowercase letters.
__label__0 Given a fixed length\xc2\xa0array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written.\nDo the above modifications to the input array in place, do not return anything from your function.\n\xc2\xa0\nExample 1:\nInput: [1,0,2,3,0,4,5,0]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nExample 2:\nInput: [1,2,3]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n\n\xc2\xa0\nNote:\n\n1 <= arr.length <= 10000\n0 <= arr[i] <= 9
__label__0 Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\xc2\xa0 as an array of 0s and 1s, from most significant bit to least significant bit.\xc2\xa0 For example, arr = [1,1,0,1] represents the number (-2)^3\xc2\xa0+ (-2)^2 + (-2)^0 = -3.\xc2\xa0 A number arr in array format is also guaranteed to have no leading zeros: either\xc2\xa0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.\n\xc2\xa0\nExample 1:\nInput: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.\n\n\xc2\xa0\nNote:\n\n1 <= arr1.length <= 1000\n1 <= arr2.length <= 1000\narr1 and arr2 have no leading zeros\narr1[i] is 0 or 1\narr2[i] is 0 or 1
__label__0 Let's call any (contiguous) subarray B (of A)\xc2\xa0a mountain if the following properties hold:\n\nB.length >= 3\nThere exists some 0 < i\xc2\xa0< B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]\n\n(Note that B could be any subarray of A, including the entire array A.)\nGiven an array A\xc2\xa0of integers,\xc2\xa0return the length of the longest\xc2\xa0mountain.\xc2\xa0\nReturn 0 if there is no mountain.\nExample 1:\nInput: [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\nExample 2:\nInput: [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\nNote:\n\n0 <= A.length <= 10000\n0 <= A[i] <= 10000\n\nFollow up:\n\nCan you solve it using only one pass?\nCan you solve it in O(1) space?
__label__0 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nGiven the below binary tree and sum = 22,\n      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\      \\\n7    2      1\n\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
__label__0 Given inorder and postorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\ninorder =\xc2\xa0[9,3,15,20,7]\npostorder = [9,15,7,20,3]\nReturn the following binary tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7
__label__0 We are given a\xc2\xa0personal information string S, which may represent\xc2\xa0either an email address or a phone number.\nWe would like to mask this\xc2\xa0personal information according to the\xc2\xa0following rules:\n\n1. Email address:\nWe define a\xc2\xa0name to be a string of length \xe2\x89\xa5 2 consisting\xc2\xa0of only lowercase letters\xc2\xa0a-z or uppercase\xc2\xa0letters\xc2\xa0A-Z.\nAn email address starts with a name, followed by the\xc2\xa0symbol \'@\', followed by a name, followed by the\xc2\xa0dot\xc2\xa0\'.\'\xc2\xa0and\xc2\xa0followed by a name.\xc2\xa0\nAll email addresses are\xc2\xa0guaranteed to be valid and in the format of\xc2\xa0"name1@name2.name3".\nTo mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks \'*\'.\n\n2. Phone number:\nA phone number is a string consisting of\xc2\xa0only the digits 0-9 or the characters from the set {\'+\', \'-\', \'(\', \')\', \'\xc2\xa0\'}.\xc2\xa0You may assume a phone\xc2\xa0number contains\xc2\xa010 to 13 digits.\nThe last 10 digits make up the local\xc2\xa0number, while the digits before those make up the country code. Note that\xc2\xa0the country code is optional. We want to expose only the last 4 digits\xc2\xa0and mask all other\xc2\xa0digits.\nThe local\xc2\xa0number\xc2\xa0should be formatted and masked as "***-***-1111",\xc2\xa0where 1 represents the exposed digits.\nTo mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".\xc2\xa0 The \'+\'\xc2\xa0sign and the first \'-\'\xc2\xa0sign before the local number should only exist if there is a country code.\xc2\xa0 For example, a 12 digit phone number mask\xc2\xa0should start\xc2\xa0with "+**-".\nNote that extraneous characters like "(", ")", " ", as well as\xc2\xa0extra dashes or plus signs not part of the above formatting scheme should be removed.\n\xc2\xa0\nReturn the correct "mask" of the information provided.\n\xc2\xa0\nExample 1:\nInput: "LeetCode@LeetCode.com"\nOutput: "l*****e@leetcode.com"\nExplanation:\xc2\xa0All names are converted to lowercase, and the letters between the\n\xc2\xa0            first and last letter of the first name is replaced by 5 asterisks.\n\xc2\xa0            Therefore, "leetcode" -> "l*****e".\n\nExample 2:\nInput: "AB@qq.com"\nOutput: "a*****b@qq.com"\nExplanation:\xc2\xa0There must be 5 asterisks between the first and last letter \n\xc2\xa0            of the first name "ab". Therefore, "ab" -> "a*****b".\n\nExample 3:\nInput: "1(234)567-890"\nOutput: "***-***-7890"\nExplanation:\xc2\xa010 digits in the phone number, which means all digits make up the local number.\n\nExample 4:\nInput: "86-(10)12345678"\nOutput: "+**-***-***-5678"\nExplanation:\xc2\xa012 digits, 2 digits for country code and 10 digits for local number. \n\nNotes:\n\nS.length\xc2\xa0<=\xc2\xa040.\nEmails have length at least 8.\nPhone numbers have length at least 10.
__label__0 Shuffle a set of numbers without duplicates.\n\nExample:\n// Init an array with set 1, 2, and 3.\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\nsolution.shuffle();\n\n// Resets the array back to its original configuration [1,2,3].\nsolution.reset();\n\n// Returns the random shuffling of array [1,2,3].\nsolution.shuffle();
__label__0 SQL SchemaThere is a table World\n+-----------------+------------+------------+--------------+---------------+\n| name            | continent  | area       | population   | gdp           |\n+-----------------+------------+------------+--------------+---------------+\n| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |\n| Albania         | Europe     | 28748      | 2831741      | 12960000      |\n| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |\n| Andorra         | Europe     | 468        | 78115        | 3712000       |\n| Angola          | Africa     | 1246700    | 20609294     | 100990000     |\n+-----------------+------------+------------+--------------+---------------+\n\nA country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\nFor example, according to the above table, we should output:\n+--------------+-------------+--------------+\n| name         | population  | area         |\n+--------------+-------------+--------------+\n| Afghanistan  | 25500100    | 652230       |\n| Algeria      | 37100000    | 2381741      |\n+--------------+-------------+--------------+
__label__0 In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\n\n\nYou're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.\nThe reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\n\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n\nExample 1:\nInput: \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\nOutput: \n[[1,2,3,4]]\nExplanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\n\n\nExample 2:\nInput: \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\nOutput: \n[[1,2],\n [3,4]]\nExplanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\n\n\nNote:\n\nThe height and width of the given matrix is in range [1, 100].\nThe given r and c are all positive.
__label__0 A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]\xe2\x80\xa6 By that analogy, we stop adding right before a duplicate element occurs in S.\n\xc2\xa0\nExample 1:\nInput: A = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\nOne of the longest S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n\n\xc2\xa0\nNote:\n\nN is an integer within the range [1, 20,000].\nThe elements of A are all distinct.\nEach element of A is an integer within the range [0, N-1].
__label__0 Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom \nnote can be constructed from the magazines ; otherwise, it will return false. \n\n\nEach letter in the magazine string can only be used once in your ransom note.\n\nNote:\nYou may assume that both strings contain only lowercase letters.\n\ncanConstruct("a", "b") -> false\ncanConstruct("aa", "ab") -> false\ncanConstruct("aa", "aab") -> true
__label__0 We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nNow, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\nExample 1:\nInput: [1,3,2,2,5,2,3,7]\nOutput: 5\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].\n\n\xc2\xa0\nNote: The length of the input array will not exceed 20,000.
__label__0 You are given a string representing an attendance record for a student. The record only contains the following three characters:\n\n\n\n\'A\' : Absent. \n\'L\' : Late.\n \'P\' : Present. \n\n\n\nA student could be rewarded if his attendance record doesn\'t contain more than one \'A\' (absent) or more than two continuous \'L\' (late).    \nYou need to return whether the student could be rewarded according to his attendance record.\nExample 1:\nInput: "PPALLP"\nOutput: True\n\n\nExample 2:\nInput: "PPALLL"\nOutput: False
__label__0 Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\npreorder =\xc2\xa0[3,9,20,15,7]\ninorder = [9,3,15,20,7]\nReturn the following binary tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7
__label__0 In a string\xc2\xa0S\xc2\xa0of lowercase letters, these letters form consecutive groups of the same character.\nFor example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and\xc2\xa0"yy".\nCall a group large if it has 3 or more characters.\xc2\xa0 We would like the starting and ending positions of every large group.\nThe final answer should be in lexicographic order.\n\xc2\xa0\nExample 1:\nInput: "abbxxxxzzy"\nOutput: [[3,6]]\nExplanation: "xxxx" is the single large group with starting  3 and ending positions 6.\n\nExample 2:\nInput: "abc"\nOutput: []\nExplanation: We have "a","b" and "c" but no large group.\n\nExample 3:\nInput: "abcdddeeeeaabbbcd"\nOutput: [[3,5],[6,9],[12,14]]\n\xc2\xa0\nNote:\xc2\xa0\xc2\xa01 <= S.length <= 1000
__label__0 Given two\xc2\xa0strings\xc2\xa0S\xc2\xa0and T,\xc2\xa0return if they are equal when both are typed into empty text editors. # means a backspace character.\n\nExample 1:\nInput: S = "ab#c", T = "ad#c"\nOutput: true\nExplanation: Both S and T become "ac".\n\n\nExample 2:\nInput: S = "ab##", T = "c#d#"\nOutput: true\nExplanation: Both S and T become "".\n\n\nExample 3:\nInput: S = "a##c", T = "#a#c"\nOutput: true\nExplanation: Both S and T become "c".\n\n\nExample 4:\nInput: S = "a#c", T = "b"\nOutput: false\nExplanation: S becomes "c" while T becomes "b".\n\nNote:\n\n1 <= S.length <= 200\n1 <= T.length <= 200\nS\xc2\xa0and T only contain\xc2\xa0lowercase letters and \'#\' characters.\n\nFollow up:\n\nCan you solve it in O(N) time and O(1) space?
__label__0 Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its minimum\xc2\xa0depth = 2.
__label__0 Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every\xc2\xa0cell in that column.\xc2\xa0 Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0.\nReturn the maximum number of rows that have all values equal after some number of flips.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [[0,1],[1,1]]\nOutput: 1\nExplanation: After flipping no values, 1 row has all values equal.\n\n\nExample 2:\nInput: [[0,1],[1,0]]\nOutput: 2\nExplanation: After flipping values in the first column, both rows have equal values.\n\n\nExample 3:\nInput: [[0,0,0],[0,0,1],[1,1,0]]\nOutput: 2\nExplanation: After flipping values in the first two columns, the last two rows have equal values.\n\n\xc2\xa0\nNote:\n\n1 <= matrix.length <= 300\n1 <= matrix[i].length <= 300\nAll matrix[i].length's are equal\nmatrix[i][j] is\xc2\xa00 or 1
__label__0 Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\n\xc2\xa0\nExample 1:\nInput: "cdadabcc"\nOutput: "adbc"\n\n\nExample 2:\nInput: "abcd"\nOutput: "abcd"\n\n\nExample 3:\nInput: "ecbacba"\nOutput: "eacb"\n\n\nExample 4:\nInput: "leetcode"\nOutput: "letcod"\n\n\xc2\xa0\nNote:\n\n1 <= text.length <= 1000\ntext consists of lowercase English letters.
__label__0 Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\xc2\xa0where the candidate numbers sums to target.\nEach number in candidates\xc2\xa0may only be used once in the combination.\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\nExample 1:\nInput: candidates =\xc2\xa0[10,1,2,7,6,1,5], target =\xc2\xa08,\nA solution set is:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\nExample 2:\nInput: candidates =\xc2\xa0[2,5,2,1,2], target =\xc2\xa05,\nA solution set is:\n[\n\xc2\xa0 [1,2,2],\n\xc2\xa0 [5]\n]
__label__0 Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])\n\xc2\xa0\nExample 1:\nInput: [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n\nExample 2:\nInput: [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false\n\n\nExample 3:\nInput: [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n\n\n\n\xc2\xa0\nNote:\n\n3 <= A.length <= 50000\n-10000 <= A[i] <= 10000
__label__0 We are given a linked list with\xc2\xa0head\xc2\xa0as the first node.\xc2\xa0 Let's number the\xc2\xa0nodes in the list: node_1, node_2, node_3, ... etc.\nEach node may have a next larger value: for node_i,\xc2\xa0next_larger(node_i)\xc2\xa0is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice.\xc2\xa0 If such a j\xc2\xa0does not exist, the next larger value is 0.\nReturn an array of integers\xc2\xa0answer, where answer[i] = next_larger(node_{i+1}).\nNote that in the example inputs\xc2\xa0(not outputs) below, arrays such as [2,1,5]\xc2\xa0represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5.\n\xc2\xa0\n\nExample 1:\nInput: [2,1,5]\nOutput: [5,5,0]\n\n\nExample 2:\nInput: [2,7,4,3,5]\nOutput: [7,0,5,5,0]\n\n\nExample 3:\nInput: [1,7,5,1,9,2,5,1]\nOutput: [7,9,9,9,0,5,0,0]\n\n\xc2\xa0\nNote:\n\n1 <= node.val\xc2\xa0<= 10^9\xc2\xa0for each node in the linked list.\nThe given list has length in the range [0, 10000].
__label__0 Roman numerals are represented by seven different symbols:\xc2\xa0I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\xc2\xa0two is written as II\xc2\xa0in Roman numeral, just two one\'s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\xc2\xa0\nX can be placed before L (50) and C (100) to make 40 and 90.\xc2\xa0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\nInput:\xc2\xa03\nOutput: "III"\nExample 2:\nInput:\xc2\xa04\nOutput: "IV"\nExample 3:\nInput:\xc2\xa09\nOutput: "IX"\nExample 4:\nInput:\xc2\xa058\nOutput: "LVIII"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 5:\nInput:\xc2\xa01994\nOutput: "MCMXCIV"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__0 There are N workers.\xc2\xa0 The i-th worker has a quality[i] and a minimum wage expectation wage[i].\nNow we want to hire exactly K\xc2\xa0workers to form a paid group.\xc2\xa0 When hiring a group of K workers, we must pay them according to the following rules:\n\nEvery worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\nEvery worker in the paid group must be paid at least their minimum wage expectation.\n\nReturn the least amount of money needed to form a paid group satisfying the above conditions.\n\xc2\xa0\n\n\n\nExample 1:\nInput: quality = [10,20,5], wage = [70,50,30], K = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0-th worker and 35 to 2-th worker.\n\n\nExample 2:\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. \n\n\xc2\xa0\nNote:\n\n1 <= K <= N <= 10000, where N = quality.length = wage.length\n1 <= quality[i] <= 10000\n1 <= wage[i] <= 10000\nAnswers within 10^-5 of the correct answer will be considered correct.
__label__0 We are given two sentences A and B.\xc2\xa0 (A sentence\xc2\xa0is a string of space separated words.\xc2\xa0 Each word consists only of lowercase letters.)\nA word is uncommon\xc2\xa0if it appears exactly once in one of the sentences, and does not appear in the other sentence.\nReturn a list of all uncommon words.\xc2\xa0\nYou may return the list in any order.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = "this apple is sweet", B = "this apple is sour"\nOutput: ["sweet","sour"]\n\n\nExample 2:\nInput: A = "apple apple", B = "banana"\nOutput: ["banana"]\n\n\xc2\xa0\nNote:\n\n0 <= A.length <= 200\n0 <= B.length <= 200\nA and B both contain only spaces and lowercase letters.
__label__0 Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i\xc2\xa0for which A[i] > B[i].\nReturn any permutation of A that maximizes its advantage with respect to B.\n\xc2\xa0\n\nExample 1:\nInput: A = [2,7,11,15], B = [1,10,4,11]\nOutput: [2,11,7,15]\n\n\nExample 2:\nInput: A = [12,24,8,32], B = [13,25,32,11]\nOutput: [24,32,8,12]\n\n\xc2\xa0\nNote:\n\n1 <= A.length = B.length <= 10000\n0 <= A[i] <= 10^9\n0 <= B[i] <= 10^9
__label__0 There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\nThe move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.\nNote: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot\'s movement is the same for each move.\nExample 1:\nInput: "UD"\nOutput: true \nExplanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n\xc2\xa0\nExample 2:\nInput: "LL"\nOutput: false\nExplanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.
__label__0 Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\nExample 1:\nInput: nums = [1, 5, 1, 1, 6, 4]\nOutput: One possible answer is [1, 4, 1, 5, 1, 6].\nExample 2:\nInput: nums = [1, 3, 2, 2, 3, 1]\nOutput: One possible answer is [2, 3, 1, 3, 1, 2].\nNote:\nYou may assume all input has valid answer.\nFollow Up:\nCan you do it in O(n) time and/or in-place with O(1) extra space?
__label__0 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\nExample:\nInput: [5,2,6,1]\nOutput: [2,1,1,0] \nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.
__label__0 Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).\n\nExample 1:\nInput: [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. \nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \n\n\nExample 2:\nInput: [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence is [2], its length is 1. \n\n\nNote:\nLength of the array will not exceed 10,000.
__label__0 Given a positive integer num, write a function which returns True if num is a perfect square else False.\nNote: Do not use any built-in library function such as sqrt.\nExample 1:\n\nInput: 16\nOutput: true\n\n\nExample 2:\nInput: 14\nOutput: false
__label__0 Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.\n\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)\n\nExample 1:Input: L = 6, R = 10\nOutput: 4\nExplanation:\n6 -> 110 (2 set bits, 2 is prime)\n7 -> 111 (3 set bits, 3 is prime)\n9 -> 1001 (2 set bits , 2 is prime)\n10->1010 (2 set bits , 2 is prime)\n\nExample 2:Input: L = 10, R = 15\nOutput: 5\nExplanation:\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n\nNote:\nL, R will be integers L <= R in the range [1, 10^6].\nR - L will be at most 10000.
__label__0 There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: 2, [[1,0]] \nOutput: [0,1]\nExplanation:\xc2\xa0There are a total of 2 courses to take. To take course 1 you should have finished   \n\xc2\xa0            course 0. So the correct course order is [0,1] .\nExample 2:\nInput: 4, [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,1,2,3] or [0,2,1,3]\nExplanation:\xc2\xa0There are a total of 4 courses to take. To take course 3 you should have finished both     \n             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \n\xc2\xa0            So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\nNote:\n\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.
__label__0 Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.\n\nExample 1:\nInput: \nwords = ["w","wo","wor","worl", "world"]\nOutput: "world"\nExplanation: \nThe word "world" can be built one character at a time by "w", "wo", "wor", and "worl".\n\n\nExample 2:\nInput: \nwords = ["a", "banana", "app", "appl", "ap", "apply", "apple"]\nOutput: "apple"\nExplanation: \nBoth "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".\n\n\nNote:\nAll the strings in the input will only contain lowercase letters.\nThe length of words will be in the range [1, 1000].\nThe length of words[i] will be in the range [1, 30].
__label__0 A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nAlso, a self-dividing number is not allowed to contain the digit zero.\n\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\n\nExample 1:\nInput: \nleft = 1, right = 22\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\n\nNote:\nThe boundaries of each input argument are 1 <= left <= right <= 10000.
__label__0 Implement a basic calculator to evaluate a simple expression string.\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\nExample 1:\nInput: "1 + 1"\nOutput: 2\n\nExample 2:\nInput: " 2-1 + 2 "\nOutput: 3\nExample 3:\nInput: "(1+(4+5+2)-3)+(6+8)"\nOutput: 23\nNote:\n\nYou may assume that the given expression is always valid.\nDo not use the eval built-in library function.
__label__0 Given an array nums of n integers where n > 1, \xc2\xa0return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nExample:\nInput:  [1,2,3,4]\nOutput: [24,12,8,6]\n\nNote: Please solve it without division and in O(n).\nFollow up:\nCould you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
__label__0 Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\xc2\xa0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\xc2\xa0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\xc2\xa0\nExample 1:\nInput: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.\n\nExample 2:\nInput: n = 100\nOutput: 682289015\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 100
__label__0 Write a program to find the\xc2\xa0n-th ugly number.\nUgly numbers are\xc2\xa0positive integers\xc2\xa0which are divisible by\xc2\xa0a\xc2\xa0or\xc2\xa0b\xc2\xa0or c.\n\xc2\xa0\nExample 1:\nInput: n = 3, a = 2, b = 3, c = 5\nOutput: 4\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\nExample 2:\nInput: n = 4, a = 2, b = 3, c = 4\nOutput: 6\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\n\nExample 3:\nInput: n = 5, a = 2, b = 11, c = 13\nOutput: 10\nExplanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.\n\nExample 4:\nInput: n = 1000000000, a = 2, b = 217983653, c = 336916467\nOutput: 1999999984\n\n\xc2\xa0\nConstraints:\n\n1 <= n, a, b, c <= 10^9\n1 <= a * b * c <= 10^18\nIt's guaranteed that the result will be in range\xc2\xa0[1,\xc2\xa02 * 10^9]
__label__0 Write a class RecentCounter to count recent requests.\nIt has only one method:\xc2\xa0ping(int t), where t represents some time in milliseconds.\nReturn the number of pings that have been made from 3000 milliseconds ago until now.\nAny ping with time in [t - 3000, t] will count, including the current ping.\nIt is guaranteed that every call to ping uses a strictly larger value of\xc2\xa0t than before.\n\xc2\xa0\nExample 1:\nInput: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]\nOutput: [null,1,2,3,3]\n\xc2\xa0\nNote:\n\nEach test case will have at most 10000 calls to ping.\nEach test case will call\xc2\xa0ping with strictly increasing values of t.\nEach call to ping will have 1 <= t <= 10^9.
__label__0 Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.\nIf there isn't any rectangle, return 0.\n\xc2\xa0\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\n\xc2\xa0\nNote:\n\n1 <= points.length <= 500\n0 <=\xc2\xa0points[i][0] <=\xc2\xa040000\n0 <=\xc2\xa0points[i][1] <=\xc2\xa040000\nAll points are distinct.
__label__0 Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j]\xc2\xa0with i+1 < j, such that:\n\nA[0], A[1], ..., A[i] is the first part;\nA[i+1], A[i+2], ..., A[j-1] is the second part, and\nA[j], A[j+1], ..., A[A.length - 1] is the third part.\nAll three parts have equal binary value.\n\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents.\xc2\xa0 For example, [1,1,0]\xc2\xa0represents 6\xc2\xa0in decimal,\xc2\xa0not 3.\xc2\xa0 Also, leading zeros are allowed, so\xc2\xa0[0,1,1] and [1,1] represent the same value.\n\xc2\xa0\nExample 1:\nInput: [1,0,1,0,1]\nOutput: [0,3]\n\n\nExample 2:\nInput: [1,1,0,1,1]\nOutput: [-1,-1]\n\n\xc2\xa0\nNote:\n\n3 <= A.length <= 30000\nA[i] == 0\xc2\xa0or A[i] == 1
__label__0 Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\nExample:\nInput:\xc2\xa0n = 4, k = 2\nOutput:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]
__label__0 Given an array A\xc2\xa0of 0s and 1s, we may change up to K\xc2\xa0values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s.\xc2\xa0\n\xc2\xa0\n\nExample 1:\nInput: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\nOutput: 6\nExplanation: \n[1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\nExample 2:\nInput: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\nOutput: 10\nExplanation: \n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 20000\n0 <= K <= A.length\nA[i] is 0 or 1
__label__0 SQL SchemaGiven a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\n+---------+------------------+------------------+\n| Id(INT) | RecordDate(DATE) | Temperature(INT) |\n+---------+------------------+------------------+\n|       1 |       2015-01-01 |               10 |\n|       2 |       2015-01-02 |               25 |\n|       3 |       2015-01-03 |               20 |\n|       4 |       2015-01-04 |               30 |\n+---------+------------------+------------------+\n\nFor example, return the following Ids for the above Weather table:\n+----+\n| Id |\n+----+\n|  2 |\n|  4 |\n+----+
__label__0 Given an array equations\xc2\xa0of strings that represent relationships between variables, each string equations[i]\xc2\xa0has length 4 and takes one of two different forms: "a==b" or "a!=b".\xc2\xa0 Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true\xc2\xa0if and only if it is possible to assign integers to variable names\xc2\xa0so as to satisfy all the given equations.\n\xc2\xa0\n\n\n\nExample 1:\nInput: ["a==b","b!=a"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.\n\n\nExample 2:\nInput: ["b==a","a==b"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations.\n\n\nExample 3:\nInput: ["a==b","b==c","a==c"]\nOutput: true\n\n\nExample 4:\nInput: ["a==b","b!=c","c==a"]\nOutput: false\n\n\nExample 5:\nInput: ["c==c","b==d","x!=z"]\nOutput: true\n\n\xc2\xa0\nNote:\n\n1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] and equations[i][3] are lowercase letters\nequations[i][1] is either \'=\' or \'!\'\nequations[i][2] is\xc2\xa0\'=\'
__label__0 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: [1,2,2]\nOutput:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]
__label__0 On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).\nNow rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are\xc2\xa0at most\xc2\xa0t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nYou start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\nExample 1:\nInput: [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\nExample 2:\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation:\n 0  1  2  3  4\n24 23 22 21  5\n12 13 14 15 16\n11 17 18 19 20\n10  9  8  7  6\n\nThe final route is marked in bold.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\nNote:\n\n2 <= N <= 50.\ngrid[i][j] is a permutation of [0, ..., N*N - 1].
__label__0 SQL SchemaThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\n\nThe Department table holds all departments of the company.\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n\nExplanation:\nIn IT department, Max earns the highest salary, both Randy and Joe earn the second highest salary, and Will earns the third highest salary. There are only two employees in the Sales department, Henry earns the highest salary while Sam earns the second highest salary.
__label__0 Given a column title as appear in an Excel sheet, return its corresponding column number.\nFor example:\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n\nExample 1:\nInput: "A"\nOutput: 1\n\nExample 2:\nInput: "AB"\nOutput: 28\n\nExample 3:\nInput: "ZY"\nOutput: 701
__label__0 Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.\xc2\xa0 After concatenating them,\xc2\xa0the result equals the sorted array.\nWhat is the most number of chunks we could have made?\nExample 1:\nInput: arr = [4,3,2,1,0]\nOutput: 1\nExplanation:\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn\'t sorted.\n\nExample 2:\nInput: arr = [1,0,2,3,4]\nOutput: 4\nExplanation:\nWe can split into two chunks, such as [1, 0], [2, 3, 4].\nHowever, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.\n\nNote:\n\narr will have length in range [1, 10].\narr[i] will be a permutation of [0, 1, ..., arr.length - 1].
__label__0 In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts\xc2\xa0can be different for different buildings). Height\xc2\xa00 is considered to be a\xc2\xa0building\xc2\xa0as well.\xc2\xa0\nAt the end, the "skyline" when viewed from all four directions\xc2\xa0of the grid, i.e.\xc2\xa0top, bottom, left, and right,\xc2\xa0must be the same as the\xc2\xa0skyline of the original grid. A city\'s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See\xc2\xa0the following example.\nWhat is the maximum total sum that the height of the buildings can be increased?\nExample:\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: \nThe grid is:\n[ [3, 0, 8, 4], \n  [2, 4, 5, 7],\n  [9, 2, 6, 3],\n  [0, 3, 1, 0] ]\n\nThe skyline viewed from top or bottom is: [9, 4, 8, 7]\nThe skyline viewed from left or right is: [8, 7, 9, 3]\n\nThe grid after increasing the height of buildings without affecting skylines is:\n\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\n\nNotes: \n\n1 < grid.length = grid[0].length <= 50.\nAll heights grid[i][j] are in the range [0, 100].\nAll buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.
__label__0 Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such\nthat i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\nNote: n will be less than 15,000.\nExample 1:\nInput: [1, 2, 3, 4]\n\nOutput: False\n\nExplanation: There is no 132 pattern in the sequence.\n\n\nExample 2:\nInput: [3, 1, 4, 2]\n\nOutput: True\n\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\n\n\nExample 3:\nInput: [-1, 3, 2, 0]\n\nOutput: True\n\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
__label__0 Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. \n\n\nYou are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\n\nTo sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n\nExample 1:\nInput: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\n\nOutput: 4\n\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\n             After finishing it you will obtain profit 1 and your capital becomes 1.\n             With capital 1, you can either start the project indexed 1 or the project indexed 2.\n             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n\nNote:\n\nYou may assume all numbers in the input are non-negative integers.\nThe length of Profits array and Capital array will not exceed 50,000.\nThe answer is guaranteed to fit in a 32-bit signed integer.
__label__0 In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\nExample 1:\nInput: [1,4], 2\nOutput: 4\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. \nThis poisoned status will last 2 seconds until the end of time point 2. \nAnd at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. \nSo you finally need to output 4.\n\n\xc2\xa0\nExample 2:\nInput: [1,2], 2\nOutput: 3\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. \nThis poisoned status will last 2 seconds until the end of time point 2. \nHowever, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. \nSince the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. \nSo you finally need to output 3.\n\n\xc2\xa0\nNote:\n\nYou may assume the length of given time series array won't exceed 10000.\nYou may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.
__label__0 You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\nGiven n, find the total number of full staircase rows that can be formed.\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\nExample 1:\nn = 5\n\nThe coins can form the following rows:\n\xc2\xa4\n\xc2\xa4 \xc2\xa4\n\xc2\xa4 \xc2\xa4\n\nBecause the 3rd row is incomplete, we return 2.\n\n\nExample 2:\nn = 8\n\nThe coins can form the following rows:\n\xc2\xa4\n\xc2\xa4 \xc2\xa4\n\xc2\xa4 \xc2\xa4 \xc2\xa4\n\xc2\xa4 \xc2\xa4\n\nBecause the 4th row is incomplete, we return 3.
__label__0 Given a string s\xc2\xa0that consists of only uppercase English letters, you can perform at most k operations on that string.\nIn one operation, you can choose any character of the string and change it to any other uppercase English character.\nFind the length of the longest sub-string containing all repeating letters you can get after performing the above operations.\nNote:\nBoth the string\'s length and k will not exceed 104.\nExample 1:\nInput:\ns = "ABAB", k = 2\n\nOutput:\n4\n\nExplanation:\nReplace the two \'A\'s with two \'B\'s or vice versa.\n\n\xc2\xa0\nExample 2:\nInput:\ns = "AABABBA", k = 1\n\nOutput:\n4\n\nExplanation:\nReplace the one \'A\' in the middle with \'B\' and form "AABBBBA".\nThe substring "BBBB" has the longest repeating letters, which is 4.
__label__0 Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.\nNote:\n\nInput contains only lowercase English letters.\nInput is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.\nInput length is less than 50,000.\n\n\nExample 1:\nInput: "owoztneoer"\n\nOutput: "012"\n\n\nExample 2:\nInput: "fviefuro"\n\nOutput: "45"
__label__0 Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.\nNote: 1 \xe2\x89\xa4 k \xe2\x89\xa4 n \xe2\x89\xa4 109.\nExample:\nInput:\nn: 13   k: 2\n\nOutput:\n10\n\nExplanation:\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
__label__0 Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\nNote:\nYou may assume the greed factor is always positive. \nYou cannot assign more than one cookie to one child.\n\nExample 1:\nInput: [1,2,3], [1,1]\n\nOutput: 1\n\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n\nExample 2:\nInput: [1,2], [1,2,3]\n\nOutput: 2\n\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.
__label__0 Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\n\xc2\xa0\nFor example:\nGiven BST [1,null,2,2],\n   1\n    \\\n     2\n    /\n   2\n\n\xc2\xa0\nreturn [2].\nNote: If a tree has more than one mode, you can return them in any order.\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).
__label__0 We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array\xc2\xa0widths, an array where widths[0] is the width of \'a\', widths[1] is the width of \'b\', ..., and widths[25] is the width of \'z\'.\nNow answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.\n\xc2\xa0\nExample :\nInput: \nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = "abcdefghijklmnopqrstuvwxyz"\nOutput: [3, 60]\nExplanation: \nAll letters have the same length of 10. To write all 26 letters,\nwe need two full lines and one line with 60 units.\n\nExample :\nInput: \nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = "bbbcccdddaaa"\nOutput: [2, 4]\nExplanation: \nAll letters except \'a\' have the same length of 10, and \n"bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units.\nFor the last \'a\', it is written on the second line because\nthere is only 2 units left in the first line.\nSo the answer is 2 lines, plus 4 units in the second line.\n\n\xc2\xa0\nNote:\n\nThe length of S will be in the range\xc2\xa0[1, 1000].\nS will only contain lowercase letters.\nwidths is\xc2\xa0an array of length 26.\nwidths[i] will be in the range of [2, 10].
__label__0 Given an array of size n, find the majority element. The majority element is the element that appears more than \xe2\x8c\x8a n/2 \xe2\x8c\x8b times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\nExample 1:\nInput: [3,2,3]\nOutput: 3\nExample 2:\nInput: [2,2,1,1,1,2,2]\nOutput: 2
__label__0 This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.\n\nGiven an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.\xc2\xa0 After concatenating them,\xc2\xa0the result equals the sorted array.\nWhat is the most number of chunks we could have made?\nExample 1:\nInput: arr = [5,4,3,2,1]\nOutput: 1\nExplanation:\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn\'t sorted.\n\nExample 2:\nInput: arr = [2,1,3,4,4]\nOutput: 4\nExplanation:\nWe can split into two chunks, such as [2, 1], [3, 4, 4].\nHowever, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\n\nNote:\n\narr will have length in range [1, 2000].\narr[i] will be an integer in range [0, 10**8].
__label__0 In a string composed of \'L\', \'R\', and \'X\' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\nExample:\nInput: start = "RXXLRXRXL", end = "XRLXXRRLX"\nOutput: True\nExplanation:\nWe can transform start to end following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX\n\nNote:\n\n1 <= len(start) = len(end) <= 10000.\nBoth start and end will only consist of characters in {\'L\', \'R\', \'X\'}.
__label__0 The gray code is a binary numeral system where two successive values differ in only one bit.\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\nExample 1:\nInput:\xc2\xa02\nOutput:\xc2\xa0[0,1,3,2]\nExplanation:\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\nFor a given\xc2\xa0n, a gray code sequence may not be uniquely defined.\nFor example, [0,2,3,1] is also a valid gray code sequence.\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n\nExample 2:\nInput:\xc2\xa00\nOutput:\xc2\xa0[0]\nExplanation: We define the gray code sequence to begin with 0.\n\xc2\xa0            A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.\n\xc2\xa0            Therefore, for n = 0 the gray code sequence is [0].
__label__0 SQL SchemaThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2 \xc2\xa0| Jim \xc2\xa0 | 90000 \xc2\xa0| 1 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0|\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\n\nThe Department table holds all departments of the company.\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n\nWrite a SQL query to find employees who have the highest salary in each of the departments.\xc2\xa0For the above tables, your SQL query should return the following rows (order of rows does not matter).\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 | Jim \xc2\xa0 \xc2\xa0 \xc2\xa0| 90000 \xc2\xa0|\n| Sales      | Henry    | 80000  |\n+------------+----------+--------+\n\nExplanation:\nMax and Jim both have\xc2\xa0the highest salary in the IT department and Henry has the highest salary in the Sales department.
__label__0 On a broken calculator that has a number showing on its display, we can perform two operations:\n\nDouble: Multiply the number on the display by 2, or;\nDecrement: Subtract 1 from the number on the display.\n\nInitially, the calculator is displaying the number X.\nReturn the minimum number of operations needed to display the number Y.\n\xc2\xa0\nExample 1:\nInput: X = 2, Y = 3\nOutput: 2\nExplanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n\nExample 2:\nInput: X = 5, Y = 8\nOutput: 2\nExplanation: Use decrement and then double {5 -> 4 -> 8}.\n\nExample 3:\nInput: X = 3, Y = 10\nOutput: 3\nExplanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\nExample 4:\nInput: X = 1024, Y = 1\nOutput: 1023\nExplanation: Use decrement operations 1023 times.\n\n\xc2\xa0\nNote:\n\n1 <= X <= 10^9\n1 <= Y <= 10^9
__label__0 Given an array A of integers, we must\xc2\xa0modify the array in the following way: we choose an i\xc2\xa0and replace\xc2\xa0A[i] with -A[i], and we repeat this process K times in total.\xc2\xa0 (We may choose the same index i multiple times.)\nReturn the largest possible sum of the array after modifying it in this way.\n\xc2\xa0\nExample 1:\nInput: A = [4,2,3], K = 1\nOutput: 5\nExplanation: Choose indices (1,) and A becomes [4,-2,3].\n\n\nExample 2:\nInput: A = [3,-1,0,2], K = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].\n\n\nExample 3:\nInput: A = [2,-3,-1,5,-4], K = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].\n\n\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n1 <= K <= 10000\n-100 <= A[i] <= 100
__label__0 Given a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: nums = [1,2,3]\nOutput:\n[\n  [3],\n\xc2\xa0 [1],\n\xc2\xa0 [2],\n\xc2\xa0 [1,2,3],\n\xc2\xa0 [1,3],\n\xc2\xa0 [2,3],\n\xc2\xa0 [1,2],\n\xc2\xa0 []\n]
__label__0 A string of \'0\'s and \'1\'s is monotone increasing if it consists of some number of \'0\'s (possibly 0), followed by some number of \'1\'s (also possibly 0.)\nWe are given a string S of \'0\'s and \'1\'s, and we may flip any \'0\' to a \'1\' or a \'1\' to a \'0\'.\nReturn the minimum number of flips to make S\xc2\xa0monotone increasing.\n\xc2\xa0\n\nExample 1:\nInput: "00110"\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n\n\nExample 2:\nInput: "010110"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n\n\nExample 3:\nInput: "00011000"\nOutput: 2\nExplanation: We flip to get 00000000.\n\n\xc2\xa0\nNote:\n\n1 <= S.length <= 20000\nS only consists of \'0\' and \'1\' characters.
__label__0 Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).\nThe binary search tree is guaranteed to have unique values.\n\xc2\xa0\n\nExample 1:\nInput: root = [10,5,15,3,7,null,18], L = 7, R = 15\nOutput: 32\n\n\nExample 2:\nInput: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\nOutput: 23\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the tree is at most 10000.\nThe final answer is guaranteed to be less than 2^31.
__label__0 For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that:\nFor every i < j, there is no\xc2\xa0k with i < k < j\xc2\xa0such that A[k] * 2 = A[i] + A[j].\nGiven N, return any beautiful array A.\xc2\xa0 (It is guaranteed that one exists.)\n\xc2\xa0\nExample 1:\nInput: 4\nOutput: [2,1,4,3]\n\n\nExample 2:\nInput: 5\nOutput: [3,1,2,5,4]\n\xc2\xa0\n\nNote:\n\n1 <= N <= 1000
__label__0 You are given a string s, and an array of pairs of indices in the string\xc2\xa0pairs\xc2\xa0where\xc2\xa0pairs[i] =\xc2\xa0[a, b]\xc2\xa0indicates 2 indices(0-indexed) of the string.\nYou can\xc2\xa0swap the characters at any pair of indices in the given\xc2\xa0pairs\xc2\xa0any number of times.\nReturn the\xc2\xa0lexicographically smallest string that s\xc2\xa0can be changed to after using the swaps.\n\xc2\xa0\nExample 1:\nInput: s = "dcab", pairs = [[0,3],[1,2]]\nOutput: "bacd"\nExplaination: \nSwap s[0] and s[3], s = "bcad"\nSwap s[1] and s[2], s = "bacd"\n\nExample 2:\nInput: s = "dcab", pairs = [[0,3],[1,2],[0,2]]\nOutput: "abcd"\nExplaination: \nSwap s[0] and s[3], s = "bcad"\nSwap s[0] and s[2], s = "acbd"\nSwap s[1] and s[2], s = "abcd"\nExample 3:\nInput: s = "cba", pairs = [[0,1],[1,2]]\nOutput: "abc"\nExplaination: \nSwap s[0] and s[1], s = "bca"\nSwap s[1] and s[2], s = "bac"\nSwap s[0] and s[1], s = "abc"\n\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length <= 10^5\n0 <= pairs.length <= 10^5\n0 <= pairs[i][0], pairs[i][1] <\xc2\xa0s.length\ns\xc2\xa0only contains lower case English letters.
__label__0 Given a string s, we make queries on substrings of s.\nFor each query queries[i] = [left, right, k], we may rearrange\xc2\xa0the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter.\xc2\xa0\nIf the substring\xc2\xa0is possible to be a\xc2\xa0palindrome string after the operations above, the result of the query is true.\xc2\xa0Otherwise, the result\xc2\xa0is false.\nReturn an array answer[], where answer[i] is the result of the i-th query queries[i].\nNote that: Each letter is counted individually for replacement so\xc2\xa0if for example\xc2\xa0s[left..right] = "aaa", and k = 2, we can only replace two of the letters.\xc2\xa0 (Also, note that the initial string s\xc2\xa0is never modified by any query.)\n\xc2\xa0\nExample :\nInput: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\nOutput: [true,false,false,true,true]\nExplanation:\nqueries[0] : substring = "d", is palidrome.\nqueries[1] :\xc2\xa0substring = "bc", is not palidrome.\nqueries[2] :\xc2\xa0substring = "abcd", is not palidrome after replacing only 1 character.\nqueries[3] :\xc2\xa0substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".\nqueries[4] :\xc2\xa0substring = "abcda",\xc2\xa0could be changed to "abcba" which is palidrome.\n\n\xc2\xa0\nConstraints:\n\n1 <= s.length,\xc2\xa0queries.length\xc2\xa0<= 10^5\n0 <= queries[i][0] <= queries[i][1] <\xc2\xa0s.length\n0 <= queries[i][2] <= s.length\ns only contains lowercase English letters.
__label__0 Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\nGiven linked list --\xc2\xa0head =\xc2\xa0[4,5,1,9], which looks like following:\n\n\xc2\xa0\nExample 1:\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\nExample 2:\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n\xc2\xa0\nNote:\n\nThe linked list will have at least two elements.\nAll of the nodes' values will be unique.\nThe given node\xc2\xa0will not be the tail and it will always be a valid node of the linked list.\nDo not return anything from your function.
__label__0 Given a chemical formula (given as a string), return the count of each atom.\n\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\n\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \n\nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\n\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nExample 1:\nInput: \nformula = "H2O"\nOutput: "H2O"\nExplanation: \nThe count of elements are {\'H\': 2, \'O\': 1}.\n\n\nExample 2:\nInput: \nformula = "Mg(OH)2"\nOutput: "H2MgO2"\nExplanation: \nThe count of elements are {\'H\': 2, \'Mg\': 1, \'O\': 2}.\n\n\nExample 3:\nInput: \nformula = "K4(ON(SO3)2)2"\nOutput: "K4N2O14S4"\nExplanation: \nThe count of elements are {\'K\': 4, \'N\': 2, \'O\': 14, \'S\': 4}.\n\n\nNote:\nAll atom names consist of lowercase letters, except for the first character which is uppercase.\nThe length of formula will be in the range [1, 1000].\nformula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.
__label__0 Find the total area covered by two rectilinear rectangles in a 2D plane.\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n\nExample:\nInput: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2\nOutput: 45\nNote:\nAssume that the total area is never beyond the maximum possible value of int.
__label__0 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum \xe2\x89\xa5 s. If there isn't one, return 0 instead.\nExample:\xc2\xa0\nInput: s = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\nFollow up:\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
__label__0 Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. \nExample 1:\nInput:\nnums = [1,3,1]\nk = 1\nOutput: 0 \nExplanation:\nHere are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\n\nNote:\n\n2 <= len(nums) <= 10000.\n0 <= nums[i] < 1000000.\n1 <= k <= len(nums) * (len(nums) - 1) / 2.
__label__0 A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\n\nExample 1:\nInput: S = "ababcbacadefegdehijhklij"\nOutput: [9,7,8]\nExplanation:\nThe partition is "ababcbaca", "defegde", "hijhklij".\nThis is a partition so that each letter appears in at most one part.\nA partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.\n\n\nNote:\nS will have length in range [1, 500].\nS will consist of lowercase letters (\'a\' to \'z\') only.
__label__0 Implement the following operations of a stack using queues.\n\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\nempty() -- Return whether the stack is empty.\n\nExample:\nMyStack stack = new MyStack();\n\nstack.push(1);\nstack.push(2);  \nstack.top();   // returns 2\nstack.pop();   // returns 2\nstack.empty(); // returns false\nNotes:\n\nYou must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.\nDepending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\nYou may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).
__label__0 Given an array of integers nums, write a method that returns the "pivot" index of this array.\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\nExample 1:\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\n\xc2\xa0\nExample 2:\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere is no index that satisfies the conditions in the problem statement.\n\n\xc2\xa0\nNote:\n\nThe length of nums will be in the range [0, 10000].\nEach element nums[i] will be an integer in the range [-1000, 1000].
__label__0 We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).  \nNow given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.\nExample 1:\nInput: \nbits = [1, 0, 0]\nOutput: True\nExplanation: \nThe only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.\n\n\nExample 2:\nInput: \nbits = [1, 1, 1, 0]\nOutput: False\nExplanation: \nThe only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.\n\n\nNote:\n1 <= len(bits) <= 1000.\nbits[i] is always 0 or 1.
__label__0 Design a data structure that supports the following two operations:\nvoid addWord(word)\nbool search(word)\n\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\nExample:\naddWord("bad")\naddWord("dad")\naddWord("mad")\nsearch("pad") -> false\nsearch("bad") -> true\nsearch(".ad") -> true\nsearch("b..") -> true\n\nNote:\nYou may assume that all words are consist of lowercase letters a-z.
__label__0 Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.\n\xc2\xa0\n\nExample 1:\nInput: "Hello"\nOutput: "hello"\n\n\nExample 2:\nInput: "here"\nOutput: "here"\n\n\nExample 3:\nInput: "LOVELY"\nOutput: "lovely"
__label__0 Given an\xc2\xa0array\xc2\xa0of distinct\xc2\xa0integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\xc2\xa0\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows\n\na, b are from arr\na < b\nb - a\xc2\xa0equals to the minimum absolute difference of any two elements in arr\n\n\xc2\xa0\nExample 1:\nInput: arr = [4,2,1,3]\nOutput: [[1,2],[2,3],[3,4]]\nExplanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\nExample 2:\nInput: arr = [1,3,6,10,15]\nOutput: [[1,3]]\n\nExample 3:\nInput: arr = [3,8,-10,23,19,-4,-14,27]\nOutput: [[-14,-10],[19,23],[23,27]]\n\n\xc2\xa0\nConstraints:\n\n2 <= arr.length <= 10^5\n-10^6 <= arr[i] <= 10^6
__label__0 You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same\xc2\xa0maximum capacity.\nImplement the DinnerPlates class:\n\nDinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks.\nvoid push(int val)\xc2\xa0pushes the given positive integer val into the leftmost stack with size less than capacity.\nint pop()\xc2\xa0returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty.\nint popAtStack(int index)\xc2\xa0returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that\xc2\xa0given index is empty.\n\nExample:\nInput: \n["DinnerPlates","push","push","push","push","push","popAtStack","push","push","popAtStack","popAtStack","pop","pop","pop","pop","pop"]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\nOutput: \n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\nExplanation: \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2 \xc2\xa04\n\xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                           \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88\nD.popAtStack(0);   // Returns 2.  The stacks are now:    \xc2\xa04\n            \xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                                       \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88\nD.push(20);        // The stacks are now: 20  4\n\xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                           \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88\nD.push(21);        // The stacks are now: 20  4 21\n\xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                           \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n             \xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                                        \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n             \xc2\xa0                                          1 \xc2\xa03 \xc2\xa05\n                                                        \xef\xb9\x88 \xef\xb9\x88 \xef\xb9\x88 \nD.pop()            // Returns 5.  The stacks are now:      4\n             \xc2\xa0                                          1 \xc2\xa03 \n                                                        \xef\xb9\x88 \xef\xb9\x88  \nD.pop()            // Returns 4.  The stacks are now:   1 \xc2\xa03 \n                                                        \xef\xb9\x88 \xef\xb9\x88   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        \xef\xb9\x88   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks.\n\n\xc2\xa0\nConstraints:\n\n1 <= capacity\xc2\xa0<= 20000\n1 <= val\xc2\xa0<= 20000\n0 <= index\xc2\xa0<= 100000\nAt most 200000\xc2\xa0calls will be made to push, pop, and popAtStack.
__label__0 In a given 2D binary array A, there are two islands.\xc2\xa0 (An island is a 4-directionally connected group of\xc2\xa01s not connected to any other 1s.)\nNow, we may change 0s to 1s so as to connect the two islands together to form 1 island.\nReturn the smallest number of 0s that must be flipped.\xc2\xa0 (It is guaranteed that the answer is at least 1.)\n\xc2\xa0\nExample 1:\nInput: [[0,1],[1,0]]\nOutput: 1\n\n\nExample 2:\nInput: [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\n\n\nExample 3:\nInput: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n\xc2\xa0\n\n\nNote:\n\n1 <= A.length =\xc2\xa0A[0].length <= 100\nA[i][j] == 0 or A[i][j] == 1
__label__0 Implement pow(x, n), which calculates\xc2\xa0x raised to the power n (xn).\nExample 1:\nInput: 2.00000, 10\nOutput: 1024.00000\n\nExample 2:\nInput: 2.10000, 3\nOutput: 9.26100\n\nExample 3:\nInput: 2.00000, -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\nNote:\n\n-100.0 < x < 100.0\nn is a 32-bit signed integer, within the range\xc2\xa0[\xe2\x88\x92231,\xc2\xa0231\xc2\xa0\xe2\x88\x92 1]
__label__0 Given an array of integers A\xc2\xa0sorted in non-decreasing order,\xc2\xa0return an array of the squares of each number,\xc2\xa0also in sorted non-decreasing order.\n\xc2\xa0\n\nExample 1:\nInput: [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\n\n\nExample 2:\nInput: [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n-10000 <= A[i] <= 10000\nA\xc2\xa0is sorted in non-decreasing order.
__label__0 For a non-negative integer X, the\xc2\xa0array-form of X\xc2\xa0is an array of its digits in left to right order.\xc2\xa0 For example, if X = 1231, then the array form is\xc2\xa0[1,2,3,1].\nGiven the array-form A of a non-negative\xc2\xa0integer X, return the array-form of the integer X+K.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = [1,2,0,0], K = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n\n\nExample 2:\nInput: A = [2,7,4], K = 181\nOutput: [4,5,5]\nExplanation: 274 + 181 = 455\n\n\nExample 3:\nInput: A = [2,1,5], K = 806\nOutput: [1,0,2,1]\nExplanation: 215 + 806 = 1021\n\n\nExample 4:\nInput: A = [9,9,9,9,9,9,9,9,9,9], K = 1\nOutput: [1,0,0,0,0,0,0,0,0,0,0]\nExplanation: 9999999999 + 1 = 10000000000\n\n\xc2\xa0\nNote\xef\xbc\x9a\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\nIf A.length > 1, then A[0] != 0
__label__0 Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nExample:\nInput: S = "ADOBECODEBANC", T = "ABC"\nOutput: "BANC"\n\nNote:\n\nIf there is no such window in S that covers all characters in T, return the empty string "".\nIf there is such window, you are guaranteed that there will always be only one unique minimum window in S.
__label__0 We are given that the string "abc" is valid.\nFrom any valid string V, we may split\xc2\xa0V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V.\xc2\xa0 (X or Y may be empty.)\xc2\xa0 Then, X + "abc" + Y is also valid.\nIf for example S = "abc", then examples of valid strings are: "abc", "aabcbc", "abcabc", "abcabcababcc".\xc2\xa0 Examples of invalid\xc2\xa0strings are: "abccba", "ab", "cababc", "bac".\nReturn true if and only if the given string\xc2\xa0S\xc2\xa0is valid.\n\xc2\xa0\nExample 1:\nInput: "aabcbc"\nOutput: true\nExplanation: \nWe start with the valid string "abc".\nThen we can insert another "abc" between "a" and "bc", resulting in "a" + "abc" + "bc" which is "aabcbc".\n\n\nExample 2:\nInput: "abcabcababcc"\nOutput: true\nExplanation: \n"abcabcabc" is valid after consecutive insertings of "abc".\nThen we can insert "abc" before the last letter, resulting in "abcabcab" + "abc" + "c" which is "abcabcababcc".\n\n\nExample 3:\nInput: "abccba"\nOutput: false\n\n\nExample 4:\nInput: "cababc"\nOutput: false\n\xc2\xa0\n\n\n\nNote:\n\n1 <= S.length <= 20000\nS[i] is \'a\', \'b\', or \'c\'
__label__0 Given an expression\xc2\xa0such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, such as ["-1*a","14"]\n\nAn expression alternates chunks and symbols, with a space separating each chunk and symbol.\nA chunk is either an expression in parentheses, a variable, or a non-negative integer.\nA variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".\n\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = "1 + 2 * 3" has an answer of ["7"].\nThe format of the output is as follows:\n\nFor each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like "b*a*c", only "a*b*c".\nTerms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, "a*a*b*c" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\nThe leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)\xc2\xa0 A leading coefficient of 1 is still printed.\nAn example of a well formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]\xc2\xa0\nTerms (including constant terms) with coefficient 0 are not included.\xc2\xa0 For example, an expression of "0" has an output of [].\n\nExamples:\nInput: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]\nOutput: ["-1*a","14"]\n\nInput: expression = "e - 8 + temperature - pressure",\nevalvars = ["e", "temperature"], evalints = [1, 12]\nOutput: ["-1*pressure","5"]\n\nInput: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []\nOutput: ["1*e*e","-64"]\n\nInput: expression = "7 - 7", evalvars = [], evalints = []\nOutput: []\n\nInput: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []\nOutput: ["5*a*b*c"]\n\nInput: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))",\nevalvars = [], evalints = []\nOutput: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]\n\nNote:\n\nexpression will have length in range [1, 250].\nevalvars, evalints will have equal lengths in range [0, 100].
__label__0 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\nNote:\n\nYour returned answers (both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\n\nExample:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
__label__0 SQL SchemaWrite a SQL query to find all duplicate emails in a table named Person.\n+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\nFor example, your query should return the following for the above table:\n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n\nNote: All emails are in lowercase.
__label__0 On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\nGiven row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).\nExamples:\nInput: N = 1, K = 1\nOutput: 0\n\nInput: N = 2, K = 1\nOutput: 0\n\nInput: N = 2, K = 2\nOutput: 1\n\nInput: N = 4, K = 5\nOutput: 1\n\nExplanation:\nrow 1: 0\nrow 2: 01\nrow 3: 0110\nrow 4: 01101001\n\nNote:\n\nN will be an integer in the range [1, 30].\nK will be an integer in the range [1, 2^(N-1)].
__label__0 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.\nExample 1:\nInput: [[1,1],[2,2],[3,3]]\nOutput: 3\nExplanation:\n^\n|\n| \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0o\n| \xc2\xa0 \xc2\xa0 o\n| \xc2\xa0o \xc2\xa0\n+------------->\n0 \xc2\xa01 \xc2\xa02 \xc2\xa03  4\n\nExample 2:\nInput: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\nExplanation:\n^\n|\n|  o\n| \xc2\xa0\xc2\xa0\xc2\xa0\xc2\xa0o\xc2\xa0\xc2\xa0      o\n| \xc2\xa0\xc2\xa0\xc2\xa0\xc2\xa0   o\n| \xc2\xa0o \xc2\xa0      o\n+------------------->\n0 \xc2\xa01 \xc2\xa02 \xc2\xa03 \xc2\xa04 \xc2\xa05 \xc2\xa06\n\nNOTE:\xc2\xa0input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\nExample 1:\nInput: [1,1,2,2,2]\nOutput: true\n\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n\n\nExample 2:\nInput: [3,3,3,3,4]\nOutput: false\n\nExplanation: You cannot find a way to form a square with all the matchsticks.\n\n\nNote:\n\nThe length sum of the given matchsticks is in the range of 0 to 10^9.\nThe length of the given matchstick array will not exceed 15.
__label__0 Given an array of integers, 1 \xe2\x89\xa4 a[i] \xe2\x89\xa4 n (n = size of array), some elements appear twice and others appear once.\nFind all the elements that appear twice in this array.\nCould you do it without extra space and in O(n) runtime?\n\nExample:\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[2,3]
__label__0 For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page\xe2\x80\x99s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:1. The area of the rectangular web page you designed must equal to the given target area.\n2. The width W should not be larger than the length L, which means L >= W.\n3. The difference between length L and width W should be as small as possible.\n\nYou need to output the length L and the width W of the web page you designed in sequence.\n\nExample:\nInput: 4\nOutput: [2, 2]\nExplanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n\n\nNote:\n\nThe given area won't exceed 10,000,000 and is a positive integer\nThe web page's width and length you designed must be positive integers.
__label__0 Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n\xc2\xa0\nExample:\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nOutput:  [1,2,4,7,5,3,6,8,9]\n\nExplanation:\n\n\n\xc2\xa0\nNote:\nThe total number of elements of the given matrix will not exceed 10,000.
__label__0 You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k\xc2\xa0steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element.\nDetermine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.\n\xc2\xa0\nExample 1:\nInput: [2,-1,1,2,2]\nOutput: true\nExplanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.\n\nExample 2:\nInput: [-1,2]\nOutput: false\nExplanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.\n\nExample 3:\nInput: [-2,1,-1,-2,-2]\nOutput: false\nExplanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction.\n\xc2\xa0\nNote:\n\n-1000 \xe2\x89\xa4\xc2\xa0nums[i] \xe2\x89\xa4\xc2\xa01000\nnums[i] \xe2\x89\xa0\xc2\xa00\n1 \xe2\x89\xa4\xc2\xa0nums.length \xe2\x89\xa4 5000\n\n\xc2\xa0\nFollow up:\nCould you solve it in O(n) time complexity and\xc2\xa0O(1) extra space complexity?
__label__0 Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.\nDesign the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
__label__0 Given two strings representing two complex numbers.\n\nYou need to return a string representing their multiplication. Note i2 = -1 according to the definition.\n\nExample 1:\nInput: "1+1i", "1+1i"\nOutput: "0+2i"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n\n\nExample 2:\nInput: "1+-1i", "1+-1i"\nOutput: "0+-2i"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n\n\nNote:\n\nThe input strings will not have extra blank.\nThe input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.
__label__0 Given a List of words, return the words that can be typed using letters of alphabet on only one row\'s of American keyboard like the image below.\n\xc2\xa0\n\n\xc2\xa0\n\nExample:\nInput: ["Hello", "Alaska", "Dad", "Peace"]\nOutput: ["Alaska", "Dad"]\n\n\xc2\xa0\nNote:\n\nYou may use one character in the keyboard more than once.\nYou may assume the input string will only contain letters of alphabet.
__label__0 There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour?\nAnswer this question, and write an algorithm for the general case.\n\xc2\xa0\nGeneral case: \nIf there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous\xc2\xa0bucket within p minutes? There is exactly one bucket with poison.\n\xc2\xa0\nNote:\n\nA pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time.\nAfter a pig has instantly finished drinking buckets, there has to be a cool down time of m\xc2\xa0minutes. During this time, only observation is allowed and no feedings at all.\nAny given bucket can be sampled an infinite number of times (by an unlimited number of pigs).
__label__0 Given an array of characters, compress it in-place.\nThe length after compression must always be smaller than or equal to the original array.\nEvery element of the array should be a character (not int) of length 1.\nAfter you are done modifying the input array in-place, return the new length of the array.\n\xc2\xa0\n\nFollow up:\nCould you solve it using only O(1) extra space?\n\xc2\xa0\n\nExample 1:\nInput:\n["a","a","b","b","c","c","c"]\n\nOutput:\nReturn 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]\n\nExplanation:\n"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".\n\n\xc2\xa0\nExample 2:\nInput:\n["a"]\n\nOutput:\nReturn 1, and the first 1 characters of the input array should be: ["a"]\n\nExplanation:\nNothing is replaced.\n\n\xc2\xa0\nExample 3:\nInput:\n["a","b","b","b","b","b","b","b","b","b","b","b","b"]\n\nOutput:\nReturn 4, and the first 4 characters of the input array should be: ["a","b","1","2"].\n\nExplanation:\nSince the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".\nNotice each digit has it\'s own entry in the array.\n\n\xc2\xa0\nNote:\n\nAll characters have an ASCII value in [35, 126].\n1 <= len(chars) <= 1000.
__label__0 Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\nYou need to return the number of important reverse pairs in the given array.\nExample1:\nInput: [1,3,2,3,1]\nOutput: 2\n\nExample2:\nInput: [2,4,3,5,1]\nOutput: 3\n\nNote:\n\nThe length of the given array will not exceed 50,000.\nAll the numbers in the input array are in the range of 32-bit integer.
__label__0 Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\nNote:\n\nDivision between two integers should truncate toward zero.\nThe given RPN expression is always valid. That means the expression would always evaluate to a result and there won\'t\xc2\xa0be any\xc2\xa0divide\xc2\xa0by zero operation.\n\nExample 1:\nInput: ["2", "1", "+", "3", "*"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\nInput: ["4", "13", "5", "/", "+"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\nInput: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]\nOutput: 22\nExplanation: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22
__label__0 SQL SchemaSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\nTable: Customers.\n+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n\nTable: Orders.\n+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\nUsing the above tables as example, return the following:\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+
__label__0 A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).\nGiven a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.\nExamples:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: True\nExplanation:\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: False\n\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: True\n\n\nNote:\n\nsx, sy, tx, ty will all be integers in the range [1, 10^9].
__label__0 You\'re given strings J representing the types of stones that are jewels, and S representing the stones you have.\xc2\xa0 Each character in S is a type of stone you have.\xc2\xa0 You want to know how many of the stones you have are also jewels.\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".\nExample 1:\nInput: J = "aA", S = "aAAbbbb"\nOutput: 3\n\nExample 2:\nInput: J = "z", S = "ZZ"\nOutput: 0\n\nNote:\n\nS and J will consist of letters and have length at most 50.\nThe characters in J are distinct.
__label__0 Given a positive integer, return its corresponding column title as appear in an Excel sheet.\nFor example:\n    1 -> A\n    2 -> B\n    3 -> C\n    ...\n    26 -> Z\n    27 -> AA\n    28 -> AB \n    ...\n\nExample 1:\nInput: 1\nOutput: "A"\n\nExample 2:\nInput: 28\nOutput: "AB"\n\nExample 3:\nInput: 701\nOutput: "ZY"
__label__0 Given an array\xc2\xa0A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).\xc2\xa0\xc2\xa0For example, if a character occurs 3 times\xc2\xa0in all strings but not 4 times, you need to include that character three times\xc2\xa0in the final answer.\nYou may return the answer in any order.\n\xc2\xa0\n\nExample 1:\nInput: ["bella","label","roller"]\nOutput: ["e","l","l"]\n\n\nExample 2:\nInput: ["cool","lock","cook"]\nOutput: ["c","o"]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100\nA[i][j] is a lowercase letter
__label__0 Given an array with n objects colored red, white or blue, sort them in-place\xc2\xa0so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote:\xc2\xa0You are not suppose to use the library's sort function for this problem.\nExample:\nInput: [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nFollow up:\n\nA rather straight forward solution is a two-pass algorithm using counting sort.\n\tFirst, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\nCould you come up with a\xc2\xa0one-pass algorithm using only constant space?
__label__0 Given the root of a binary tree, each node has a value from 0 to 25 representing the letters \'a\' to \'z\': a value of 0 represents \'a\', a value of 1 represents \'b\', and so on.\nFind the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\n(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, "ab" is lexicographically smaller than "aba".\xc2\xa0 A leaf of a node is a node that has no children.)\n\n\n\xc2\xa0\n\n\n\n\n\nExample 1:\n\nInput: [0,1,2,3,4,3,4]\nOutput: "dba"\n\n\nExample 2:\n\nInput: [25,1,3,1,3,0,2]\nOutput: "adz"\n\n\nExample 3:\n\nInput: [2,2,1,null,1,0,null,0]\nOutput: "abc"\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the given tree will be between 1 and 8500.\nEach node in the tree will have a value between 0 and 25.
__label__0 Given a linked\xc2\xa0list, rotate the list to the right by k places, where k is non-negative.\nExample 1:\nInput: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\nExplanation:\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n\nExample 2:\nInput: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right:\xc2\xa00->1->2->NULL\nrotate 4 steps to the right:\xc2\xa02->0->1->NULL
__label__0 Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\nIf it is impossible to form any\xc2\xa0triangle of non-zero area, return 0.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [2,1,2]\nOutput: 5\n\n\nExample 2:\nInput: [1,2,1]\nOutput: 0\n\n\nExample 3:\nInput: [3,2,3,4]\nOutput: 10\n\n\nExample 4:\nInput: [3,6,2,3]\nOutput: 8\n\n\xc2\xa0\nNote:\n\n3 <= A.length <= 10000\n1 <= A[i] <= 10^6
__label__0 Given an array of strings, group anagrams together.\nExample:\nInput: ["eat", "tea", "tan", "ate", "nat", "bat"],\nOutput:\n[\n  ["ate","eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]\nNote:\n\nAll inputs will be in lowercase.\nThe order of your output does not\xc2\xa0matter.
__label__0 Given an array A of integers, return true if and only if it is a valid mountain array.\nRecall that A is a mountain array if and only if:\n\nA.length >= 3\nThere exists some i with\xc2\xa00 < i\xc2\xa0< A.length - 1\xc2\xa0such that:\n\t\nA[0] < A[1] < ... A[i-1] < A[i] \nA[i] > A[i+1] > ... > A[A.length - 1]\n\n\n\n\xc2\xa0\nExample 1:\nInput: [2,1]\nOutput: false\n\n\nExample 2:\nInput: [3,5,5]\nOutput: false\n\n\nExample 3:\nInput: [0,3,2,1]\nOutput: true\n\n\n\xc2\xa0\nNote:\n\n0 <= A.length <= 10000\n0 <= A[i] <= 10000
__label__0 Given a\xc2\xa0wordlist, we want to implement a spellchecker that converts a query word into a correct word.\nFor a given query word, the spell checker handles two categories of spelling mistakes:\n\nCapitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n\n\t\nExample: wordlist = ["yellow"], query = "YellOw": correct = "yellow"\nExample: wordlist = ["Yellow"], query = "yellow": correct = "Yellow"\nExample: wordlist = ["yellow"], query = "yellow": correct = "yellow"\n\n\nVowel Errors: If after replacing the vowels (\'a\', \'e\', \'i\', \'o\', \'u\') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.\n\t\nExample: wordlist = ["YellOw"], query = "yollow": correct = "YellOw"\nExample: wordlist = ["YellOw"], query = "yeellow": correct = "" (no match)\nExample: wordlist = ["YellOw"], query = "yllw": correct = "" (no match)\n\n\n\nIn addition, the spell checker operates under the following precedence rules:\n\nWhen the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\nWhen the query matches a word up to capitlization, you should return the first such match in the wordlist.\nWhen the query matches a word up to vowel errors, you should return the first such match in the wordlist.\nIf the query has no matches in the wordlist, you should return the empty string.\n\nGiven some queries, return a\xc2\xa0list of words answer, where answer[i]\xc2\xa0is\xc2\xa0the correct word for query = queries[i].\n\xc2\xa0\nExample 1:\nInput: wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]\nOutput: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]\n\xc2\xa0\nNote:\n\n1 <= wordlist.length <= 5000\n1 <= queries.length <= 5000\n1 <= wordlist[i].length <= 7\n1 <= queries[i].length <= 7\nAll strings in wordlist and queries consist only of english\xc2\xa0letters.
__label__0 Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.\nAfter doing so, return the head of the final linked list.\xc2\xa0 You may return any such answer.\n\xc2\xa0\n(Note that in the examples below, all sequences are serializations of ListNode objects.)\nExample 1:\nInput: head = [1,2,-3,3,1]\nOutput: [3,1]\nNote: The answer [1,2,1] would also be accepted.\n\nExample 2:\nInput: head = [1,2,3,-3,4]\nOutput: [1,2,4]\n\nExample 3:\nInput: head = [1,2,3,-3,-2]\nOutput: [1]\n\n\xc2\xa0\nConstraints:\n\nThe given linked list will contain between 1 and 1000 nodes.\nEach node in the linked list has -1000 <= node.val <= 1000.
__label__0 Write a program that outputs the string representation of numbers from 1 to\xc2\xa0n, however:\n\nIf the number is divisible by 3, output "fizz".\nIf the number is divisible by 5, output\xc2\xa0"buzz".\nIf the number is divisible by both 3 and 5, output\xc2\xa0"fizzbuzz".\n\nFor example, for\xc2\xa0n = 15, we output:\xc2\xa01, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz.\nSuppose you are given the following code:\nclass FizzBuzz {\n\xc2\xa0 public FizzBuzz(int n) { ... }\xc2\xa0              // constructor\n  public void fizz(printFizz) { ... }          // only output "fizz"\n  public void buzz(printBuzz) { ... }          // only output "buzz"\n  public void fizzbuzz(printFizzBuzz) { ... }  // only output "fizzbuzz"\n  public void number(printNumber) { ... }      // only output the numbers\n}\nImplement a multithreaded version of FizzBuzz with four threads. The same instance of FizzBuzz will be passed to four different threads:\n\nThread A will call\xc2\xa0fizz()\xc2\xa0to check for divisibility of 3 and outputs\xc2\xa0fizz.\nThread B will call\xc2\xa0buzz()\xc2\xa0to check for divisibility of 5 and outputs\xc2\xa0buzz.\nThread C will call fizzbuzz()\xc2\xa0to check for divisibility of 3 and 5 and outputs\xc2\xa0fizzbuzz.\nThread D will call number() which should only output the numbers.
__label__0 Given a blacklist\xc2\xa0B containing unique integers\xc2\xa0from [0, N), write a function to return a uniform random integer from [0, N) which is NOT\xc2\xa0in B.\nOptimize it such that it minimizes the call to system\xe2\x80\x99s Math.random().\nNote:\n\n1 <= N <= 1000000000\n0 <= B.length < min(100000, N)\n[0, N)\xc2\xa0does NOT include N. See interval notation.\n\nExample 1:\nInput: \n["Solution","pick","pick","pick"]\n[[1,[]],[],[],[]]\nOutput: [null,0,0,0]\n\nExample 2:\nInput: \n["Solution","pick","pick","pick"]\n[[2,[]],[],[],[]]\nOutput: [null,1,1,1]\n\nExample 3:\nInput: \n["Solution","pick","pick","pick"]\n[[3,[1]],[],[],[]]\nOutput: [null,0,0,2]\n\nExample 4:\nInput: \n["Solution","pick","pick","pick"]\n[[4,[2]],[],[],[]]\nOutput: [null,1,3,1]\n\nExplanation of Input Syntax:\nThe input is two lists:\xc2\xa0the subroutines called\xc2\xa0and their\xc2\xa0arguments.\xc2\xa0Solution\'s\xc2\xa0constructor has two arguments,\xc2\xa0N and the blacklist B. pick has no arguments.\xc2\xa0Arguments\xc2\xa0are\xc2\xa0always wrapped with a list, even if there aren\'t any.
__label__0 Given a 2D board and a list of words from the dictionary, find all words in the board.\nEach word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\xc2\xa0\nExample:\nInput: \nboard = [\n  [\'o\',\'a\',\'a\',\'n\'],\n  [\'e\',\'t\',\'a\',\'e\'],\n  [\'i\',\'h\',\'k\',\'r\'],\n  [\'i\',\'f\',\'l\',\'v\']\n]\nwords = ["oath","pea","eat","rain"]\n\nOutput:\xc2\xa0["eat","oath"]\n\n\xc2\xa0\nNote:\n\nAll inputs are consist of lowercase letters a-z.\nThe values of\xc2\xa0words are distinct.
__label__0 Invert a binary tree.\nExample:\nInput:\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\nOutput:\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\nTrivia:\nThis problem was inspired by this original tweet by Max Howell:\nGoogle: 90% of our engineers use the software you wrote (Homebrew), but you can\xe2\x80\x99t invert a binary tree on a whiteboard so f*** off.
__label__0 Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\n\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n\nReturn a List of ListNode\'s representing the linked list parts that are formed.\n\n\nExamples\n1->2->3->4, k = 5 // 5 equal parts\n[ [1], \n[2],\n[3],\n[4],\nnull ]\n\nExample 1:\nInput: \nroot = [1, 2, 3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe input and each element of the output are ListNodes, not arrays.\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but it\'s string representation as a ListNode is [].\n\n\nExample 2:\nInput: \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n\n\nNote:\nThe length of root will be in the range [0, 1000].\nEach value of a node in the input will be an integer in the range [0, 999].\nk will be an integer in the range [1, 50].
__label__0 Given a complete binary tree, count the number of nodes.\nNote: \nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nExample:\nInput: \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\nOutput: 6
__label__0 Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\nNote:\n\nAll numbers will be positive integers.\nThe solution set must not contain duplicate combinations.\n\nExample 1:\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\n\nExample 2:\nInput: k = 3, n = 9\nOutput: [[1,2,6], [1,3,5], [2,3,4]]
__label__0 Your are given an array of positive integers nums.\nCount and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.\nExample 1:\nInput: nums = [10, 5, 2, 6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n\n\nNote:\n0 < nums.length <= 50000.\n0 < nums[i] < 1000.\n0 <= k < 10^6.
__label__0 Given a string\xc2\xa0text, you want to use the characters of\xc2\xa0text\xc2\xa0to form as many instances of the word "balloon" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n\xc2\xa0\nExample 1:\n\nInput: text = "nlaebolko"\nOutput: 1\n\nExample 2:\n\nInput: text = "loonbalxballpoon"\nOutput: 2\n\nExample 3:\nInput: text = "leetcode"\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= text.length <= 10^4\ntext\xc2\xa0consists of lower case English letters only.
__label__0 With respect to a given puzzle string, a word is valid\xc2\xa0if both the following conditions are satisfied:\n\nword contains the first letter of puzzle.\nFor each letter in word, that letter is in puzzle.\n\tFor example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage"; while invalid words are "beefed" (doesn\'t include "a") and "based" (includes "s" which isn\'t in the puzzle).\n\nReturn an array answer, where answer[i] is the number of words in the given word list\xc2\xa0words that are valid with respect to the puzzle puzzles[i].\n\xc2\xa0\nExample :\nInput: \nwords = ["aaaa","asas","able","ability","actt","actor","access"], \npuzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]\nOutput: [1,1,3,2,4,0]\nExplanation:\n1 valid word\xc2\xa0for "aboveyz" : "aaaa" \n1 valid word\xc2\xa0for "abrodyz" : "aaaa"\n3 valid words for "abslute" : "aaaa", "asas", "able"\n2 valid words for\xc2\xa0"absoryz" : "aaaa", "asas"\n4 valid words for\xc2\xa0"actresz" : "aaaa", "asas", "actt", "access"\nThere\'re\xc2\xa0no valid words for\xc2\xa0"gaswxyz" cause none of the words in the list contains letter \'g\'.\n\n\xc2\xa0\nConstraints:\n\n1 <= words.length <= 10^5\n4 <= words[i].length <= 50\n1 <= puzzles.length <= 10^4\npuzzles[i].length == 7\nwords[i][j], puzzles[i][j] are English lowercase letters.\nEach puzzles[i] doesn\'t contain repeated characters.
__label__0 Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.\nReturn the least number of moves to make every value in A unique.\n\xc2\xa0\nExample 1:\nInput: [1,2,2]\nOutput: 1\nExplanation:  After 1 move, the array could be [1, 2, 3].\n\n\nExample 2:\nInput: [3,2,1,2,1,7]\nOutput: 6\nExplanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].\nIt can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n\n\xc2\xa0\n\nNote:\n\n0 <= A.length <= 40000\n0 <= A[i] < 40000
__label__0 Validate if a given string can be interpreted as\xc2\xa0a decimal number.\nSome examples:\n"0" => true\n" 0.1 " => true\n"abc" => false\n"1 a" => false\n"2e10" => true\n" -90e3\xc2\xa0 \xc2\xa0" => true\n" 1e" => false\n"e3" => false\n" 6e-1" => true\n" 99e2.5\xc2\xa0" => false\n"53.5e93" => true\n" --6 " => false\n"-+3" => false\n"95a54e53" => false\nNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:\n\nNumbers 0-9\nExponent - "e"\nPositive/negative sign - "+"/"-"\nDecimal point - "."\n\nOf course, the context of these characters also matters in the input.\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.
__label__0 Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\n(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\nReturn the number of good subarrays of A.\n\xc2\xa0\nExample 1:\nInput: A = [1,2,1,2,3], K = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n\nExample 2:\nInput: A = [1,2,1,3,4], K = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= A.length\n1 <= K <= A.length
__label__0 Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.\nIn a UNIX-style file system, a period .\xc2\xa0refers to the current directory. Furthermore, a double period ..\xc2\xa0moves the directory up a level. For more information, see:\xc2\xa0Absolute path\xc2\xa0vs\xc2\xa0relative\xc2\xa0path\xc2\xa0in\xc2\xa0Linux/Unix\nNote that the returned canonical path must always begin\xc2\xa0with a slash /, and there must be only a single slash /\xc2\xa0between two directory names.\xc2\xa0The last directory name (if it exists) must not\xc2\xa0end with a trailing /. Also, the canonical path must be the shortest string\xc2\xa0representing the absolute path.\n\xc2\xa0\nExample 1:\nInput: "/home/"\nOutput: "/home"\nExplanation: Note that there is no trailing slash after the last directory name.\n\nExample 2:\nInput: "/../"\nOutput: "/"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\nExample 3:\nInput: "/home//foo/"\nOutput: "/home/foo"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n\nExample 4:\nInput: "/a/./b/../../c/"\nOutput: "/c"\n\nExample 5:\nInput: "/a/../../b/../c//.//"\nOutput: "/c"\n\nExample 6:\nInput: "/a//b////c/d//././/.."\nOutput: "/a/b/c"
__label__0 We are given the root\xc2\xa0node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.\nJust as in the previous problem, the given tree\xc2\xa0was constructed from an list\xc2\xa0A\xc2\xa0(root = Construct(A)) recursively with the following\xc2\xa0Construct(A) routine:\n\nIf A is empty, return null.\nOtherwise, let A[i] be the largest element of A.\xc2\xa0 Create a root node with value A[i].\nThe left child of root will be Construct([A[0], A[1], ..., A[i-1]])\nThe right child of root\xc2\xa0will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])\nReturn root.\n\nNote that we were not given A directly, only a root node root = Construct(A).\nSuppose B is a copy of A with the value val appended to it.\xc2\xa0 It is guaranteed that B has unique values.\nReturn Construct(B).\n\xc2\xa0\nExample 1:\n\nInput: root = [4,1,3,null,null,2], val = 5\nOutput: [5,4,null,1,3,null,null,2]\nExplanation: A = [1,4,2,3], B = [1,4,2,3,5]\n\n\nExample 2:\n\nInput: root = [5,2,4,null,1], val = 3\nOutput: [5,2,4,null,1,null,3]\nExplanation: A = [2,1,5,4], B = [2,1,5,4,3]\n\n\nExample 3:\n\nInput: root = [5,2,3,null,1], val = 4\nOutput: [5,2,4,null,1,3]\nExplanation: A = [2,1,5,3], B = [2,1,5,3,4]\n\n\xc2\xa0\n\n\nNote:\n\n1 <= B.length <= 100
__label__0 Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\nExample:\nInput: 3\nOutput:\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]
__label__0 Given two lists\xc2\xa0of closed intervals, each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\n(Formally, a closed interval [a, b] (with a <= b) denotes\xc2\xa0the set of real numbers x with a <= x <= b.\xc2\xa0 The\xc2\xa0intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.\xc2\xa0 For example, the intersection of [1, 3] and [2, 4] is [2, 3].)\n\n\xc2\xa0\nExample 1:\n\nInput: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]\nOutput: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\nReminder: The inputs and the desired output are lists of Interval\xc2\xa0objects, and not arrays or lists.\n\n\xc2\xa0\nNote:\n\n0 <= A.length < 1000\n0 <= B.length < 1000\n0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9\n\nNOTE:\xc2\xa0input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nExample 1:\nInput: numerator = 1, denominator = 2\nOutput: "0.5"\n\nExample 2:\nInput: numerator = 2, denominator = 1\nOutput: "2"\nExample 3:\nInput: numerator = 2, denominator = 3\nOutput: "0.(6)"
__label__0 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\nCalling next() will return the next smallest number in the BST.\n\xc2\xa0\n\n\nExample:\n\nBSTIterator iterator = new BSTIterator(root);\niterator.next();    // return 3\niterator.next();    // return 7\niterator.hasNext(); // return true\niterator.next();    // return 9\niterator.hasNext(); // return true\niterator.next();    // return 15\niterator.hasNext(); // return true\niterator.next();    // return 20\niterator.hasNext(); // return false\n\n\xc2\xa0\nNote:\n\nnext() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\nYou may assume that\xc2\xa0next()\xc2\xa0call\xc2\xa0will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
__label__0 Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.\nIf possible, output any possible result.\xc2\xa0 If not possible, return the empty string.\nExample 1:\nInput: S = "aab"\nOutput: "aba"\n\nExample 2:\nInput: S = "aaab"\nOutput: ""\n\nNote:\n\nS will consist of lowercase letters and have length in range [1, 500].
__label__0 Given a string S, we can transform every letter individually\xc2\xa0to be lowercase or uppercase to create another string.\xc2\xa0 Return a list of all possible strings we could create.\nExamples:\nInput: S = "a1b2"\nOutput: ["a1b2", "a1B2", "A1b2", "A1B2"]\n\nInput: S = "3z4"\nOutput: ["3z4", "3Z4"]\n\nInput: S = "12345"\nOutput: ["12345"]\n\nNote:\n\nS will be a string with length between 1 and 12.\nS will consist only of letters or digits.
__label__0 Given a list of non negative integers, arrange them such that they form the largest number.\nExample 1:\nInput: [10,2]\nOutput: "210"\nExample 2:\nInput: [3,30,34,5,9]\nOutput: "9534330"\n\nNote: The result may be very large, so you need to return a string instead of an integer.
__label__0 You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.\nGiven a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.\nGiven a non-empty string S and a number K, format the string according to the rules described above.\nExample 1:\nInput: S = "5F3Z-2e-9-w", K = 4\n\nOutput: "5F3Z-2E9W"\n\nExplanation: The string S has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\n\nExample 2:\nInput: S = "2-5g-3-J", K = 2\n\nOutput: "2-5G-3J"\n\nExplanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n\n\nNote:\n\nThe length of string S will not exceed 12,000, and K is a positive integer.\nString S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\nString S is non-empty.
__label__0 Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn\'t exist, return -1.\n\nExample 1:\nInput: "aba", "cdc", "eae"\nOutput: 3\n\n\nNote:\n\nAll the given strings\' lengths will not exceed 10.\nThe length of the given list will be in the range of [2, 50].
__label__0 Given an array of integers where 1 \xe2\x89\xa4 a[i] \xe2\x89\xa4 n (n = size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nExample:\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[5,6]
__label__0 Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 \xe2\x89\xa4 N \xe2\x89\xa4 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\nExample:\nInput:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\nOutput:\n2\n\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
__label__0 Given an integer, return its base 7 string representation.\nExample 1:\nInput: 100\nOutput: "202"\n\n\nExample 2:\nInput: -7\nOutput: "-10"\n\n\nNote:\nThe input will be in range of [-1e7, 1e7].
__label__0 Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\nExample:\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
__label__0 Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n\nExample 1:\nInput: [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.\n\n\nNote:\nThe length of given array won't exceed 10000.
__label__0 Given a binary array, find the maximum number of consecutive 1s in this array.\nExample 1:\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n\n\nNote:\n\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000
__label__0 Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\nFind the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).\nExample:\nInput:\n[[0,0],[1,0],[2,0]]\n\nOutput:\n2\n\nExplanation:\nThe two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
__label__0 Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn\'t exist, return -1.\n\nExample 1:\nInput: "aba", "cdc"\nOutput: 3\nExplanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. \n\n\nNote:\n\nBoth strings\' lengths will not exceed 100.\nOnly letters from a ~ z will appear in input strings.
__label__0 For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.\nNow given a string representing n, you should return the smallest good base of n in string format.\nExample 1:\nInput: "13"\nOutput: "3"\nExplanation: 13 base 3 is 111.\n\n\xc2\xa0\nExample 2:\nInput: "4681"\nOutput: "8"\nExplanation: 4681 base 8 is 11111.\n\n\xc2\xa0\nExample 3:\nInput: "1000000000000000000"\nOutput: "999999999999999999"\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\n\n\xc2\xa0\nNote:\n\nThe range of n is [3, 10^18].\nThe string representing n is always valid and will not have leading zeros.
__label__0 Given a Binary Search Tree (BST) with the root node root, return\xc2\xa0the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]\nOutput: 1\nExplanation:\nNote that root is a TreeNode object, not an array.\n\nThe given tree [4,2,6,1,3,null,null] is represented by the following diagram:\n\n          4\n        /   \\\n      2      6\n     / \\    \n    1   3  \n\nwhile the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.\n\nNote:\n\nThe size of the BST will be between 2 and\xc2\xa0100.\nThe BST is always valid, each node's value is an integer, and each node's value is different.
__label__0 SQL SchemaWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.\n+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\nFor example, given the above Scores table, your query should generate the following report (order by highest score):\n+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n|\xc2\xa03.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+
__label__0 Given an integer n, return the number of trailing zeroes in n!.\nExample 1:\nInput: 3\nOutput: 0\nExplanation:\xc2\xa03! = 6, no trailing zero.\nExample 2:\nInput: 5\nOutput: 1\nExplanation:\xc2\xa05! = 120, one trailing zero.\nNote: Your solution should be in logarithmic time complexity.
__label__0 A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.\nNow given an M x N matrix, return\xc2\xa0True\xc2\xa0if and only if the matrix is Toeplitz.\n\xc2\xa0\nExample 1:\nInput:\nmatrix = [\n\xc2\xa0 [1,2,3,4],\n\xc2\xa0 [5,1,2,3],\n\xc2\xa0 [9,5,1,2]\n]\nOutput: True\nExplanation:\nIn the above grid, the\xc2\xa0diagonals are:\n"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".\nIn each diagonal all elements are the same, so the answer is True.\n\nExample 2:\nInput:\nmatrix = [\n\xc2\xa0 [1,2],\n\xc2\xa0 [2,2]\n]\nOutput: False\nExplanation:\nThe diagonal "[1, 2]" has different elements.\n\n\nNote:\n\nmatrix will be a 2D array of integers.\nmatrix will have a number of rows and columns in range [1, 20].\nmatrix[i][j] will be integers in range [0, 99].\n\n\nFollow up:\n\nWhat if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\nWhat if the matrix is so large that you can only load up a partial row into the memory at once?
__label__0 Compare two version numbers version1 and version2.\nIf version1 > version2 return 1;\xc2\xa0if version1 < version2 return -1;otherwise return 0.\nYou may assume that the version strings are non-empty and contain only digits and the . character.\nThe . character does not represent a decimal point and is used to separate number sequences.\nFor instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.\nYou may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.\n\xc2\xa0\nExample 1:\nInput: version1 = "0.1", version2 = "1.1"\nOutput: -1\nExample 2:\nInput: version1 = "1.0.1", version2 = "1"\nOutput: 1\nExample 3:\nInput: version1 = "7.5.2.4", version2 = "7.5.3"\nOutput: -1\nExample 4:\nInput: version1 = "1.01", version2 = "1.001"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \xe2\x80\x9c01\xe2\x80\x9d and \xe2\x80\x9c001" represent the same number \xe2\x80\x9c1\xe2\x80\x9d\nExample 5:\nInput: version1 = "1.0", version2 = "1.0.0"\nOutput: 0\nExplanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"\n\xc2\xa0\nNote:\n\nVersion strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. \nVersion strings do not start or end with dots, and they will not be two consecutive dots.
__label__0 Given a binary tree, return the vertical order traversal of its nodes\xc2\xa0values.\nFor each node at position (X, Y), its left and right children respectively\xc2\xa0will be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).\nIf two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\nReturn an list\xc2\xa0of non-empty reports in order of X coordinate.\xc2\xa0 Every report will have a list of values of nodes.\n\xc2\xa0\nExample 1:\n\n\nInput: [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation: \nWithout loss of generality, we can assume the root node is at position (0, 0):\nThen, the node with value 9 occurs at position (-1, -1);\nThe nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);\nThe node with value 20 occurs at position (1, -1);\nThe node with value 7 occurs at position (2, -2).\n\n\nExample 2:\n\nInput: [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation: \nThe node with value 5 and the node with value 6 have the same position according to the given scheme.\nHowever, in the report "[1,5,6]", the node value of 5 comes first since 5 is smaller than 6.\n\n\xc2\xa0\n\nNote:\n\nThe tree will have between 1\xc2\xa0and 1000 nodes.\nEach node\'s value will be between 0 and 1000.
__label__0 The set [1,2,3,...,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n"123"\n"132"\n"213"\n"231"\n"312"\n"321"\n\nGiven n and k, return the kth permutation sequence.\nNote:\n\nGiven n will be between 1 and 9 inclusive.\nGiven\xc2\xa0k\xc2\xa0will be between 1 and n! inclusive.\n\nExample 1:\nInput: n = 3, k = 3\nOutput: "213"\n\nExample 2:\nInput: n = 4, k = 9\nOutput: "2314"
__label__0 On an 8 x 8 chessboard, there is one white rook.\xc2\xa0 There also may be empty squares, white bishops, and black pawns.\xc2\xa0 These are given as characters \'R\', \'.\', \'B\', and \'p\' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.\nThe rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.\xc2\xa0 Also, rooks cannot move into the same square as other friendly bishops.\nReturn the number of pawns the rook can capture in one move.\n\xc2\xa0\nExample 1:\n\nInput: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]\nOutput: 3\nExplanation: \nIn this example the rook is able to capture all the pawns.\n\nExample 2:\n\nInput: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]\nOutput: 0\nExplanation: \nBishops are blocking the rook to capture any pawn.\n\nExample 3:\n\nInput: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]\nOutput: 3\nExplanation: \nThe rook can capture the pawns at positions b5, d6 and f5.\n\n\xc2\xa0\nNote:\n\nboard.length == board[i].length == 8\nboard[i][j] is either \'R\', \'.\', \'B\', or\xc2\xa0\'p\'\nThere is exactly one cell with board[i][j] == \'R\'
__label__0 In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.\nTwo nodes of a binary tree are cousins if they have the same depth, but have different parents.\nWe are given the root of a binary tree with unique values, and the values x\xc2\xa0and y\xc2\xa0of two different nodes in the tree.\nReturn\xc2\xa0true\xc2\xa0if and only if the nodes corresponding to the values x and y are cousins.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4], x = 4, y = 3\nOutput: false\n\n\nExample 2:\n\nInput: root = [1,2,3,null,4,null,5], x = 5, y = 4\nOutput: true\n\n\nExample 3:\n\nInput: root = [1,2,3,null,4], x = 2, y = 3\nOutput: false\n\xc2\xa0\n\n\nNote:\n\nThe number of nodes in the tree will be between 2 and 100.\nEach node has a unique integer value from 1 to 100.
__label__0 Given a non-empty array of digits\xc2\xa0representing a non-negative integer, plus one to the integer.\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n\nExample 2:\nInput: [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.
__label__0 In an array A of 0s and 1s, how many non-empty subarrays have sum S?\n\xc2\xa0\nExample 1:\nInput: A = [1,0,1,0,1], S = 2\nOutput: 4\nExplanation: \nThe 4 subarrays are bolded below:\n[1,0,1,0,1]\n[1,0,1,0,1]\n[1,0,1,0,1]\n[1,0,1,0,1]\n\n\xc2\xa0\nNote:\n\nA.length <= 30000\n0 <= S <= A.length\nA[i]\xc2\xa0is either 0\xc2\xa0or 1.
__label__0 We are given an array\xc2\xa0A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"],\xc2\xa0and the remaining columns of A are\xc2\xa0["b","v"], ["e","y"], and ["f","z"].\xc2\xa0 (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].)\nSuppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.\nReturn the minimum possible value of D.length.\n\xc2\xa0\n\nExample 1:\nInput: ["cba","daf","ghi"]\nOutput: 1\nExplanation: \nAfter choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order.\nIf we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.\n\n\nExample 2:\nInput: ["a","b"]\nOutput: 0\nExplanation: D = {}\n\n\nExample 3:\nInput: ["zyx","wvu","tsr"]\nOutput: 3\nExplanation: D = {0, 1, 2}\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 1000
__label__0 SQL SchemaTable: Department\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| revenue       | int     |\n| month         | varchar |\n+---------------+---------+\n(id, month) is the primary key of this table.\nThe table has information about the revenue of each department per month.\nThe month has values in ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"].\n\n\xc2\xa0\nWrite an SQL query to reformat the table such that there is a department id column\xc2\xa0and a revenue column for each month.\nThe query result format is in the following example:\nDepartment table:\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\n\nResult table:\n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\n\nNote that the result table has 13 columns (1 for the department id + 12 for the months).
__label__0 There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n\nIf a cell has two adjacent neighbors that are both occupied or both vacant,\xc2\xa0then the cell becomes occupied.\nOtherwise, it becomes vacant.\n\n(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)\nWe describe the current state of the prison\xc2\xa0in the following way:\xc2\xa0cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\nGiven the initial state of the prison, return the state of the prison after N days (and N such changes described above.)\n\xc2\xa0\n\n\n\n\n\nExample 1:\nInput: cells = [0,1,0,1,1,0,0,1], N = 7\nOutput: [0,0,1,1,0,0,0,0]\nExplanation: \nThe following table summarizes the state of the prison on each day:\nDay 0: [0, 1, 0, 1, 1, 0, 0, 1]\nDay 1: [0, 1, 1, 0, 0, 0, 0, 0]\nDay 2: [0, 0, 0, 0, 1, 1, 1, 0]\nDay 3: [0, 1, 1, 0, 0, 1, 0, 0]\nDay 4: [0, 0, 0, 0, 0, 1, 0, 0]\nDay 5: [0, 1, 1, 1, 0, 1, 0, 0]\nDay 6: [0, 0, 1, 0, 1, 1, 0, 0]\nDay 7: [0, 0, 1, 1, 0, 0, 0, 0]\n\n\n\nExample 2:\nInput: cells = [1,0,0,1,0,0,1,0], N = 1000000000\nOutput: [0,0,1,1,1,1,1,0]\n\n\xc2\xa0\nNote:\n\ncells.length == 8\ncells[i] is in {0, 1}\n1 <= N <= 10^9
__label__0 You are given a string s that consists of lower case English letters and brackets.\xc2\xa0\nReverse the strings\xc2\xa0in each\xc2\xa0pair of matching parentheses, starting\xc2\xa0from the innermost one.\nYour result should not contain any brackets.\n\xc2\xa0\nExample 1:\nInput: s = "(abcd)"\nOutput: "dcba"\n\nExample 2:\nInput: s = "(u(love)i)"\nOutput: "iloveu"\nExplanation:\xc2\xa0The substring "love" is reversed first, then the whole string is reversed.\n\nExample 3:\nInput: s = "(ed(et(oc))el)"\nOutput: "leetcode"\nExplanation:\xc2\xa0First, we reverse the substring "oc", then "etco", and finally, the whole string.\n\nExample 4:\nInput: s = "a(bcdefghijkl(mno)p)q"\nOutput: "apmnolkjihgfedcbq"\n\n\xc2\xa0\nConstraints:\n\n0 <= s.length <= 2000\ns only contains lower case English characters and parentheses.\nIt\'s guaranteed that all parentheses are balanced.
__label__0 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nExample 1:\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n\nExample 2:\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\nNote: \nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 array's length.
__label__0 Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\nA double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\nExample 1:\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\nExplanation: \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n\n\xc2\xa0\nNote:\n\nThe number of calls to MyCalendar.book per test case will be at most 1000.\nIn calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].
__label__0 Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\nExample 1:\nInput: [1, 2, 2, 3, 1]\nOutput: 2\nExplanation: \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.\n\n\nExample 2:\nInput: [1,2,2,3,1,4,2]\nOutput: 6\n\n\nNote:\nnums.length will be between 1 and 50,000.\nnums[i] will be an integer between 0 and 49,999.
__label__0 In a given integer array nums, there is always exactly one largest element.\nFind whether the largest element in the array is at least twice as much as every other number in the array.\nIf it is, return the index of the largest element, otherwise return -1.\nExample 1:\nInput: nums = [3, 6, 1, 0]\nOutput: 1\nExplanation: 6 is the largest integer, and for every other number in the array x,\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\n\n\xc2\xa0\nExample 2:\nInput: nums = [1, 2, 3, 4]\nOutput: -1\nExplanation: 4 isn't at least as big as twice the value of 3, so we return -1.\n\n\xc2\xa0\nNote:\n\nnums will have a length in the range [1, 50].\nEvery nums[i] will be an integer in the range [0, 99].
__label__0 Write a program to check whether a given number is an ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5.\nExample 1:\nInput: 6\nOutput: true\nExplanation: 6 = 2 \xc3\x97\xc2\xa03\nExample 2:\nInput: 8\nOutput: true\nExplanation: 8 = 2 \xc3\x97 2 \xc3\x97\xc2\xa02\n\nExample 3:\nInput: 14\nOutput: false \nExplanation: 14 is not ugly since it includes another prime factor 7.\n\nNote:\n\n1 is typically treated as an ugly number.\nInput is within the 32-bit signed integer range:\xc2\xa0[\xe2\x88\x92231,\xc2\xa0 231\xc2\xa0\xe2\x88\x92 1].
__label__0 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n\n\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n\n\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false
__label__0 Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.\nYour class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\nA triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\nExample 1:\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(50, 60); // returns true\nMyCalendar.book(10, 40); // returns true\nMyCalendar.book(5, 15); // returns false\nMyCalendar.book(5, 10); // returns true\nMyCalendar.book(25, 55); // returns true\nExplanation: \nThe first two events can be booked.  The third event can be double booked.\nThe fourth event (5, 15) can't be booked, because it would result in a triple booking.\nThe fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.\nThe sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;\nthe time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\n\n\xc2\xa0\nNote:\n\nThe number of calls to MyCalendar.book per test case will be at most 1000.\nIn calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].
__label__0 Given a date, return the corresponding day of the week for that date.\nThe input is given as three integers representing the day, month and year respectively.\nReturn the answer as one of the following values\xc2\xa0{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.\n\xc2\xa0\nExample 1:\nInput: day = 31, month = 8, year = 2019\nOutput: "Saturday"\n\nExample 2:\nInput: day = 18, month = 7, year = 1999\nOutput: "Sunday"\n\nExample 3:\nInput: day = 15, month = 8, year = 1993\nOutput: "Sunday"\n\n\xc2\xa0\nConstraints:\n\nThe given dates are valid\xc2\xa0dates between the years 1971 and 2100.
__label__0 There are\xc2\xa0n servers numbered from\xc2\xa00\xc2\xa0to\xc2\xa0n-1 connected by\xc2\xa0undirected server-to-server connections forming a network where connections[i] = [a, b]\xc2\xa0represents a connection between servers a\xc2\xa0and b. Any server can reach any other server directly or indirectly through the network.\nA critical connection\xc2\xa0is a connection that, if removed, will make some server unable to reach some other server.\nReturn all critical connections in the network in any order.\n\xc2\xa0\nExample 1:\n\nInput: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\nOutput: [[1,3]]\nExplanation: [[3,1]] is also accepted.\n\n\xc2\xa0\nConstraints:\n\n1 <= n <= 10^5\nn-1 <= connections.length <= 10^5\nconnections[i][0] != connections[i][1]\nThere are no repeated connections.
__label__0 We are given two arrays A and B of words.\xc2\xa0 Each word is a string of lowercase letters.\nNow, say that\xc2\xa0word b is a subset of word a\xc2\xa0if every letter in b occurs in a, including multiplicity.\xc2\xa0 For example, "wrr" is a subset of "warrior", but is not a subset of "world".\nNow say a word a from A is universal if for every b in B, b\xc2\xa0is a subset of a.\xc2\xa0\nReturn a list of all universal words in A.\xc2\xa0 You can return the words in any order.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]\nOutput: ["facebook","google","leetcode"]\n\n\nExample 2:\nInput: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]\nOutput: ["apple","google","leetcode"]\n\n\nExample 3:\nInput: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]\nOutput: ["facebook","google"]\n\n\nExample 4:\nInput: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]\nOutput: ["google","leetcode"]\n\n\nExample 5:\nInput: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]\nOutput: ["facebook","leetcode"]\n\n\xc2\xa0\nNote:\n\n1 <= A.length, B.length <= 10000\n1 <= A[i].length, B[i].length\xc2\xa0<= 10\nA[i] and B[i] consist only of lowercase letters.\nAll words in A[i] are unique: there isn\'t i != j with A[i] == A[j].
__label__0 (This problem is the same as Minimize Malware Spread, with the differences bolded.)\nIn a network of nodes, each node i is directly connected to another node j if and only if\xc2\xa0graph[i][j] = 1.\nSome nodes initial are initially infected by malware.\xc2\xa0 Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.\xc2\xa0 This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial)\xc2\xa0is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will\xc2\xa0remove one node from the initial list, completely removing it and any connections from this node to any other node.\xc2\xa0 Return the node that if removed, would minimize\xc2\xa0M(initial).\xc2\xa0 If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\xc2\xa0\n\n\n\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\n\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\n\n\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\n\n\xc2\xa0\nNote:\n\n1 < graph.length = graph[0].length <= 300\n0 <= graph[i][j] == graph[j][i] <= 1\ngraph[i][i] = 1\n1 <= initial.length < graph.length\n0 <= initial[i] < graph.length
__label__0 Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length.\nReturn any permutation A of [0, 1, ..., N] such that for all i = 0,\xc2\xa0..., N-1:\n\nIf S[i] == "I", then A[i] < A[i+1]\nIf S[i] == "D", then A[i] > A[i+1]\n\n\xc2\xa0\nExample 1:\nInput: "IDID"\nOutput: [0,4,1,3,2]\n\n\nExample 2:\nInput: "III"\nOutput: [0,1,2,3]\n\n\nExample 3:\nInput: "DDI"\nOutput: [3,2,0,1]\n\n\n\xc2\xa0\nNote:\n\n1 <= S.length <= 10000\nS only contains characters "I" or "D".
__label__0 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\nIntegers in each row are sorted from left to right.\nThe first integer of each row is greater than the last integer of the previous row.\n\nExample 1:\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\nOutput: true\n\nExample 2:\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\nOutput: false
__label__0 On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp.\nInitially, some number of lamps are on.\xc2\xa0 lamps[i] tells us the location of the i-th lamp that is on.\xc2\xa0 Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).\nFor the i-th query\xc2\xa0queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0.\nAfter each query (x, y) [in the order given by queries], we turn off any\xc2\xa0lamps that are at cell (x, y)\xc2\xa0or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).)\nReturn an array of answers.\xc2\xa0 Each\xc2\xa0value answer[i] should be equal to the answer of the i-th query queries[i].\n\xc2\xa0\nExample 1:\nInput: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\nOutput: [1,0]\nExplanation: \nBefore performing the first query we have both lamps [0,0] and [4,4] on.\nThe grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner:\n1 1 1 1 1\n1 1 0 0 1\n1 0 1 0 1\n1 0 0 1 1\n1 1 1 1 1\nThen the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this:\n1 0 0 0 1\n0 1 0 0 1\n0 0 1 0 1\n0 0 0 1 1\n1 1 1 1 1\nBefore performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10^9\n0 <= lamps.length <= 20000\n0 <= queries.length <= 20000\nlamps[i].length == queries[i].length == 2
__label__0 Given an array of words and a width\xc2\xa0maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \' \' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left justified and no extra space is inserted between words.\nNote:\n\nA word is defined as a character sequence consisting\xc2\xa0of non-space characters only.\nEach word\'s length is\xc2\xa0guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words\xc2\xa0contains at least one word.\n\nExample 1:\nInput:\nwords = ["This", "is", "an", "example", "of", "text", "justification."]\nmaxWidth = 16\nOutput:\n[\n\xc2\xa0 \xc2\xa0"This \xc2\xa0 \xc2\xa0is \xc2\xa0 \xc2\xa0an",\n\xc2\xa0 \xc2\xa0"example \xc2\xa0of text",\n\xc2\xa0 \xc2\xa0"justification. \xc2\xa0"\n]\n\nExample 2:\nInput:\nwords = ["What","must","be","acknowledgment","shall","be"]\nmaxWidth = 16\nOutput:\n[\n\xc2\xa0 "What \xc2\xa0 must \xc2\xa0 be",\n\xc2\xa0 "acknowledgment \xc2\xa0",\n\xc2\xa0 "shall be \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0"\n]\nExplanation: Note that the last line is "shall be    " instead of "shall     be",\n\xc2\xa0            because the last line must be left-justified instead of fully-justified.\n             Note that the second line is also left-justified becase it contains only one word.\n\nExample 3:\nInput:\nwords = ["Science","is","what","we","understand","well","enough","to","explain",\n\xc2\xa0        "to","a","computer.","Art","is","everything","else","we","do"]\nmaxWidth = 20\nOutput:\n[\n\xc2\xa0 "Science \xc2\xa0is \xc2\xa0what we",\n  "understand \xc2\xa0 \xc2\xa0 \xc2\xa0well",\n\xc2\xa0 "enough to explain to",\n\xc2\xa0 "a \xc2\xa0computer. \xc2\xa0Art is",\n\xc2\xa0 "everything \xc2\xa0else \xc2\xa0we",\n\xc2\xa0 "do \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0"\n]
__label__0 In an array A containing only 0s and 1s, a K-bit flip\xc2\xa0consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of K-bit flips required so that there is no 0 in the array.\xc2\xa0 If it is not possible, return -1.\n\xc2\xa0\nExample 1:\nInput: A = [0,1,0], K = 1\nOutput: 2\nExplanation: Flip A[0], then flip A[2].\n\n\nExample 2:\nInput: A = [1,1,0], K = 2\nOutput: -1\nExplanation:\xc2\xa0No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].\n\n\nExample 3:\nInput: A = [0,0,0,1,0,1,1,0], K = 3\nOutput: 3\nExplanation:\nFlip A[0],A[1],A[2]:\xc2\xa0A becomes [1,1,1,1,0,1,1,0]\nFlip A[4],A[5],A[6]:\xc2\xa0A becomes [1,1,1,1,1,0,0,0]\nFlip A[5],A[6],A[7]:\xc2\xa0A becomes [1,1,1,1,1,1,1,1]\n\n\xc2\xa0\n\n\nNote:\n\n1 <= A.length <=\xc2\xa030000\n1 <= K <= A.length
__label__0 Implement a trie with insert, search, and startsWith methods.\nExample:\nTrie trie = new Trie();\n\ntrie.insert("apple");\ntrie.search("apple");   // returns true\ntrie.search("app");     // returns false\ntrie.startsWith("app"); // returns true\ntrie.insert("app");   \ntrie.search("app");     // returns true\n\nNote:\n\nYou may assume that all inputs are consist of lowercase letters a-z.\nAll inputs are guaranteed to be non-empty strings.
__label__0 We are given an array A of positive integers, and two positive integers L and R (L <= R).\nReturn the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.\nExample :\nInput: \nA = [2, 1, 4, 3]\nL = 2\nR = 3\nOutput: 3\nExplanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].\n\nNote:\n\nL, R\xc2\xa0 and A[i] will be an integer in the range [0, 10^9].\nThe length of A will be in the range of [1, 50000].
__label__0 SQL SchemaWrite a SQL query to find all numbers that appear at least three times consecutively.\n+----+-----+\n| Id | Num |\n+----+-----+\n| 1  |  1  |\n| 2  |  1  |\n| 3  |  1  |\n| 4  |  2  |\n| 5  |  1  |\n| 6  |  2  |\n| 7  |  2  |\n+----+-----+\n\nFor example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.\n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+
__label__0 In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.\nReturn the minimum number of rabbits that could be in the forest.\nExamples:\nInput: answers = [1, 1, 2]\nOutput: 5\nExplanation:\nThe two rabbits that answered "1" could both be the same color, say red.\nThe rabbit than answered "2" can\'t be red or the answers would be inconsistent.\nSay the rabbit that answered "2" was blue.\nThen there should be 2 other blue rabbits in the forest that didn\'t answer into the array.\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn\'t.\n\nInput: answers = [10, 10, 10]\nOutput: 11\n\nInput: answers = []\nOutput: 0\n\nNote:\n\nanswers will have length at most 1000.\nEach answers[i] will be an integer in the range [0, 999].
__label__0 Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nExample 1:\nInput: [1,3,null,null,2]\n\n\xc2\xa0  1\n\xc2\xa0 /\n\xc2\xa03\n\xc2\xa0 \\\n\xc2\xa0  2\n\nOutput: [3,1,null,null,2]\n\n\xc2\xa0  3\n\xc2\xa0 /\n\xc2\xa01\n\xc2\xa0 \\\n\xc2\xa0  2\n\nExample 2:\nInput: [3,1,4,null,null,2]\n\n  3\n / \\\n1   4\n\xc2\xa0  /\n\xc2\xa0 2\n\nOutput: [2,1,4,null,null,3]\n\n  2\n / \\\n1   4\n\xc2\xa0  /\n \xc2\xa03\n\nFollow up:\n\nA solution using O(n) space is pretty straight forward.\nCould you devise a constant space solution?
__label__0 You are given a binary tree in which each node contains an integer value.\nFind the number of paths that sum to a given value.\nThe path does not need to start or end at the root or a leaf, but it must go downwards\n(traveling only from parent nodes to child nodes).\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n\nExample:\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3. -3 -> 11
__label__0 Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".\nExample 1:\nInput: [5, 4, 3, 2, 1]\nOutput: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]\nExplanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". For the left two athletes, you just need to output their relative ranks according to their scores.\n\n\nNote:\n\nN is a positive integer and won\'t exceed 10,000.\nAll the scores of athletes are guaranteed to be unique.
__label__0 Given a string, sort it in decreasing order based on the frequency of characters.\nExample 1:\nInput:\n"tree"\n\nOutput:\n"eert"\n\nExplanation:\n\'e\' appears twice while \'r\' and \'t\' both appear once.\nSo \'e\' must appear before both \'r\' and \'t\'. Therefore "eetr" is also a valid answer.\n\n\nExample 2:\nInput:\n"cccaaa"\n\nOutput:\n"cccaaa"\n\nExplanation:\nBoth \'c\' and \'a\' appear three times, so "aaaccc" is also a valid answer.\nNote that "cacaca" is incorrect, as the same characters must be together.\n\n\nExample 3:\nInput:\n"Aabb"\n\nOutput:\n"bbAa"\n\nExplanation:\n"bbaA" is also a valid answer, but "Aabb" is incorrect.\nNote that \'A\' and \'a\' are treated as two different characters.
__label__0 You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up:\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n\n\nExample:\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 8 -> 0 -> 7
__label__0 Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.\n\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.\n\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\n\nExamples:\nInput: "WRRBBW", "RB"\nOutput: -1\nExplanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\n\nInput: "WWRRBBWW", "WRBRW"\nOutput: 2\nExplanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\n\nInput:"G", "GGGGG"\nOutput: 2\nExplanation: G -> G[G] -> GG[G] -> empty \n\nInput: "RBYYBBRRB", "YRBGB"\nOutput: 3\nExplanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \n\n\nNote:\n\nYou may assume that the initial row of balls on the table won\xe2\x80\x99t have any 3 or more consecutive balls with the same color.\nThe number of balls on the table won\'t exceed 20, and the string represents these balls is called "board" in the input.\nThe number of balls in your hand won\'t exceed 5, and the string represents these balls is called "hand" in the input.\nBoth input strings will be non-empty and only contain characters \'R\',\'Y\',\'B\',\'G\',\'W\'.
__label__0 Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.\n\xc2\xa0\nExample:\nInput: [4, 6, 7, 7]\nOutput: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n\n\xc2\xa0\nNote:\n\nThe length of the given array will not exceed 15.\nThe range of integer in the given array is [-100,100].\nThe given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.
__label__0 We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. \n\nNow, given an integer n, write a function that returns true when it is a perfect number and false when it is not.\n\nExample:\nInput: 28\nOutput: True\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n\n\nNote:\nThe input number n will not exceed 100,000,000. (1e8)
__label__0 There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart \xe2\x89\xa4 x \xe2\x89\xa4 xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.\nExample:\nInput:\n[[10,16], [2,8], [1,6], [7,12]]\n\nOutput:\n2\n\nExplanation:\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
__label__0 Given a string s and a non-empty string p, find all the start indices of p\'s anagrams in s.\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\nThe order of output does not matter.\nExample 1:\nInput:\ns: "cbaebabacd" p: "abc"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is "cba", which is an anagram of "abc".\nThe substring with start index = 6 is "bac", which is an anagram of "abc".\n\n\nExample 2:\nInput:\ns: "abab" p: "ab"\n\nOutput:\n[0, 1, 2]\n\nExplanation:\nThe substring with start index = 0 is "ab", which is an anagram of "ab".\nThe substring with start index = 1 is "ba", which is an anagram of "ab".\nThe substring with start index = 2 is "ab", which is an anagram of "ab".
__label__0 Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nExample 1:\nInput:     1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\nOutput: true\n\nExample 2:\nInput:     1         1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\nOutput: false\n\nExample 3:\nInput:     1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\nOutput: false
__label__0 N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats. \n\nThe people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).\n\nThe couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.\n\nExample 1:Input: row = [0, 2, 1, 3]\nOutput: 1\nExplanation: We only need to swap the second (row[1]) and third (row[2]) person.\n\nExample 2:Input: row = [3, 2, 0, 1]\nOutput: 0\nExplanation: All couples are already seated side by side.\n\n\nNote:\n\n len(row) is even and in the range of [4, 60].\n row is guaranteed to be a permutation of 0...len(row)-1.
__label__0 SQL SchemaTable: Person\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId is the primary key column for this table.\n\nTable: Address\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId is the primary key column for this table.\n\n\xc2\xa0\nWrite a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\nFirstName, LastName, City, State
__label__0 SQL SchemaThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n\nGiven the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+
__label__0 An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.\nWhat is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1.\nExamples:\nInput: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\nOutput: 2\nExplanation:\nOne potential sequence of moves is shown below, from left to right:\n\n0110     1010     1010\n0110 --> 1010 --> 0101\n1001     0101     1010\n1001     0101     0101\n\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n\nInput: board = [[0, 1], [1, 0]]\nOutput: 0\nExplanation:\nAlso note that the board with 0 in the top left corner,\n01\n10\n\nis also a valid chessboard.\n\nInput: board = [[1, 0], [1, 0]]\nOutput: -1\nExplanation:\nNo matter what sequence of moves you make, you cannot end with a valid chessboard.\n\nNote:\n\nboard will have the same number of rows and columns, a number in the range [2, 30].\nboard[i][j] will be only 0s or 1s.
__label__0 We are given two strings, A and B.\nA shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A.\nExample 1:\nInput: A = 'abcde', B = 'cdeab'\nOutput: true\n\nExample 2:\nInput: A = 'abcde', B = 'abced'\nOutput: false\n\nNote:\n\nA and B will have length at most 100.
__label__0 Determine whether an integer is a palindrome. An integer\xc2\xa0is\xc2\xa0a\xc2\xa0palindrome when it\xc2\xa0reads the same backward as forward.\nExample 1:\nInput: 121\nOutput: true\n\nExample 2:\nInput: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\nInput: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\nFollow up:\nCoud you solve\xc2\xa0it without converting the integer to a string?
__label__0 In a given grid, each cell can have one of three\xc2\xa0values:\n\nthe value 0 representing an empty cell;\nthe value 1 representing a fresh orange;\nthe value 2 representing a rotten orange.\n\nEvery minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange.\xc2\xa0 If this is impossible, return -1 instead.\n\xc2\xa0\n\nExample 1:\n\nInput: [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n\n\nExample 2:\nInput: [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n\nExample 3:\nInput: [[0,2]]\nOutput: 0\nExplanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\xc2\xa0\nNote:\n\n1 <= grid.length <= 10\n1 <= grid[0].length <= 10\ngrid[i][j] is only 0, 1, or 2.
__label__0 Given two binary strings, return their sum (also a binary string).\nThe input strings are both non-empty and contains only characters 1 or\xc2\xa00.\nExample 1:\nInput: a = "11", b = "1"\nOutput: "100"\nExample 2:\nInput: a = "1010", b = "1011"\nOutput: "10101"
__label__0 There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nExample 1:\nInput: 2, [[1,0]] \nOutput: true\nExplanation:\xc2\xa0There are a total of 2 courses to take. \n\xc2\xa0            To take course 1 you should have finished course 0. So it is possible.\nExample 2:\nInput: 2, [[1,0],[0,1]]\nOutput: false\nExplanation:\xc2\xa0There are a total of 2 courses to take. \n\xc2\xa0            To take course 1 you should have finished course 0, and to take course 0 you should\n\xc2\xa0            also have finished course 1. So it is impossible.\n\nNote:\n\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.
__label__0 Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\nExample 1:\nInput: \n[\n\xc2\xa0 [1,1,1],\n\xc2\xa0 [1,0,1],\n\xc2\xa0 [1,1,1]\n]\nOutput: \n[\n\xc2\xa0 [1,0,1],\n\xc2\xa0 [0,0,0],\n\xc2\xa0 [1,0,1]\n]\n\nExample 2:\nInput: \n[\n\xc2\xa0 [0,1,2,0],\n\xc2\xa0 [3,4,5,2],\n\xc2\xa0 [1,3,1,5]\n]\nOutput: \n[\n\xc2\xa0 [0,0,0,0],\n\xc2\xa0 [0,4,5,0],\n\xc2\xa0 [0,3,1,0]\n]\n\nFollow up:\n\nA straight forward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution?
__label__0 Every email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,\xc2\xa0alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain \'.\'s or \'+\'s.\nIf you add periods (\'.\') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\xc2\xa0 For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.\xc2\xa0 (Note that this rule does not apply for domain names.)\nIf you add a plus (\'+\') in the local name, everything after the first plus sign will be\xc2\xa0ignored. This allows certain emails to be filtered, for example\xc2\xa0m.y+name@email.com\xc2\xa0will be forwarded to\xc2\xa0my@email.com.\xc2\xa0 (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.\xc2\xa0\xc2\xa0How many different addresses actually receive mails?\xc2\xa0\n\xc2\xa0\n\nExample 1:\nInput: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]\nOutput: 2\nExplanation:\xc2\xa0"testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails\n\n\xc2\xa0\nNote:\n\n1 <= emails[i].length\xc2\xa0<= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one \'@\' character.\nAll local and domain names are non-empty.\nLocal names do not start with a \'+\' character.
__label__0 Given a string S, return the "reversed" string where all characters that are not a letter\xc2\xa0stay in the same place, and all letters reverse their positions.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\nExample 1:\nInput: "ab-cd"\nOutput: "dc-ba"\n\n\nExample 2:\nInput: "a-bC-dEf-ghIj"\nOutput: "j-Ih-gfE-dCba"\n\n\nExample 3:\nInput: "Test1ng-Leet=code-Q!"\nOutput: "Qedo1ct-eeLg=ntse-T!"\n\n\xc2\xa0\n\nNote:\n\nS.length <= 100\n33 <= S[i].ASCIIcode <= 122\xc2\xa0\nS doesn\'t contain \\ or "
__label__0 A bus\xc2\xa0has n stops numbered from 0 to n - 1 that form\xc2\xa0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\xc2\xa0i and (i + 1) % n.\nThe bus goes along both directions\xc2\xa0i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given\xc2\xa0start\xc2\xa0and destination\xc2\xa0stops.\n\xc2\xa0\nExample 1:\n\nInput: distance = [1,2,3,4], start = 0, destination = 1\nOutput: 1\nExplanation: Distance between 0 and 1 is 1 or 9, minimum is 1.\n\xc2\xa0\nExample 2:\n\nInput: distance = [1,2,3,4], start = 0, destination = 2\nOutput: 3\nExplanation: Distance between 0 and 2 is 3 or 7, minimum is 3.\n\n\xc2\xa0\nExample 3:\n\nInput: distance = [1,2,3,4], start = 0, destination = 3\nOutput: 4\nExplanation: Distance between 0 and 3 is 6 or 4, minimum is 4.\n\n\xc2\xa0\nConstraints:\n\n1 <= n\xc2\xa0<= 10^4\ndistance.length == n\n0 <= start, destination < n\n0 <= distance[i] <= 10^4
__label__0 Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n\nExample 1:\nInput: nums = [1,2,3,1], k = 3, t = 0\nOutput: true\n\n\nExample 2:\nInput: nums = [1,0,1,1], k = 1, t = 2\nOutput: true\n\n\nExample 3:\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3\nOutput: false
__label__0 Implement a MyCalendarThree class to store your events. A new event can always be added.\nYour class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\nA K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)\nFor each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.\nYour class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)\nExample 1:\nMyCalendarThree();\nMyCalendarThree.book(10, 20); // returns 1\nMyCalendarThree.book(50, 60); // returns 1\nMyCalendarThree.book(10, 40); // returns 2\nMyCalendarThree.book(5, 15); // returns 3\nMyCalendarThree.book(5, 10); // returns 3\nMyCalendarThree.book(25, 55); // returns 3\nExplanation: \nThe first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.\nThe third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.\nThe remaining events cause the maximum K-booking to be only a 3-booking.\nNote that the last event locally causes a 2-booking, but the answer is still 3 because\neg. [10, 20), [10, 40), and [5, 15) are still triple booked.\n\n\xc2\xa0\nNote:\n\nThe number of calls to MyCalendarThree.book per test case will be at most 400.\nIn calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].
__label__0 A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.\naddRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\nqueryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)\n is currently being tracked.\nremoveRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right).\nExample 1:\naddRange(10, 20): null\nremoveRange(14, 16): null\nqueryRange(10, 14): true (Every number in [10, 14) is being tracked)\nqueryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nqueryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n\n\nNote:\nA half open interval [left, right) denotes all real numbers left <= x < right.\n0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange.\nThe total number of calls to addRange in a single test case is at most 1000.\nThe total number of calls to queryRange in a single test case is at most 5000.\nThe total number of calls to removeRange in a single test case is at most 1000.
__label__0 Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\nExample 1:\nInput: "aacecaaa"\nOutput: "aaacecaaa"\n\nExample 2:\nInput: "abcd"\nOutput: "dcbabcd"
__label__0 There are N network nodes, labelled 1 to N.\nGiven times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.\nNow, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.\n\xc2\xa0\nExample 1:\n\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2\nOutput: 2\n\n\xc2\xa0\nNote:\n\nN will be in the range [1, 100].\nK will be in the range [1, N].\nThe length of times will be in the range [1, 6000].\nAll edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.
__label__0 A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\nResources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\n\nCan you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\n\nExample 1:\nInput: grid = \n[[0,1,0,0,0,0,0,1],\n [0,1,0,0,0,0,0,1],\n [0,0,0,0,0,0,0,1],\n [0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation:\nThere are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n\n[[0,1,0,0,0,0,1,1],\n [0,1,0,0,0,0,1,1],\n [0,0,0,0,0,0,1,1],\n [0,0,0,0,0,0,0,1]]\n\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n\n\nExample 2:\nInput: grid = \n[[1,1,1],\n [1,0,1],\n [1,1,1]]\nOutput: 4\nExplanation: Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n\nExample 3:\nInput: grid = \n[[1,1,1,0,0,0,0,0,0],\n [1,0,1,0,1,1,1,1,1],\n [1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region on the left only builds two new walls.\n\n\nNote:\n\nThe number of rows and columns of grid will each be in the range [1, 50].\nEach grid[i][j] will be either 0 or 1.\nThroughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.
__label__0 Given an integer array of size n, find all elements that appear more than \xe2\x8c\x8a n/3 \xe2\x8c\x8b times.\nNote: The algorithm should run in linear time and in O(1) space.\nExample 1:\nInput: [3,2,3]\nOutput: [3]\nExample 2:\nInput: [1,1,1,3,3,2,2,2]\nOutput: [1,2]
__label__0 Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\nExample 1:\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n\nGiven the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.\n\nExample 2:\n[[0,0,0,0,0,0,0,0]]\nGiven the above grid, return 0.\n\nNote: The length of each dimension in the given grid does not exceed 50.
__label__0 Given the root node of a binary search tree (BST) and a value to be inserted into the tree,\xc2\xa0insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist\xc2\xa0multiple valid ways for the\xc2\xa0insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\xc2\xa0\nGiven the tree:\n        4\n       / \\\n      2   7\n     / \\\n    1   3\nAnd the value to insert: 5\n\nYou can return this binary search tree:\n         4\n       /   \\\n      2     7\n     / \\   /\n    1   3 5\n\nThis tree is also valid:\n         5\n       /   \\\n      2     7\n     / \\   \n    1   3\n         \\\n          4
__label__0 Given a binary tree, return all root-to-leaf paths.\nNote:\xc2\xa0A leaf is a node with no children.\nExample:\nInput:\n\n   1\n /   \\\n2     3\n \\\n  5\n\nOutput: ["1->2->5", "1->3"]\n\nExplanation: All root-to-leaf paths are: 1->2->5, 1->3
__label__0 Given an array of integers, find if the array contains any duplicates.\nYour function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\nExample 1:\nInput: [1,2,3,1]\nOutput: true\nExample 2:\nInput: [1,2,3,4]\nOutput: false\nExample 3:\nInput: [1,1,1,3,3,4,3,2,4,2]\nOutput: true
__label__0 We are given an array\xc2\xa0A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]).\nReturn the minimum possible value of D.length.\n\xc2\xa0\n\n\n\n\n\n\n\nExample 1:\nInput: ["ca","bb","ac"]\nOutput: 1\nExplanation: \nAfter deleting the first column, A = ["a", "b", "c"].\nNow A is in lexicographic order (ie. A[0] <= A[1] <= A[2]).\nWe require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.\n\n\nExample 2:\nInput: ["xc","yb","za"]\nOutput: 0\nExplanation: \nA is already in lexicographic order, so we don\'t need to delete anything.\nNote that the rows of A are not necessarily in lexicographic order:\nie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)\n\n\nExample 3:\nInput: ["zyx","wvu","tsr"]\nOutput: 3\nExplanation: \nWe have to delete every column.\n\n\xc2\xa0\n\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100
__label__0 In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\xc2\xa0\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even
__label__0 Given an array of integers nums, sort the array in ascending order.\n\xc2\xa0\n\n\nExample 1:\nInput:\xc2\xa0[5,2,3,1]\nOutput: [1,2,3,5]\n\nExample 2:\nInput: [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n-50000 <= A[i] <= 50000
__label__0 Given a circular\xc2\xa0array\xc2\xa0C of integers represented by\xc2\xa0A, find the maximum possible sum of a non-empty subarray of C.\nHere, a\xc2\xa0circular\xc2\xa0array means the end of the array connects to the beginning of the array.\xc2\xa0 (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i]\xc2\xa0when\xc2\xa0i >= 0.)\nAlso, a subarray may only include each element of the fixed buffer A at most once.\xc2\xa0 (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length\xc2\xa0= k2 % A.length.)\n\xc2\xa0\n\nExample 1:\nInput: [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3\n\n\nExample 2:\nInput: [5,-3,5]\nOutput: 10\nExplanation:\xc2\xa0Subarray [5,5] has maximum sum 5 + 5 = 10\n\n\nExample 3:\nInput: [3,-1,2,-1]\nOutput: 4\nExplanation:\xc2\xa0Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4\n\n\nExample 4:\nInput: [3,-2,2,-3]\nOutput: 3\nExplanation:\xc2\xa0Subarray [3] and [3,-2,2] both have maximum sum 3\n\nExample 5:\nInput: [-2,-3,-1]\nOutput: -1\nExplanation:\xc2\xa0Subarray [-1] has maximum sum -1\n\n\xc2\xa0\nNote: \n\n-30000 <= A[i] <= 30000\n1 <= A.length <= 30000
__label__0 Given two sequences pushed and popped\xc2\xa0with distinct values,\xc2\xa0return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n\xc2\xa0\n\nExample 1:\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\nOutput: true\nExplanation: We might do the following sequence:\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n\nExample 2:\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\nOutput: false\nExplanation: 1 cannot be popped before 2.\n\n\xc2\xa0\nNote:\n\n0 <= pushed.length == popped.length <= 1000\n0 <= pushed[i], popped[i] < 1000\npushed is a permutation of popped.\npushed and popped have distinct values.
__label__0 Count the number of prime numbers less than a non-negative number, n.\nExample:\nInput: 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
__label__0 Reverse bits of a given 32 bits unsigned integer.\n\xc2\xa0\nExample 1:\nInput: 00000010100101000001111010011100\nOutput: 00111001011110000010100101000000\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n\nExample 2:\nInput: 11111111111111111111111111111101\nOutput: 10111111111111111111111111111111\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.\n\xc2\xa0\nNote:\n\nNote that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\nIn Java,\xc2\xa0the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2\xc2\xa0above the input represents the signed integer -3\xc2\xa0and the output represents the signed integer -1073741825.\n\n\xc2\xa0\nFollow up:\nIf this function is called many times, how would you optimize it?
__label__0 Given a string s consists of upper/lower-case alphabets and empty space characters \' \', return the length of last word in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a character sequence consists of non-space characters only.\nExample:\nInput: "Hello World"\nOutput: 5
__label__0 We have an array A of integers, and an array queries\xc2\xa0of queries.\nFor the i-th\xc2\xa0query val =\xc2\xa0queries[i][0], index\xc2\xa0= queries[i][1], we add val\xc2\xa0to A[index].\xc2\xa0 Then, the answer to the i-th query is the sum of the even values of A.\n(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)\nReturn the answer to all queries.\xc2\xa0 Your answer array should have\xc2\xa0answer[i]\xc2\xa0as\xc2\xa0the answer to the i-th query.\n\xc2\xa0\nExample 1:\nInput: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\nOutput: [8,6,2,4]\nExplanation: \nAt the beginning, the array is [1,2,3,4].\nAfter adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.\nAfter adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.\nAfter adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.\nAfter adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n-10000 <= A[i] <= 10000\n1 <= queries.length <= 10000\n-10000 <= queries[i][0] <= 10000\n0 <= queries[i][1] < A.length
__label__0 The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: "PAHNAPLSIIGYIR"\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);\nExample 1:\nInput: s = "PAYPALISHIRING", numRows = 3\nOutput: "PAHNAPLSIIGYIR"\n\nExample 2:\nInput: s = "PAYPALISHIRING", numRows =\xc2\xa04\nOutput:\xc2\xa0"PINALSIGYAHRPI"\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I
__label__0 Given a binary tree with N nodes, each node has a different value from\xc2\xa0{1, ..., N}.\nA node in this binary tree can be flipped\xc2\xa0by swapping the left child and the right child of that node.\nConsider the sequence of\xc2\xa0N values reported by a preorder traversal starting from the root.\xc2\xa0 Call such a sequence of N values the\xc2\xa0voyage\xc2\xa0of the tree.\n(Recall that a preorder traversal\xc2\xa0of a node means we report the current node's value, then preorder-traverse the left child, then preorder-traverse the right child.)\nOur goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.\nIf we can do so, then return a\xc2\xa0list\xc2\xa0of the values of all nodes flipped.\xc2\xa0 You may return the answer in any order.\nIf we cannot do so, then return the list [-1].\n\xc2\xa0\n\nExample 1:\n\nInput: root = [1,2], voyage = [2,1]\nOutput: [-1]\n\n\nExample 2:\n\nInput: root = [1,2,3], voyage = [1,3,2]\nOutput: [1]\n\n\nExample 3:\n\nInput: root = [1,2,3], voyage = [1,2,3]\nOutput: []\n\n\xc2\xa0\nNote:\n\n1 <= N <= 100
__label__0 Given a directed, acyclic graph of N nodes.\xc2\xa0 Find all possible paths from node 0 to node N-1, and return them in any order.\nThe graph is given as follows:\xc2\xa0 the nodes are 0, 1, ..., graph.length - 1.\xc2\xa0 graph[i] is a list of all nodes j for which the edge (i, j) exists.\nExample:\nInput: [[1,2], [3], [3], []] \nOutput: [[0,1,3],[0,2,3]] \nExplanation: The graph looks like this:\n0--->1\n|    |\nv    v\n2--->3\nThere are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\nNote:\n\nThe number of nodes in the graph will be in the range [2, 15].\nYou can print different paths in any order, but you should keep the order of nodes inside one path.
__label__0 A peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] \xe2\x89\xa0 nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may imagine that nums[-1] = nums[n] = -\xe2\x88\x9e.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 1 or 5 \nExplanation: Your function can return either index number 1 where the peak element is 2, \n\xc2\xa0            or index number 5 where the peak element is 6.\n\nNote:\nYour solution should be in logarithmic complexity.
__label__0 Given a singly linked list L: L0\xe2\x86\x92L1\xe2\x86\x92\xe2\x80\xa6\xe2\x86\x92Ln-1\xe2\x86\x92Ln,\nreorder it to: L0\xe2\x86\x92Ln\xe2\x86\x92L1\xe2\x86\x92Ln-1\xe2\x86\x92L2\xe2\x86\x92Ln-2\xe2\x86\x92\xe2\x80\xa6\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\nExample 1:\nGiven 1->2->3->4, reorder it to 1->4->2->3.\nExample 2:\nGiven 1->2->3->4->5, reorder it to 1->5->2->4->3.
__label__0 S and T are strings composed of lowercase letters. In S, no letter occurs more than once.\nS was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.\nReturn any permutation of T (as a string) that satisfies this property.\nExample :\nInput: \nS = "cba"\nT = "abcd"\nOutput: "cbad"\nExplanation: \n"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a". \nSince "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.\n\n\xc2\xa0\nNote:\n\nS has length at most 26, and no character is repeated in S.\nT has length at most 200.\nS and T consist of lowercase letters only.
__label__0 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\nYou are given a target value to search. If found in the array return true, otherwise return false.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\nFollow up:\n\nThis is a follow up problem to\xc2\xa0Search in Rotated Sorted Array, where nums may contain duplicates.\nWould this affect the run-time complexity? How and why?
__label__0 Given an undirected\xc2\xa0graph, return true if and only if it is bipartite.\nRecall that a graph is bipartite if we can split it's set of nodes into two independent\xc2\xa0subsets A and B such that every edge in the graph has one node in A and another node in B.\nThe graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.\xc2\xa0 Each node is an integer between 0 and graph.length - 1.\xc2\xa0 There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.\nExample 1:\nInput: [[1,3], [0,2], [1,3], [0,2]]\nOutput: true\nExplanation: \nThe graph looks like this:\n0----1\n|    |\n|    |\n3----2\nWe can divide the vertices into two groups: {0, 2} and {1, 3}.\n\nExample 2:\nInput: [[1,2,3], [0,2], [0,1,3], [0,2]]\nOutput: false\nExplanation: \nThe graph looks like this:\n0----1\n| \\  |\n|  \\ |\n3----2\nWe cannot find a way to divide the set of nodes into two independent subsets.\n\n\xc2\xa0\nNote:\n\ngraph will have length in range [1, 100].\ngraph[i] will contain integers in range [0, graph.length - 1].\ngraph[i] will not contain i or duplicate values.\nThe graph is undirected: if any element j is in graph[i], then i will be in graph[j].
__label__0 A magical string S consists of only \'1\' and \'2\' and obeys the following rules:\n\n\nThe string S is magical because concatenating the number of contiguous occurrences of characters \'1\' and \'2\' generates the string S itself.\n\n\nThe first few elements of string S is the following:\nS = "1221121221221121122\xe2\x80\xa6\xe2\x80\xa6"\n\n\nIf we group the consecutive \'1\'s and \'2\'s in S, it will be:\n\n\n1   22  11  2  1  22  1  22  11  2  11  22 ......\n\n\nand the occurrences of \'1\'s or \'2\'s in each group are:\n\n\n1   2\t   2    1   1    2     1    2     2    1    2    2 ......\n\n\nYou can see that the occurrence sequence above is the S itself. \n\n\nGiven an integer N as input, return the number of \'1\'s in the first N number in the magical string S.\n\nNote:\nN will not exceed 100,000.\n\nExample 1:\nInput: 6\nOutput: 3\nExplanation: The first 6 elements of magical string S is "12211" and it contains three 1\'s, so return 3.
__label__0 A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T".\nSuppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.\nFor example, "AACCGGTT" -> "AACCGGTA" is 1 mutation.\nAlso, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.\nNow, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.\nNote:\n\nStarting point is assumed to be valid, so it might not be included in the bank.\nIf multiple mutations are needed, all mutations during in the sequence must be valid.\nYou may assume start and end string is not the same.\n\n\xc2\xa0\nExample 1:\nstart: "AACCGGTT"\nend:   "AACCGGTA"\nbank: ["AACCGGTA"]\n\nreturn: 1\n\n\xc2\xa0\nExample 2:\nstart: "AACCGGTT"\nend:   "AAACGGTA"\nbank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]\n\nreturn: 2\n\n\xc2\xa0\nExample 3:\nstart: "AAAAACCC"\nend:   "AACCCCCC"\nbank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]\n\nreturn: 3
__label__0 Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. \nExample 1:\nInput: [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n\n\nExample 2:\nInput: [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\nNote:\nThe length of the given binary array will not exceed 50,000.
__label__0 You are given the number of rows n_rows\xc2\xa0and number of columns n_cols\xc2\xa0of a\xc2\xa02D\xc2\xa0binary matrix\xc2\xa0where all values are initially 0.\xc2\xa0Write a function flip\xc2\xa0which chooses\xc2\xa0a 0 value\xc2\xa0uniformly at random,\xc2\xa0changes it to 1,\xc2\xa0and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0.\xc2\xa0Try to minimize the number of calls to system\'s Math.random() and optimize the time and\xc2\xa0space complexity.\nNote:\n\n1 <= n_rows, n_cols\xc2\xa0<= 10000\n0 <= row.id < n_rows and 0 <= col.id < n_cols\nflip\xc2\xa0will not be called when the matrix has no\xc2\xa00 values left.\nthe total number of calls to\xc2\xa0flip\xc2\xa0and reset\xc2\xa0will not exceed\xc2\xa01000.\n\nExample 1:\nInput: \n["Solution","flip","flip","flip","flip"]\n[[2,3],[],[],[],[]]\nOutput: [null,[0,1],[1,2],[1,0],[1,1]]\n\n\nExample 2:\nInput: \n["Solution","flip","flip","reset","flip"]\n[[1,2],[],[],[],[]]\nOutput: [null,[0,0],[0,1],null,[0,0]]\n\nExplanation of Input Syntax:\nThe input is two lists:\xc2\xa0the subroutines called\xc2\xa0and their\xc2\xa0arguments. Solution\'s constructor\xc2\xa0has two arguments, n_rows and n_cols.\xc2\xa0flip\xc2\xa0and reset have\xc2\xa0no\xc2\xa0arguments.\xc2\xa0Arguments\xc2\xa0are\xc2\xa0always wrapped with a list, even if there aren\'t any.
__label__0 Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\nThe encoded string should be as compact as possible.\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__0 Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\n\n\nNote: Time complexity should be O(height of tree).\nExample:\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7
__label__0 Given a word, you need to judge whether the usage of capitals in it is right or not.\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll letters in this word are capitals, like "USA".\nAll letters in this word are not capitals, like "leetcode".\nOnly the first letter in this word is capital, like "Google".\n\nOtherwise, we define that this word doesn\'t use capitals in a right way.\n\n\xc2\xa0\nExample 1:\nInput: "USA"\nOutput: True\n\n\xc2\xa0\nExample 2:\nInput: "FlaG"\nOutput: False\n\n\xc2\xa0\nNote: The input will be a non-empty word consisting of uppercase and lowercase latin letters.
__label__0 Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\nExample 1:\nInput: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n\n\nExample 2:\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n\n\nExample 3:\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.
__label__0 Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\nPlease note that the string does not contain any non-printable characters.\nExample:\nInput: "Hello, my name is John"\nOutput: 5
__label__0 Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:\n\nThe number at the ith position is divisible by i.\ni is divisible by the number at the ith position.\n\n\xc2\xa0\nNow given N, how many beautiful arrangements can you construct?\nExample 1:\nInput: 2\nOutput: 2\nExplanation: \n\nThe first beautiful arrangement is [1, 2]:\n\nNumber at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\n\nNumber at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\n\nThe second beautiful arrangement is [2, 1]:\n\nNumber at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\n\nNumber at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\n\n\xc2\xa0\nNote:\n\nN is a positive integer and will not exceed 15.
__label__0 You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\'t have "lakes" (water inside that isn\'t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don\'t exceed 100. Determine the perimeter of the island.\n\xc2\xa0\nExample:\nInput:\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\nOutput: 16\n\nExplanation: The perimeter is the 16 yellow stripes in the image below:
__label__0 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nExamples: \n[2,3,4] , the median is 3\n[2,3], the median is (2 + 3) / 2 = 2.5 \nGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\nWindow position                Median\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n\nTherefore, return the median sliding window as [1,-1,-1,3,5,6].\nNote: \nYou may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.
__label__0 A sorted list A contains 1, plus some number of primes.\xc2\xa0 Then, for every p < q in the list, we consider the fraction p/q.\nWhat is the K-th smallest fraction considered?\xc2\xa0 Return your answer as an array of ints, where answer[0] = p and answer[1] = q.\nExamples:\nInput: A = [1, 2, 3, 5], K = 3\nOutput: [2, 5]\nExplanation:\nThe fractions to be considered in sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\nThe third fraction is 2/5.\n\nInput: A = [1, 7], K = 1\nOutput: [1, 7]\n\nNote:\n\nA will have length between 2 and 2000.\nEach A[i] will be between 1 and 30000.\nK will be between 1 and A.length * (A.length - 1) / 2.
__label__0 Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\nExample 1:\nInput: 1->2->3->3->4->4->5\nOutput: 1->2->5\n\nExample 2:\nInput: 1->1->1->2->3\nOutput: 2->3
__label__0 Given a binary tree, return the preorder traversal of its nodes' values.\nExample:\nInput:\xc2\xa0[1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput:\xc2\xa0[1,2,3]\n\nFollow up: Recursive solution is trivial, could you do it iteratively?
__label__0 Given string S and a\xc2\xa0dictionary of words words, find the number of words[i] that is a subsequence of S.\nExample :\nInput: \nS = "abcde"\nwords = ["a", "bb", "acd", "ace"]\nOutput: 3\nExplanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".\n\nNote:\n\nAll words in words and S will only consists of lowercase letters.\nThe length of S will be in the range of [1, 50000].\nThe length of words will be in the range of\xc2\xa0[1, 5000].\nThe length of words[i] will be in the range of [1, 50].
__label__0 Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].\xc2\xa0 Afterward, any entries that are less than or equal to their index are worth 1 point.\xc2\xa0\nFor example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].\xc2\xa0 This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\nOver all possible rotations, return the rotation index K that corresponds to the highest score we could receive.\xc2\xa0 If there are multiple answers, return the smallest such index K.\nExample 1:\nInput: [2, 3, 1, 4, 0]\nOutput: 3\nExplanation:  \nScores for each K are listed below: \nK = 0,  A = [2,3,1,4,0],    score 2\nK = 1,  A = [3,1,4,0,2],    score 3\nK = 2,  A = [1,4,0,2,3],    score 3\nK = 3,  A = [4,0,2,3,1],    score 4\nK = 4,  A = [0,2,3,1,4],    score 3\n\nSo we should choose K = 3, which has the highest score.\n\xc2\xa0\nExample 2:\nInput: [1, 3, 0, 2, 4]\nOutput: 0\nExplanation:  A will always have 3 points no matter how it shifts.\nSo we will choose the smallest K, which is 0.\n\nNote:\n\nA\xc2\xa0will have\xc2\xa0length at most 20000.\nA[i] will be in the range [0, A.length].
__label__0 Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\nReturn 0 if the array contains less than 2 elements.\nExample 1:\nInput: [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either\n\xc2\xa0            (3,6) or (6,9) has the maximum difference 3.\nExample 2:\nInput: [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\nNote:\n\nYou may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\nTry to solve it in linear time/space.
__label__0 Given two positive integers x and y, an integer is powerful\xc2\xa0if it is equal to x^i + y^j\xc2\xa0for\xc2\xa0some integers i >= 0 and j >= 0.\nReturn a list of all powerful integers that have value less than or equal to bound.\nYou may return the answer in any order.\xc2\xa0 In your answer, each value should occur at most once.\n\xc2\xa0\n\nExample 1:\nInput: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation: \n2 = 2^0 + 3^0\n3 = 2^1 + 3^0\n4 = 2^0 + 3^1\n5 = 2^1 + 3^1\n7 = 2^2 + 3^1\n9 = 2^3 + 3^0\n10 = 2^0 + 3^2\n\n\nExample 2:\nInput: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]\n\n\n\n\xc2\xa0\nNote:\n\n1 <= x <= 100\n1 <= y\xc2\xa0<= 100\n0 <= bound\xc2\xa0<= 10^6
__label__0 Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nExample 1:\nInput: num1 = "2", num2 = "3"\nOutput: "6"\nExample 2:\nInput: num1 = "123", num2 = "456"\nOutput: "56088"\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contain\xc2\xa0only digits 0-9.\nBoth num1 and num2\xc2\xa0do not contain any leading zero, except the number 0 itself.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__0 Given two integers A and B, return any string S such that:\n\nS has length A + B and contains exactly A \'a\' letters, and exactly B \'b\' letters;\nThe substring\xc2\xa0\'aaa\'\xc2\xa0does not occur in S;\nThe substring \'bbb\' does not occur in S.\n\n\xc2\xa0\nExample 1:\nInput: A = 1, B = 2\nOutput: "abb"\nExplanation: "abb", "bab" and "bba" are all correct answers.\n\n\nExample 2:\nInput: A = 4, B = 1\nOutput: "aabaa"\n\xc2\xa0\n\nNote:\n\n0 <= A <= 100\n0 <= B <= 100\nIt is guaranteed such an S exists for the given A and B.
__label__0 Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\nNOTE:\xc2\xa0input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 Given an array, rotate the array to the right by k steps, where\xc2\xa0k\xc2\xa0is non-negative.\nExample 1:\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\nNote:\n\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\nCould you do it in-place with O(1) extra space?
__label__0 Remove all elements from a linked list of integers that have value val.\nExample:\nInput:  1->2->6->3->4->5->6, val = 6\nOutput: 1->2->3->4->5
__label__0 On a 2D plane, we place stones at some integer coordinate points.\xc2\xa0 Each coordinate point may have at most one stone.\nNow, a move consists of removing a stone\xc2\xa0that shares a column or row with another stone on the grid.\nWhat is the largest possible number of moves we can make?\n\xc2\xa0\n\nExample 1:\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\n\n\nExample 2:\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\n\n\nExample 3:\nInput: stones = [[0,0]]\nOutput: 0\n\n\xc2\xa0\nNote:\n\n1 <= stones.length <= 1000\n0 <= stones[i][j] < 10000
__label__0 A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nWrite a data structure\xc2\xa0CBTInserter\xc2\xa0that is initialized with a complete binary tree and supports the following operations:\n\nCBTInserter(TreeNode root) initializes the data structure on a given tree\xc2\xa0with head node root;\nCBTInserter.insert(int v) will insert a TreeNode\xc2\xa0into the tree with value node.val =\xc2\xa0v\xc2\xa0so that the tree remains complete, and returns the value of the parent of the inserted TreeNode;\nCBTInserter.get_root() will return the head node of the tree.\n\n\n\n\n\xc2\xa0\nExample 1:\nInput: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]\nOutput: [null,1,[1,2]]\n\n\nExample 2:\nInput: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]\nOutput: [null,3,4,[1,2,3,4,5,6,7,8]]\n\n\n\xc2\xa0\nNote:\n\nThe initial given tree is complete and contains between 1 and 1000 nodes.\nCBTInserter.insert is called at most 10000 times per test case.\nEvery value of a given or inserted node is between 0 and 5000.
__label__0 A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nMouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.\nDuring each player's turn, they must travel along one\xc2\xa0edge of the graph that meets where they are.\xc2\xa0 For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\nThen, the game can end in 3 ways:\n\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\nIf ever the Mouse reaches the Hole, the Mouse wins.\nIf ever a position is repeated (ie.\xc2\xa0the players are in the same position as a previous turn, and\xc2\xa0it is the same player's turn to move), the game is a draw.\n\nGiven a graph, and assuming both players play optimally, return 1\xc2\xa0if the game is won by Mouse, 2\xc2\xa0if the game is won by Cat, and 0\xc2\xa0if the game is a draw.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\nExplanation:\n4---3---1\n|\xc2\xa0 \xc2\xa0|\n2---5\n\xc2\xa0\\\xc2\xa0/\n\xc2\xa0 0\n\n\xc2\xa0\nNote:\n\n3 <= graph.length <= 50\nIt is guaranteed that graph[1] is non-empty.\nIt is guaranteed that graph[2] contains a non-zero element.
__label__0 Given an array of integers A\xc2\xa0with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <=\xc2\xa0i < len(A) / 2.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\nExample 1:\nInput: [3,1,3,6]\nOutput: false\n\n\nExample 2:\nInput: [2,1,2,6]\nOutput: false\n\n\nExample 3:\nInput: [4,-2,2,-4]\nOutput: true\nExplanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n\n\nExample 4:\nInput: [1,2,4,16,8,4]\nOutput: false\n\n\xc2\xa0\nNote:\n\n0 <= A.length <= 30000\nA.length is even\n-100000 <= A[i] <= 100000
__label__0 A city\'s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\n    \nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 \xe2\x89\xa4 Li, Ri \xe2\x89\xa4 INT_MAX, 0 < Hi \xe2\x89\xa4 INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\nThe output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]
__label__0 Design a class to find\xc2\xa0the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nYour\xc2\xa0KthLargest\xc2\xa0class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from\xc2\xa0the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.\nExample:\nint k = 3;\nint[] arr = [4,5,8,2];\nKthLargest kthLargest = new KthLargest(3, arr);\nkthLargest.add(3);\xc2\xa0 \xc2\xa0// returns 4\nkthLargest.add(5);\xc2\xa0 \xc2\xa0// returns 5\nkthLargest.add(10);\xc2\xa0 // returns 5\nkthLargest.add(9);\xc2\xa0 \xc2\xa0// returns 8\nkthLargest.add(4);\xc2\xa0 \xc2\xa0// returns 8\n\nNote: \nYou may assume that\xc2\xa0nums' length\xc2\xa0\xe2\x89\xa5\xc2\xa0k-1\xc2\xa0and k \xe2\x89\xa5\xc2\xa01.
__label__0 Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nExample:\nInput: 38\nOutput: 2 \nExplanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. \n\xc2\xa0            Since 2 has only one digit, return it.\n\nFollow up:\nCould you do it without any loop/recursion in O(1) runtime?
__label__0 Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\nNote: \nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 BST's total elements.\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n\xc2\xa0  2\nOutput: 1\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
__label__0 Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0\'s and 1\'s, and all the 0\'s and all the 1\'s in these substrings are grouped consecutively. \n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: "00110011"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1\'s and 0\'s: "0011", "01", "1100", "10", "0011", and "01".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, "00110011" is not a valid substring because all the 0\'s (and 1\'s) are not grouped together.\n\n\nExample 2:\nInput: "10101"\nOutput: 4\nExplanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1\'s and 0\'s.\n\n\nNote:\ns.length will be between 1 and 50,000.\ns will only consist of "0" or "1" characters.
__label__0 Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate\n\nHere, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.\n\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\n\nThe license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.\n\nExample 1:\nInput: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]\nOutput: "steps"\nExplanation: The smallest length word that contains the letters "S", "P", "S", and "T".\nNote that the answer is not "step", because the letter "s" must occur in the word twice.\nAlso note that we ignored case for the purposes of comparing whether a letter exists in the word.\n\n\nExample 2:\nInput: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]\nOutput: "pest"\nExplanation: There are 3 smallest length words that contains the letters "s".\nWe return the one that occurred first.\n\n\nNote:\n\nlicensePlate will be a string with length in range [1, 7].\nlicensePlate will contain digits, spaces, or letters (uppercase or lowercase).\nwords will have a length in the range [10, 1000].\nEvery words[i] will consist of lowercase letters, and have length in range [1, 15].
__label__0 You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'.  The wheels can rotate freely and wrap around: for example we can turn \'9\' to be \'0\', or \'0\' to be \'9\'.  Each move consists of turning one wheel one slot.\n\nThe lock initially starts at \'0000\', a string representing the state of the 4 wheels.\n\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\nExample 1:\nInput: deadends = ["0201","0101","0102","1212","2002"], target = "0202"\nOutput: 6\nExplanation:\nA sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".\nNote that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end "0102".\n\n\nExample 2:\nInput: deadends = ["8888"], target = "0009"\nOutput: 1\nExplanation:\nWe can turn the last wheel in reverse to move from "0000" -> "0009".\n\n\nExample 3:\nInput: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"\nOutput: -1\nExplanation:\nWe can\'t reach the target without getting stuck.\n\n\nExample 4:\nInput: deadends = ["0000"], target = "8888"\nOutput: -1\n\n\nNote:\n\nThe length of deadends will be in the range [1, 500].\ntarget will not be in the list deadends.\nEvery string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities \'0000\' to \'9999\'.
__label__0 Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.\n\nLetters also wrap around.  For example, if the target is target = \'z\' and letters = [\'a\', \'b\'], the answer is \'a\'.\n\nExamples:\nInput:\nletters = ["c", "f", "j"]\ntarget = "a"\nOutput: "c"\n\nInput:\nletters = ["c", "f", "j"]\ntarget = "c"\nOutput: "f"\n\nInput:\nletters = ["c", "f", "j"]\ntarget = "d"\nOutput: "f"\n\nInput:\nletters = ["c", "f", "j"]\ntarget = "g"\nOutput: "j"\n\nInput:\nletters = ["c", "f", "j"]\ntarget = "j"\nOutput: "c"\n\nInput:\nletters = ["c", "f", "j"]\ntarget = "k"\nOutput: "c"\n\n\nNote:\n\nletters has a length in range [2, 10000].\nletters consists of lowercase letters, and contains at least 2 unique letters.\ntarget is a lowercase letter.
__label__0 SQL SchemaThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (\xe2\x80\x98completed\xe2\x80\x99, \xe2\x80\x98cancelled_by_driver\xe2\x80\x99, \xe2\x80\x98cancelled_by_client\xe2\x80\x99).\n+----+-----------+-----------+---------+--------------------+----------+\n| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|\n+----+-----------+-----------+---------+--------------------+----------+\n| 1  |     1     |    10     |    1    |     completed      |2013-10-01|\n| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|\n| 3  |     3     |    12     |    6    |     completed      |2013-10-01|\n| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|\n| 5  |     1     |    10     |    1    |     completed      |2013-10-02|\n| 6  |     2     |    11     |    6    |     completed      |2013-10-02|\n| 7  |     3     |    12     |    6    |     completed      |2013-10-02|\n| 8  |     2     |    12     |    12   |     completed      |2013-10-03|\n| 9  |     3     |    10     |    12   |     completed      |2013-10-03| \n| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|\n+----+-----------+-----------+---------+--------------------+----------+\n\nThe Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (\xe2\x80\x98client\xe2\x80\x99, \xe2\x80\x98driver\xe2\x80\x99, \xe2\x80\x98partner\xe2\x80\x99).\n+----------+--------+--------+\n| Users_Id | Banned |  Role  |\n+----------+--------+--------+\n|    1     |   No   | client |\n|    2     |   Yes  | client |\n|    3     |   No   | client |\n|    4     |   No   | client |\n|    10    |   No   | driver |\n|    11    |   No   | driver |\n|    12    |   No   | driver |\n|    13    |   No   | driver |\n+----------+--------+--------+\n\nWrite a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned)\xc2\xa0between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests\xc2\xa0made by unbanned users by the total number of requests\xc2\xa0made by unbanned users.\nFor the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\n+------------+-------------------+\n|     Day    | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 |       0.33        |\n| 2013-10-02 |       0.00        |\n| 2013-10-03 |       0.50        |\n+------------+-------------------+\n\nCredits:\nSpecial thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.
__label__0 Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.\nFor example,\xc2\xa0\nGiven the tree:\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\nAnd the value to search: 2\n\nYou should return this subtree:\n      2     \n     / \\   \n    1   3\n\nIn the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.\nNote that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as\xc2\xa0[], not null.
__label__0 Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\nExample 1:\nInput: 5\nOutput: True\nExplanation:\nThe binary representation of 5 is: 101\n\n\nExample 2:\nInput: 7\nOutput: False\nExplanation:\nThe binary representation of 7 is: 111.\n\n\nExample 3:\nInput: 11\nOutput: False\nExplanation:\nThe binary representation of 11 is: 1011.\n\n\nExample 4:\nInput: 10\nOutput: True\nExplanation:\nThe binary representation of 10 is: 1010.
__label__0 Implement the following operations of a queue using stacks.\n\npush(x) -- Push element x to the back of queue.\npop() -- Removes the element from in front of queue.\npeek() -- Get the front element.\nempty() -- Return whether the queue is empty.\n\nExample:\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false\nNotes:\n\nYou must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\nYou may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
__label__0 We are given an array asteroids of integers representing asteroids in a row.\n\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.\n\nExample 1:\nInput: \nasteroids = [5, 10, -5]\nOutput: [5, 10]\nExplanation: \nThe 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\n\n\nExample 2:\nInput: \nasteroids = [8, -8]\nOutput: []\nExplanation: \nThe 8 and -8 collide exploding each other.\n\n\nExample 3:\nInput: \nasteroids = [10, 2, -5]\nOutput: [10]\nExplanation: \nThe 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.\n\n\nExample 4:\nInput: \nasteroids = [-2, -1, 1, 2]\nOutput: [-2, -1, 1, 2]\nExplanation: \nThe -2 and -1 are moving left, while the 1 and 2 are moving right.\nAsteroids moving the same direction never meet, so no asteroids will meet each other.\n\n\nNote:\nThe length of asteroids will be at most 10000.\nEach asteroid will be a non-zero integer in the range [-1000, 1000]..
__label__0 Given a binary tree, determine if it is a complete binary tree.\nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n\xc2\xa0\nExample 1:\n\nInput: [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\n\nExample 2:\n\nInput: [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible.\n\n\xc2\xa0\n\nNote:\n\nThe tree will have between 1 and 100 nodes.
__label__0 Given a non-empty\xc2\xa0array of unique positive integers A, consider the following graph:\n\nThere are A.length nodes, labelled A[0] to A[A.length - 1];\nThere is an edge between A[i] and A[j]\xc2\xa0if and only if\xc2\xa0A[i] and A[j] share a common factor greater than 1.\n\nReturn the size of the largest connected component in the graph.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [4,6,15,35]\nOutput: 4\n\n\n\nExample 2:\nInput: [20,50,9,63]\nOutput: 2\n\n\n\nExample 3:\nInput: [2,3,6,7,4,12,21,39]\nOutput: 8\n\n\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= 100000
__label__0 Given a string\xc2\xa0S of \'(\' and \')\' parentheses, we add the minimum number of parentheses ( \'(\' or \')\', and in any positions ) so that the resulting parentheses string is valid.\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, or\nIt can be written as AB\xc2\xa0(A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\n\nGiven a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.\n\xc2\xa0\nExample 1:\nInput: "())"\nOutput: 1\n\n\nExample 2:\nInput: "((("\nOutput: 3\n\n\nExample 3:\nInput: "()"\nOutput: 0\n\n\nExample 4:\nInput: "()))(("\nOutput: 4\n\xc2\xa0\n\n\n\nNote:\n\nS.length <= 1000\nS only consists of \'(\' and \')\' characters.
__label__0 Given an array A, partition it\xc2\xa0into two (contiguous) subarrays\xc2\xa0left\xc2\xa0and right\xc2\xa0so that:\n\nEvery element in left\xc2\xa0is less than or equal to every element in right.\nleft and right are non-empty.\nleft\xc2\xa0has the smallest possible size.\n\nReturn the length of left after such a partitioning.\xc2\xa0 It is guaranteed that such a partitioning exists.\n\xc2\xa0\nExample 1:\nInput: [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\n\nExample 2:\nInput: [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\n\xc2\xa0\n\nNote:\n\n2 <= A.length\xc2\xa0<= 30000\n0 <= A[i] <= 10^6\nIt is guaranteed there is at least one way to partition A as described.
__label__0 Write a function that takes an unsigned integer and return\xc2\xa0the number of '1'\xc2\xa0bits it has (also known as the Hamming weight).\n\xc2\xa0\nExample 1:\nInput: 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011\xc2\xa0has a total of three '1' bits.\n\nExample 2:\nInput: 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000\xc2\xa0has a total of one '1' bit.\n\nExample 3:\nInput: 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n\xc2\xa0\nNote:\n\nNote that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\nIn Java,\xc2\xa0the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3\xc2\xa0above the input represents the signed integer -3.\n\n\xc2\xa0\nFollow up:\nIf this function is called many times, how would you optimize it?
__label__0 Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\nExample 1:\nInput: s = "egg", t = "add"\nOutput: true\n\nExample 2:\nInput: s = "foo", t = "bar"\nOutput: false\nExample 3:\nInput: s = "paper", t = "title"\nOutput: true\nNote:\nYou may assume both s\xc2\xa0and t\xc2\xa0have the same length.
__label__0 Implement int sqrt(int x).\nCompute and return the square root of x, where\xc2\xa0x\xc2\xa0is guaranteed to be a non-negative integer.\nSince the return type\xc2\xa0is an integer, the decimal digits are truncated and only the integer part of the result\xc2\xa0is returned.\nExample 1:\nInput: 4\nOutput: 2\n\nExample 2:\nInput: 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since \n\xc2\xa0            the decimal part is truncated, 2 is returned.
__label__0 Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.\nReturn the number of permutations of A that are squareful.\xc2\xa0 Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].\n\xc2\xa0\nExample 1:\nInput: [1,17,8]\nOutput: 2\nExplanation: \n[1,8,17] and [17,8,1] are the valid permutations.\n\nExample 2:\nInput: [2,2,2]\nOutput: 1\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 12\n0 <= A[i] <= 1e9
__label__0 Given an unsorted integer array, find the smallest missing\xc2\xa0positive integer.\nExample 1:\nInput: [1,2,0]\nOutput: 3\n\nExample 2:\nInput: [3,4,-1,1]\nOutput: 2\n\nExample 3:\nInput: [7,8,9,11,12]\nOutput: 1\n\nNote:\nYour algorithm should run in O(n) time and uses constant extra space.
__label__0 Given a 32-bit signed integer, reverse digits of an integer.\nExample 1:\nInput: 123\nOutput: 321\n\nExample 2:\nInput: -123\nOutput: -321\n\nExample 3:\nInput: 120\nOutput: 21\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\xe2\x88\x92231,\xc2\xa0 231\xc2\xa0\xe2\x88\x92 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
__label__0 Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n\xc2\xa0            jump length is 0, which makes it impossible to reach the last index.
__label__0 A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\nThe board is a 3 x 3 array, and consists of characters " ", "X", and "O".\xc2\xa0 The " " character represents an empty square.\nHere are the rules of Tic-Tac-Toe:\n\nPlayers take turns placing characters into empty squares (" ").\nThe first player always places "X" characters, while the second player always places "O" characters.\n"X" and "O" characters are always placed into empty squares, never filled ones.\nThe game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.\nThe game also ends if all squares are non-empty.\nNo more moves can be played if the game is over.\n\nExample 1:\nInput: board = ["O\xc2\xa0 ", "\xc2\xa0 \xc2\xa0", "\xc2\xa0 \xc2\xa0"]\nOutput: false\nExplanation: The first player always plays "X".\n\nExample 2:\nInput: board = ["XOX", " X ", "   "]\nOutput: false\nExplanation: Players take turns making moves.\n\nExample 3:\nInput: board = ["XXX", "   ", "OOO"]\nOutput: false\n\nExample 4:\nInput: board = ["XOX", "O O", "XOX"]\nOutput: true\n\nNote:\n\nboard is a length-3 array of strings, where each string board[i] has length 3.\nEach board[i][j] is a character in the set {" ", "X", "O"}.
__label__0 Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)\xc2\xa0in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nNote: Do not modify the linked list.\n\xc2\xa0\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\n\n\n\xc2\xa0\nFollow-up:\nCan you solve it without using extra space?
__label__0 Write a program to find the node at which the intersection of two singly linked lists begins.\nFor example, the following two linked lists:\n\nbegin to intersect at node c1.\n\xc2\xa0\nExample 1:\n\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\nOutput: Reference of the node with value = 8\nInput Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n\xc2\xa0\nExample 2:\n\nInput: intersectVal\xc2\xa0= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Reference of the node with value = 2\nInput Explanation:\xc2\xa0The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\xc2\xa0\nExample 3:\n\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: null\nInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\xc2\xa0\nNotes:\n\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.
__label__0 Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n\xc2\xa0\n\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n\xc2\xa0\n\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n\xc2\xa0\nExample:\nInput: [2,1,5,6,2,3]\nOutput: 10
__label__0 Write a SQL query to get the nth highest salary from the Employee table.\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\nFor example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.\n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+
__label__0 Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\n\xc2\xa0\nExample 1:\n    2\n   / \\\n  1   3\n\nInput:\xc2\xa0[2,1,3]\nOutput: true\n\nExample 2:\n    5\n   / \\\n  1   4\n\xc2\xa0    / \\\n\xc2\xa0   3   6\n\nInput: [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.
__label__0 The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, calculate the Hamming distance.\nNote:\n0 \xe2\x89\xa4 x, y < 231.\n\nExample:\nInput: x = 1, y = 4\n\nOutput: 2\n\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \xe2\x86\x91   \xe2\x86\x91\n\nThe above arrows point to positions where the corresponding bits are different.
__label__0 Given the radius and x-y positions of the center of a circle, write a function randPoint\xc2\xa0which\xc2\xa0generates a uniform random\xc2\xa0point in the circle.\nNote:\n\ninput and output values are\xc2\xa0in\xc2\xa0floating-point.\nradius and x-y position of the center of the circle is passed into the class constructor.\na point on the circumference of the circle is considered to be\xc2\xa0in the circle.\nrandPoint\xc2\xa0returns\xc2\xa0a size 2 array containing x-position and y-position of the random point, in that order.\n\n\nExample 1:\nInput: \n["Solution","randPoint","randPoint","randPoint"]\n[[1,0,0],[],[],[]]\nOutput: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]\n\n\nExample 2:\nInput: \n["Solution","randPoint","randPoint","randPoint"]\n[[10,5,-7.5],[],[],[]]\nOutput: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]\n\nExplanation of Input Syntax:\nThe input is two lists:\xc2\xa0the subroutines called\xc2\xa0and their\xc2\xa0arguments.\xc2\xa0Solution\'s\xc2\xa0constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments.\xc2\xa0Arguments\xc2\xa0are\xc2\xa0always wrapped with a list, even if there aren\'t any.
__label__0 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\n\n\n\xc2\xa0\nExample 1:\nInput: amount = 5, coins = [1, 2, 5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\nExample 2:\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\n\nExample 3:\nInput: amount = 10, coins = [10] \nOutput: 1\n\n\xc2\xa0\nNote:\nYou can assume that\n\n0 <= amount <= 5000\n1 <= coin <= 5000\nthe number of coins is less than 500\nthe answer is guaranteed to fit into signed 32-bit integer
__label__0 Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n\nExample 1:\nInput:\ns = "abpcplea", d = ["ale","apple","monkey","plea"]\n\nOutput: \n"apple"\n\n\n\nExample 2:\nInput:\ns = "abpcplea", d = ["a","b","c"]\n\nOutput: \n"a"\n\n\nNote:\n\nAll the strings in the input will only contain lower-case letters.\nThe size of the dictionary won\'t exceed 1,000.\nThe length of all the strings in the input won\'t exceed 1,000.
__label__0 Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.\nFor any interval i, you need to store the minimum interval j\'s index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn\'t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\nNote:\n\nYou may assume the interval\'s end point is always bigger than its start point.\nYou may assume none of these intervals have the same start point.\n\n\xc2\xa0\nExample 1:\nInput: [ [1,2] ]\n\nOutput: [-1]\n\nExplanation: There is only one interval in the collection, so it outputs -1.\n\n\xc2\xa0\nExample 2:\nInput: [ [3,4], [2,3], [1,2] ]\n\nOutput: [-1, 0, 1]\n\nExplanation: There is no satisfied "right" interval for [3,4].\nFor [2,3], the interval [3,4] has minimum-"right" start point;\nFor [1,2], the interval [2,3] has minimum-"right" start point.\n\n\xc2\xa0\nExample 3:\nInput: [ [1,4], [2,3], [3,4] ]\n\nOutput: [-1, 2, -1]\n\nExplanation: There is no satisfied "right" interval for [1,4] and [3,4].\nFor [2,3], the interval [3,4] has minimum-"right" start point.\n\nNOTE:\xc2\xa0input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 The\xc2\xa0Fibonacci numbers, commonly denoted\xc2\xa0F(n)\xc2\xa0form a sequence, called the\xc2\xa0Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0,\xc2\xa0 \xc2\xa0F(1)\xc2\xa0= 1\nF(N) = F(N - 1) + F(N - 2), for N > 1.\n\nGiven N, calculate F(N).\n\xc2\xa0\nExample 1:\nInput: 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n\nExample 2:\nInput: 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n\nExample 3:\nInput: 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\xc2\xa0\nNote:\n0 \xe2\x89\xa4 N \xe2\x89\xa4 30.
__label__0 Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n\nExamples 1\nInput:\n  5\n /  \\\n2   -3\n\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\n\nExamples 2\nInput:\n  5\n /  \\\n2   -5\n\nreturn [2], since 2 happens twice, however -5 only occur once.\n\nNote:\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.
__label__0 Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\n\n\xc2\xa0\nExample 1:\nInput: [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of intervals are non-overlapping.\n\nExample 2:\nInput: [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.\n\nExample 3:\nInput: [[1,2],[2,3]]\nOutput: 0\nExplanation: You don\'t need to remove any of the intervals since they\'re already non-overlapping.\n\n\xc2\xa0\nNote:\n\nYou may assume the interval\'s end point is always bigger than its start point.\nIntervals like [1,2] and [2,3] have borders "touching" but they don\'t overlap each other.
__label__0 Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\nNote:\n\nThe length of both num1 and num2 is < 5100.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__0 Find the largest palindrome made from the product of two n-digit numbers.\nSince the result could be very large, you should return the largest palindrome mod 1337.\n\xc2\xa0\nExample:\nInput: 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n\xc2\xa0\nNote:\nThe range of n is [1,8].
__label__0 Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\nYou may assume the array's length is at most 10,000.\nExample:\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
__label__0 SQL SchemaWrite a SQL query to get the second highest salary from the Employee table.\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\nFor example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+
__label__0 Given a sorted linked list, delete all duplicates such that each element appear only once.\nExample 1:\nInput: 1->1->2\nOutput: 1->2\n\nExample 2:\nInput: 1->1->2->3->3\nOutput: 1->2->3
__label__0 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\ngetMin() -- Retrieve the minimum element in the stack.\n\n\xc2\xa0\nExample:\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> Returns -3.\nminStack.pop();\nminStack.top();      --> Returns 0.\nminStack.getMin();   --> Returns -2.
__label__0 We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.\xc2\xa0 Each glass holds one cup (250ml) of champagne.\nThen, some champagne is poured in the first glass at the top.\xc2\xa0 When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.\xc2\xa0 When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.\xc2\xa0 (A glass at the bottom row has it's excess champagne fall on the floor.)\nFor example, after one cup of champagne is poured, the top most glass is full.\xc2\xa0 After two cups of champagne are poured, the two glasses on the second row are half full.\xc2\xa0 After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.\xc2\xa0 After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)\n\xc2\xa0\nExample 1:\nInput: poured = 1, query_glass = 1, query_row = 1\nOutput: 0.0\nExplanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\nExample 2:\nInput: poured = 2, query_glass = 1, query_row = 1\nOutput: 0.5\nExplanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n\xc2\xa0\nNote:\n\npoured\xc2\xa0will\xc2\xa0be\xc2\xa0in the range of [0, 10 ^ 9].\nquery_glass and query_row will be in the range of [0, 99].
__label__0 Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\nExample 1:\nInput: K = 0\nOutput: 5\nExplanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.\n\nExample 2:\nInput: K = 5\nOutput: 0\nExplanation: There is no x such that x! ends in K = 5 zeroes.\n\nNote:\n\nK will be an integer in the range [0, 10^9].
__label__0 Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)\xc2\xa0in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n\xc2\xa0\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\n\n\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\n\n\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\n\n\n\xc2\xa0\nFollow up:\nCan you solve it using O(1) (i.e. constant) memory?
__label__0 Implement atoi which\xc2\xa0converts a string to an integer.\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\nIf no valid conversion could be performed, a zero value is returned.\nNote:\n\nOnly the space character \' \' is considered as whitespace character.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\xe2\x88\x92231,\xc2\xa0 231\xc2\xa0\xe2\x88\x92 1]. If the numerical value is out of the range of representable values, INT_MAX (231\xc2\xa0\xe2\x88\x92 1) or INT_MIN (\xe2\x88\x92231) is returned.\n\nExample 1:\nInput: "42"\nOutput: 42\n\nExample 2:\nInput: "   -42"\nOutput: -42\nExplanation: The first non-whitespace character is \'-\', which is the minus sign.\n\xc2\xa0            Then take as many numerical digits as possible, which gets 42.\n\nExample 3:\nInput: "4193 with words"\nOutput: 4193\nExplanation: Conversion stops at digit \'3\' as the next character is not a numerical digit.\n\nExample 4:\nInput: "words and 987"\nOutput: 0\nExplanation: The first non-whitespace character is \'w\', which is not a numerical \n\xc2\xa0            digit or a +/- sign. Therefore no valid conversion could be performed.\nExample 5:\nInput: "-91283472332"\nOutput: -2147483648\nExplanation: The number "-91283472332" is out of the range of a 32-bit signed integer.\n\xc2\xa0            Thefore INT_MIN (\xe2\x88\x92231) is returned.
__label__0 Given a collection of intervals, merge all overlapping intervals.\nExample 1:\nInput: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n\nExample 2:\nInput: [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\nNOTE:\xc2\xa0input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 Given an array A, we can perform a\xc2\xa0pancake flip:\xc2\xa0We choose some positive integer\xc2\xa0k <= A.length, then reverse the order of the first k elements of A.\xc2\xa0 We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.\nReturn the k-values corresponding to a sequence of pancake flips that sort A.\xc2\xa0 Any\xc2\xa0valid answer that sorts the array within 10 * A.length flips will be judged as correct.\n\xc2\xa0\nExample 1:\nInput: [3,2,4,1]\nOutput: [4,2,4,3]\nExplanation: \nWe perform 4 pancake flips, with k values 4, 2, 4, and 3.\nStarting state: A = [3, 2, 4, 1]\nAfter 1st flip (k=4): A = [1, 4, 2, 3]\nAfter 2nd flip (k=2): A = [4, 1, 2, 3]\nAfter 3rd flip (k=4): A = [3, 2, 1, 4]\nAfter 4th flip (k=3): A = [1, 2, 3, 4], which is sorted. \n\n\nExample 2:\nInput: [1,2,3]\nOutput: []\nExplanation: The input is already sorted, so there is no need to flip anything.\nNote that other answers, such as [3, 3], would also be accepted.\n\n\xc2\xa0\n\nNote:\n\n1 <= A.length <= 100\nA[i] is a permutation of [1, 2, ..., A.length]
__label__0 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\nExample:\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6
__label__0 Reverse a singly linked list.\nExample:\nInput: 1->2->3->4->5->NULL\nOutput: 5->4->3->2->1->NULL\n\nFollow up:\nA linked list can be reversed either iteratively or recursively. Could you implement both?
__label__0 In a town, there are N people labelled from\xc2\xa01 to N.\xc2\xa0 There is a rumor that one of these people is secretly the town judge.\nIf the\xc2\xa0town judge exists, then:\n\nThe town judge trusts nobody.\nEverybody (except for the town judge) trusts the town judge.\nThere is exactly one person that satisfies properties 1 and 2.\n\nYou are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.\nIf the town judge exists and can be identified, return the label of the town judge.\xc2\xa0 Otherwise, return -1.\n\xc2\xa0\nExample 1:\nInput: N = 2, trust = [[1,2]]\nOutput: 2\n\n\nExample 2:\nInput: N = 3, trust = [[1,3],[2,3]]\nOutput: 3\n\n\nExample 3:\nInput: N = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1\n\n\nExample 4:\nInput: N = 3, trust = [[1,2],[2,3]]\nOutput: -1\n\n\nExample 5:\nInput: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]\nOutput: 3\n\xc2\xa0\n\n\n\n\nNote:\n\n1 <= N <= 1000\ntrust.length <= 10000\ntrust[i] are all different\ntrust[i][0] != trust[i][1]\n1 <= trust[i][0], trust[i][1] <= N
__label__0 Write a bash script to calculate the frequency of each word in a text file words.txt.\nFor simplicity sake, you may assume:\n\nwords.txt contains only lowercase characters and space ' ' characters.\nEach word must consist of lowercase characters only.\nWords are separated by one or more whitespace characters.\n\nExample:\nAssume that words.txt has the following content:\nthe day is sunny the the\nthe sunny is is\n\nYour script should output the following, sorted by descending frequency:\nthe 4\nis 3\nsunny 2\nday 1\n\nNote:\n\nDon't worry about handling ties, it is guaranteed that each word's frequency count is unique.\nCould you write it in one-line using Unix pipes?
__label__0 In a deck of cards, each card has an integer written on it.\nReturn true if and only if you can choose\xc2\xa0X >= 2 such that\xc2\xa0it is possible to split the entire deck\xc2\xa0into 1 or more groups of cards, where:\n\nEach group has exactly X cards.\nAll the cards in each group have the same integer.\n\n\xc2\xa0\nExample 1:\nInput: [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4]\n\n\nExample 2:\nInput: [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.\n\n\nExample 3:\nInput: [1]\nOutput: false\nExplanation: No possible partition.\n\n\nExample 4:\nInput: [1,1]\nOutput: true\nExplanation: Possible partition [1,1]\n\n\nExample 5:\nInput: [1,1,2,2,2,2]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[2,2]\n\n\n\n\n\n\nNote:\n\n1 <= deck.length <= 10000\n0 <= deck[i] <\xc2\xa010000
__label__0 In an alien language, surprisingly they also use english lowercase letters, but possibly\xc2\xa0in a different order. The\xc2\xa0order of the alphabet\xc2\xa0is some permutation\xc2\xa0of lowercase letters.\nGiven a sequence of words\xc2\xa0written in the alien language,\xc2\xa0and the order of the alphabet,\xc2\xa0return true if and only if the given words\xc2\xa0are sorted lexicographicaly in this alien language.\n\xc2\xa0\n\nExample 1:\nInput: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"\nOutput: true\nExplanation: As \'h\' comes before \'l\' in this language, then the sequence is sorted.\n\n\nExample 2:\nInput: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"\nOutput: false\nExplanation: As \'d\' comes after \'l\' in this language, then words[0] > words[1], hence the sequence is unsorted.\n\n\nExample 3:\nInput: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"\nOutput: false\nExplanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because \'l\' > \'\xe2\x88\x85\', where \'\xe2\x88\x85\' is defined as the blank character which is less than any other character (More info).\n\n\xc2\xa0\nNote:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 20\norder.length == 26\nAll characters in words[i] and order are english lowercase letters.
__label__0 In a N x N\xc2\xa0grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \\, or blank space.\xc2\xa0 These characters divide the square into contiguous regions.\n(Note that backslash characters are escaped, so a \\\xc2\xa0is represented as "\\\\".)\nReturn the number of regions.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1:\nInput:\n[\n\xc2\xa0 " /",\n\xc2\xa0 "/ "\n]\nOutput: 2\nExplanation: The 2x2 grid is as follows:\n\n\n\nExample 2:\nInput:\n[\n\xc2\xa0 " /",\n\xc2\xa0 "  "\n]\nOutput: 1\nExplanation: The 2x2 grid is as follows:\n\n\n\nExample 3:\nInput:\n[\n\xc2\xa0 "\\\\/",\n\xc2\xa0 "/\\\\"\n]\nOutput: 4\nExplanation: (Recall that because \\ characters are escaped, "\\\\/" refers to \\/, and "/\\\\" refers to /\\.)\nThe 2x2 grid is as follows:\n\n\n\nExample 4:\nInput:\n[\n\xc2\xa0 "/\\\\",\n\xc2\xa0 "\\\\/"\n]\nOutput: 5\nExplanation: (Recall that because \\ characters are escaped, "/\\\\" refers to /\\, and "\\\\/" refers to \\/.)\nThe 2x2 grid is as follows:\n\n\n\nExample 5:\nInput:\n[\n\xc2\xa0 "//",\n\xc2\xa0 "/ "\n]\nOutput: 3\nExplanation: The 2x2 grid is as follows:\n\n\n\xc2\xa0\nNote:\n\n1 <= grid.length == grid[0].length <= 30\ngrid[i][j] is either \'/\', \'\\\', or \' \'.
__label__0 An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\n\nGiven a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.\n\nTo perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\n\nAt the end, return the modified image.\n\nExample 1:\nInput: \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: \nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \nby a path of the same color as the starting pixel are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\nto the starting pixel.\n\n\nNote:\nThe length of image and image[0] will be in the range [1, 50].\nThe given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length.\nThe value of each color in image[i][j] and newColor will be an integer in [0, 65535].
__label__0 Given a non-empty list of words, return the k most frequent elements.\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\nExample 1:\nInput: ["i", "love", "leetcode", "i", "love", "coding"], k = 2\nOutput: ["i", "love"]\nExplanation: "i" and "love" are the two most frequent words.\n    Note that "i" comes before "love" due to a lower alphabetical order.\n\n\nExample 2:\nInput: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4\nOutput: ["the", "is", "sunny", "day"]\nExplanation: "the", "is", "sunny" and "day" are the four most frequent words,\n    with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\nNote:\n\nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 number of unique elements.\nInput words contain only lowercase letters.\n\n\nFollow up:\n\nTry to solve it in O(n log k) time and O(n) extra space.
__label__0 Given an integer, write a function to determine if it is a power of two.\nExample 1:\nInput: 1\nOutput: true \nExplanation: 20\xc2\xa0= 1\n\nExample 2:\nInput: 16\nOutput: true\nExplanation: 24\xc2\xa0= 16\nExample 3:\nInput: 218\nOutput: false
__label__0 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\nExample:\nInput:  [1,2,1,3,2,5]\nOutput: [3,5]\nNote:\n\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?
__label__0 On an infinite number line (x-axis), we drop given squares in the order they are given.\nThe i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].\nThe square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.\nThe squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.\n\xc2\xa0\n\nReturn a list ans of heights. Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].\nExample 1:\nInput: [[1, 2], [2, 3], [6, 1]]\nOutput: [2, 5, 5]\nExplanation:\n\nAfter the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.\nAfter the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5. The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.\nAfter the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5. Thus, we return an answer of [2, 5, 5].\n\xc2\xa0\n\xc2\xa0\n\nExample 2:\nInput: [[100, 100], [200, 100]]\nOutput: [100, 100]\nExplanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\n\n\xc2\xa0\nNote:\n\n1 <= positions.length <= 1000.\n1 <= positions[i][0] <= 10^8.\n1 <= positions[i][1] <= 10^6.
__label__0 Given many words, words[i] has weight i.\nDesign a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.\nExamples:\nInput:\nWordFilter(["apple"])\nWordFilter.f("a", "e") // returns 0\nWordFilter.f("b", "") // returns -1\n\n\xc2\xa0\nNote:\n\nwords has length in range [1, 15000].\nFor each test case, up to words.length queries WordFilter.f may be made.\nwords[i] has length in range [1, 10].\nprefix, suffix have lengths in range [0, 10].\nwords[i] and prefix, suffix queries consist of lowercase letters only.
__label__0 There is a box protected by a password. The password is a sequence of\xc2\xa0n digits\xc2\xa0where each digit can be one of the first k digits 0, 1, ..., k-1.\nWhile entering a password,\xc2\xa0the last n digits entered will automatically be matched against the correct password.\nFor example, assuming the correct password is "345",\xc2\xa0if you type "012345", the box will open because the correct password matches the suffix of the entered password.\nReturn any password of minimum length that is guaranteed to open the box at some point of entering it.\n\xc2\xa0\nExample 1:\nInput: n = 1, k = 2\nOutput: "01"\nNote: "10" will be accepted too.\n\nExample 2:\nInput: n = 2, k = 2\nOutput: "00110"\nNote: "01100", "10011", "11001" will be accepted too.\n\n\xc2\xa0\nNote:\n\nn will be in the range [1, 4].\nk will be in the range [1, 10].\nk^n will be at most 4096.
__label__0 Special binary strings are binary strings with the following two properties:\n\nThe number of 0\'s is equal to the number of 1\'s.\nEvery prefix of the binary string has at least as many 1\'s as 0\'s.\n\nGiven a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)\n\nAt the end of any number of moves, what is the lexicographically largest resulting string possible?\n\nExample 1:\nInput: S = "11011000"\nOutput: "11100100"\nExplanation:\nThe strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n\n\nNote:\nS has length at most 50.\nS is guaranteed to be a special binary string as defined above.
__label__0 Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order.\nExample 1:\nInput: \naccounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]\nOutput: [["John", \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]\nExplanation: \nThe first and third John\'s are the same person as they have the common email "johnsmith@mail.com".\nThe second John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [[\'Mary\', \'mary@mail.com\'], [\'John\', \'johnnybravo@mail.com\'], \n[\'John\', \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\']] would still be accepted.\n\n\nNote:\nThe length of accounts will be in the range [1, 1000].\nThe length of accounts[i] will be in the range [1, 10].\nThe length of accounts[i][j] will be in the range [1, 30].
__label__0 Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\n\nExample 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\n\xc2\xa0\nNote:\n\nYou may assume that all elements in nums are unique.\nn will be in the range [1, 10000].\nThe value of each element in nums will be in the range [-9999, 9999].
__label__0 Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.\nExample 1:\nInput: "2-1-1"\nOutput: [0, 2]\nExplanation: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\nExample 2:\nInput: "2*3-4*5"\nOutput: [-34, -14, -10, -10, 10]\nExplanation: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10
__label__0 Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \xe2\x80\x9cThe lowest common ancestor is defined between two nodes p and q\xc2\xa0as the lowest node in T that has both p and q\xc2\xa0as descendants (where we allow a node to be a descendant of itself).\xe2\x80\x9d\nGiven binary search tree:\xc2\xa0 root =\xc2\xa0[6,2,8,0,4,7,9,null,null,3,5]\n\n\xc2\xa0\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\nExample 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n\xc2\xa0\nNote:\n\nAll of the nodes' values will be unique.\np and q are different and both values will\xc2\xa0exist in the BST.
__label__0 Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes.\nIf there isn't any rectangle, return 0.\n\xc2\xa0\nExample 1:\n\nInput: [[1,2],[2,1],[1,0],[0,1]]\nOutput: 2.00000\nExplanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\n\nExample 2:\n\nInput: [[0,1],[2,1],[1,1],[1,0],[2,0]]\nOutput: 1.00000\nExplanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\n\nExample 3:\n\nInput: [[0,3],[1,2],[3,1],[1,3],[2,1]]\nOutput: 0\nExplanation: There is no possible rectangle to form from these points.\n\n\nExample 4:\n\nInput: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]\nOutput: 2.00000\nExplanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.\n\n\n\xc2\xa0\n\n\nNote:\n\n1 <= points.length <= 50\n0 <=\xc2\xa0points[i][0] <=\xc2\xa040000\n0 <=\xc2\xa0points[i][1] <=\xc2\xa040000\nAll points are distinct.\nAnswers within 10^-5 of the actual value will be accepted as correct.
__label__0 Given an array of 4 digits, return the largest 24 hour time that can be made.\nThe smallest 24 hour time is 00:00, and the largest is 23:59.\xc2\xa0 Starting from 00:00, a time is larger if more time has elapsed since midnight.\nReturn the answer as a string of length 5.\xc2\xa0 If no valid time can be made, return an empty string.\n\xc2\xa0\n\nExample 1:\nInput: [1,2,3,4]\nOutput: "23:41"\n\n\nExample 2:\nInput: [5,5,5,5]\nOutput: ""\n\n\xc2\xa0\nNote:\n\nA.length == 4\n0 <= A[i] <= 9
__label__0 In a network of nodes, each node i is directly connected to another node j if and only if\xc2\xa0graph[i][j] = 1.\nSome nodes initial are initially infected by malware.\xc2\xa0 Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.\xc2\xa0 This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial)\xc2\xa0is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will\xc2\xa0remove one node from the initial list.\xc2\xa0 Return the node that if removed, would minimize\xc2\xa0M(initial).\xc2\xa0 If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial\xc2\xa0list of infected nodes, it may still be infected later as a result of the malware spread.\n\xc2\xa0\n\n\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\nExample 2:\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\n\nExample 3:\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\n\n\xc2\xa0\nNote:\n\n1 < graph.length = graph[0].length <= 300\n0 <= graph[i][j] == graph[j][i] <= 1\ngraph[i][i] = 1\n1 <= initial.length < graph.length\n0 <= initial[i] < graph.length
__label__0 Given an array A of integers, for each integer A[i] we need to choose either\xc2\xa0x = -K\xc2\xa0or x = K, and add x to A[i] (only once).\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of B\xc2\xa0and the minimum value of B.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = [1], K = 0\nOutput: 0\nExplanation: B = [1]\n\n\nExample 2:\nInput: A = [0,10], K = 2\nOutput: 6\nExplanation: B = [2,8]\n\n\nExample 3:\nInput: A = [1,3,6], K = 3\nOutput: 3\nExplanation: B = [4,6,3]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n0 <= A[i] <= 10000\n0 <= K <= 10000
__label__0 Given a collection of distinct integers, return all possible permutations.\nExample:\nInput: [1,2,3]\nOutput:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]
__label__0 We have a list of points\xc2\xa0on the plane.\xc2\xa0 Find the K closest points to the origin (0, 0).\n(Here, the distance between two points on a plane is the Euclidean distance.)\nYou may return the answer in any order.\xc2\xa0 The\xc2\xa0answer is guaranteed to be unique (except for the order that it is in.)\n\xc2\xa0\n\nExample 1:\nInput: points = [[1,3],[-2,2]], K = 1\nOutput: [[-2,2]]\nExplanation: \nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\n\n\nExample 2:\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\nOutput: [[3,3],[-2,4]]\n(The answer [[-2,4],[3,3]] would also be accepted.)\n\n\xc2\xa0\nNote:\n\n1 <= K <= points.length <= 10000\n-10000 < points[i][0] < 10000\n-10000 < points[i][1] < 10000
__label__0 The n-queens puzzle is the problem of placing n queens on an n\xc3\x97n chessboard such that no two queens attack each other.\n\nGiven an integer\xc2\xa0n, return the number of\xc2\xa0distinct solutions to the\xc2\xa0n-queens puzzle.\nExample:\nInput: 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown below.\n[\n\xc2\xa0[".Q..", \xc2\xa0// Solution 1\n\xc2\xa0 "...Q",\n\xc2\xa0 "Q...",\n\xc2\xa0 "..Q."],\n\n\xc2\xa0["..Q.", \xc2\xa0// Solution 2\n\xc2\xa0 "Q...",\n\xc2\xa0 "...Q",\n\xc2\xa0 ".Q.."]\n]
__label__0 Given the root of a binary tree with N nodes, each node\xc2\xa0in the tree has node.val coins, and there are N coins total.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another.\xc2\xa0 (The move may be from parent to child, or from child to parent.)\nReturn the number of moves required to make every node have exactly one coin.\n\xc2\xa0\n\nExample 1:\n\nInput: [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n\nExample 2:\n\nInput: [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.\n\n\nExample 3:\n\nInput: [1,0,2]\nOutput: 2\n\n\nExample 4:\n\nInput: [1,0,0,null,3]\nOutput: 4\n\n\xc2\xa0\nNote:\n\n1<= N <= 100\n0 <= node.val <= N
__label__0 There are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2\xc2\xa0cannot be both empty.\nExample 1:\nnums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n\nExample 2:\nnums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5
__label__0 Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId is the primary key column for this table.\n\nFor example, after running your query, the above Person table should have the following rows:\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n\nNote:\nYour output is the whole Person\xc2\xa0table after executing your sql. Use delete statement.
__label__0 Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most\xc2\xa0twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nGiven nums = [1,1,1,2,2,3],\n\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\nExample 2:\nGiven nums = [0,0,1,1,1,1,2,3,3],\n\nYour function should return length = 7, with the first seven elements of nums being modified to\xc2\xa00, 0, 1, 1, 2, 3 and\xc2\xa03 respectively.\n\nIt doesn't matter what values are set beyond\xc2\xa0the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n\xc2\xa0 \xc2\xa0 print(nums[i]);\n}
__label__0 In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino.\xc2\xa0 (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\nWe may rotate the i-th domino, so that A[i] and B[i] swap values.\nReturn the minimum number of rotations so that all the values in A are the same, or all the values in B\xc2\xa0are the same.\nIf it cannot be done, return -1.\n\xc2\xa0\nExample 1:\n\nInput: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]\nOutput: 2\nExplanation: \nThe first figure represents the dominoes as given by A and B: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\nExample 2:\nInput: A = [3,5,1,2,3], B = [3,6,3,3,4]\nOutput: -1\nExplanation: \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n\xc2\xa0\nNote:\n\n1 <= A[i], B[i] <= 6\n2 <= A.length == B.length <= 20000
__label__0 Write an algorithm to determine if a number is "happy".\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\nExample:\xc2\xa0\nInput: 19\nOutput: true\nExplanation: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1
__label__0 All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\nExample:\nInput: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"\n\nOutput: ["AAAAACCCCC", "CCCCCAAAAA"]
__label__0 Given a string containing only digits, restore it by returning all possible valid IP address combinations.\nExample:\nInput: "25525511135"\nOutput: ["255.255.11.135", "255.255.111.35"]
__label__0 Given a binary tree, return the postorder traversal of its nodes' values.\nExample:\nInput:\xc2\xa0[1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput:\xc2\xa0[3,2,1]\n\nFollow up: Recursive solution is trivial, could you do it iteratively?
__label__0 You are playing a simplified Pacman game. You\xc2\xa0start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]).\nEach turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.\nYou escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)\xc2\xa0 If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.\nReturn True if and only if it is possible to escape.\nExample 1:\nInput: \nghosts = [[1, 0], [0, 3]]\ntarget = [0, 1]\nOutput: true\nExplanation: \nYou can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.\n\nExample 2:\nInput: \nghosts = [[1, 0]]\ntarget = [2, 0]\nOutput: false\nExplanation: \nYou need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\n\nExample 3:\nInput: \nghosts = [[2, 0]]\ntarget = [1, 0]\nOutput: false\nExplanation: \nThe ghost can reach the target at the same time as you.\n\nNote:\n\nAll points have coordinates with absolute value <= 10000.\nThe number of ghosts will not exceed 100.
__label__0 International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We\'ll call such a concatenation, the transformation\xc2\xa0of a word.\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = ["gin", "zen", "gig", "msg"]\nOutput: 2\nExplanation: \nThe transformation of each word is:\n"gin" -> "--...-."\n"zen" -> "--...-."\n"gig" -> "--...--."\n"msg" -> "--...--."\n\nThere are 2 different transformations, "--...-." and "--...--.".\n\nNote:\n\nThe length of words will be at most 100.\nEach words[i] will have length in range [1, 12].\nwords[i] will only consist of lowercase letters.
__label__0 Given an input string, reverse the string word by word.\n\xc2\xa0\nExample 1:\nInput: "the sky is blue"\nOutput:\xc2\xa0"blue is sky the"\n\nExample 2:\nInput: " \xc2\xa0hello world! \xc2\xa0"\nOutput:\xc2\xa0"world! hello"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nExample 3:\nInput: "a good \xc2\xa0 example"\nOutput:\xc2\xa0"example good a"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\xc2\xa0\nNote:\n\nA word is defined as a sequence of non-space characters.\nInput string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.\nYou need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\xc2\xa0\nFollow up:\nFor C programmers, try to solve it in-place in O(1) extra space.
__label__0 Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.\nNow, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\nSo, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\nNote:\n\nNumbers of houses and heaters you are given are non-negative and will not exceed 25000.\nPositions of houses and heaters you are given are non-negative and will not exceed 10^9.\nAs long as a house is in the heaters' warm radius range, it can be warmed.\nAll the heaters follow your radius standard and the warm radius will the same.\n\n\xc2\xa0\nExample 1:\nInput: [1,2,3],[2]\nOutput: 1\nExplanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n\n\xc2\xa0\nExample 2:\nInput: [1,2,3,4],[1,4]\nOutput: 1\nExplanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
__label__0 You are given two arrays (without duplicates) nums1 and nums2 where nums1\xe2\x80\x99s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. \n\n\nThe Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n\nExample 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2].\nOutput: [-1,3,-1]\nExplanation:\n    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n    For number 1 in the first array, the next greater number for it in the second array is 3.\n    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n\n\nExample 2:\nInput: nums1 = [2,4], nums2 = [1,2,3,4].\nOutput: [3,-1]\nExplanation:\n    For number 2 in the first array, the next greater number for it in the second array is 3.\n    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n\n\nNote:\n\nAll elements in nums1 and nums2 are unique.\nThe length of both nums1 and nums2 would not exceed 1000.
__label__0 Given a binary tree, find the leftmost value in the last row of the tree. \n\nExample 1:\nInput:\n\n    2\n   / \\\n  1   3\n\nOutput:\n1\n\n\n  Example 2: \nInput:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\nOutput:\n7\n\n\nNote:\nYou may assume the tree (i.e., the given root node) is not NULL.
__label__0 A password is considered strong if below conditions are all met:\n\n It has at least 6 characters and at most 20 characters. \n It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. \n It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met). \n\nWrite a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.\nInsertion, deletion or replace of any one character are all considered as one change.
__label__0 You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.\nFlatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.\n\xc2\xa0\nExample:\nInput:\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\nOutput:\n1-2-3-7-8-11-12-9-10-4-5-6-NULL\n\n\xc2\xa0\nExplanation for the above example:\nGiven the following multilevel doubly linked list:\n\n\xc2\xa0\nWe should return the following flattened doubly linked list:
__label__0 Given an array w of positive integers, where w[i] describes the weight of index i,\xc2\xa0write a function pickIndex\xc2\xa0which randomly\xc2\xa0picks an index\xc2\xa0in proportion\xc2\xa0to its weight.\nNote:\n\n1 <= w.length <= 10000\n1 <= w[i] <= 10^5\npickIndex\xc2\xa0will be called at most 10000 times.\n\nExample 1:\nInput: \n["Solution","pickIndex"]\n[[[1]],[]]\nOutput: [null,0]\n\n\nExample 2:\nInput: \n["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]\n[[[1,3]],[],[],[],[],[]]\nOutput: [null,0,1,1,1,0]\n\nExplanation of Input Syntax:\nThe input is two lists:\xc2\xa0the subroutines called\xc2\xa0and their\xc2\xa0arguments.\xc2\xa0Solution\'s\xc2\xa0constructor has one argument, the\xc2\xa0array w. pickIndex has no arguments.\xc2\xa0Arguments\xc2\xa0are\xc2\xa0always wrapped with a list, even if there aren\'t any.
__label__0 Implement a data structure supporting the following operations:\n\n\nInc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.\nDec(Key) - If Key\'s value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.\nGetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "".\nGetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".\n\n\n\nChallenge: Perform all these in O(1) time complexity.
__label__0 Let's play the minesweeper game (Wikipedia, online game)!\nYou are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\nNow given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:\n\nIf a mine ('M') is revealed, then the game is over - change it to 'X'.\nIf an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\nIf an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\nReturn the board when no more squares will be revealed.\n\n\xc2\xa0\nExample 1:\nInput: \n\n[['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'M', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E']]\n\nClick : [3,0]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nExplanation:\n\n\nExample 2:\nInput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nClick : [1,2]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'X', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nExplanation:\n\n\n\xc2\xa0\nNote:\n\nThe range of the input matrix's height and width is [1,50].\nThe click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.\nThe input board won't be a stage when game is over (some mines have been revealed).\nFor simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.
__label__0 Given a non-empty array of numbers, a0, a1, a2, \xe2\x80\xa6 , an-1, where 0 \xe2\x89\xa4 ai < 231.\nFind the maximum result of ai XOR aj, where 0 \xe2\x89\xa4 i, j < n.\nCould you do this in O(n) runtime?\nExample:\nInput: [3, 10, 5, 25, 2, 8]\n\nOutput: 28\n\nExplanation: The maximum result is 5 ^ 25 = 28.
__label__0 Given a list of non-overlapping\xc2\xa0axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space\xc2\xa0covered by the rectangles.\nNote:\n\nAn integer point\xc2\xa0is a point that has integer coordinates.\xc2\xa0\nA point\xc2\xa0on the perimeter\xc2\xa0of a rectangle is\xc2\xa0included in the space covered by the rectangles.\xc2\xa0\nith rectangle = rects[i] =\xc2\xa0[x1,y1,x2,y2], where [x1, y1]\xc2\xa0are the integer coordinates of the bottom-left corner, and [x2, y2]\xc2\xa0are the integer coordinates of the top-right corner.\nlength and width of each rectangle does not exceed 2000.\n1 <= rects.length\xc2\xa0<= 100\npick return a point as an array of integer coordinates\xc2\xa0[p_x, p_y]\npick is called at most 10000\xc2\xa0times.\n\n\nExample 1:\nInput: \n["Solution","pick","pick","pick"]\n[[[[1,1,5,5]]],[],[],[]]\nOutput: \n[null,[4,1],[4,1],[3,3]]\n\n\nExample 2:\nInput: \n["Solution","pick","pick","pick","pick","pick"]\n[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]\nOutput: \n[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]\n\n\nExplanation of Input Syntax:\nThe input is two lists:\xc2\xa0the subroutines called\xc2\xa0and their\xc2\xa0arguments.\xc2\xa0Solution\'s\xc2\xa0constructor has one argument, the array of rectangles rects. pick\xc2\xa0has no arguments.\xc2\xa0Arguments\xc2\xa0are\xc2\xa0always wrapped with a list, even if there aren\'t any.
__label__0 In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)\nReturn true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.\nExample :\nInput: \n[1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.\n\nNote:\n\nThe length of A will be in the range\xc2\xa0[1, 30].\nA[i] will be in the range of [0, 10000].
__label__0 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\nThe cache is initialized with a positive capacity.\nFollow up:\nCould you do both operations in O(1) time complexity?\nExample:\nLRUCache cache = new LRUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.put(4, 4);    // evicts key 1\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4
__label__0 Given a binary tree, return the inorder traversal of its nodes' values.\nExample:\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [1,3,2]\nFollow up: Recursive solution is trivial, could you do it iteratively?
__label__0 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote:\n\nThe number of elements initialized in nums1 and nums2 are m and n respectively.\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n\nExample:\nInput:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput:\xc2\xa0[1,2,2,3,5,6]
__label__0 Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: [5,7]\nOutput: 4\n\nExample 2:\nInput: [0,1]\nOutput: 0
__label__0 Given a text file\xc2\xa0file.txt, print\xc2\xa0just the 10th line of the\xc2\xa0file.\nExample:\nAssume that file.txt has the following content:\nLine 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n\nYour script should output the tenth line, which is:\nLine 10\n\nNote:\n1. If the file contains less than 10 lines, what should you output?\n2. There's at least three different solutions. Try to explore all possibilities.
__label__0 Normally, the factorial of a positive integer n\xc2\xa0is the product of all positive integers less than or equal to n.\xc2\xa0 For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\nWe instead make a clumsy factorial:\xc2\xa0using the integers in decreasing order, we\xc2\xa0swap out the multiply operations for a fixed rotation of operations:\xc2\xa0multiply (*), divide (/), add (+) and subtract (-) in this order.\nFor example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.\xc2\xa0 However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\nAdditionally, the division that we use is floor division\xc2\xa0such that\xc2\xa010 * 9 / 8\xc2\xa0equals\xc2\xa011.\xc2\xa0 This guarantees the result is\xc2\xa0an integer.\nImplement the\xc2\xa0clumsy\xc2\xa0function\xc2\xa0as defined above: given an integer N, it returns the clumsy factorial of N.\n\xc2\xa0\nExample 1:\nInput: 4\nOutput:\xc2\xa07\nExplanation: 7 = 4 * 3 / 2 + 1\n\nExample 2:\nInput: 10\nOutput: 12\nExplanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10000\n-2^31 <= answer <= 2^31 - 1\xc2\xa0 (The answer is guaranteed to fit within a 32-bit integer.)
__label__0 Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard =\n[\n  [\'A\',\'B\',\'C\',\'E\'],\n  [\'S\',\'F\',\'C\',\'S\'],\n  [\'A\',\'D\',\'E\',\'E\']\n]\n\nGiven word = "ABCCED", return true.\nGiven word = "SEE", return true.\nGiven word = "ABCB", return false.
__label__0 The n-queens puzzle is the problem of placing n queens on an n\xc3\x97n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\nEach solution contains a distinct board configuration of the n-queens\' placement, where \'Q\' and \'.\' both indicate a queen and an empty space respectively.\nExample:\nInput: 4\nOutput: [\n [".Q..",  // Solution 1\n  "...Q",\n  "Q...",\n  "..Q."],\n\n ["..Q.",  // Solution 2\n  "Q...",\n  "...Q",\n  ".Q.."]\n]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
__label__0 Given a string, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: "abcabcbb"\nOutput: 3 \nExplanation: The answer is "abc", with the length of 3. \n\n\nExample 2:\nInput: "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n\n\nExample 3:\nInput: "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3. \n             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
__label__0 Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\nIn general a rational number can be represented using up to\xc2\xa0three parts: an\xc2\xa0integer part, a\xc2\xa0non-repeating part, and a\xc2\xa0repeating part. The number will be represented\xc2\xa0in one of the following three ways:\n\n<IntegerPart> (e.g. 0, 12, 123)\n<IntegerPart><.><NonRepeatingPart> \xc2\xa0(e.g. 0.5, 1., 2.12, 2.0001)\n<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))\n\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.\xc2\xa0 For example:\n1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)\nBoth 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.\n\xc2\xa0\nExample 1:\nInput: S = "0.(52)", T = "0.5(25)"\nOutput: true\nExplanation:\nBecause "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.\n\n\nExample 2:\nInput: S = "0.1666(6)", T = "0.166(66)"\nOutput: true\n\n\nExample 3:\nInput: S = "0.9(9)", T = "1."\nOutput: true\nExplanation: \n"0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n"1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".\n\xc2\xa0\n\n\nNote:\n\nEach part consists only of digits.\nThe <IntegerPart>\xc2\xa0will\xc2\xa0not begin with 2 or more zeros.\xc2\xa0 (There is no other restriction on the digits of each part.)\n1 <= <IntegerPart>.length <= 4 \n0 <= <NonRepeatingPart>.length <= 4 \n1 <= <RepeatingPart>.length <= 4
__label__0 Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nYour goal is to reach the last index in the minimum number of jumps.\nExample:\nInput: [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\nNote:\nYou can assume that you can always reach the last index.
__label__0 In an election, the i-th\xc2\xa0vote was cast for persons[i] at time times[i].\nNow, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.\xc2\xa0\xc2\xa0\nVotes cast at time t will count towards our query.\xc2\xa0 In the case of a tie, the most recent vote (among tied candidates) wins.\n\xc2\xa0\n\nExample 1:\nInput: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]\nOutput: [null,0,1,1,0,0,1]\nExplanation: \nAt time 3, the votes are [0], and 0 is leading.\nAt time 12, the votes are [0,1,1], and 1 is leading.\nAt time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\nThis continues for 3 more queries at time 15, 24, and 8.\n\n\xc2\xa0\nNote:\n\n1 <= persons.length = times.length <= 5000\n0 <= persons[i] <= persons.length\ntimes\xc2\xa0is a strictly increasing array with all elements in [0, 10^9].\nTopVotedCandidate.q is called at most 10000 times per test case.\nTopVotedCandidate.q(int t) is always called with t >= times[0].
__label__0 Your friend is typing his name\xc2\xa0into a keyboard.\xc2\xa0 Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed\xc2\xa0characters of the keyboard.\xc2\xa0 Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n\xc2\xa0\nExample 1:\nInput: name = "alex", typed = "aaleex"\nOutput: true\nExplanation: \'a\' and \'e\' in \'alex\' were long pressed.\n\n\nExample 2:\nInput: name = "saeed", typed = "ssaaedd"\nOutput: false\nExplanation: \'e\' must have been pressed twice, but it wasn\'t in the typed output.\n\n\nExample 3:\nInput: name = "leelee", typed = "lleeelee"\nOutput: true\n\n\nExample 4:\nInput: name = "laiden", typed = "laiden"\nOutput: true\nExplanation: It\'s not necessary to long press any character.\n\n\xc2\xa0\n\n\n\nNote:\n\nname.length <= 1000\ntyped.length <= 1000\nThe characters of name and typed are lowercase letters.
__label__0 You have an initial power P, an initial score of 0 points, and a bag of tokens.\nEach token can be used at most once, has a value token[i], and has potentially two ways to use it.\n\nIf we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.\nIf we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.\n\nReturn the largest number of points we can have after playing any number of tokens.\n\xc2\xa0\n\n\n\nExample 1:\nInput: tokens = [100], P = 50\nOutput: 0\n\n\nExample 2:\nInput: tokens = [100,200], P = 150\nOutput: 1\n\n\nExample 3:\nInput: tokens = [100,200,300,400], P = 200\nOutput: 2\n\n\xc2\xa0\nNote:\n\ntokens.length <= 1000\n0 <= tokens[i] < 10000\n0 <= P < 10000
__label__0 There are\xc2\xa0n\xc2\xa0items each\xc2\xa0belonging to zero or one of\xc2\xa0m\xc2\xa0groups where group[i]\xc2\xa0is the group that the i-th item belongs to and it's equal to -1\xc2\xa0if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\nReturn a sorted list of the items such that:\n\nThe items that belong to the same group are next to each other in the sorted list.\nThere are some\xc2\xa0relations\xc2\xa0between these items where\xc2\xa0beforeItems[i]\xc2\xa0is a list containing all the items that should come before the\xc2\xa0i-th item in the sorted array (to the left of the\xc2\xa0i-th item).\n\nReturn any solution if there is more than one solution and return an empty list\xc2\xa0if there is no solution.\n\xc2\xa0\nExample 1:\n\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\nOutput: [6,3,4,1,5,2,0,7]\n\nExample 2:\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\nOutput: []\nExplanation:\xc2\xa0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n\n\xc2\xa0\nConstraints:\n\n1 <= m <= n <= 3*10^4\ngroup.length == beforeItems.length == n\n-1 <= group[i] <= m-1\n0 <= beforeItems[i].length <= n-1\n0 <= beforeItems[i][j] <= n-1\ni != beforeItems[i][j]\nbeforeItems[i]\xc2\xa0does not contain\xc2\xa0duplicates elements.
__label__0 Given an array A of integers, a ramp\xc2\xa0is a tuple (i, j) for which i < j\xc2\xa0and\xc2\xa0A[i] <= A[j].\xc2\xa0 The width of such a\xc2\xa0ramp is j - i.\nFind the maximum width of a ramp in A.\xc2\xa0 If one doesn't exist, return 0.\n\xc2\xa0\nExample 1:\nInput: [6,0,8,2,1,5]\nOutput: 4\nExplanation: \nThe maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.\n\n\nExample 2:\nInput: [9,8,1,0,1,9,4,0,4,1]\nOutput: 7\nExplanation: \nThe maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.\n\n\n\n\n\xc2\xa0\nNote:\n\n2 <= A.length <= 50000\n0 <= A[i] <= 50000
__label__0 Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \xe2\x80\x9cThe lowest common ancestor is defined between two nodes p\xc2\xa0and q\xc2\xa0as the lowest node in T that has both p\xc2\xa0and q\xc2\xa0as descendants (where we allow a node to be a descendant of itself).\xe2\x80\x9d\nGiven the following binary tree:\xc2\xa0 root =\xc2\xa0[3,5,1,6,2,0,8,null,null,7,4]\n\n\xc2\xa0\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\xc2\xa0\nNote:\n\nAll of the nodes' values will be unique.\np and q are different and both values will\xc2\xa0exist in the binary tree.
__label__0 Design a HashSet\xc2\xa0without using any built-in hash table libraries.\nTo be specific, your design should include these functions:\n\nadd(value):\xc2\xa0Insert a value into the HashSet.\xc2\xa0\ncontains(value) : Return whether the value exists in the HashSet or not.\nremove(value): Remove a value in\xc2\xa0the HashSet. If the value does not exist in the HashSet, do nothing.\n\n\nExample:\nMyHashSet hashSet = new MyHashSet();\nhashSet.add(1); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \nhashSet.add(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \nhashSet.contains(1); \xc2\xa0\xc2\xa0\xc2\xa0// returns true\nhashSet.contains(3); \xc2\xa0\xc2\xa0\xc2\xa0// returns false (not found)\nhashSet.add(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0\nhashSet.contains(2); \xc2\xa0\xc2\xa0\xc2\xa0// returns true\nhashSet.remove(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0\nhashSet.contains(2); \xc2\xa0\xc2\xa0\xc2\xa0// returns false (already removed)\n\n\nNote:\n\nAll values will be in the range of [0, 1000000].\nThe number of operations will be in the range of\xc2\xa0[1, 10000].\nPlease do not use the built-in HashSet library.
__label__0 Given two strings s and t\xc2\xa0, write a function to determine if t is an anagram of s.\nExample 1:\nInput: s = "anagram", t = "nagaram"\nOutput: true\n\nExample 2:\nInput: s = "rat", t = "car"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\nFollow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?
__label__0 Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \\n.\nIn C++, there are two types of comments, line comments, and block comments.\n\nThe string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\n\nThe string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.\n\nThe first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.\n\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\n\nThere will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)\n\nIt is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.\n\nFinally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.\n\nAfter removing the comments from the source code, return the source code in the same format.\nExample 1:\nInput: \nsource = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]\n\nThe line by line code is visualized as below:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\n\nOutput: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]\n\nThe line by line code is visualized as below:\nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}\n\nExplanation: \nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\n\n\nExample 2:\nInput: \nsource = ["a/*comment", "line", "more_comment*/b"]\nOutput: ["ab"]\nExplanation: The original source string is "a/*comment\\nline\\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].\n\n\nNote:\nThe length of source is in the range [1, 100].\nThe length of source[i] is in the range [0, 80].\nEvery open block comment is eventually closed.\nThere are no single-quote, double-quote, or control characters in the source code.
__label__0 Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.\n\nFor example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n\nNote:\nThe length of temperatures will be in the range [1, 30000].\nEach temperature will be an integer in the range [30, 100].
__label__0 An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.\n\nFind the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.\n\nExample 1:\nInput: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]\nOutput: 3\nExplanation:\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n\n\nExample 2:\nInput: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]\nOutput: 5\nExplanation:\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n\n\nNote:\nintervals will have length in range [1, 3000].\nintervals[i] will have length 2, representing some integer interval.\nintervals[i][j] will be an integer in [0, 10^8].
__label__0 You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\nAn expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n\n(An integer could be positive or negative.)\n\nA let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string "let", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.\n\nAn add-expression takes the form (add e1 e2) where add is always the string "add", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.\n\nA mult-expression takes the form (mult e1 e2) where mult is always the string "mult", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.\n\nFor the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.\n\nFinally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n\nEvaluation Examples:\nInput: (add 1 2)\nOutput: 3\n\nInput: (mult 3 (add 2 3))\nOutput: 15\n\nInput: (let x 2 (mult x 5))\nOutput: 10\n\nInput: (let x 2 (mult x (let x 3 y 4 (add x y))))\nOutput: 14\nExplanation: In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\nInput: (let x 3 x 2 x)\nOutput: 2\nExplanation: Assignment in let statements is processed sequentially.\n\nInput: (let x 1 y 2 x (add x y) (add x y))\nOutput: 5\nExplanation: The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\nOutput: 6\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\nof the final x in the add-expression.  That final x will equal 2.\n\nInput: (let a1 3 b2 (add a1 1) b2) \nOutput 4\nExplanation: Variable names can contain digits after the first character.\n\n\nNote:\nThe given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.\nThe length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.)\nThe answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.
__label__0 You are standing at position 0 on an infinite number line.  There is a goal at position target.\n\nOn each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.\n\nReturn the minimum number of steps required to reach the destination.\n\nExample 1:\nInput: target = 3\nOutput: 2\nExplanation:\nOn the first move we step from 0 to 1.\nOn the second step we step from 1 to 3.\n\n\nExample 2:\nInput: target = 2\nOutput: 3\nExplanation:\nOn the first move we step from 0 to 1.\nOn the second move we step  from 1 to -1.\nOn the third move we step from -1 to 2.\n\n\nNote:\ntarget will be a non-zero integer in the range [-10^9, 10^9].
__label__0 Given a sorted integer array without duplicates, return the summary of its ranges.\nExample 1:\nInput:  [0,1,2,4,5,7]\nOutput: ["0->2","4->5","7"]\nExplanation: 0,1,2 form a continuous range;\xc2\xa04,5 form a continuous range.\n\nExample 2:\nInput:  [0,2,3,4,6,8,9]\nOutput: ["0","2->4","6","8->9"]\nExplanation: 2,3,4 form a continuous range;\xc2\xa08,9 form a continuous range.
__label__0 Given a singly linked list, determine if it is a palindrome.\nExample 1:\nInput: 1->2\nOutput: false\nExample 2:\nInput: 1->2->2->1\nOutput: true\nFollow up:\nCould you do it in O(n) time and O(1) space?
__label__0 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.\n\nExample:\nConsider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\nGiven\xc2\xa0target\xc2\xa0=\xc2\xa05, return\xc2\xa0true.\nGiven\xc2\xa0target\xc2\xa0=\xc2\xa020, return\xc2\xa0false.
__label__0 Design your\xc2\xa0implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly\xc2\xa0linked list should have two attributes: val\xc2\xa0and next. val is the value of the current node, and next\xc2\xa0is\xc2\xa0a\xc2\xa0pointer/reference to the next node. If you want to use the doubly linked list,\xc2\xa0you will need\xc2\xa0one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\nImplement these functions in your linked list class:\n\nget(index) : Get the value of\xc2\xa0the index-th\xc2\xa0node in the linked list. If the index is invalid, return -1.\naddAtHead(val) : Add a node of value val\xc2\xa0before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\naddAtTail(val) : Append a node of value val\xc2\xa0to the last element of the linked list.\naddAtIndex(index, val) : Add a node of value val\xc2\xa0before the index-th\xc2\xa0node in the linked list.\xc2\xa0If index\xc2\xa0equals\xc2\xa0to the length of\xc2\xa0linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. If index is negative, the node will be inserted at the head\xc2\xa0of the list.\ndeleteAtIndex(index) : Delete\xc2\xa0the index-th\xc2\xa0node in the linked list, if the index is valid.\n\nExample:\nMyLinkedList linkedList = new MyLinkedList();\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1, 2);  // linked list becomes 1->2->3\nlinkedList.get(1);            // returns 2\nlinkedList.deleteAtIndex(1);  // now the linked list is 1->3\nlinkedList.get(1);\xc2\xa0\xc2\xa0\xc2\xa0         // returns 3\n\nNote:\n\nAll values will be in the range of [1, 1000].\nThe number of operations will be in the range of\xc2\xa0[1, 1000].\nPlease do not use the built-in LinkedList library.
__label__0 In a deck of cards, every card has a unique integer.\xc2\xa0 You can order the deck in\xc2\xa0any order you want.\nInitially, all the cards start face down (unrevealed) in one deck.\nNow, you do the following steps repeatedly, until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck, put the next top card of the deck at\xc2\xa0the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1.\xc2\xa0 Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards\xc2\xa0in increasing order.\nThe first entry in the answer is considered to be the top of the deck.\n\xc2\xa0\n\nExample 1:\nInput: [17,13,11,2,3,5,7]\nOutput: [2,13,3,11,5,17,7]\nExplanation: \nWe get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.\n\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 1000\n1 <= A[i] <= 10^6\nA[i] != A[j]\xc2\xa0for all\xc2\xa0i != j
__label__0 You have an array of logs.\xc2\xa0 Each log is a space delimited string of words.\nFor each log, the first word in each log is an alphanumeric identifier.\xc2\xa0 Then, either:\n\nEach word after the identifier will consist only of lowercase letters, or;\nEach word after the identifier will consist only of digits.\n\nWe will call these two varieties of logs letter-logs and digit-logs.\xc2\xa0 It is guaranteed that each log has at least one word after its identifier.\nReorder the logs so that all of the letter-logs come before any digit-log.\xc2\xa0 The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.\xc2\xa0 The digit-logs should be put in their original order.\nReturn the final order of the logs.\n\xc2\xa0\nExample 1:\nInput: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]\nOutput: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]\n\n\xc2\xa0\nConstraints:\n\n0 <= logs.length <= 100\n3 <= logs[i].length <= 100\nlogs[i] is guaranteed to have an identifier, and a word after the identifier.
__label__0 On an N x N board, the numbers from 1 to N*N are written\xc2\xa0boustrophedonically\xc2\xa0starting from the bottom\xc2\xa0left of the board, and alternating direction each row.\xc2\xa0 For example, for a 6 x 6 board, the numbers are written as follows:\n\n\nYou start on square 1 of the board (which is always in the last row and\xc2\xa0first column).\xc2\xa0 Each move, starting from square x, consists of the following:\n\nYou choose a destination square S with number\xc2\xa0x+1, x+2, x+3, x+4, x+5, or x+6, provided this\xc2\xa0number is\xc2\xa0<=\xc2\xa0N*N.\n\n\t\n(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)\n\n\nIf S\xc2\xa0has a snake or ladder, you move to the destination of that snake or ladder.\xc2\xa0 Otherwise, you move to S.\n\nA board square on row r and column c\xc2\xa0has a "snake or ladder" if board[r][c] != -1.\xc2\xa0 The destination of that snake or ladder is board[r][c].\nNote that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another\xc2\xa0snake or ladder, you do not continue moving.\xc2\xa0 (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at\xc2\xa0`3`, because you do not continue moving to `4`.)\nReturn the least number of moves required to reach square N*N.\xc2\xa0 If it is not possible, return -1.\nExample 1:\nInput: [\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,35,-1,-1,13,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,15,-1,-1,-1,-1]]\nOutput: 4\nExplanation: \nAt the beginning, you start at square 1 [at row 5, column 0].\nYou decide to move to square 2, and must take the ladder to square 15.\nYou then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.\nYou then decide to move to square 14, and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nIt can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.\n\nNote:\n\n2 <= board.length = board[0].length\xc2\xa0<= 20\nboard[i][j]\xc2\xa0is between 1 and N*N or is equal to -1.\nThe board\xc2\xa0square with number 1 has no snake or ladder.\nThe board square with number N*N has no snake or ladder.
__label__0 Given an integer array A, and an integer target, return the number of\xc2\xa0tuples\xc2\xa0i, j, k\xc2\xa0 such that i < j < k and\xc2\xa0A[i] + A[j] + A[k] == target.\nAs the answer can be very large, return it modulo\xc2\xa010^9 + 7.\n\xc2\xa0\nExample 1:\nInput: A = [1,1,2,2,3,3,4,4,5,5], target = 8\nOutput: 20\nExplanation: \nEnumerating by the values (A[i], A[j], A[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n\n\nExample 2:\nInput: A = [1,1,2,2,2,2], target = 5\nOutput: 12\nExplanation: \nA[i] = 1, A[j] = A[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n\n\xc2\xa0\n\nNote:\n\n3 <= A.length <= 3000\n0 <= A[i] <= 100\n0 <= target <= 300
__label__0 Given an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].
__label__0 On a 2-dimensional\xc2\xa0grid, there are 4 types of squares:\n\n1 represents the starting square.\xc2\xa0 There is exactly one starting square.\n2 represents the ending square.\xc2\xa0 There is exactly one ending square.\n0 represents empty squares we can walk over.\n-1 represents obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks\xc2\xa0from the starting square to the ending square, that walk over every non-obstacle square\xc2\xa0exactly once.\n\xc2\xa0\n\nExample 1:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\nInput: [[0,1],[2,0]]\nOutput: 0\nExplanation: \nThere is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\n\n\n\xc2\xa0\nNote:\n\n1 <= grid.length * grid[0].length <= 20
__label__0 Given a collection of numbers that might contain duplicates, return all possible unique permutations.\nExample:\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]
__label__0 Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\n\xc2\xa0\n\nExample 1:\nInput: A = [4,5,0,-2,-3,1], K = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by K = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 30000\n-10000 <= A[i] <= 10000\n2 <= K <= 10000
__label__0 Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample:\nInput:\xc2\xa0[1,2,3,null,5,null,4]\nOutput:\xc2\xa0[1, 3, 4]\nExplanation:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---
__label__0 Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.\nYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)\nYou may also assume each line in the text file must not contain leading or trailing white spaces.\nExample:\nAssume that file.txt has the following content:\n987-123-4567\n123 456 7890\n(123) 456-7890\n\nYour script should output the following valid phone numbers:\n987-123-4567\n(123) 456-7890
__label__0 We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.\nThe number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].\nThe number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].\nReturn true\xc2\xa0if and only if the number of global inversions is equal to the number of local inversions.\nExample 1:\nInput: A = [1,0,2]\nOutput: true\nExplanation: There is 1 global inversion, and 1 local inversion.\n\nExample 2:\nInput: A = [1,2,0]\nOutput: false\nExplanation: There are 2 global inversions, and 1 local inversion.\n\nNote:\n\nA will be a permutation of [0, 1, ..., A.length - 1].\nA will have length in range [1, 5000].\nThe time limit for this problem has been reduced.
__label__0 Reverse a linked list from position m to n. Do it in one-pass.\nNote:\xc2\xa01 \xe2\x89\xa4 m \xe2\x89\xa4 n \xe2\x89\xa4 length of list.\nExample:\nInput: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL
__label__0 Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample:\nInput: head = 1->4->3->2->5->2, x = 3\nOutput: 1->2->2->4->3->5
__label__0 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., \xc2\xa0[0,1,2,4,5,6,7]\xc2\xa0might become \xc2\xa0[4,5,6,7,0,1,2]).\nFind the minimum element.\nThe array may contain duplicates.\nExample 1:\nInput: [1,3,5]\nOutput: 1\nExample 2:\nInput: [2,2,2,0,1]\nOutput: 0\nNote:\n\nThis is a follow up problem to\xc2\xa0Find Minimum in Rotated Sorted Array.\nWould allow duplicates affect the run-time complexity? How and why?
__label__0 We have a grid of 1s and 0s; the 1s in a cell represent bricks.\xc2\xa0 A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.\nWe will do some erasures\xc2\xa0sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may\xc2\xa0drop because of that\xc2\xa0erasure.\nReturn an array representing the number of bricks that will drop after each erasure in sequence.\nExample 1:\nInput: \ngrid = [[1,0,0,0],[1,1,1,0]]\nhits = [[1,0]]\nOutput: [2]\nExplanation: \nIf we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.\nExample 2:\nInput: \ngrid = [[1,0,0,0],[1,1,0,0]]\nhits = [[1,1],[1,0]]\nOutput: [0,0]\nExplanation: \nWhen we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.\n\xc2\xa0\nNote:\n\nThe number of rows and columns in the grid will be in the range\xc2\xa0[1, 200].\nThe number of erasures will not exceed the area of the grid.\nIt is guaranteed that each erasure will be different from any other erasure, and located inside the grid.\nAn erasure may refer to a location with no brick - if it does, no bricks drop.
__label__0 X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.\xc2\xa0 Each digit must be rotated - we cannot choose to leave it alone.\nA number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.\nNow\xc2\xa0given a positive number N, how many numbers X from 1 to N are good?\nExample:\nInput: 10\nOutput: 4\nExplanation: \nThere are four good numbers in the range [1, 10] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\nNote:\n\nN\xc2\xa0 will be in range [1, 10000].
__label__0 Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4->2->1->3\nOutput: 1->2->3->4\n\nExample 2:\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5
__label__0 Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\nNote:\n\nThe given integer is guaranteed to fit within the range of a 32-bit signed integer.\nYou could assume no leading zero bit in the integer\xe2\x80\x99s binary representation.\n\n\nExample 1:\nInput: 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\n\nExample 2:\nInput: 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
__label__0 Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\n\n\nIPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;\n\n\nBesides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.\n\n\nIPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).\n\n\nHowever, we don\'t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.\n\n\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.\n\nNote:\nYou may assume there is no extra space or special characters in the input string.\n\nExample 1:\nInput: "172.16.254.1"\n\nOutput: "IPv4"\n\nExplanation: This is a valid IPv4 address, return "IPv4".\n\n\nExample 2:\nInput: "2001:0db8:85a3:0:0:8A2E:0370:7334"\n\nOutput: "IPv6"\n\nExplanation: This is a valid IPv6 address, return "IPv6".\n\n\nExample 3:\nInput: "256.256.256.256"\n\nOutput: "Neither"\n\nExplanation: This is neither a IPv4 address nor a IPv6 address.
__label__0 Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.\nNote that the number of times an item is used is the number of calls to the\xc2\xa0get\xc2\xa0and\xc2\xa0put\xc2\xa0functions for that item since it was inserted. This number is set to zero when the item is removed.\n\xc2\xa0\nFollow up:\nCould you do both operations in O(1) time complexity?\n\xc2\xa0\nExample:\nLFUCache cache = new LFUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.get(3);       // returns 3.\ncache.put(4, 4);    // evicts key 1.\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4
__label__0 Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n\nExample 1:\nInput: [3, 1, 4, 1, 5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.\n\n\nExample 2:\nInput:[1, 2, 3, 4, 5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n\n\nExample 3:\nInput: [1, 3, 1, 5, 4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n\n\nNote:\n\nThe pairs (i, j) and (j, i) count as the same pair.\nThe length of the array won't exceed 10,000.\nAll the integers in the given input belong to the range: [-1e7, 1e7].
__label__0 Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\nFor example, given a 3-ary tree:\n\xc2\xa0\n\n\xc2\xa0\nWe should return its level order traversal:\n[\n     [1],\n     [3,2,4],\n     [5,6]\n]\n\n\xc2\xa0\nNote:\n\nThe depth of the tree is at most 1000.\nThe total number of nodes is at most 5000.
__label__0 Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n\n\nYou receive a valid board, made of only battleships or empty slots.\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n\nExample:\nX..X\n...X\n...X\n\nIn the above board there are 2 battleships.\n\nInvalid Example:\n...X\nXXXX\n...X\n\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n\nFollow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?
__label__0 Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.\nWater can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\nFind the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\nNote:\n\nThe order of returned grid coordinates does not matter.\nBoth m and n are less than 150.\n\n\xc2\xa0\nExample:\nGiven the following 5x5 matrix:\n\n  Pacific ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
__label__0 You need to find the largest value in each row of a binary tree.\nExample:\nInput: \n\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n\nOutput: [1, 3, 9]
__label__0 Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput:\n\n   1\n    \\\n     3\n    /\n   2\n\nOutput:\n1\n\nExplanation:\nThe minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\n\n\xc2\xa0\nNote: There are at least two nodes in this BST.
__label__0 We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same.\nEach node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.\nYour task is to use a quad tree to represent a given grid. The following example may help you understand the problem better:\nGiven the 8 x 8 grid below, we want to construct the corresponding quad tree:\n\nIt can be divided according to the definition above:\n\n\xc2\xa0\nThe corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair.\nFor the non-leaf\xc2\xa0nodes,\xc2\xa0val can be arbitrary, so it is represented as *.\n\nNote:\n\nN is less than 1000 and guaranteened to be a power of 2.\nIf you want to know more about the quad tree, you can refer to its wiki.
__label__0 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\n\xc2\xa0\nExample 1:\nInput: "abab"\nOutput: True\nExplanation: It\'s the substring "ab" twice.\n\nExample 2:\nInput: "aba"\nOutput: False\n\nExample 3:\nInput: "abcabcabcabc"\nOutput: True\nExplanation: It\'s the substring "abc" four times. (And the substring "abcabc" twice.)
__label__0 Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10\xc2\xa0which generates a uniform random integer in the range 1 to 10.\nDo NOT use system's Math.random().\n\n\n\xc2\xa0\n\nExample 1:\nInput: 1\nOutput: [7]\n\n\nExample 2:\nInput: 2\nOutput: [8,4]\n\n\nExample 3:\nInput: 3\nOutput: [8,1,10]\n\n\xc2\xa0\nNote:\n\nrand7 is predefined.\nEach testcase has one argument:\xc2\xa0n, the number of times that rand10 is called.\n\n\xc2\xa0\nFollow up:\n\nWhat is the expected value\xc2\xa0for the number of calls to\xc2\xa0rand7()\xc2\xa0function?\nCould you minimize the number of calls to rand7()?
__label__0 The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nNow your job is to find the total Hamming distance between all pairs of the given numbers.\n\n\nExample:\nInput: 4, 14, 2\n\nOutput: 6\n\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case). So the answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n\n\nNote:\n\nElements of the given array are in the range of 0  to 10^9\nLength of the array will not exceed 10^4.
__label__0 Sort a linked list using insertion sort.\n\n\n\nA graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.\nWith each iteration one element (red) is removed from the input data and inserted in-place into the sorted list\n\xc2\xa0\n\n\nAlgorithm of Insertion Sort:\n\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\nAt each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\nIt repeats until no input elements remain.\n\n\nExample 1:\nInput: 4->2->1->3\nOutput: 1->2->3->4\n\nExample 2:\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5
__label__0 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., \xc2\xa0[0,1,2,4,5,6,7]\xc2\xa0might become \xc2\xa0[4,5,6,7,0,1,2]).\nFind the minimum element.\nYou may assume no duplicate exists in the array.\nExample 1:\nInput: [3,4,5,1,2] \nOutput: 1\n\nExample 2:\nInput: [4,5,6,7,0,1,2]\nOutput: 0
__label__0 In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.\xc2\xa0 If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\nNow, say our starting node is eventually safe\xc2\xa0if and only if we must eventually walk to a terminal node.\xc2\xa0 More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\nWhich nodes are eventually safe?\xc2\xa0 Return them as an array in sorted order.\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.\xc2\xa0 The\xc2\xa0graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\nExample:\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nHere is a diagram of the above graph.\n\n\n\nNote:\n\ngraph will have length at most 10000.\nThe number of edges in the graph will not exceed 32000.\nEach graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].
__label__0 On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.\nA move consists of choosing 0\xc2\xa0and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\nExamples:\nInput: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.\n\nInput: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.\n\nInput: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]\n\nInput: board = [[3,2,4],[1,5,0]]\nOutput: 14\n\nNote:\n\nboard will be a 2 x 3 array as described above.\nboard[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].
__label__0 Given a text file file.txt, transpose its content.\nYou may assume that each row has the same number of columns and each field is separated by the ' ' character.\nExample:\nIf file.txt has the following content:\nname age\nalice 21\nryan 30\n\nOutput the following:\nname alice ryan\nage 21 30
__label__0 Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput:\n11110\n11010\n11000\n00000\n\nOutput:\xc2\xa01\n\nExample 2:\nInput:\n11000\n11000\n00100\n00011\n\nOutput: 3
__label__0 You are given an n x n 2D matrix representing an image.\nRotate the image by 90 degrees (clockwise).\nNote:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nGiven input matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n\nExample 2:\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]
__label__0 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.
__label__0 Create a timebased key-value store class\xc2\xa0TimeMap, that supports two operations.\n1. set(string key, string value, int timestamp)\n\nStores the key and value, along with the given timestamp.\n\n2. get(string key, int timestamp)\n\nReturns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\nIf there are multiple such values, it returns the one with the largest timestamp_prev.\nIf there are no values, it returns the empty string ("").\n\n\xc2\xa0\n\nExample 1:\nInput: inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]\nOutput: [null,null,"bar","bar",null,"bar2","bar2"]\nExplanation: \xc2\xa0 \nTimeMap kv; \xc2\xa0 \nkv.set("foo", "bar", 1); // store the key "foo" and value "bar" along with timestamp = 1 \xc2\xa0 \nkv.get("foo", 1);  // output "bar" \xc2\xa0 \nkv.get("foo", 3); // output "bar" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie "bar" \xc2\xa0 \nkv.set("foo", "bar2", 4); \xc2\xa0 \nkv.get("foo", 4); // output "bar2" \xc2\xa0 \nkv.get("foo", 5); //output "bar2" \xc2\xa0 \n\n\n\nExample 2:\nInput: inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]\nOutput: [null,null,null,"","high","high","low","low"]\n\n\n\n\xc2\xa0\nNote:\n\nAll key/value strings are lowercase.\nAll key/value strings have\xc2\xa0length in the range\xc2\xa0[1, 100]\nThe timestamps for all TimeMap.set operations are strictly increasing.\n1 <= timestamp <= 10^7\nTimeMap.set and TimeMap.get\xc2\xa0functions will be called a total of 120000 times (combined) per test case.
__label__0 Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nExample 1:\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\nInput:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]
__label__0 Given an array A\xc2\xa0of non-negative integers, half of the integers in A are odd, and half of the integers are even.\nSort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.\nYou may return any answer array that satisfies this condition.\n\xc2\xa0\nExample 1:\nInput: [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\n\xc2\xa0\nNote:\n\n2 <= A.length <= 20000\nA.length % 2 == 0\n0 <= A[i] <= 1000
__label__0 Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i].\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of B\xc2\xa0and the minimum value of B.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = [1], K = 0\nOutput: 0\nExplanation: B = [1]\n\n\nExample 2:\nInput: A = [0,10], K = 2\nOutput: 6\nExplanation: B = [2,8]\n\n\nExample 3:\nInput: A = [1,3,6], K = 3\nOutput: 0\nExplanation: B = [3,3,3] or B = [4,4,4]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n0 <= A[i] <= 10000\n0 <= K <= 10000
__label__0 You want to form a target\xc2\xa0string of lowercase letters.\nAt the beginning, your sequence is target.length\xc2\xa0\'?\' marks.\xc2\xa0 You also have a stamp\xc2\xa0of lowercase letters.\nOn each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.\xc2\xa0 You can make up to 10 * target.length turns.\nFor example, if the initial sequence is "?????", and your stamp is "abc",\xc2\xa0 then you may make "abc??", "?abc?", "??abc"\xc2\xa0in the first turn.\xc2\xa0 (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)\nIf the sequence is possible to stamp, then return an array of\xc2\xa0the index of the left-most letter being stamped at each turn.\xc2\xa0 If the sequence is not possible to stamp, return an empty array.\nFor example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc".\nAlso, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length\xc2\xa0moves.\xc2\xa0 Any answers specifying more than this number of moves\xc2\xa0will not be accepted.\n\xc2\xa0\nExample 1:\nInput: stamp = "abc", target = "ababc"\nOutput: [0,2]\n([1,0,2] would also be accepted as an answer, as well as some other answers.)\n\n\nExample 2:\nInput: stamp = "abca", target = "aabcaca"\nOutput: [3,0,1]\n\n\n\xc2\xa0\nNote:\n\n\n\n1 <= stamp.length <= target.length <= 1000\nstamp and target only contain lowercase letters.
__label__0 A binary tree is univalued if every node in the tree has the same value.\nReturn true\xc2\xa0if and only if the given tree is univalued.\n\xc2\xa0\nExample 1:\n\nInput: [1,1,1,1,1,null,1]\nOutput: true\n\n\nExample 2:\n\nInput: [2,2,2,5,2]\nOutput: false\n\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the given tree will be in the range [1, 100].\nEach node's value will be an integer in the range [0, 99].
__label__0 For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X\xc2\xa0is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nWrite a function that determines whether two binary trees\xc2\xa0are flip equivalent.\xc2\xa0 The trees are given by root nodes root1 and root2.\n\xc2\xa0\nExample 1:\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\nOutput: true\nExplanation: We flipped at nodes with values 1, 3, and 5.\n\n\n\xc2\xa0\nNote:\n\nEach tree will have at most 100 nodes.\nEach value in each tree will be a unique\xc2\xa0integer in the range [0, 99].
__label__0 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\nExample:\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3\nOutput: [3,3,5,5,6,7] \nExplanation: \n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\nNote: \nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 input array's size for non-empty array.\nFollow up:\nCould you solve it in linear time?
__label__0 Design a HashMap\xc2\xa0without using any built-in hash table libraries.\nTo be specific, your design should include these functions:\n\nput(key, value) :\xc2\xa0Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.\nget(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nremove(key) :\xc2\xa0Remove the mapping for the value key if this map contains the mapping for the key.\n\n\nExample:\nMyHashMap hashMap = new MyHashMap();\nhashMap.put(1, 1); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0\nhashMap.put(2, 2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \nhashMap.get(1); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns 1\nhashMap.get(3); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns -1 (not found)\nhashMap.put(2, 1); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// update the existing value\nhashMap.get(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns 1 \nhashMap.remove(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// remove the mapping for 2\nhashMap.get(2); \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns -1 (not found) \n\n\nNote:\n\nAll keys and values will be in the range of [0, 1000000].\nThe number of operations will be in the range of\xc2\xa0[1, 10000].\nPlease do not use the built-in HashMap library.
__label__0 You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.\nFor example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.\nNow given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.\nExample 1:\nInput: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\nOutput: 11\nExplanation:\nEmployee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.\n\n\xc2\xa0\nNote:\n\nOne employee has at most one direct leader and may have several subordinates.\nThe maximum number of employees won't exceed 2000.
__label__0 Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\nExample:\nInput: 13\nOutput: 6 \nExplanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
__label__0 Implement a basic calculator to evaluate a simple expression string.\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.\nExample 1:\nInput: "3+2*2"\nOutput: 7\n\nExample 2:\nInput: " 3/2 "\nOutput: 1\nExample 3:\nInput: " 3+5 / 2 "\nOutput: 5\n\nNote:\n\nYou may assume that the given expression is always valid.\nDo not use the eval built-in library function.
__label__0 We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.\nWe are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple.\nWe start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3.\nReturn true if we can build the pyramid all the way to the top, otherwise false.\nExample 1:\nInput: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"]\nOutput: true\nExplanation:\nWe can stack the pyramid like this:\n    A\n   / \\\n  G   E\n / \\ / \\\nB   C   D\n\nWe are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.\n\xc2\xa0\nExample 2:\nInput: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"]\nOutput: false\nExplanation:\nWe can\'t stack the pyramid to the top.\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\n\n\xc2\xa0\nNote:\n\nbottom will be a string with length in range [2, 8].\nallowed will have length in range [0, 200].\nLetters in all strings will be chosen from the set {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'}.
__label__0 Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.\n\n(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)\n\nExample 1:\nInput: N = 10\nOutput: 9\n\n\nExample 2:\nInput: N = 1234\nOutput: 1234\n\n\nExample 3:\nInput: N = 332\nOutput: 299\n\n\nNote:\nN is an integer in the range [0, 10^9].
__label__0 Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\nFormally the function should:\nReturn true if there exists i, j, k \nsuch that arr[i] < arr[j] < arr[k] given 0 \xe2\x89\xa4 i < j < k \xe2\x89\xa4 n-1 else return false.\nNote: Your algorithm should run in O(n) time complexity and O(1) space complexity.\n\nExample 1:\nInput: [1,2,3,4,5]\nOutput: true\n\n\nExample 2:\nInput: [5,4,3,2,1]\nOutput: false
__label__0 Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property\xc2\xa0root.val = min(root.left.val, root.right.val)\xc2\xa0always holds.\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\nIf no such second minimum value exists, output -1 instead.\nExample 1:\nInput: \n    2\n   / \\\n  2   5\n     / \\\n    5   7\n\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.\n\n\xc2\xa0\nExample 2:\nInput: \n    2\n   / \\\n  2   2\n\nOutput: -1\nExplanation: The smallest value is 2, but there isn't any second smallest value.
__label__0 Given an array of citations sorted\xc2\xa0in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher\'s h-index.\nAccording to the\xc2\xa0definition of h-index on Wikipedia: "A scientist has index\xc2\xa0h\xc2\xa0if\xc2\xa0h\xc2\xa0of his/her\xc2\xa0N\xc2\xa0papers have\xc2\xa0at least\xc2\xa0h\xc2\xa0citations each, and the other\xc2\xa0N \xe2\x88\x92 h\xc2\xa0papers have\xc2\xa0no more than\xc2\xa0h\xc2\xa0citations each."\nExample:\nInput: citations = [0,1,3,5,6]\nOutput: 3 \nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had \n             received 0, 1, 3, 5, 6 citations respectively. \n\xc2\xa0            Since the researcher has 3 papers with at least 3 citations each and the remaining \n\xc2\xa0            two with no more than 3 citations each, her h-index is 3.\nNote:\nIf there are several possible values for\xc2\xa0h, the maximum one is taken as the h-index.\nFollow up:\n\nThis is a follow up problem to\xc2\xa0H-Index, where citations is now guaranteed to be sorted in ascending order.\nCould you solve it in logarithmic time complexity?
__label__0 Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\nNote:\xc2\xa0The input string may contain letters other than the parentheses ( and ).\nExample 1:\nInput: "()())()"\nOutput: ["()()()", "(())()"]\n\nExample 2:\nInput: "(a)())()"\nOutput: ["(a)()()", "(a())()"]\n\nExample 3:\nInput: ")("\nOutput: [""]
__label__0 Implement a MapSum class with insert, and sum methods.\n\n\nFor the method insert, you\'ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.\n\n\nFor the method sum, you\'ll be given a string representing the prefix, and you need to return the sum of all the pairs\' value whose key starts with the prefix.\n\nExample 1:\nInput: insert("apple", 3), Output: Null\nInput: sum("ap"), Output: 3\nInput: insert("app", 2), Output: Null\nInput: sum("ap"), Output: 5
__label__0 Implement a SnapshotArray that supports the following interface:\n\nSnapshotArray(int length) initializes an array-like data structure with the given length.\xc2\xa0 Initially, each element equals 0.\nvoid set(index, val) sets the element at the given index to be equal to val.\nint snap()\xc2\xa0takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.\nint get(index, snap_id)\xc2\xa0returns the value at the given index, at the time we took the snapshot with the given snap_id\n\n\xc2\xa0\nExample 1:\nInput: ["SnapshotArray","set","snap","set","get"]\n[[3],[0,5],[],[0,6],[0,0]]\nOutput: [null,null,0,null,5]\nExplanation: \nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\xc2\xa0\nConstraints:\n\n1 <= length\xc2\xa0<= 50000\nAt most 50000\xc2\xa0calls will be made to set, snap, and get.\n0 <= index\xc2\xa0<\xc2\xa0length\n0 <=\xc2\xa0snap_id <\xc2\xa0(the total number of times we call snap())\n0 <=\xc2\xa0val <= 10^9
__label__0 Under a grammar given below, strings can represent a set of lowercase words.\xc2\xa0 Let\'s\xc2\xa0use R(expr)\xc2\xa0to denote the set of words the expression represents.\nGrammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR("a") = {"a"}\nR("w") = {"w"}\n\n\nWhen we take a comma delimited list of 2 or more expressions, we take the union of possibilities.\n\t\nR("{a,b,c}") = {"a","b","c"}\nR("{{a,b},{b,c}}") = {"a","b","c"}\xc2\xa0(notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR("{a,b}{c,d}") = {"ac","ad","bc","bd"}\nR("a{b,c}{d,e}f{g,h}")\xc2\xa0= {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}\n\n\n\nFormally, the 3 rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}\nFor expressions e_1, e_2, ... , e_k\xc2\xa0with k >= 2, we have R({e_1,e_2,...}) = R(e_1)\xc2\xa0\xe2\x88\xaa R(e_2)\xc2\xa0\xe2\x88\xaa ...\nFor\xc2\xa0expressions e_1 and e_2, we have R(e_1 + e_2) = {a + b for (a, b) in\xc2\xa0R(e_1)\xc2\xa0\xc3\x97 R(e_2)}, where + denotes concatenation, and \xc3\x97 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the\xc2\xa0sorted list of words that the expression represents.\n\xc2\xa0\n\nExample 1:\nInput: "{a,b}{c,{d,e}}"\nOutput: ["ac","ad","ae","bc","bd","be"]\n\n\nExample 2:\nInput: "{{a,z},a{b,c},{ab,z}}"\nOutput: ["a","ab","ac","z"]\nExplanation: Each distinct word is written only once in the final answer.\n\n\xc2\xa0\nConstraints:\n\n1 <= expression.length <= 50\nexpression[i] consists of \'{\', \'}\', \',\'or lowercase English letters.\nThe given\xc2\xa0expression\xc2\xa0represents a set of words based on the grammar given in the description.
__label__0 Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\n\nThe node of a binary tree is a leaf if and only if it has no children\nThe depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children\xc2\xa0is\xc2\xa0d+1.\nThe lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.\n\n\xc2\xa0\nExample 1:\nInput: root = [1,2,3]\nOutput: [1,2,3]\nExplanation: \nThe deepest leaves are the nodes with values 2 and 3.\nThe lowest common ancestor of these leaves is the node with value 1.\nThe answer returned is a TreeNode object (not an array) with serialization "[1,2,3]".\n\nExample 2:\nInput: root = [1,2,3,4]\nOutput: [4]\n\nExample 3:\nInput: root = [1,2,3,4,5]\nOutput: [2,4,5]\n\n\xc2\xa0\nConstraints:\n\nThe given tree will have between 1 and 1000 nodes.\nEach node of the tree will have a distinct value between 1 and 1000.
__label__0 Implement FreqStack, a class which simulates the operation of a stack-like data structure.\nFreqStack\xc2\xa0has two functions:\n\npush(int x), which pushes an integer x onto the stack.\npop(), which removes and returns the most frequent element in the stack.\n\t\nIf there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.\n\n\n\n\xc2\xa0\nExample 1:\nInput: \n["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\nOutput: [null,null,null,null,null,null,null,5,7,5,4]\nExplanation:\nAfter making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:\n\npop() -> returns 5, as 5 is the most frequent.\nThe stack becomes [5,7,5,7,4].\n\npop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.\nThe stack becomes [5,7,5,4].\n\npop() -> returns 5.\nThe stack becomes [5,7,4].\n\npop() -> returns 4.\nThe stack becomes [5,7].\n\n\xc2\xa0\nNote:\n\nCalls to FreqStack.push(int x)\xc2\xa0will be such that 0 <= x <= 10^9.\nIt is guaranteed that FreqStack.pop() won\'t be called if the stack has zero elements.\nThe total number of FreqStack.push calls will not exceed 10000 in a single test case.\nThe total number of FreqStack.pop\xc2\xa0calls will not exceed 10000 in a single test case.\nThe total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.
__label__0 Write a class StockSpanner which collects daily price quotes for some stock, and returns the span\xc2\xa0of that stock\'s price for the current day.\nThe span of the stock\'s price today\xc2\xa0is defined as the maximum number of consecutive days (starting from today and going backwards)\xc2\xa0for which the price of the stock was less than or equal to today\'s price.\nFor example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].\n\xc2\xa0\n\nExample 1:\nInput: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]\nOutput: [null,1,1,1,2,1,4,6]\nExplanation: \nFirst, S = StockSpanner() is initialized.  Then:\nS.next(100) is called and returns 1,\nS.next(80) is called and returns 1,\nS.next(60) is called and returns 1,\nS.next(70) is called and returns 2,\nS.next(60) is called and returns 1,\nS.next(75) is called and returns 4,\nS.next(85) is called and returns 6.\n\nNote that (for example) S.next(75) returned 4, because the last 4 prices\n(including today\'s price of 75) were less than or equal to today\'s price.\n\n\xc2\xa0\nNote:\n\nCalls to StockSpanner.next(int price) will have 1 <= price <= 10^5.\nThere will be at most 10000 calls to StockSpanner.next\xc2\xa0per test case.\nThere will be at most 150000 calls to StockSpanner.next across all test cases.\nThe total\xc2\xa0time limit for this problem has been reduced by 75% for\xc2\xa0C++, and 50% for all other languages.
__label__0 There is\xc2\xa0a special square room with mirrors on each of the four\xc2\xa0walls.\xc2\xa0 Except for the southwest\xc2\xa0corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\nThe square room has walls of length p, and a laser ray from the southwest corner\xc2\xa0first meets the east wall at a distance q\xc2\xa0from the 0th receptor.\nReturn the number of the receptor that the ray meets first.\xc2\xa0 (It is guaranteed that the ray will meet\xc2\xa0a receptor eventually.)\n\xc2\xa0\n\nExample 1:\nInput: p = 2, q = 1\nOutput: 2\nExplanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.\n\n\nNote:\n\n1 <= p <= 1000\n0 <= q <= p
__label__0 Given a binary string S (a string consisting only of \'0\' and \'1\'s) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.\n\xc2\xa0\nExample 1:\nInput: S = "0110", N = 3\nOutput: true\n\nExample 2:\nInput: S = "0110", N = 4\nOutput: false\n\n\xc2\xa0\nNote:\n\n1 <= S.length <= 1000\n1 <= N <= 10^9
__label__0 Let's call an array A a mountain\xc2\xa0if the following properties hold:\n\nA.length >= 3\nThere exists some 0 < i\xc2\xa0< A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]\n\nGiven an array that is definitely a mountain, return any\xc2\xa0i\xc2\xa0such that\xc2\xa0A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].\nExample 1:\nInput: [0,1,0]\nOutput: 1\n\n\nExample 2:\nInput: [0,2,1,0]\nOutput: 1\n\nNote:\n\n3 <= A.length <= 10000\n0 <= A[i] <= 10^6\nA\xc2\xa0is a mountain, as defined above.
__label__0 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nExample 1:\nInput: [1,3,5,6], 5\nOutput: 2\n\nExample 2:\nInput: [1,3,5,6], 2\nOutput: 1\n\nExample 3:\nInput: [1,3,5,6], 7\nOutput: 4\n\nExample 4:\nInput: [1,3,5,6], 0\nOutput: 0
__label__0 You have N gardens, labelled 1 to N.\xc2\xa0 In each garden, you want to plant one of 4 types of flowers.\npaths[i] = [x, y] describes the existence of a bidirectional path from garden x to garden y.\nAlso, there is no garden that has more than 3 paths coming into or leaving it.\nYour task is to choose a flower type for each garden such that,\xc2\xa0for any two gardens connected by a path, they have different types of flowers.\nReturn any such a choice as an array answer, where\xc2\xa0answer[i] is the type of flower\xc2\xa0planted in the (i+1)-th garden.\xc2\xa0 The flower types are denoted\xc2\xa01, 2, 3, or 4.\xc2\xa0 It is guaranteed an answer exists.\n\xc2\xa0\n\nExample 1:\nInput: N = 3, paths = [[1,2],[2,3],[3,1]]\nOutput: [1,2,3]\n\n\nExample 2:\nInput: N = 4, paths = [[1,2],[3,4]]\nOutput: [1,2,1,2]\n\n\nExample 3:\nInput: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\nOutput: [1,2,3,4]\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10000\n0 <= paths.size <= 20000\nNo garden has 4 or more paths coming into or leaving it.\nIt is guaranteed an answer exists.
__label__0 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\nExample:\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4
__label__0 We run a\xc2\xa0preorder\xc2\xa0depth first search on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.\xc2\xa0\xc2\xa0(If the depth of a node is D, the depth of its immediate child is D+1.\xc2\xa0 The depth of the root node is 0.)\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output S of this traversal, recover the tree and return its root.\n\xc2\xa0\nExample 1:\n\nInput: "1-2--3--4-5--6--7"\nOutput: [1,2,5,3,4,6,7]\n\n\nExample 2:\n\nInput: "1-2--3---4-5--6---7"\nOutput: [1,2,5,3,null,6,null,4,null,7]\n\n\n\xc2\xa0\n\nExample 3:\n\nInput: "1-401--349---90--88"\nOutput: [1,401,null,349,88,90]\n\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the original tree is between 1 and 1000.\nEach node will have a value between 1 and 10^9.
__label__0 Given a non-empty\xc2\xa0array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1]\nOutput: 1\n\nExample 2:\nInput: [4,1,2,1,2]\nOutput: 4
__label__0 Given a string S\xc2\xa0and a character C, return an array of integers representing the shortest distance from the character C in the string.\nExample 1:\nInput: S = "loveleetcode", C = \'e\'\nOutput: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n\n\xc2\xa0\nNote:\n\nS string length is\xc2\xa0in\xc2\xa0[1, 10000].\nC\xc2\xa0is a single character, and guaranteed to be in string S.\nAll letters in S and C are lowercase.
__label__0 We have a list of bus routes. Each routes[i] is a bus route that the i-th bus\xc2\xa0repeats forever. For example if routes[0] = [1, 5, 7], this means that the first\xc2\xa0bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.\nWe start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.\nExample:\nInput: \nroutes = [[1, 2, 7], [3, 6, 7]]\nS = 1\nT = 6\nOutput: 2\nExplanation: \nThe best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\nNote: \n\n1 <= routes.length <= 500.\n1 <= routes[i].length <= 500.\n0 <= routes[i][j] < 10 ^ 6.
__label__0 Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n\xc2\xa0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nExample 2:\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\xc2\xa0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\xc2\xa0            engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.
__label__0 Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\n\na binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\nExample 1:\nGiven the following tree [3,9,20,null,null,15,7]:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nReturn true.\n\nExample 2:\nGiven the following tree [1,2,2,3,3,null,null,4,4]:\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\nReturn false.
__label__0 Given an integer array, find three numbers whose product is maximum and output the maximum product.\nExample 1:\nInput: [1,2,3]\nOutput: 6\n\n\xc2\xa0\nExample 2:\nInput: [1,2,3,4]\nOutput: 24\n\n\xc2\xa0\nNote:\n\nThe length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].\nMultiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.
__label__0 SQL SchemaX city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies\xe2\x80\x99 ratings and descriptions.\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.\n\xc2\xa0\nFor example, table cinema:\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   1     | War       |   great 3D   |   8.9     |\n|   2     | Science   |   fiction    |   8.5     |\n|   3     | irish     |   boring     |   6.2     |\n|   4     | Ice song  |   Fantacy    |   8.6     |\n|   5     | House card|   Interesting|   9.1     |\n+---------+-----------+--------------+-----------+\n\nFor the example above, the output should be:\n\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   5     | House card|   Interesting|   9.1     |\n|   1     | War       |   great 3D   |   8.9     |\n+---------+-----------+--------------+-----------+
__label__0 There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.\nThe brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.\nIf your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.\nYou cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. \n\xc2\xa0\nExample:\nInput: [[1,2,2,1],\n        [3,1,2],\n        [1,3,2],\n        [2,4],\n        [3,1,2],\n        [1,3,1,1]]\n\nOutput: 2\n\nExplanation: \n\n\n\xc2\xa0\nNote:\n\nThe width sum of bricks in different rows are the same and won't exceed INT_MAX.\nThe number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.
__label__0 Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\nThis is case sensitive, for example "Aa" is not considered a palindrome here.\nNote:\nAssume the length of given string will not exceed 1,010.\n\nExample: \nInput:\n"abccccdd"\n\nOutput:\n7\n\nExplanation:\nOne longest palindrome that can be built is "dccaccd", whose length is 7.
__label__0 Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won\'t be input like 3a or 2[4].\nExamples:\ns = "3[a]2[bc]", return "aaabcbc".\ns = "3[a2[c]]", return "accaccacc".\ns = "2[abc]3[cd]ef", return "abcabccdcdcdef".
__label__0 Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\n\nExample:\nGiven a binary tree \n          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n\n\n\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n\nNote:\nThe length of path between two nodes is represented by the number of edges between them.
__label__0 Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. \n\n\nYou need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\n\nExample 1:\nInput:\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]\nOutput: ["Shogun"]\nExplanation: The only restaurant they both like is "Shogun".\n\n\nExample 2:\nInput:\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["KFC", "Shogun", "Burger King"]\nOutput: ["Shogun"]\nExplanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).\n\n\nNote:\n\nThe length of both lists will be in the range of [1, 1000].\nThe length of strings in both lists will be in the range of [1, 30].\nThe index is starting from 0 to the list length minus 1.\nNo duplicates in both lists.
__label__0 A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\n\nThis is how the UTF-8 encoding would work:\n   Char. number range  |        UTF-8 octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\n\n\nNote:\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\n\nExample 1:\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\n\nReturn true.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n\n\nExample 2:\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\n\nReturn false.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.
__label__0 Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\n\xc2\xa0\nExample 1: \nInput:\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\nOutput:\n[[0,0,0],\n\xc2\xa0[0,1,0],\n\xc2\xa0[0,0,0]]\n\nExample 2: \nInput:\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\nOutput:\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n\n\xc2\xa0\nNote:\n\nThe number of elements of the given matrix will not exceed 10,000.\nThere are at least one 0 in the given matrix.\nThe cells are adjacent in only four directions: up, down, left and right.
__label__0 Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4.\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.\nExample:\nInput: [1000,100,10,2]\nOutput: "1000/(100/10/2)"\nExplanation:\n1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don\'t influence the operation priority. So you should return "1000/(100/10/2)". \n\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\n\nNote:\n\nThe length of the input array is [1, 10].\nElements in the given array will be in range [2, 1000].\nThere is only one optimal division for each test case.
__label__0 Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n\xc2\xa0\nNote:\nBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\n\xc2\xa0\nExample:\nGiven the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\n\nReturn 4.\n\n\nThe above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.\n\xc2\xa0\n\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.
__label__0 Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.\nHowever, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.\nYou need to return the least number of intervals the CPU will take to finish all the given tasks.\n\xc2\xa0\nExample:\nInput: tasks = ["A","A","A","B","B","B"], n = 2\nOutput: 8\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B.\n\n\xc2\xa0\nNote:\n\nThe number of tasks is in the range [1, 10000].\nThe integer n is in the range [0, 100].
__label__0 Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\nGiven the sorted linked list: [-10,-3,0,5,9],\n\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5
__label__0 We are given the head node root\xc2\xa0of a binary tree, where additionally every node\'s value is either a 0 or a 1.\nReturn the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\nExample 1:\nInput: [1,null,0,0,1]\nOutput: [1,null,0,null,1]\n \nExplanation: \nOnly the red nodes satisfy the property "every subtree not containing a 1".\nThe diagram on the right represents the answer.\n\n\n\nExample 2:\nInput: [1,0,1,0,0,0,1]\nOutput: [1,null,1,null,1]\n\n\n\n\nExample 3:\nInput: [1,1,0,1,1,0,1,0]\nOutput: [1,1,0,1,1,null,1]\n\n\n\n\nNote: \n\nThe binary tree\xc2\xa0will\xc2\xa0have\xc2\xa0at\xc2\xa0most 100 nodes.\nThe value of each node will only be 0 or 1.
__label__0 There are N children standing in a line. Each child is assigned a rating value.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\n\nWhat is the minimum candies you must give?\nExample 1:\nInput: [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\nInput: [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\n             The third child gets 1 candy because it satisfies the above two conditions.
__label__0 Given a list of words, we may encode it by writing a reference string S and a list of indexes A.\nFor example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#"\xc2\xa0and indexes = [0, 2, 5].\nThen for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character.\nWhat is the length of the shortest reference string S possible that encodes the given words?\nExample:\nInput: words = ["time", "me", "bell"]\nOutput: 10\nExplanation: S = "time#bell#" and indexes = [0, 2, 5].\n\n\xc2\xa0\nNote:\n\n1 <= words.length\xc2\xa0<= 2000.\n1 <=\xc2\xa0words[i].length\xc2\xa0<= 7.\nEach word\xc2\xa0has only\xc2\xa0lowercase letters.
__label__0 There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].\nReturn the minimum cost to fly every person to a city such that exactly N people arrive in each city.\n\xc2\xa0\nExample 1:\nInput: [[10,20],[30,200],[400,50],[30,20]]\nOutput: 110\nExplanation: \nThe first person goes to city A for a cost of 10.\nThe second person goes to city A for a cost of 30.\nThe third person goes to city B for a cost of 50.\nThe fourth person goes to city B for a cost of 20.\n\nThe total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\n\xc2\xa0\nNote:\n\n1 <= costs.length <= 100\nIt is guaranteed that costs.length is even.\n1 <= costs[i][0], costs[i][1] <= 1000
__label__0 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n\nFor example, given n = 3, a solution set is:\n\n[\n  "((()))",\n  "(()())",\n  "(())()",\n  "()(())",\n  "()()()"\n]
__label__0 Given an integer array A, you partition the array into (contiguous) subarrays of length at most K.\xc2\xa0 After partitioning, each subarray has their values changed to become the maximum value of that subarray.\nReturn the largest sum of the given array after partitioning.\n\xc2\xa0\nExample 1:\nInput: A = [1,15,7,9,2,5,10], K = 3\nOutput: 84\nExplanation: A becomes [15,15,15,9,10,10,10]\n\xc2\xa0\nNote:\n\n1 <= K <= A.length\xc2\xa0<= 500\n0 <= A[i] <= 10^6
__label__0 Determine if a\xc2\xa09x9 Sudoku board\xc2\xa0is valid.\xc2\xa0Only the filled cells need to be validated\xc2\xa0according to the following rules:\n\nEach row\xc2\xa0must contain the\xc2\xa0digits\xc2\xa01-9 without repetition.\nEach column must contain the digits\xc2\xa01-9\xc2\xa0without repetition.\nEach of the 9 3x3 sub-boxes of the grid must contain the digits\xc2\xa01-9\xc2\xa0without repetition.\n\n\nA partially filled sudoku which is valid.\nThe Sudoku board could be partially filled, where empty cells are filled with the character \'.\'.\nExample 1:\nInput:\n[\n  ["5","3",".",".","7",".",".",".","."],\n  ["6",".",".","1","9","5",".",".","."],\n  [".","9","8",".",".",".",".","6","."],\n  ["8",".",".",".","6",".",".",".","3"],\n  ["4",".",".","8",".","3",".",".","1"],\n  ["7",".",".",".","2",".",".",".","6"],\n  [".","6",".",".",".",".","2","8","."],\n  [".",".",".","4","1","9",".",".","5"],\n  [".",".",".",".","8",".",".","7","9"]\n]\nOutput: true\n\nExample 2:\nInput:\n[\n\xc2\xa0 ["8","3",".",".","7",".",".",".","."],\n\xc2\xa0 ["6",".",".","1","9","5",".",".","."],\n\xc2\xa0 [".","9","8",".",".",".",".","6","."],\n\xc2\xa0 ["8",".",".",".","6",".",".",".","3"],\n\xc2\xa0 ["4",".",".","8",".","3",".",".","1"],\n\xc2\xa0 ["7",".",".",".","2",".",".",".","6"],\n\xc2\xa0 [".","6",".",".",".",".","2","8","."],\n\xc2\xa0 [".",".",".","4","1","9",".",".","5"],\n\xc2\xa0 [".",".",".",".","8",".",".","7","9"]\n]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being \n    modified to 8. Since there are two 8\'s in the top left 3x3 sub-box, it is invalid.\n\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned\xc2\xa0rules.\nThe given board\xc2\xa0contain only digits 1-9 and the character \'.\'.\nThe given board size is always 9x9.
__label__0 N cars are going to the same destination along a one lane road.\xc2\xa0 The destination is target\xc2\xa0miles away.\nEach car i\xc2\xa0has a constant speed speed[i]\xc2\xa0(in miles per hour), and initial position position[i]\xc2\xa0miles towards the target along the road.\nA car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.\nThe distance between these two cars is ignored - they are assumed to have the same position.\nA car fleet is some non-empty set of cars driving\xc2\xa0at the same position and same speed.\xc2\xa0 Note that a single car is also a car fleet.\nIf a car catches up to a car fleet right at the destination point, it will\xc2\xa0still be\xc2\xa0considered as one car fleet.\n\nHow many car fleets will arrive at the destination?\n\xc2\xa0\nExample 1:\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\nOutput: 3\nExplanation:\nThe cars starting at 10 and 8 become a fleet, meeting each other at 12.\nThe car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 and 3 become a fleet, meeting each other at 6.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n\nNote:\n\n0 <= N <= 10 ^ 4\n0 < target\xc2\xa0<= 10 ^ 6\n0 <\xc2\xa0speed[i] <= 10 ^ 6\n0 <= position[i] < target\nAll initial positions are different.
__label__0 Given a number N, return a string consisting of "0"s and "1"s\xc2\xa0that represents its value in base -2\xc2\xa0(negative two).\nThe returned string must have no leading zeroes, unless the string is "0".\n\xc2\xa0\n\nExample 1:\nInput: 2\nOutput: "110"\nExplantion: (-2) ^ 2 + (-2) ^ 1 = 2\n\n\nExample 2:\nInput: 3\nOutput: "111"\nExplantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3\n\n\nExample 3:\nInput: 4\nOutput: "100"\nExplantion: (-2) ^ 2 = 4\n\n\xc2\xa0\nNote:\n\n0 <= N <= 10^9
__label__0 Given two strings A and B\xc2\xa0of lowercase letters, return true if and only if we\xc2\xa0can swap two letters in A so that the result equals B.\n\xc2\xa0\nExample 1:\n\nInput: A = "ab", B = "ba"\nOutput: true\n\n\nExample 2:\nInput: A = "ab", B = "ab"\nOutput: false\n\n\nExample 3:\nInput: A = "aa", B = "aa"\nOutput: true\n\n\nExample 4:\nInput: A = "aaaaaaabc", B = "aaaaaaacb"\nOutput: true\n\n\nExample 5:\nInput: A = "", B = "aa"\nOutput: false\n\n\xc2\xa0\nNote:\n\n0 <= A.length <= 20000\n0 <= B.length <= 20000\nA and\xc2\xa0B consist only of lowercase letters.
__label__0 Write an iterator that iterates through a run-length encoded sequence.\nThe iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some\xc2\xa0sequence.\xc2\xa0 More specifically,\xc2\xa0for all even i,\xc2\xa0A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.\nThe iterator supports one function:\xc2\xa0next(int n), which exhausts the next n elements\xc2\xa0(n >= 1) and returns the last element exhausted in this way.\xc2\xa0 If there is no element left to exhaust, next\xc2\xa0returns -1 instead.\nFor example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].\xc2\xa0 This is because the sequence can be read as\xc2\xa0"three eights, zero nines, two fives".\n\xc2\xa0\nExample 1:\nInput: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]\nOutput: [null,8,8,5,-1]\nExplanation: \nRLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).\nThis maps to the sequence [8,8,8,5,5].\nRLEIterator.next is then called 4 times:\n\n.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].\n\n.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].\n\n.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].\n\n.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,\nbut the second term did not exist.  Since the last term exhausted does not exist, we return -1.\n\n\nNote:\n\n0 <= A.length <= 1000\nA.length\xc2\xa0is an even integer.\n0 <= A[i] <= 10^9\nThere are at most 1000 calls to RLEIterator.next(int n) per test case.\nEach call to\xc2\xa0RLEIterator.next(int n)\xc2\xa0will have 1 <= n <= 10^9.
__label__0 A full binary tree\xc2\xa0is a binary tree where each node has exactly 0 or 2\xc2\xa0children.\nReturn a list of all possible full binary trees with N nodes.\xc2\xa0 Each element of the answer is the root node of one possible tree.\nEach node of each\xc2\xa0tree in the answer must have node.val = 0.\nYou may return the final list of trees in any order.\n\xc2\xa0\nExample 1:\nInput: 7\nOutput: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\nExplanation:\n\n\n\xc2\xa0\nNote:\n\n1 <= N <= 20
__label__0 We are given hours, a list of the number of hours\xc2\xa0worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\xc2\xa0\nExample 1:\nInput: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].\n\n\xc2\xa0\nConstraints:\n\n1 <= hours.length <= 10000\n0 <= hours[i] <= 16
__label__0 We distribute some\xc2\xa0number of candies, to a row of n =\xc2\xa0num_people\xc2\xa0people in the following way:\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give n\xc2\xa0candies to the last person.\nThen, we go back to the start of the row, giving n\xc2\xa0+ 1 candies to the first person, n\xc2\xa0+ 2 candies to the second person, and so on until we give 2 * n\xc2\xa0candies to the last person.\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.\xc2\xa0 The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\nReturn an array (of length num_people\xc2\xa0and sum candies) that represents the final distribution of candies.\n\xc2\xa0\nExample 1:\nInput: candies = 7, num_people = 4\nOutput: [1,2,3,1]\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n\nExample 2:\nInput: candies = 10, num_people = 3\nOutput: [5,2,3]\nExplanation: \nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n\xc2\xa0\nConstraints:\n\n1 <= candies <= 10^9\n1 <= num_people <= 1000
__label__0 Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.\nThe width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.\nExample 1:\nInput: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n\nExample 2:\nInput: \n\n          1\n         /  \n        3    \n       / \\       \n      5   3     \n\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n\nExample 3:\nInput: \n\n          1\n         / \\\n        3   2 \n       /        \n      5      \n\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n\nExample 4:\nInput: \n\n          1\n         / \\\n        3   2\n       /     \\  \n      5       9 \n     /         \\\n    6           7\nOutput: 8\nExplanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\n\n\n\nNote: Answer will in the range of 32-bit signed integer.
__label__0 Implement a magic directory with buildDict, and search methods.\n\n\nFor the method buildDict, you\'ll be given a list of non-repetitive words to build a dictionary.\n\n\nFor the method search, you\'ll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.\n\nExample 1:\nInput: buildDict(["hello", "leetcode"]), Output: Null\nInput: search("hello"), Output: False\nInput: search("hhllo"), Output: True\nInput: search("hell"), Output: False\nInput: search("leetcoded"), Output: False\n\n\nNote:\n\nYou may assume that all the inputs are consist of lowercase letters a-z.\nFor contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.\nPlease remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.
__label__0 Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\n\nExample 1:\nInput: 2736\nOutput: 7236\nExplanation: Swap the number 2 and the number 7.\n\n\nExample 2:\nInput: 9973\nOutput: 9973\nExplanation: No swap.\n\n\nNote:\n\nThe given number is in the range [0, 108]
__label__0 Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher\'s h-index.\nAccording to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N \xe2\x88\x92 h papers have no more than h citations each."\nExample:\nInput: citations = [3,0,6,1,5]\nOutput: 3 \nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had \n             received 3, 0, 6, 1, 5 citations respectively. \n\xc2\xa0            Since the researcher has 3 papers with at least 3 citations each and the remaining \n\xc2\xa0            two with no more than 3 citations each, her h-index is 3.\nNote:\xc2\xa0If there are several possible values for h, the maximum one is taken as the h-index.
__label__0 Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:\n\n\npostTweet(userId, tweetId): Compose a new tweet.\ngetNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\nfollow(followerId, followeeId): Follower follows a followee.\nunfollow(followerId, followeeId): Follower unfollows a followee.\n\n\nExample:\nTwitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -> [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -> [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);
__label__0 You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise.\nWrite a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.\n\xc2\xa0\nExample 1:\n\xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n\xe2\x94\x82 \xc2\xa0 \xe2\x94\x82\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80>\n\xc2\xa0 \xc2\xa0 \xe2\x94\x82\n\nInput: [2,1,1,2]\nOutput: true\n\nExample 2:\n\xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n\xe2\x94\x82 \xc2\xa0 \xc2\xa0 \xc2\xa0\xe2\x94\x82\n\xe2\x94\x82\n\xe2\x94\x82\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80>\n\nInput: [1,2,3,4]\nOutput: false \n\nExample 3:\n\xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n\xe2\x94\x82 \xc2\xa0 \xe2\x94\x82\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc>\n\nInput: [1,1,1,1]\nOutput: true
__label__0 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\nExample 1:\nInput: [3,2,3,null,3,null,1]\n\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\nOutput: 7 \nExplanation:\xc2\xa0Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\nExample 2:\nInput: [3,4,5,1,3,null,1]\n\n\xc2\xa0    3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\n\nOutput: 9\nExplanation:\xc2\xa0Maximum amount of money the thief can rob = 4 + 5 = 9.
__label__0 Given a string containing only three types of characters: \'(\', \')\' and \'*\', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\nAny left parenthesis \'(\' must have a corresponding right parenthesis \')\'.\nAny right parenthesis \')\' must have a corresponding left parenthesis \'(\'.\nLeft parenthesis \'(\' must go before the corresponding right parenthesis \')\'.\n\'*\' could be treated as a single right parenthesis \')\' or a single left parenthesis \'(\' or an empty string.\nAn empty string is also valid.\n\n\nExample 1:\nInput: "()"\nOutput: True\n\n\nExample 2:\nInput: "(*)"\nOutput: True\n\n\nExample 3:\nInput: "(*))"\nOutput: True\n\n\nNote:\n\nThe string size will be in the range [1, 100].
__label__0 Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nExample:\xc2\xa0\nYou may serialize the following tree:\n\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\nas "[1,2,3,null,null,4,5]"\n\nClarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nNote:\xc2\xa0Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__0 Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\nExample 1:\nInput: [3,0,1]\nOutput: 2\n\nExample 2:\nInput: [9,6,4,2,3,5,7,0,1]\nOutput: 8\n\nNote:\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
__label__0 There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\nSuppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\n\nFlip all the lights.\nFlip lights with even numbers.\nFlip lights with odd numbers.\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\n\n\xc2\xa0\nExample 1:\nInput: n = 1, m = 1.\nOutput: 2\nExplanation: Status can be: [on], [off]\n\n\xc2\xa0\nExample 2:\nInput: n = 2, m = 1.\nOutput: 3\nExplanation: Status can be: [on, off], [off, on], [off, off]\n\n\xc2\xa0\nExample 3:\nInput: n = 3, m = 1.\nOutput: 4\nExplanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\n\n\xc2\xa0\nNote: n and m both fit in range [0, 1000].
__label__0 Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\nExample 1:\nInput: ["abcw","baz","foo","bar","xtfn","abcdef"]\nOutput: 16 \nExplanation: The two words can be "abcw", "xtfn".\nExample 2:\nInput: ["a","ab","abc","d","cd","bcd","abcd"]\nOutput: 4 \nExplanation: The two words can be "ab", "cd".\nExample 3:\nInput: ["a","aa","aaa","aaaa"]\nOutput: 0 \nExplanation: No such pair of words.
__label__0 Given a list of dominoes,\xc2\xa0dominoes[i] = [a, b]\xc2\xa0is equivalent to dominoes[j] = [c, d]\xc2\xa0if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and\xc2\xa0dominoes[i] is equivalent to dominoes[j].\n\xc2\xa0\nExample 1:\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= dominoes.length <= 40000\n1 <= dominoes[i][j] <= 9
__label__0 On a\xc2\xa0N\xc2\xa0*\xc2\xa0N\xc2\xa0grid, we place some\xc2\xa01 * 1 * 1\xc2\xa0cubes.\nEach value\xc2\xa0v = grid[i][j]\xc2\xa0represents a tower of\xc2\xa0v\xc2\xa0cubes placed on top of grid cell\xc2\xa0(i, j).\nReturn the total surface area of the resulting shapes.\n\xc2\xa0\n\n\n\n\n\n\n\n\n\nExample 1:\nInput: [[2]]\nOutput: 10\n\n\nExample 2:\nInput: [[1,2],[3,4]]\nOutput: 34\n\n\nExample 3:\nInput: [[1,0],[0,2]]\nOutput: 16\n\n\nExample 4:\nInput: [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 32\n\n\nExample 5:\nInput: [[2,2,2],[2,1,2],[2,2,2]]\nOutput: 46\n\n\xc2\xa0\nNote:\n\n1 <= N <= 50\n0 <= grid[i][j] <= 50
__label__0 Given a set of N\xc2\xa0people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size.\nEach person may dislike some other people, and they should not go into the same group.\xc2\xa0\nFormally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.\nReturn true\xc2\xa0if and only if it is possible to split everyone into two groups in this way.\n\xc2\xa0\n\n\n\n\n\n\n\nExample 1:\nInput: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n\n\nExample 2:\nInput: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n\n\nExample 3:\nInput: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n\n\xc2\xa0\nNote:\n\n1 <= N <= 2000\n0 <= dislikes.length <= 10000\n1 <= dislikes[i][j] <= N\ndislikes[i][0] < dislikes[i][1]\nThere does not exist i != j for which dislikes[i] == dislikes[j].
__label__0 In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.\nWhen a student enters the room, they must sit in the seat that maximizes the distance to the closest person.\xc2\xa0 If there are multiple such seats, they sit in the seat with the lowest number.\xc2\xa0 (Also, if no one is in the room, then the student sits at seat number 0.)\nReturn a class ExamRoom(int N)\xc2\xa0that exposes two functions: ExamRoom.seat()\xc2\xa0returning an int\xc2\xa0representing what seat the student sat in, and ExamRoom.leave(int p)\xc2\xa0representing that the student in seat number p\xc2\xa0now leaves the room.\xc2\xa0 It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.\n\xc2\xa0\nExample 1:\nInput: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]\nOutput: [null,0,9,4,2,null,5]\nExplanation:\nExamRoom(10) -> null\nseat() -> 0, no one is in the room, then the student sits at seat number 0.\nseat() -> 9, the student sits at the last seat number 9.\nseat() -> 4, the student sits at the last seat number 4.\nseat() -> 2, the student sits at the last seat number 2.\nleave(4) -> null\nseat() -> 5, the student sits at the last seat number 5.\n\n\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\xe2\x80\x8b\nNote:\n\n1 <= N <= 10^9\nExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.\nCalls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.
__label__0 We have a two dimensional matrix\xc2\xa0A where each value is 0 or 1.\nA move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.\nAfter making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible\xc2\xa0score.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation:\nToggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].\n0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\xc2\xa0\nNote:\n\n1 <= A.length <= 20\n1 <= A[0].length <= 20\nA[i][j]\xc2\xa0is 0 or 1.
__label__0 Given a\xc2\xa0linked list, swap every two adjacent nodes and return its head.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\xc2\xa0\nExample:\nGiven 1->2->3->4, you should return the list as 2->1->4->3.
__label__0 Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths\xc2\xa0L and M.\xc2\xa0 (For clarification, the L-length subarray could occur before or after the M-length subarray.)\nFormally,\xc2\xa0return the largest V for which\xc2\xa0V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:\n\n0 <= i < i + L - 1 < j < j + M - 1 < A.length, or\n0 <= j < j + M - 1 < i < i + L - 1 < A.length.\n\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n\n\nExample 2:\nInput: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n\n\nExample 3:\nInput: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.\n\n\xc2\xa0\nNote:\n\nL >= 1\nM >= 1\nL + M <= A.length <= 1000\n0 <= A[i] <= 1000
__label__0 The count-and-say sequence is the sequence of integers with the first five terms as following:\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n\n1 is read off as "one 1" or 11.\n11 is read off as "two 1s" or 21.\n21 is read off as "one 2, then one 1" or 1211.\nGiven an integer n\xc2\xa0where 1 \xe2\x89\xa4 n \xe2\x89\xa4 30, generate the nth term of the count-and-say sequence.\nNote: Each term of the sequence of integers will be represented as a string.\n\xc2\xa0\nExample 1:\nInput: 1\nOutput: "1"\n\nExample 2:\nInput: 4\nOutput: "1211"
__label__0 We have a collection of rocks, each rock has a positive integer weight.\nEach turn, we choose the two heaviest\xc2\xa0rocks\xc2\xa0and smash them together.\xc2\xa0 Suppose the stones have weights x and y with x <= y.\xc2\xa0 The result of this smash is:\n\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\n\nAt the end, there is at most 1 stone left.\xc2\xa0 Return the weight of this stone (or 0 if there are no stones left.)\n\xc2\xa0\nExample 1:\nInput: [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.\n\xc2\xa0\nNote:\n\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000
__label__0 You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.\nExample:\nInput: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\nOutput: 2\nExplanation: \nThe five points are show in the figure below. The red triangle is the largest.\n\n\nNotes: \n\n3 <= points.length <= 50.\nNo points will be duplicated.\n\xc2\xa0-50 <= points[i][j] <= 50.\nAnswers within\xc2\xa010^-6\xc2\xa0of the true value will be accepted as correct.
__label__0 Given a non-empty\xc2\xa0array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,3,2]\nOutput: 3\n\nExample 2:\nInput: [0,1,0,1,0,1,99]\nOutput: 99
__label__0 Alice has a hand of cards, given as an array of integers.\nNow she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.\nReturn true if and only if she can.\n\xc2\xa0\n\n\nExample 1:\nInput: hand = [1,2,3,6,2,3,4,7,8], W = 3\nOutput: true\nExplanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].\nExample 2:\nInput: hand = [1,2,3,4,5], W = 4\nOutput: false\nExplanation: Alice's hand can't be rearranged into groups of 4.\n\xc2\xa0\nNote:\n\n1 <= hand.length <= 10000\n0 <= hand[i]\xc2\xa0<= 10^9\n1 <= W <= hand.length
__label__0 Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\nExample 1:\nInput: \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \nOutput: \nMerged tree:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n\n\xc2\xa0\nNote: The merging process must start from the root nodes of both trees.
__label__0 SQL SchemaGiven a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\n\xc2\xa0\nExample:\n| id | name | sex | salary |\n|----|------|-----|--------|\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n\nAfter running your update statement, the above salary table should have the following rows:\n\n| id | name | sex | salary |\n|----|------|-----|--------|\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |
__label__0 Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region.\nEach rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\n\nExample 1:\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [3,2,4,4],\n  [1,3,2,4],\n  [2,3,3,4]\n]\n\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\n\n\xc2\xa0\n\xc2\xa0\n\nExample 2:\nrectangles = [\n  [1,1,2,3],\n  [1,3,2,4],\n  [3,1,4,2],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap between the two rectangular regions.\n\n\xc2\xa0\n\xc2\xa0\n\nExample 3:\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap in the top center.\n\n\xc2\xa0\n\xc2\xa0\n\nExample 4:\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [2,2,4,4]\n]\n\nReturn false. Because two of the rectangles overlap with each other.
__label__0 Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two\xe2\x80\x99s complement method is used.\n\nNote:\n\nAll letters in hexadecimal (a-f) must be in lowercase.\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character \'0\'; otherwise, the first character in the hexadecimal string will not be the zero character.\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\nYou must not use any method provided by the library which converts/formats the number to hex directly.\n\n\nExample 1:\nInput:\n26\n\nOutput:\n"1a"\n\n\nExample 2:\nInput:\n-1\n\nOutput:\n"ffffffff"
__label__0 Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.\nExample 1:\nInput: 12\nOutput: 21\n\n\xc2\xa0\nExample 2:\nInput: 21\nOutput: -1
__label__0 Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\n\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n\nExample:\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n\n\nNote: \nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 n2.
__label__0 Design a data structure that supports all following operations in average O(1) time.\n\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\n\n\nExample:\n// Init an empty set.\nRandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\nrandomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\nrandomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\nrandomSet.remove(1);\n\n// 2 was already in the set, so return false.\nrandomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\nrandomSet.getRandom();
__label__0 Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\nNote:\nThe number of people is less than 1,100.\n\xc2\xa0\n\nExample\nInput:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
__label__0 Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\nExample 1:\nInput: "Let\'s take LeetCode contest"\nOutput: "s\'teL ekat edoCteeL tsetnoc"\n\n\nNote:\nIn the string, each word is separated by single space and there will not be any extra space in the string.
__label__0 There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\n\n\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\n\nExample 1:\nInput: \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\nOutput: 2\nExplanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.\n\n\nExample 2:\nInput: \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\nOutput: 1\nExplanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.\n\n\nNote:\n\nN is in range [1,200].\nM[i][i] = 1 for all students.\nIf M[i][j] = 1, then M[j][i] = 1.
__label__0 SQL SchemaMary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids.\nThe column id is continuous increment.\n\n\xc2\xa0\nMary wants to change seats for the adjacent students.\n\n\xc2\xa0\nCan you write a SQL query to output the result for Mary?\n\n\xc2\xa0\n+---------+---------+\n|    id   | student |\n+---------+---------+\n|    1    | Abbot   |\n|    2    | Doris   |\n|    3    | Emerson |\n|    4    | Green   |\n|    5    | Jeames  |\n+---------+---------+\n\nFor the sample input, the output is:\n\n\xc2\xa0\n+---------+---------+\n|    id   | student |\n+---------+---------+\n|    1    | Doris   |\n|    2    | Abbot   |\n|    3    | Green   |\n|    4    | Emerson |\n|    5    | Jeames  |\n+---------+---------+\n\nNote:\nIf the number of students is odd, there is no need to change the last one's seat.
__label__0 Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\nExample 1:\nInput: [2,2,3,4]\nOutput: 3\nExplanation:\nValid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n\n\nNote:\n\nThe length of the given array won't exceed 1000.\nThe integers in the given array are in the range of [0, 1000].
__label__0 Given a paragraph\xc2\xa0and a list of banned words, return the most frequent word that is not in the list of banned words.\xc2\xa0 It is guaranteed there is at least one word that isn\'t banned, and that the answer is unique.\nWords in the list of banned words are given in lowercase, and free of punctuation.\xc2\xa0 Words in the paragraph are not case sensitive.\xc2\xa0 The answer is in lowercase.\n\xc2\xa0\nExample:\nInput: \nparagraph = "Bob hit a ball, the hit BALL flew far after it was hit."\nbanned = ["hit"]\nOutput: "ball"\nExplanation: \n"hit" occurs 3 times, but it is a banned word.\n"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as "ball,"), \nand that "hit" isn\'t the answer even though it occurs more because it is banned.\n\n\xc2\xa0\nNote: \n\n1 <= paragraph.length <= 1000.\n0 <= banned.length <= 100.\n1 <= banned[i].length <= 10.\nThe answer is unique, and written in lowercase (even if its occurrences in paragraph\xc2\xa0may have\xc2\xa0uppercase symbols, and even if it is a proper noun.)\nparagraph only consists of letters, spaces, or the punctuation symbols !?\',;.\nThere are no hyphens or hyphenated words.\nWords only consist of letters, never apostrophes or other punctuation symbols.
__label__0 Given words first and second, consider occurrences in some\xc2\xa0text of the form "first second third", where second comes immediately after first, and third comes immediately after second.\nFor each such occurrence, add "third" to the answer, and return the answer.\n\xc2\xa0\nExample 1:\nInput: text = "alice is a good girl she is a good student", first = "a", second = "good"\nOutput: ["girl","student"]\n\n\nExample 2:\nInput: text = "we will we will rock you", first = "we", second = "will"\nOutput: ["we","rock"]\n\n\xc2\xa0\nNote:\n\n1 <= text.length <= 1000\ntext consists of space separated words, where each word consists of lowercase English letters.\n1 <= first.length, second.length <= 10\nfirst and second consist of lowercase English letters.
__label__0 A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\nReturn a deep copy of the list.\n\xc2\xa0\nExample 1:\n\nInput:\n{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}\n\nExplanation:\nNode 1\'s value is 1, both of its next and random pointer points to Node 2.\nNode 2\'s value is 2, its next pointer points to null and its random pointer points to itself.\n\n\xc2\xa0\nNote:\n\nYou must return the copy of the given head\xc2\xa0as a reference to the cloned list.
__label__0 Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nExample 1:\nInput: [1,2,3]\n\n       1\n      / \\\n     2   3\n\nOutput: 6\n\nExample 2:\nInput: [-10,9,20,null,null,15,7]\n\n\xc2\xa0  -10\n\xc2\xa0 \xc2\xa0/ \\\n\xc2\xa0 9 \xc2\xa020\n\xc2\xa0 \xc2\xa0 / \xc2\xa0\\\n\xc2\xa0 \xc2\xa015 \xc2\xa0 7\n\nOutput: 42
__label__0 Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.\xc2\xa0 (The occurrences\xc2\xa0may overlap.)\nReturn any duplicated\xc2\xa0substring that has the longest possible length.\xc2\xa0 (If S does not have a duplicated substring, the answer is "".)\n\xc2\xa0\nExample 1:\nInput: "banana"\nOutput: "ana"\n\nExample 2:\nInput: "abcd"\nOutput: ""\n\n\xc2\xa0\nNote:\n\n2 <= S.length <= 10^5\nS consists of lowercase English letters.
__label__0 Write a program to solve a Sudoku puzzle by filling the empty cells.\nA\xc2\xa0sudoku solution must satisfy all of\xc2\xa0the following rules:\n\nEach of the digits\xc2\xa01-9 must occur exactly\xc2\xa0once in each row.\nEach of the digits\xc2\xa01-9\xc2\xa0must occur\xc2\xa0exactly once in each column.\nEach of the the digits\xc2\xa01-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nEmpty cells are indicated by the character '.'.\n\nA sudoku puzzle...\n\n...and its solution numbers marked in red.\nNote:\n\nThe given board\xc2\xa0contain only digits 1-9 and the character '.'.\nYou may assume that the given Sudoku puzzle will have a single unique solution.\nThe given board size is always 9x9.
__label__0 We are given a matrix with R rows and C columns has cells with integer coordinates\xc2\xa0(r, c), where 0 <= r < R and 0 <= c < C.\nAdditionally, we are given a cell in that matrix with coordinates\xc2\xa0(r0, c0).\nReturn the coordinates of\xc2\xa0all cells in the matrix, sorted by their distance from (r0, c0)\xc2\xa0from smallest distance to largest distance.\xc2\xa0 Here,\xc2\xa0the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance,\xc2\xa0|r1 - r2| + |c1 - c2|.\xc2\xa0 (You may return the answer in any order that satisfies this condition.)\n\xc2\xa0\n\nExample 1:\nInput: R = 1, C = 2, r0 = 0, c0 = 0\nOutput: [[0,0],[0,1]]\nExplanation: The distances from (r0, c0) to other cells are: [0,1]\n\n\nExample 2:\nInput: R = 2, C = 2, r0 = 0, c0 = 1\nOutput: [[0,1],[0,0],[1,1],[1,0]]\nExplanation: The distances from (r0, c0) to other cells are: [0,1,1,2]\nThe answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.\n\n\nExample 3:\nInput: R = 2, C = 3, r0 = 1, c0 = 2\nOutput: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\nExplanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]\nThere are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].\n\n\xc2\xa0\nNote:\n\n1 <= R <= 100\n1 <= C <= 100\n0 <= r0 < R\n0 <= c0 < C
__label__0 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\nExample:\nInput:\n[\n\xc2\xa0 1->4->5,\n\xc2\xa0 1->3->4,\n\xc2\xa0 2->6\n]\nOutput: 1->1->2->3->4->4->5->6
__label__0 At a lemonade stand, each lemonade costs $5.\xc2\xa0\nCustomers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).\nEach customer will only buy one lemonade and\xc2\xa0pay with either a $5, $10, or $20 bill.\xc2\xa0 You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.\nNote that you don't have any change\xc2\xa0in hand at first.\nReturn true\xc2\xa0if and only if you can provide every customer with correct change.\n\xc2\xa0\n\nExample 1:\nInput: [5,5,5,10,20]\nOutput: true\nExplanation: \nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.\n\n\nExample 2:\nInput: [5,5,10]\nOutput: true\n\n\nExample 3:\nInput: [10,10]\nOutput: false\n\n\nExample 4:\nInput: [5,5,10,10,20]\nOutput: false\nExplanation: \nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can't give change of $15 back because we only have two $10 bills.\nSince not every customer received correct change, the answer is false.\n\n\xc2\xa0\nNote:\n\n0 <= bills.length <= 10000\nbills[i]\xc2\xa0will be either\xc2\xa05, 10, or 20.
__label__0 Strings\xc2\xa0A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K\xc2\xa0times so that the resulting string equals B.\nGiven two anagrams A and B, return the smallest K\xc2\xa0for which A and B are K-similar.\nExample 1:\nInput: A = "ab", B = "ba"\nOutput: 1\n\n\nExample 2:\nInput: A = "abc", B = "bca"\nOutput: 2\n\n\nExample 3:\nInput: A = "abac", B = "baca"\nOutput: 2\n\n\nExample 4:\nInput: A = "aabc", B = "abca"\nOutput: 2\n\n\n\nNote:\n\n1 <= A.length == B.length <= 20\nA and B contain only lowercase letters from the set {\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'}
__label__0 You are given an array A of strings.\nTwo strings S and T are\xc2\xa0special-equivalent\xc2\xa0if after any number of moves, S == T.\nA move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].\nNow, a group of special-equivalent strings from A\xc2\xa0is a\xc2\xa0non-empty subset S of A\xc2\xa0such that any string not in S\xc2\xa0is not special-equivalent with any string in S.\nReturn the number of groups of special-equivalent strings from A.\n\xc2\xa0\n\n\n\nExample 1:\nInput: ["a","b","c","a","c","c"]\nOutput: 3\nExplanation: 3 groups ["a","a"], ["b"], ["c","c","c"]\n\n\nExample 2:\nInput: ["aa","bb","ab","ba"]\nOutput: 4\nExplanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]\n\n\nExample 3:\nInput: ["abc","acb","bac","bca","cab","cba"]\nOutput: 3\nExplanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]\n\n\nExample 4:\nInput: ["abcd","cdab","adcb","cbad"]\nOutput: 1\nExplanation: 1 group ["abcd","cdab","adcb","cbad"]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 1000\n1 <= A[i].length <= 20\nAll A[i] have the same length.\nAll A[i] consist of only lowercase letters.
__label__0 A string S of lowercase letters is given.\xc2\xa0 Then, we may make any number of moves.\nIn each move, we\xc2\xa0choose one\xc2\xa0of the first K letters (starting from the left), remove it,\xc2\xa0and place it at the end of the string.\nReturn the lexicographically smallest string we could have after any number of moves.\n\xc2\xa0\n\nExample 1:\nInput: S = "cba", K = 1\nOutput: "acb"\nExplanation: \nIn the first move, we move the 1st character ("c") to the end, obtaining the string "bac".\nIn the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".\n\n\nExample 2:\nInput: S = "baaca", K = 3\nOutput: "aaabc"\nExplanation: \nIn the first move, we move the 1st character ("b") to the end, obtaining the string "aacab".\nIn the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".\n\n\xc2\xa0\nNote:\n\n1 <= K <= S.length\xc2\xa0<= 1000\nS\xc2\xa0consists of lowercase letters only.
__label__0 In an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the\xc2\xa0node with that label.\n\xc2\xa0\nExample 1:\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n\xc2\xa0\nConstraints:\n\n1 <= label <= 10^6
__label__0 There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\nExample:\nInput: 3\nOutput: 1 \nExplanation: \nAt first, the three bulbs are [off, off, off].\nAfter first round, the three bulbs are [on, on, on].\nAfter second round, the three bulbs are [on, off, on].\nAfter third round, the three bulbs are [on, off, off]. \n\nSo you should return 1, because there is only one bulb is on.
__label__0 Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.\nExample 1:\nInput: 123\nOutput: "One Hundred Twenty Three"\n\nExample 2:\nInput: 12345\nOutput: "Twelve Thousand Three Hundred Forty Five"\nExample 3:\nInput: 1234567\nOutput: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"\n\nExample 4:\nInput: 1234567891\nOutput: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
__label__0 You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.\n\nExample 1:\nInput: [4, 1, 8, 7]\nOutput: True\nExplanation: (8-4) * (7-1) = 24\n\n\nExample 2:\nInput: [1, 2, 1, 2]\nOutput: False\n\n\nNote:\n\nThe division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.\nEvery operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.\nYou cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.
__label__0 You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.\nWrite a function to return a hint according to the secret number and friend\'s guess, use A to indicate the bulls and B to indicate the cows.\xc2\xa0\nPlease note that both secret number and friend\'s guess may contain duplicate digits.\nExample 1:\nInput: secret = "1807", guess = "7810"\n\nOutput: "1A3B"\n\nExplanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\nExample 2:\nInput: secret = "1123", guess = "0111"\n\nOutput: "1A1B"\n\nExplanation: The 1st 1 in friend\'s guess is a bull, the 2nd or 3rd 1 is a cow.\nNote: You may assume that the secret number and your friend\'s guess only contain digits, and their lengths are always equal.
__label__0 Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\nExample 1:\n\nInput: ["abcd","dcba","lls","s","sssll"]\nOutput: [[0,1],[1,0],[3,2],[2,4]] \nExplanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]\n\n\nExample 2:\nInput: ["bat","tab","cat"]\nOutput: [[0,1],[1,0]] \nExplanation: The palindromes are ["battab","tabbat"]
__label__0 Given two arrays, write a function to compute their intersection.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\n\n\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\n\nNote:\n\nEach element in the result should appear as many times as it shows in both arrays.\nThe result can be in any order.\n\nFollow up:\n\nWhat if the given array is already sorted? How would you optimize your algorithm?\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
__label__0 Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\nExample 1:\nInput: 16\nOutput: true\n\n\nExample 2:\nInput: 5\nOutput: false\n\nFollow up: Could you solve it without loops/recursion?
__label__0 Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\nNote:\n\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].\nAll airports are represented by three capital letters (IATA code).\nYou may assume all tickets form at least one valid itinerary.\n\nExample 1:\nInput: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]\nOutput: ["JFK", "MUC", "LHR", "SFO", "SJC"]\n\nExample 2:\nInput: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]\nOutput: ["JFK","ATL","JFK","SFO","ATL","SFO"]\nExplanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].\n\xc2\xa0            But it is larger in lexical order.
__label__0 Given a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\nExample 1:\nInput: pattern = "abba", str = "dog cat cat dog"\nOutput: true\nExample 2:\nInput:pattern = "abba", str = "dog cat cat fish"\nOutput: false\nExample 3:\nInput: pattern = "aaaa", str = "dog cat cat dog"\nOutput: false\nExample 4:\nInput: pattern = "abba", str = "dog dog dog dog"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.
__label__0 In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.\n\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\nExample 1:\nInput: [[1,2], [1,3], [2,3]]\nOutput: [2,3]\nExplanation: The given directed graph will be like this:\n  1\n / \\\nv   v\n2-->3\n\n\nExample 2:\nInput: [[1,2], [2,3], [3,4], [4,1], [1,5]]\nOutput: [4,1]\nExplanation: The given directed graph will be like this:\n5 <- 1 -> 2\n     ^    |\n     |    v\n     4 <- 3\n\n\nNote:\nThe size of the input 2D-array will be between 3 and 1000.\nEvery integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.
__label__0 Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\n\nExample 1:\nInput: \n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\nOutput: \n    1\n      \\\n       2\n\n\nExample 2:\nInput: \n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\nOutput: \n      3\n     / \n   2   \n  /\n 1
__label__0 There are two kinds of threads, oxygen and hydrogen. Your goal is to group these threads to form water molecules.\xc2\xa0There is a barrier where each thread has to\xc2\xa0wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen\xc2\xa0and releaseOxygen\xc2\xa0methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must be able to immediately bond with each other to form a water molecule.\xc2\xa0You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.\nIn other words:\n\nIf an oxygen thread arrives at the barrier when no hydrogen threads are present, it has to wait for two hydrogen threads.\nIf a hydrogen thread arrives at the barrier when no other threads are present, it has to wait for an oxygen thread and another hydrogen thread.\n\nWe don\xe2\x80\x99t have to worry about matching the threads up explicitly; that is, the threads do not necessarily know which other threads they are paired up with. The key is just that threads pass the barrier in complete sets; thus, if we examine the sequence of threads that bond and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.\nWrite synchronization code for oxygen and hydrogen molecules that enforces these constraints.\n\n\xc2\xa0\n\n\nExample 1:\nInput: "HOH"\nOutput: "HHO"\nExplanation: "HOH" and "OHH" are also valid answers.\n\n\nExample 2:\nInput: "OOHHHH"\nOutput: "HHOHHO"\nExplanation: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" and "OHHOHH" are also valid answers.\n\n\n\n\xc2\xa0\nConstraints:\n\nTotal length of input string will be 3n, where 1 \xe2\x89\xa4\xc2\xa0n\xc2\xa0\xe2\x89\xa4 20.\nTotal number of H will be 2n\xc2\xa0in the input string.\nTotal number of O will\xc2\xa0be n\xc2\xa0in the input\xc2\xa0string.
__label__0 There are n flights, and they are labeled\xc2\xa0from 1 to n.\nWe have a list of flight bookings.\xc2\xa0 The i-th booking\xc2\xa0bookings[i] = [i, j, k]\xc2\xa0means that we booked k seats from flights labeled i to j inclusive.\nReturn an array answer of length n, representing the number of seats booked on each flight in order of their label.\n\xc2\xa0\nExample 1:\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\n\n\xc2\xa0\nConstraints:\n\n1 <= bookings.length <= 20000\n1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000\n1 <= bookings[i][2] <= 10000
__label__0 Return any binary tree that matches the given preorder and postorder traversals.\nValues in the traversals\xc2\xa0pre and post\xc2\xa0are distinct\xc2\xa0positive integers.\n\xc2\xa0\n\nExample 1:\nInput: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\nOutput: [1,2,3,4,5,6,7]\n\n\xc2\xa0\nNote:\n\n1 <= pre.length == post.length <= 30\npre[] and post[]\xc2\xa0are both permutations of 1, 2, ..., pre.length.\nIt is guaranteed an answer exists. If there exists multiple answers, you can return any of them.
__label__0 Given an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\nExample 1:\nGiven nums = [3,2,2,3], val = 3,\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn't matter what you leave beyond the returned length.\n\nExample 2:\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing\xc2\xa00, 1, 3, 0, and\xc2\xa04.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond\xc2\xa0the returned length.\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n\xc2\xa0 \xc2\xa0 print(nums[i]);\n}
__label__0 Given a 2-dimensional\xc2\xa0grid of integers, each value in the grid represents the color of the grid square at that location.\nTwo squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions.\nThe\xc2\xa0border of a connected component is\xc2\xa0all the squares in the connected component that are\xc2\xa0either 4-directionally adjacent to\xc2\xa0a square not in the component, or on the boundary of the grid (the first or last row or column).\nGiven a square at location\xc2\xa0(r0, c0)\xc2\xa0in the grid and a color, color the\xc2\xa0border of the connected component of that square with the given color, and return the final grid.\n\xc2\xa0\nExample 1:\nInput: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3\nOutput: [[3, 3], [3, 2]]\n\n\nExample 2:\nInput: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3\nOutput: [[1, 3, 3], [2, 3, 3]]\n\n\nExample 3:\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2\nOutput: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]\n\n\n\xc2\xa0\nNote:\n\n1 <= grid.length <= 50\n1 <= grid[0].length <= 50\n1 <= grid[i][j] <= 1000\n0 <= r0 < grid.length\n0 <= c0 < grid[0].length\n1 <= color <= 1000
__label__0 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nYour algorithm's runtime complexity must be in the order of\xc2\xa0O(log\xc2\xa0n).\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1
__label__0 On an infinite number line, the position of the i-th stone is given by\xc2\xa0stones[i].\xc2\xa0 Call a stone an endpoint stone if it has the smallest or largest position.\nEach turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\nIn particular,\xc2\xa0if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\nWhen the game ends, what is the minimum and maximum number of moves that you could have made?\xc2\xa0 Return the answer as an length 2 array:\xc2\xa0answer = [minimum_moves, maximum_moves]\n\xc2\xa0\nExample 1:\nInput: [7,4,9]\nOutput: [1,2]\nExplanation: \nWe can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n\n\nExample 2:\nInput: [6,5,4,3,10]\nOutput: [2,3]\nWe can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n\n\nExample 3:\nInput: [100,101,104,102,103]\nOutput: [0,0]\n\xc2\xa0\n\n\nNote:\n\n3 <= stones.length <= 10^4\n1 <= stones[i] <= 10^9\nstones[i] have distinct values.
__label__0 We are given a list of (axis-aligned)\xc2\xa0rectangles.\xc2\xa0 Each\xc2\xa0rectangle[i] = [x1, y1, x2, y2]\xc2\xa0, where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.\nFind the total area covered by all rectangles in the plane.\xc2\xa0 Since the answer\xc2\xa0may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\nOutput: 6\nExplanation: As illustrated in the picture.\n\nExample 2:\nInput: [[0,0,1000000000,1000000000]]\nOutput: 49\nExplanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.\n\nNote:\n\n1 <= rectangles.length <= 200\nrectanges[i].length = 4\n0 <= rectangles[i][j] <= 10^9\nThe total area covered by all rectangles will never exceed\xc2\xa02^63 - 1\xc2\xa0and thus will fit in a 64-bit signed integer.
__label__0 We are given a 2-dimensional\xc2\xa0grid.\xc2\xa0"." is an empty cell, "#" is\xc2\xa0a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A",\xc2\xa0"B", ...) are locks.\nWe start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.\xc2\xa0 We cannot walk outside the grid, or walk into a wall.\xc2\xa0 If we walk over a key, we pick it up.\xc2\xa0 We can\'t walk over a lock unless we have the corresponding key.\nFor some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.\xc2\xa0 This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were\xc2\xa0chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys.\xc2\xa0 If\xc2\xa0it\'s impossible, return -1.\n\xc2\xa0\n\nExample 1:\nInput: ["@.a.#","###.#","b.A.B"]\nOutput: 8\n\n\nExample 2:\nInput: ["@..aA","..B#.","....b"]\nOutput: 6\n\n\n\xc2\xa0\nNote:\n\n1 <= grid.length\xc2\xa0<= 30\n1 <= grid[0].length\xc2\xa0<= 30\ngrid[i][j] contains only \'.\', \'#\', \'@\',\xc2\xa0\'a\'-\'f\' and \'A\'-\'F\'\nThe number of keys is in [1, 6].\xc2\xa0 Each key has a different letter and opens exactly one lock.
__label__0 (This problem is an\xc2\xa0interactive problem.)\nYou may recall that an array\xc2\xa0A is a mountain array if and only if:\n\nA.length >= 3\nThere exists some\xc2\xa0i\xc2\xa0with\xc2\xa00 < i\xc2\xa0< A.length - 1\xc2\xa0such that:\n\t\nA[0] < A[1] < ... A[i-1] < A[i]\nA[i] > A[i+1] > ... > A[A.length - 1]\n\n\n\nGiven a mountain\xc2\xa0array mountainArr, return the minimum\xc2\xa0index such that mountainArr.get(index) == target.\xc2\xa0 If such an index\xc2\xa0doesn't exist, return -1.\nYou can't access the mountain array directly.\xc2\xa0 You may only access the array using a\xc2\xa0MountainArray\xc2\xa0interface:\n\nMountainArray.get(k) returns the element of the array at index k\xc2\xa0(0-indexed).\nMountainArray.length()\xc2\xa0returns the length of the array.\n\nSubmissions making more than 100 calls to\xc2\xa0MountainArray.get\xc2\xa0will be judged Wrong Answer.\xc2\xa0 Also, any solutions that attempt to circumvent the judge\xc2\xa0will result in disqualification.\n\n\n\xc2\xa0\nExample 1:\nInput: array = [1,2,3,4,5,3,1], target = 3\nOutput: 2\nExplanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\nExample 2:\nInput: array = [0,1,2,4,2,1], target = 3\nOutput: -1\nExplanation: 3 does not exist in the array, so we return -1.\n\n\xc2\xa0\nConstraints:\n\n3 <= mountain_arr.length() <= 10000\n0 <= target <= 10^9\n0 <= mountain_arr.get(index) <=\xc2\xa010^9
__label__0 Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".\xc2\xa0 In these strings like "heeellooo", we have groups of adjacent letters that are all the same:\xc2\xa0 "h", "eee", "ll", "ooo".\nFor some given string S, a query word is stretchy if it can be made to be equal to S by any\xc2\xa0number of\xc2\xa0applications of the following extension operation: choose a group consisting of\xc2\xa0characters c, and add some number of characters c to the group so that the size of the group is 3 or more.\nFor example, starting with "hello", we could do an extension on the group "o" to get "hellooo", but we cannot get "helloo" since the group "oo" has size less than 3.\xc2\xa0 Also, we could do another extension like "ll" -> "lllll" to get "helllllooo".\xc2\xa0 If S = "helllllooo", then the query word "hello" would be stretchy because of these two extension operations:\xc2\xa0query = "hello" -> "hellooo" ->\xc2\xa0"helllllooo" = S.\nGiven a list of query words, return the number of words that are stretchy.\xc2\xa0\n\xc2\xa0\nExample:\nInput: \nS = "heeellooo"\nwords = ["hello", "hi", "helo"]\nOutput: 1\nExplanation: \nWe can extend "e" and "o" in the word "hello" to get "heeellooo".\nWe can\'t extend "helo" to get "heeellooo" because the group "ll" is not size 3 or more.\n\n\xc2\xa0\nNotes: \n\n0 <= len(S) <= 100.\n0 <= len(words) <= 100.\n0 <= len(words[i]) <= 100.\nS and all words in words\xc2\xa0consist only of\xc2\xa0lowercase letters
__label__0 Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput:\xc2\xa0[100, 4, 200, 1, 3, 2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
__label__0 There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\nNote:\n\nIf there exists a\xc2\xa0solution, it is guaranteed to be unique.\nBoth input arrays are non-empty and have the same length.\nEach element in the input arrays is a non-negative integer.\n\nExample 1:\nInput: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\nOutput: 3\n\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\nExample 2:\nInput: \ngas  = [2,3,4]\ncost = [3,4,3]\n\nOutput: -1\n\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.
__label__0 Given an array of unique integers, each integer is strictly greater than 1.\nWe make a binary tree using these integers\xc2\xa0and each number may be used for any number of times.\nEach non-leaf node's\xc2\xa0value should be equal to the product of the values of it's children.\nHow many binary trees can we make?\xc2\xa0 Return the answer modulo 10 ** 9 + 7.\nExample 1:\nInput: A = [2, 4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: A = [2, 4, 5, 10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n\xc2\xa0\nNote:\n\n1 <= A.length <=\xc2\xa01000.\n2 <=\xc2\xa0A[i]\xc2\xa0<=\xc2\xa010 ^ 9.
__label__0 SQL SchemaX city built a new stadium, each day many people visit it and the stats are saved as these columns: id, visit_date, people\nPlease write a query to display the records which have 3 or more consecutive rows and the amount of people more than 100(inclusive).\nFor example, the table stadium:\n\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+\n\nFor the sample data above, the output is:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+\n\nNote:\nEach day only have one row record, and the dates are increasing with id increasing.
__label__0 There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.\nGiven n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.\nExample:\nInput: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\nOutput: 3\nExplanation: \nThere're totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n\n\xc2\xa0\nNote:\n\nThe integer 1 <= d, t, n <= 10,000.\nYou can't take two courses simultaneously.
__label__0 There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\nRepeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.\nWe keep repeating the steps again, alternating left to right and right to left, until a single number remains.\nFind the last number that remains starting with a list of length n.\nExample:\nInput:\nn = 9,\n1 2 3 4 5 6 7 8 9\n2 4 6 8\n2 6\n6\n\nOutput:\n6
__label__0 Given an array of integers A and let n to be its length.\n\n\nAssume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:\n\n\nF(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].\nCalculate the maximum value of F(0), F(1), ..., F(n-1). \n\nNote:\nn is guaranteed to be less than 105.\n\nExample:\nA = [4, 3, 2, 6]\n\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
__label__0 Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\nExample:\nInput: s = "abcdefg", k = 2\nOutput: "bacdfeg"\n\n\nRestrictions:\n\n The string consists of lower English letters only.\n Length of the given string and k will in the range [1, 10000]
__label__0 Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\n\nExample 1:\nInput: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n\n\nNote:\n\nn is a positive integer, which is in the range of [1, 10000].\nAll the integers in the array will be in the range of [-10000, 10000].
__label__0 Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\nNote:\n\nThe length of num is less than 10002 and will be \xe2\x89\xa5 k.\nThe given num does not contain any leading zero.\n\n\nExample 1:\nInput: num = "1432219", k = 3\nOutput: "1219"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n\nExample 2:\nInput: num = "10200", k = 1\nOutput: "200"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n\nExample 3:\nInput: num = "10", k = 2\nOutput: "0"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.
__label__0 Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\nExample 1:\nInput:nums = [1,1,1], k = 2\nOutput: 2\n\n\nNote:\n\nThe length of the array is in range [1, 20,000].\nThe range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].
__label__0 A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\nEach LED represents a zero or one, with the least significant bit on the right.\n\nFor example, the above binary watch reads "3:25".\nGiven a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\nExample:\nInput: n = 1Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]\n\nNote:\n\nThe order of output does not matter.\nThe hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00".\nThe minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".
__label__0 Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n\nExample 1:\nInput:\ns = "aaabb", k = 3\n\nOutput:\n3\n\nThe longest substring is "aaa", as \'a\' is repeated 3 times.\n\n\nExample 2:\nInput:\ns = "ababbc", k = 2\n\nOutput:\n5\n\nThe longest substring is "ababb", as \'a\' is repeated 2 times and \'b\' is repeated 3 times.
__label__0 You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly\xc2\xa0once. Find this single element that appears only once.\n\xc2\xa0\nExample 1:\nInput: [1,1,2,3,3,4,4,8,8]\nOutput: 2\n\nExample 2:\nInput: [3,3,7,7,10,11,11]\nOutput: 10\n\n\xc2\xa0\nNote: Your solution should run in O(log n) time and O(1) space.
__label__0 Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nFind the letter that was added in t.\nExample:\nInput:\ns = "abcd"\nt = "abcde"\n\nOutput:\ne\n\nExplanation:\n\'e\' is the letter that was added.
__label__0 You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c.\n\xc2\xa0\nExample 1:\nInput: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n\n\xc2\xa0\nNote:\n\nThe given list may contain duplicates, so ascending order means >= here.\n1 <= k <= 3500\n-105 <= value of elements <= 105.
__label__0 Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.\nGiven a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: True\n\n\nExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: False\n\n\nNote:\n\nThe input array won't violate no-adjacent-flowers rule.\nThe input array size is in the range of [1, 20000].\nn is a non-negative integer which won't exceed the input array size.
__label__0 Given\xc2\xa0a reference of a node in a\xc2\xa0connected\xc2\xa0undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.\n\xc2\xa0\nExample:\n\nInput:\n{"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}\n\nExplanation:\nNode 1\'s value is 1, and it has two neighbors: Node 2 and 4.\nNode 2\'s value is 2, and it has two neighbors: Node 1 and 3.\nNode 3\'s value is 3, and it has two neighbors: Node 2 and 4.\nNode 4\'s value is 4, and it has two neighbors: Node 1 and 3.\n\n\xc2\xa0\nNote:\n\nThe number of nodes will be between 1 and 100.\nThe undirected\xc2\xa0graph is a simple graph,\xc2\xa0which means no repeated edges and no self-loops in the graph.\nSince the graph is undirected, if node p\xc2\xa0has node q\xc2\xa0as\xc2\xa0neighbor, then node q\xc2\xa0must have node p\xc2\xa0as neighbor too.\nYou must return the copy of the given node as a reference to the cloned graph.
__label__0 On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).\nWe flip any number of cards, and after we choose one\xc2\xa0card.\xc2\xa0\nIf the number X on the back of the chosen\xc2\xa0card is not on the front of any card, then this number X is good.\nWhat is the smallest number that is good?\xc2\xa0 If no number is good, output 0.\nHere, fronts[i] and backs[i] represent the number on the front and back of card i.\xc2\xa0\nA\xc2\xa0flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.\nExample:\nInput: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].\nWe choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.\n\xc2\xa0\nNote:\n\n1 <= fronts.length == backs.length\xc2\xa0<=\xc2\xa01000.\n1 <=\xc2\xa0fronts[i]\xc2\xa0<= 2000.\n1 <= backs[i]\xc2\xa0<= 2000.
__label__0 You are driving a vehicle that\xc2\xa0has capacity empty seats initially available for passengers.\xc2\xa0 The vehicle only drives east (ie. it cannot turn around and drive west.)\nGiven a list of trips, trip[i] = [num_passengers, start_location, end_location]\xc2\xa0contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.\xc2\xa0 The locations are given as the number of kilometers\xc2\xa0due east from your vehicle's initial location.\nReturn true if and only if\xc2\xa0it is possible to pick up and drop off all passengers for all the given trips.\xc2\xa0\n\xc2\xa0\nExample 1:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false\n\n\nExample 2:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true\n\n\nExample 3:\nInput: trips = [[2,1,5],[3,5,7]], capacity = 3\nOutput: true\n\n\nExample 4:\nInput: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11\nOutput: true\n\n\n\n\n\n\n\n\xc2\xa0\n\n\n\n\xc2\xa0\nConstraints:\n\ntrips.length <= 1000\ntrips[i].length == 3\n1 <= trips[i][0] <= 100\n0 <= trips[i][1] < trips[i][2] <= 1000\n1 <=\xc2\xa0capacity <= 100000
__label__0 Given two words (beginWord and endWord), and a dictionary\'s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time.\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\n\nNote:\n\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\n\nExample 1:\nInput:\nbeginWord = "hit",\nendWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\n\nOutput: 5\n\nExplanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",\nreturn its length 5.\n\nExample 2:\nInput:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log"]\n\nOutput:\xc2\xa00\n\nExplanation:\xc2\xa0The endWord "cog" is not in wordList, therefore no possible\xc2\xa0transformation.
__label__0 A rectangle is\xc2\xa0represented as a\xc2\xa0list [x1, y1, x2, y2], where\xc2\xa0(x1, y1)\xc2\xa0are the coordinates of its bottom-left corner, and (x2,\xc2\xa0y2)\xc2\xa0are the coordinates of its top-right corner.\nTwo rectangles overlap if the area of their intersection is positive.\xc2\xa0 To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two (axis-aligned) rectangles, return whether\xc2\xa0they overlap.\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\n\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\n\nNotes:\n\nBoth rectangles rec1 and rec2 are lists of 4 integers.\nAll coordinates in rectangles will be between\xc2\xa0-10^9 and 10^9.
__label__0 Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.\nA node is deepest if it has the largest depth possible among\xc2\xa0any node in the entire tree.\nThe subtree of a node is that node, plus the set of all descendants of that node.\nReturn the node with the largest depth such that it contains all the deepest nodes in its subtree.\n\xc2\xa0\nExample 1:\nInput: [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation:\n\n\n\nWe return the node with value 2, colored in yellow in the diagram.\nThe nodes colored in blue are the deepest nodes of the tree.\nThe input "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" is a serialization of the given tree.\nThe output "[2, 7, 4]" is a serialization of the subtree rooted at the node with value 2.\nBoth the input and output have TreeNode type.\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the tree will be between 1 and 500.\nThe values of each node are unique.
__label__0 In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.\nFor convenience, we\'ll call the person with label x, simply "person x".\nWe\'ll say that richer[i] = [x, y] if person x\xc2\xa0definitely has more money than person\xc2\xa0y.\xc2\xa0 Note that richer\xc2\xa0may only be a subset of valid observations.\nAlso, we\'ll say quiet[x] = q if person x\xc2\xa0has quietness q.\nNow, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people\xc2\xa0who definitely have\xc2\xa0equal to or more money than person x.\n\xc2\xa0\n\nExample 1:\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but\nit isn\'t clear if they have more money than person 0.\n\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7\n(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])\nis person 7.\n\nThe other answers can be filled out with similar reasoning.\n\n\nNote:\n\n1 <= quiet.length = N <= 500\n0 <= quiet[i] < N, all quiet[i] are different.\n0 <= richer.length <= N * (N-1) / 2\n0 <= richer[i][j] < N\nricher[i][0] != richer[i][1]\nricher[i]\'s are all different.\nThe\xc2\xa0observations in richer are all logically consistent.
__label__0 On an infinite plane, a\xc2\xa0robot initially stands at (0, 0) and faces north.\xc2\xa0\xc2\xa0The robot can receive one of three instructions:\n\n"G": go straight 1 unit;\n"L": turn 90 degrees to the left;\n"R": turn 90 degress to the right.\n\nThe robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n\xc2\xa0\nExample 1:\nInput: "GGLLGG"\nOutput: true\nExplanation: \nThe robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).\nWhen repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.\n\nExample 2:\nInput: "GG"\nOutput: false\nExplanation: \nThe robot moves north indefinitely.\n\nExample 3:\nInput: "GL"\nOutput: true\nExplanation: \nThe robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...\n\n\xc2\xa0\nNote:\n\n1 <= instructions.length <= 100\ninstructions[i] is in {\'G\', \'L\', \'R\'}
__label__0 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nYour algorithm's runtime complexity must be in the order of O(log n).\nIf the target is not found in the array, return [-1, -1].\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]
__label__0 We write the integers of A and B\xc2\xa0(in the order they are given) on two separate horizontal lines.\nNow, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j]\xc2\xa0such that:\n\nA[i] == B[j];\nThe line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting lines cannot intersect even at the endpoints:\xc2\xa0each number can only belong to one connecting line.\nReturn the maximum number of connecting lines we can draw in this way.\n\xc2\xa0\nExample 1:\n\nInput: A = [1,4,2], B = [1,2,4]\nOutput: 2\nExplanation: We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.\n\n\nExample 2:\nInput: A = [2,5,1,2,5], B = [10,5,2,1,5,2]\nOutput: 3\n\n\nExample 3:\nInput: A = [1,3,7,1,7,5], B = [1,9,2,5,1]\nOutput: 2\n\xc2\xa0\n\n\nNote:\n\n1 <= A.length <= 500\n1 <= B.length <= 500\n1 <= A[i], B[i] <= 2000
__label__0 Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nInput: haystack = "hello", needle = "ll"\nOutput: 2\n\nExample 2:\nInput: haystack = "aaaaa", needle = "bba"\nOutput: -1\n\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C\'s\xc2\xa0strstr() and Java\'s\xc2\xa0indexOf().
__label__0 Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.\nSince they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total\xc2\xa0amount of candy.\xc2\xa0 (The total amount of candy\xc2\xa0a person has is the sum of the sizes of candy\xc2\xa0bars they have.)\nReturn an integer array ans\xc2\xa0where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.\nIf there are multiple answers, you may return any one of them.\xc2\xa0 It is guaranteed an answer exists.\n\xc2\xa0\n\nExample 1:\nInput: A = [1,1], B = [2,2]\nOutput: [1,2]\n\n\nExample 2:\nInput: A = [1,2], B = [2,3]\nOutput: [1,2]\n\n\nExample 3:\nInput: A = [2], B = [1,3]\nOutput: [2,3]\n\n\nExample 4:\nInput: A = [1,2,5], B = [2,4]\nOutput: [5,4]\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 10000\n1 <= B.length <= 10000\n1 <= A[i] <= 100000\n1 <= B[i] <= 100000\nIt is guaranteed that Alice and Bob have different total amounts of\xc2\xa0candy.\nIt is guaranteed there exists an\xc2\xa0answer.
__label__0 Given a non-empty, singly\xc2\xa0linked list with head node head, return\xc2\xa0a\xc2\xa0middle node of linked list.\nIf there are two middle nodes, return the second middle node.\n\xc2\xa0\n\nExample 1:\nInput: [1,2,3,4,5]\nOutput: Node 3 from this list (Serialization: [3,4,5])\nThe returned node has value 3.  (The judge's serialization of this node is [3,4,5]).\nNote that we returned a ListNode object ans, such that:\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\n\n\nExample 2:\nInput: [1,2,3,4,5,6]\nOutput: Node 4 from this list (Serialization: [4,5,6])\nSince the list has two middle nodes with values 3 and 4, we return the second one.\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the given list will be between 1\xc2\xa0and 100.
__label__0 Given the root\xc2\xa0of a binary tree, each node in the tree has a distinct value.\nAfter deleting\xc2\xa0all nodes with a value in to_delete, we are left with a forest (a\xc2\xa0disjoint union of trees).\nReturn the roots of the trees in the remaining forest.\xc2\xa0 You may return the result in any order.\n\xc2\xa0\nExample 1:\n\nInput: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]\n\n\xc2\xa0\nConstraints:\n\nThe number of nodes in the given tree is at most 1000.\nEach node has a distinct value between 1 and 1000.\nto_delete.length <= 1000\nto_delete contains distinct values between 1 and 1000.
__label__0 Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.\xc2\xa0 Elements that don't appear in arr2 should be placed at the end of arr1 in ascending order.\n\xc2\xa0\nExample 1:\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]\n\n\xc2\xa0\nConstraints:\n\narr1.length, arr2.length <= 1000\n0 <= arr1[i], arr2[i] <= 1000\nEach\xc2\xa0arr2[i]\xc2\xa0is\xc2\xa0distinct.\nEach\xc2\xa0arr2[i] is in arr1.
__label__0 Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\n\n\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\n\nExample 1:\nInput: m = 3, n = 3, k = 5\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\n\n\nExample 2:\nInput: m = 2, n = 3, k = 6\nOutput: \nExplanation: \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\n\n\nNote:\n\nThe m and n will be in the range [1, 30000].\nThe k will be in the range [1, m * n]
__label__0 You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nExample:\nGiven n = 5, and version = 4 is the first bad version.\n\ncall isBadVersion(3) -> false\ncall isBadVersion(5)\xc2\xa0-> true\ncall isBadVersion(4)\xc2\xa0-> true\n\nThen 4 is the first bad version.
__label__0 According to the Wikipedia\'s article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."\nGiven a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies, as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population..\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nWrite a function to compute the next state (after one update) of the board given its current state.\xc2\xa0The next state is created by applying the above rules simultaneously to every cell in the current state, where\xc2\xa0births and deaths occur simultaneously.\nExample:\nInput: \n[\n\xc2\xa0 [0,1,0],\n\xc2\xa0 [0,0,1],\n\xc2\xa0 [1,1,1],\n\xc2\xa0 [0,0,0]\n]\nOutput: \n[\n\xc2\xa0 [0,0,0],\n\xc2\xa0 [1,0,1],\n\xc2\xa0 [0,1,1],\n\xc2\xa0 [0,1,0]\n]\n\nFollow up:\n\nCould you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?
__label__0 In this problem, a tree is an undirected graph that is connected and has no cycles.\n\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.\n\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v.\nExample 1:\nInput: [[1,2], [1,3], [2,3]]\nOutput: [2,3]\nExplanation: The given undirected graph will be like this:\n  1\n / \\\n2 - 3\n\n\nExample 2:\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]]\nOutput: [1,4]\nExplanation: The given undirected graph will be like this:\n5 - 1 - 2\n    |   |\n    4 - 3\n\n\nNote:\nThe size of the input 2D-array will be between 3 and 1000.\nEvery integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.\n\n\n\nUpdate (2017-09-26):\nWe have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.
__label__0 One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node\'s value. If it is a null node, we record using a sentinel value such as #.\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n\nFor example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node.\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\nEach comma separated value in the string must be either an integer or a character \'#\' representing null pointer.\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3".\nExample 1:\nInput: "9,3,4,#,#,1,#,#,2,#,6,#,#"\nOutput: true\nExample 2:\nInput: "1,#"\nOutput: false\n\nExample 3:\nInput: "9,#,#,1"\nOutput: false
__label__0 Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:\n[1, 1]\n[1, 1], [3, 3]\n[1, 1], [3, 3], [7, 7]\n[1, 3], [7, 7]\n[1, 3], [6, 7]\n\n\xc2\xa0\nFollow up:\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?
__label__0 Given a nested list of integers, implement an iterator to flatten it.\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\nExample 1:\n\nInput: [[1,1],2,[1,1]]\nOutput: [1,1,2,1,1]\nExplanation: By calling next repeatedly until hasNext returns false, \n\xc2\xa0            the order of elements returned by next should be: [1,1,2,1,1].\n\nExample 2:\nInput: [1,[4,[6]]]\nOutput: [1,4,6]\nExplanation: By calling next repeatedly until hasNext returns false, \n\xc2\xa0            the order of elements returned by next should be: [1,4,6].
__label__0 Given two arrays, write a function to compute their intersection.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\n\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\n\nNote:\n\nEach element in the result must be unique.\nThe result can be in any order.
__label__0 In the world of Dota2, there are two parties: the Radiant and the Dire.\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator\'s right:\n\tA senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory:\n\tIf this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\n\n\xc2\xa0\nGiven a string representing each senator\'s party belonging. The character \'R\' and \'D\' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\nExample 1:\nInput: "RD"\nOutput: "Radiant"\nExplanation: The first senator comes from Radiant and he can just ban the next senator\'s right in the round 1. \nAnd the second senator can\'t exercise any rights any more since his right has been banned. \nAnd in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\xc2\xa0\nExample 2:\nInput: "RDD"\nOutput: "Dire"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator\'s right in the round 1. \nAnd the second senator can\'t exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator\'s right in the round 1. \nAnd in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\xc2\xa0\nNote:\n\nThe length of the given string will in the range [1, 10,000].
__label__0 Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\nExample 1:\nInput: num = "123", target = 6\nOutput: ["1+2+3", "1*2*3"] \n\nExample 2:\nInput: num = "232", target = 8\nOutput: ["2*3+2", "2+3*2"]\nExample 3:\nInput: num = "105", target = 5\nOutput: ["1*0+5","10-5"]\nExample 4:\nInput: num = "00", target = 0\nOutput: ["0+0", "0-0", "0*0"]\n\nExample 5:\nInput: num = "3456237490", target = 9191\nOutput: []
__label__0 Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.\n\n\nWe define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).\n\nExample 1:\nInput: [4,2,3]\nOutput: True\nExplanation: You could modify the first 4 to 1 to get a non-decreasing array.\n\n\nExample 2:\nInput: [4,2,1]\nOutput: False\nExplanation: You can't get a non-decreasing array by modify at most one element.\n\n\nNote:\nThe n belongs to [1, 10,000].
__label__0 Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.\n\nExample 1:\nInput: "aba"\nOutput: True\n\n\nExample 2:\nInput: "abca"\nOutput: True\nExplanation: You could delete the character \'c\'.\n\n\nNote:\n\nThe string will only contain lowercase characters a-z.\nThe maximum length of the string is 50000.
__label__0 You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\nExample:\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n\xc2\xa0            No matter 1, 2, or 3 stones you remove, the last stone will always be \n\xc2\xa0            removed by your friend.
__label__0 Given a valid (IPv4) IP address, return a defanged version of that IP address.\nA defanged\xc2\xa0IP address\xc2\xa0replaces every period "." with "[.]".\n\xc2\xa0\nExample 1:\nInput: address = "1.1.1.1"\nOutput: "1[.]1[.]1[.]1"\nExample 2:\nInput: address = "255.100.50.0"\nOutput: "255[.]100[.]50[.]0"\n\n\xc2\xa0\nConstraints:\n\nThe given address is a valid IPv4 address.
__label__0 Suppose you are given the following code:\nclass ZeroEvenOdd {\n\xc2\xa0 public ZeroEvenOdd(int n) { ... }\xc2\xa0     // constructor\n  public void zero(printNumber) { ... }  // only output 0\'s\n  public void even(printNumber) { ... }  // only output even numbers\n  public void odd(printNumber) { ... }   // only output odd numbers\n}\n\nThe same instance of ZeroEvenOdd will be passed to three different threads:\n\nThread A will call\xc2\xa0zero()\xc2\xa0which should only output 0\'s.\nThread B will call\xc2\xa0even()\xc2\xa0which should only ouput even numbers.\nThread C will call odd()\xc2\xa0which should only output odd numbers.\n\nEach of the threads is given a\xc2\xa0printNumber method to output\xc2\xa0an integer. Modify the given program to output the series\xc2\xa0010203040506... where the length of the series must be 2n.\n\xc2\xa0\nExample 1:\nInput: n = 2\nOutput: "0102"\nExplanation: There are three threads being fired asynchronously. One of them calls zero(), the other calls even(), and the last one calls odd(). "0102" is the correct output.\n\nExample 2:\nInput: n = 5\nOutput: "0102030405"
__label__0 Let\'s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example,\xc2\xa0if s = "dcce" then f(s) = 2 because the smallest character is "c" and its frequency is 2.\nNow, given string arrays queries\xc2\xa0and words, return an integer array answer, where each answer[i]\xc2\xa0is the number of words such that f(queries[i])\xc2\xa0< f(W), where W\xc2\xa0is a word in words.\n\xc2\xa0\nExample 1:\nInput: queries = ["cbd"], words = ["zaaaz"]\nOutput: [1]\nExplanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").\n\nExample 2:\nInput: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]\nOutput: [1,2]\nExplanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").\n\n\xc2\xa0\nConstraints:\n\n1 <= queries.length <= 2000\n1 <= words.length <= 2000\n1 <= queries[i].length, words[i].length <= 10\nqueries[i][j], words[i][j] are English lowercase letters.
__label__0 You have a list of\xc2\xa0words and a pattern, and you want to know which words in words matches the pattern.\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)\nReturn a list of the words in words\xc2\xa0that match the given pattern.\xc2\xa0\nYou may return the answer in any order.\n\xc2\xa0\n\nExample 1:\nInput: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"\nOutput: ["mee","aqq"]\nExplanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n"ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation,\nsince a and b map to the same letter.\n\xc2\xa0\nNote:\n\n1 <= words.length <= 50\n1 <= pattern.length = words[i].length\xc2\xa0<= 20
__label__0 In a row of trees, the i-th tree\xc2\xa0produces\xc2\xa0fruit with type\xc2\xa0tree[i].\nYou start at any tree\xc2\xa0of your choice, then repeatedly perform the following steps:\n\nAdd one piece of fruit from this tree to your baskets.\xc2\xa0 If you cannot, stop.\nMove to the next tree to the right of the current tree.\xc2\xa0 If there is no tree to the right, stop.\n\nNote that you do not have any choice after the initial choice of starting tree:\xc2\xa0you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.\nYou have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.\nWhat is the total amount of fruit you can collect with this procedure?\n\xc2\xa0\nExample 1:\nInput: [1,2,1]\nOutput: 3\nExplanation: We can collect [1,2,1].\n\n\nExample 2:\nInput: [0,1,2,2]\nOutput: 3\nExplanation: We can collect [1,2,2].\nIf we started at the first tree, we would only collect [0, 1].\n\n\nExample 3:\nInput: [1,2,3,2,2]\nOutput: 4\nExplanation: We can collect [2,3,2,2].\nIf we started at the first tree, we would only collect [1, 2].\n\n\nExample 4:\nInput: [3,3,3,1,2,1,1,2,3,3,4]\nOutput: 5\nExplanation: We can collect [1,2,1,1,2].\nIf we started at the first tree or the eighth tree, we would only collect 4 fruits.\n\n\xc2\xa0\n\n\n\nNote:\n\n1 <= tree.length <= 40000\n0 <= tree[i] < tree.length
__label__0 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nGiven nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\nExample 2:\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\n\nYour function should return length = 5, with the first five elements of nums being modified to\xc2\xa00, 1, 2, 3, and\xc2\xa04 respectively.\n\nIt doesn't matter what values are set beyond\xc2\xa0the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n\xc2\xa0 \xc2\xa0 print(nums[i]);\n}
__label__0 Three stones are on a number line at positions a, b, and c.\nEach turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those\xc2\xa0endpoints.\xc2\xa0 Formally, let's say the stones are currently at positions x, y, z with x < y < z.\xc2\xa0 You pick up the stone at either position x or position z, and move that stone to an integer position k, with x < k < z and k != y.\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\nWhen the game ends, what is the minimum and maximum number of moves that you could have made?\xc2\xa0 Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]\n\xc2\xa0\nExample 1:\nInput: a = 1, b = 2, c = 5\nOutput: [1,2]\nExplanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n\n\nExample 2:\nInput: a = 4, b = 3, c = 2\nOutput: [0,0]\nExplanation: We cannot make any moves.\n\n\nExample 3:\nInput: a = 3, b = 5, c = 1\nOutput: [1,2]\nExplanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n\n\xc2\xa0\n\n\nNote:\n\n1 <= a <= 100\n1 <= b <= 100\n1 <= c <= 100\na != b, b != c, c != a
__label__0 We are given a binary tree (with root node\xc2\xa0root), a target node, and an integer value K.\nReturn a list of the values of all\xc2\xa0nodes that have a distance K from the target node.\xc2\xa0 The answer can be returned in any order.\n\xc2\xa0\n\n\n\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2\n\nOutput: [7,4,1]\n\nExplanation: \nThe nodes that are a distance 2 from the target node (with value 5)\nhave values 7, 4, and 1.\n\n\n\nNote that the inputs "root" and "target" are actually TreeNodes.\nThe descriptions of the inputs above are just serializations of these objects.\n\n\xc2\xa0\nNote:\n\nThe given tree is non-empty.\nEach node in the tree has unique values\xc2\xa00 <= node.val <= 500.\nThe target\xc2\xa0node is a node in the tree.\n0 <= K <= 1000.
__label__0 In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.\xc2\xa0\nThere is at least one empty seat, and at least one person sitting.\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\xc2\xa0\nReturn that maximum distance to closest person.\n\nExample 1:\nInput: [1,0,0,0,1,0,1]\nOutput: 2\nExplanation: \nIf Alex sits in the second open seat (seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\nExample 2:\nInput: [1,0,0,0]\nOutput: 3\nExplanation: \nIf Alex sits in the last seat, the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\nNote:\n\n1 <= seats.length <= 20000\nseats\xc2\xa0contains only 0s or 1s, at least one 0, and at least one 1.
__label__0 Given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid.\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\n\nNote that an empty string is\xc2\xa0also considered valid.\nExample 1:\nInput: "()"\nOutput: true\n\nExample 2:\nInput: "()[]{}"\nOutput: true\n\nExample 3:\nInput: "(]"\nOutput: false\n\nExample 4:\nInput: "([)]"\nOutput: false\n\nExample 5:\nInput: "{[]}"\nOutput: true
__label__0 Given a non-negative\xc2\xa0index k\xc2\xa0where k \xe2\x89\xa4\xc2\xa033, return the kth\xc2\xa0index row of the Pascal's triangle.\nNote that the row index starts from\xc2\xa00.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\nExample:\nInput: 3\nOutput: [1,3,3,1]\n\nFollow up:\nCould you optimize your algorithm to use only O(k) extra space?
__label__0 A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to "Goat Latin"\xc2\xa0(a made-up language similar to Pig Latin.)\nThe rules of Goat Latin are as follows:\n\nIf a word begins with a vowel (a, e, i, o, or u), append "ma"\xc2\xa0to the end of the word.\n\tFor example, the word \'apple\' becomes \'applema\'.\n\t\xc2\xa0\nIf a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma".\n\tFor example, the word "goat"\xc2\xa0becomes "oatgma".\n\t\xc2\xa0\nAdd one letter \'a\'\xc2\xa0to the end of each word per its word index in the sentence, starting with 1.\n\tFor example,\xc2\xa0the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.\n\nReturn the\xc2\xa0final sentence representing the conversion from S\xc2\xa0to Goat\xc2\xa0Latin.\xc2\xa0\n\xc2\xa0\nExample 1:\nInput: "I speak Goat Latin"\nOutput: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"\n\nExample 2:\nInput: "The quick brown fox jumped over the lazy dog"\nOutput: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"\n\n\xc2\xa0\nNotes:\n\nS contains only uppercase, lowercase and spaces.\xc2\xa0Exactly one space between each word.\n1 <= S.length <= 150.
__label__0 Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn all possible palindrome partitioning of s.\nExample:\nInput:\xc2\xa0"aab"\nOutput:\n[\n  ["aa","b"],\n  ["a","a","b"]\n]
__label__0 Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nNote:\xc2\xa0For the purpose of this problem, we define empty string as valid palindrome.\nExample 1:\nInput: "A man, a plan, a canal: Panama"\nOutput: true\n\nExample 2:\nInput: "race a car"\nOutput: false
__label__0 We are given non-negative integers nums[i] which are written on a chalkboard.\xc2\xa0 Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.\xc2\xa0 If erasing a number causes\xc2\xa0the bitwise XOR of all the elements of the chalkboard to become\xc2\xa00, then that player loses.\xc2\xa0 (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.\nReturn True if and only if Alice wins the game, assuming both players play optimally.\nExample:\nInput: nums = [1, 1, 2]\nOutput: false\nExplanation: \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n\nNotes: \n\n1 <= N <= 1000.\xc2\xa0\n0 <= nums[i] <= 2^16.
__label__0 On a single threaded CPU, we execute some functions.\xc2\xa0 Each function has a unique id between 0 and N-1.\nWe store logs in timestamp order that describe when a function is entered or exited.\nEach log is a string with this format: "{function_id}:{"start" | "end"}:{timestamp}".\xc2\xa0 For example, "0:start:3"\xc2\xa0means the function with id 0 started at the beginning of timestamp 3.\xc2\xa0 "1:end:2" means the function with id 1 ended at the end of timestamp 2.\nA function\'s exclusive time\xc2\xa0is the number of units of time spent in this function.\xc2\xa0 Note that this does not include any recursive\xc2\xa0calls to child functions.\nThe CPU is single threaded which means that only one function is being executed at a given time unit.\nReturn the exclusive time of each function, sorted by their function id.\n\xc2\xa0\nExample 1:\n\nInput:\nn = 2\nlogs = ["0:start:0","1:start:2","1:end:5","0:end:6"]\nOutput: [3, 4]\nExplanation:\nFunction 0 starts at the beginning of time 0, then it executes 2 units of time and reaches the end of time 1.\nNow function 1 starts at the beginning of time 2, executes 4 units of time and ends at time 5.\nFunction 0 is running again at the beginning of time 6, and also ends at the end of time 6, thus executing for 1 unit of time. \nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n\xc2\xa0\nNote:\n\n1 <= n <= 100\nTwo functions won\'t start or end at the same time.\nFunctions will always log when they exit.
__label__0 Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.\nA group of duplicate files consists of at least two files that have exactly the same content.\nA single directory info string in the input list has the following format:\n"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"\nIt means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\nThe output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n"directory_path/file_name.txt"\nExample 1:\nInput:\n["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]\nOutput:  \n[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]\n\n\xc2\xa0\nNote:\n\nNo order is required for the final output.\nYou may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].\nThe number of files given is in the range of [1,20000].\nYou may assume no files or directories share the same name in the same directory.\nYou may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.\n\n\xc2\xa0\nFollow-up beyond contest:\n\nImagine you are given a real file system, how will you search files? DFS or BFS?\nIf the file content is very large (GB level), how will you modify your solution?\nIf you can only read the file by 1kb each time, how will you modify your solution?\nWhat is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?\nHow to make sure the duplicated files you find are not false positive?
__label__0 There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.\n\xc2\xa0\nExample 1:\nInput: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation:\n\n\nExample 2:\nInput: [[1,2],[2,2],[4,2]]\nOutput: [[1,2],[2,2],[4,2]]\nExplanation:\n\nEven you only have trees in a line, you need to use rope to enclose them. \n\n\xc2\xa0\nNote:\n\nAll trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.\nAll input integers will range from 0 to 100.\nThe garden has at least one tree.\nAll coordinates are distinct.\nInput points have NO order. No order required for output.\ninput types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__0 A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions.\nWe want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.\nFor example, below are two quad trees A and B:\nA:\n+-------+-------+   T: true\n|       |       |   F: false\n|   T   |   T   |\n|       |       |\n+-------+-------+\n|       |       |\n|   F   |   F   |\n|       |       |\n+-------+-------+\ntopLeft: T\ntopRight: T\nbottomLeft: F\nbottomRight: F\n\nB:               \n+-------+---+---+\n|       | F | F |\n|   T   +---+---+\n|       | T | T |\n+-------+---+---+\n|       |       |\n|   T   |   F   |\n|       |       |\n+-------+-------+\ntopLeft: T\ntopRight:\n     topLeft: F\n     topRight: F\n     bottomLeft: T\n     bottomRight: T\nbottomLeft: T\nbottomRight: F\n\n\xc2\xa0\nYour task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees.\nA:                 B:                 C (A or B):\n+-------+-------+  +-------+---+---+  +-------+-------+\n|       |       |  |       | F | F |  |       |       |\n|   T   |   T   |  |   T   +---+---+  |   T   |   T   |\n|       |       |  |       | T | T |  |       |       |\n+-------+-------+  +-------+---+---+  +-------+-------+\n|       |       |  |       |       |  |       |       |\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\n|       |       |  |       |       |  |       |       |\n+-------+-------+  +-------+-------+  +-------+-------+\n\nNote:\n\nBoth A and B\xc2\xa0represent grids of size N * N.\nN is guaranteed to be a power of 2.\nIf you want to know more about the quad tree, you can refer to its wiki.\nThe logic OR operation is defined as this: "A or B" is true if A is true, or if B is true, or if both A and B are true.
__label__0 Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\n\nExample:\nInput: The root of a Binary Search Tree like this:\n              5\n            /   \\\n           2     13\n\nOutput: The root of a Greater Tree like this:\n             18\n            /   \\\n          20     13
__label__0 Given a positive integer n and you can do operations as follow:\n\n\n\nIf n is even, replace n with n/2.\nIf n is odd, you can replace n with either n + 1 or n - 1.\n\n\n\nWhat is the minimum number of replacements needed for n to become 1?\n\n\nExample 1:\nInput:\n8\n\nOutput:\n3\n\nExplanation:\n8 -> 4 -> 2 -> 1\n\n\nExample 2:\nInput:\n7\n\nOutput:\n4\n\nExplanation:\n7 -> 8 -> 4 -> 2 -> 1\nor\n7 -> 6 -> 3 -> 2 -> 1
__label__0 Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list. \n\nExample 1:\nInput: ["23:59","00:00"]\nOutput: 1\n\n\nNote:\n\nThe number of time points in the given list is at least 2 and won\'t exceed 20000.\nThe input time is legal and ranges from 00:00 to 23:59.
__label__0 Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\nNote:\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.\nExample:\nint[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(3);\n\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(1);
__label__0 Find the sum of all left leaves in a given binary tree.\nExample:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nThere are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
__label__0 Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nFor example, given a 3-ary tree:\n\xc2\xa0\n\n\n\xc2\xa0\nWe should return its max depth, which is 3.\n\xc2\xa0\nNote:\n\nThe depth of the tree is at most 1000.\nThe total number of nodes is at most 5000.
__label__0 Given an n-ary tree, return the preorder traversal of its nodes' values.\nFor example, given a 3-ary tree:\n\xc2\xa0\n\n\xc2\xa0\nReturn its preorder traversal as: [1,3,5,6,2,4].\n\xc2\xa0\nNote:\nRecursive solution is trivial, could you do it iteratively?
__label__0 You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.\nThe null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don\'t affect the one-to-one mapping relationship between the string and the original binary tree.\nExample 1:\nInput: Binary tree: [1,2,3,4]\n       1\n     /   \\\n    2     3\n   /    \n  4     \n\nOutput: "1(2(4))(3)"\nExplanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".\n\n\nExample 2:\nInput: Binary tree: [1,2,3,null,4]\n       1\n     /   \\\n    2     3\n     \\  \n      4 \n\nOutput: "1(2()(4))(3)"\nExplanation: Almost the same as the first example, except we can\'t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
__label__0 Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.\nExample 1:\nInput: 5\nOutput: True\nExplanation: 1 * 1 + 2 * 2 = 5\n\n\xc2\xa0\nExample 2:\nInput: 3\nOutput: False
__label__0 Given two words (beginWord and endWord), and a dictionary\'s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\n\nNote:\n\nReturn an empty list if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\n\nExample 1:\nInput:\nbeginWord = "hit",\nendWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\n\nOutput:\n[\n  ["hit","hot","dot","dog","cog"],\n\xc2\xa0 ["hit","hot","lot","log","cog"]\n]\n\nExample 2:\nInput:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log"]\n\nOutput: []\n\nExplanation:\xc2\xa0The endWord "cog" is not in wordList, therefore no possible\xc2\xa0transformation.
__label__0 A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly.\nNow, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com".\nWe are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.\nExample 1:\nInput: \n["9001 discuss.leetcode.com"]\nOutput: \n["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]\nExplanation: \nWe only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.\n\n\nExample 2:\nInput: \n["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]\nOutput: \n["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]\nExplanation: \nWe will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.\n\n\nNotes: \n\nThe length of cpdomains will not exceed\xc2\xa0100.\xc2\xa0\nThe length of each domain name will not exceed 100.\nEach address will have either 1 or 2 "." characters.\nThe input count\xc2\xa0in any count-paired domain will not exceed 10000.\nThe answer output can be returned in any order.
__label__0 Some people will make friend requests. The\xc2\xa0list of their ages is given and\xc2\xa0ages[i]\xc2\xa0is the age of the\xc2\xa0ith person.\xc2\xa0\nPerson A will NOT friend request person B (B != A) if any of the following conditions are true:\n\nage[B]\xc2\xa0<= 0.5 * age[A]\xc2\xa0+ 7\nage[B]\xc2\xa0> age[A]\nage[B]\xc2\xa0> 100 &&\xc2\xa0age[A]\xc2\xa0< 100\n\nOtherwise, A will friend request B.\nNote that if\xc2\xa0A requests B, B does not necessarily request A.\xc2\xa0 Also, people will not friend request themselves.\nHow many total friend requests are made?\nExample 1:\nInput: [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.\n\nExample 2:\nInput: [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\nExample 3:\nInput: [20,30,100,110,120]\nOutput: \nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n\xc2\xa0\nNotes:\n\n1 <= ages.length\xc2\xa0<= 20000.\n1 <= ages[i] <= 120.
__label__0 Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val|\xc2\xa0and A is an ancestor of B.\n(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)\n\xc2\xa0\nExample 1:\n\nInput: [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: \nWe have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\n\n\xc2\xa0\nNote:\n\nThe number of nodes in the tree is between 2 and 5000.\nEach node will have value between 0 and 100000.
__label__0 Given a linked list, remove the n-th node from the end of list and return its head.\nExample:\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\nGiven n will always be valid.\nFollow up:\nCould you do this in one pass?
__label__0 We have a string S of lowercase letters, and an integer array shifts.\nCall the shift of a letter, the next letter in the alphabet, (wrapping around so that \'z\' becomes \'a\').\xc2\xa0\nFor example, shift(\'a\') = \'b\', shift(\'t\') = \'u\', and shift(\'z\') = \'a\'.\nNow for each shifts[i] = x, we want to shift the first i+1\xc2\xa0letters of S, x times.\nReturn the final string\xc2\xa0after all such shifts to S are applied.\nExample 1:\nInput: S = "abc", shifts = [3,5,9]\nOutput: "rpl"\nExplanation: \nWe start with "abc".\nAfter shifting the first 1 letters of S by 3, we have "dbc".\nAfter shifting the first 2 letters of S by 5, we have "igc".\nAfter shifting the first 3 letters of S by 9, we have "rpl", the answer.\n\nNote:\n\n1 <= S.length = shifts.length <= 20000\n0 <= shifts[i] <= 10 ^ 9
__label__0 Return the length of the shortest, non-empty, contiguous\xc2\xa0subarray of A with sum at least K.\nIf there is no non-empty subarray with sum at least K, return -1.\n\xc2\xa0\n\n\n\nExample 1:\nInput: A = [1], K = 1\nOutput: 1\n\n\nExample 2:\nInput: A = [1,2], K = 4\nOutput: -1\n\n\nExample 3:\nInput: A = [2,-1,2], K = 3\nOutput: 3\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 50000\n-10 ^ 5\xc2\xa0<= A[i] <= 10 ^ 5\n1 <= K <= 10 ^ 9
__label__0 Implement the StreamChecker class as follows:\n\nStreamChecker(words): Constructor, init the data structure with the given words.\nquery(letter): returns true if and only if for some k >= 1, the last k\xc2\xa0characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.\n\n\xc2\xa0\nExample:\nStreamChecker streamChecker = new StreamChecker(["cd","f","kl"]); // init the dictionary.\nstreamChecker.query(\'a\');          // return false\nstreamChecker.query(\'b\');          // return false\nstreamChecker.query(\'c\');          // return false\nstreamChecker.query(\'d\');          // return true, because \'cd\' is in the wordlist\nstreamChecker.query(\'e\');          // return false\nstreamChecker.query(\'f\');          // return true, because \'f\' is in the wordlist\nstreamChecker.query(\'g\');          // return false\nstreamChecker.query(\'h\');          // return false\nstreamChecker.query(\'i\');          // return false\nstreamChecker.query(\'j\');          // return false\nstreamChecker.query(\'k\');          // return false\nstreamChecker.query(\'l\');          // return true, because \'kl\' is in the wordlist\n\n\xc2\xa0\nNote:\n\n1 <= words.length <= 2000\n1 <= words[i].length <= 2000\nWords will only consist of lowercase English letters.\nQueries will only consist of lowercase English letters.\nThe number of queries is at most\xc2\xa040000.
__label__0 Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\n\nExample:\nGiven this linked list: 1->2->3->4->5\nFor k = 2, you should return: 2->1->4->3->5\nFor k = 3, you should return: 3->2->1->4->5\nNote:\n\nOnly constant extra memory is allowed.\nYou may not alter the values in the list's nodes, only nodes itself may be changed.
__label__0 Given the root of a binary search tree with distinct values, modify it so that every node\xc2\xa0has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.\nAs a reminder, a\xc2\xa0binary search tree is a tree that satisfies these constraints:\n\nThe left subtree of a node contains only nodes with keys\xc2\xa0less than\xc2\xa0the node's key.\nThe right subtree of a node contains only nodes with keys\xc2\xa0greater than\xc2\xa0the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\n\xc2\xa0\nExample 1:\n\nInput: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n\xc2\xa0\n\nNote:\n\nThe number of nodes in the tree is between 1 and 100.\nEach node will have value between 0 and 100.\nThe given tree is a binary search tree.
__label__0 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant\xc2\xa0extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 \xe2\x86\x92 1,3,2\n3,2,1 \xe2\x86\x92 1,2,3\n1,1,5 \xe2\x86\x92 1,5,1
__label__0 Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.\nYou may return any answer array that satisfies this condition.\n\xc2\xa0\n\nExample 1:\nInput: [3,1,2,4]\nOutput: [2,4,3,1]\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 5000\n0 <= A[i] <= 5000
__label__0 Given an array of integers A, consider all non-empty subsequences of A.\nFor any sequence S, let the\xc2\xa0width\xc2\xa0of S be the difference between the maximum and minimum element of S.\nReturn the sum of the widths of all subsequences of A.\xc2\xa0\nAs the answer may be very large, return the answer modulo 10^9 + 7.\n\n\xc2\xa0\nExample 1:\nInput: [2,1,3]\nOutput: 6\nExplanation:\nSubsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= 20000
__label__0 A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nEach transaction string transactions[i]\xc2\xa0consists of\xc2\xa0comma separated values representing\xc2\xa0the name, time (in minutes), amount, and city of the transaction.\nGiven a list of transactions,\xc2\xa0return a list of transactions that are possibly invalid.\xc2\xa0 You may return the answer in any order.\n\xc2\xa0\nExample 1:\nInput: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]\nOutput: ["alice,20,800,mtv","alice,50,100,beijing"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\nExample 2:\nInput: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]\nOutput: ["alice,50,1200,mtv"]\n\nExample 3:\nInput: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]\nOutput: ["bob,50,1200,mtv"]\n\n\xc2\xa0\nConstraints:\n\ntransactions.length <= 1000\nEach transactions[i] takes the form "{name},{time},{amount},{city}"\nEach {name} and {city}\xc2\xa0consist of\xc2\xa0lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of\xc2\xa0digits, and represent an integer between 0 and 1000.\nEach {amount}\xc2\xa0consist of\xc2\xa0digits, and represent an integer between 0 and 2000.
__label__0 Suppose you are given the following code:\nclass FooBar {\n  public void foo() {\n\xc2\xa0 \xc2\xa0 for (int i = 0; i < n; i++) {\n\xc2\xa0 \xc2\xa0 \xc2\xa0 print("foo");\n\xc2\xa0   }\n  }\n\n  public void bar() {\n\xc2\xa0 \xc2\xa0 for (int i = 0; i < n; i++) {\n\xc2\xa0 \xc2\xa0 \xc2\xa0 print("bar");\n\xc2\xa0 \xc2\xa0 }\n  }\n}\n\nThe same instance of FooBar will be passed to two different threads. Thread A will call\xc2\xa0foo() while thread B will call\xc2\xa0bar().\xc2\xa0Modify the given program to output "foobar" n times.\n\xc2\xa0\nExample 1:\nInput: n = 1\nOutput: "foobar"\nExplanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar(). "foobar" is being output 1 time.\n\nExample 2:\nInput: n = 2\nOutput: "foobarfoobar"\nExplanation: "foobar" is being output 2 times.
__label__0 Return the result of evaluating a given boolean expression, represented as a string.\nAn expression can either be:\n\n"t", evaluating to True;\n"f", evaluating to False;\n"!(expr)", evaluating to the logical NOT of the inner expression expr;\n"&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\n"|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\n\n\xc2\xa0\nExample 1:\nInput: expression = "!(f)"\nOutput: true\n\nExample 2:\nInput: expression = "|(f,t)"\nOutput: true\n\nExample 3:\nInput: expression = "&(t,f)"\nOutput: false\n\nExample 4:\nInput: expression = "|(&(t,f,t),!(t))"\nOutput: false\n\n\xc2\xa0\nConstraints:\n\n1 <= expression.length <= 20000\nexpression[i]\xc2\xa0consists of characters in {\'(\', \')\', \'&\', \'|\', \'!\', \'t\', \'f\', \',\'}.\nexpression is a valid expression representing a boolean, as given in the description.
__label__0 You\'re now a baseball game point recorder.\n\n\nGiven a list of strings, each string can be one of the 4 following types:\n\nInteger (one round\'s score): Directly represents the number of points you get in this round.\n"+" (one round\'s score): Represents that the points you get in this round are the sum of the last two valid round\'s points.\n"D" (one round\'s score): Represents that the points you get in this round are the doubled data of the last valid round\'s points.\n"C" (an operation, which isn\'t a round\'s score): Represents the last valid round\'s points you get were invalid and should be removed.\n\n\n\nEach round\'s operation is permanent and could have an impact on the round before and the round after.\n\n\nYou need to return the sum of the points you could get in all the rounds.\n\nExample 1:\nInput: ["5","2","C","D","+"]\nOutput: 30\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2\'s data was invalid. The sum is: 5.  \nRound 3: You could get 10 points (the round 2\'s data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n\n\nExample 2:\nInput: ["5","-2","4","C","D","9","+","+"]\nOutput: 27\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3\'s data is invalid. The sum is: 3.  \nRound 4: You could get -4 points (the round 3\'s data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n\n\nNote:\nThe size of the input list will be between 1 and 1000.\nEvery integer represented in the list will be between -30000 and 30000.
__label__0 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n\n[2,3,4], the median is 3\n[2,3], the median is (2 + 3) / 2 = 2.5\nDesign a data structure that supports the following two operations:\n\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\ndouble findMedian() - Return the median of all elements so far.\n\n\xc2\xa0\nExample:\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2\n\n\xc2\xa0\nFollow up:\n\nIf all integer numbers from the stream are between 0\xc2\xa0and 100, how would you optimize it?\nIf 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?
__label__0 Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nExample:\nInput: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nNote:\n\nYou must do this in-place without making a copy of the array.\nMinimize the total number of operations.
__label__0 Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: \n\nSuppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\n\n\nIf there are multiple answers, print any of them.\n\nExample 1:\nInput: n = 3, k = 1\nOutput: [1, 2, 3]\nExplanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.\n\n\nExample 2:\nInput: n = 3, k = 2\nOutput: [1, 3, 2]\nExplanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.\n\n\nNote:\n\nThe n and k are in the range 1 <= k < n <= 104.
__label__0 Given a non-empty array of integers, return the k most frequent elements.\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nNote: \n\nYou may assume k is always valid, 1 \xe2\x89\xa4 k \xe2\x89\xa4 number of unique elements.\nYour algorithm's time complexity must be better than O(n log n), where n is the array's size.
__label__1 Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n\nExample:\nInput: [1,2,3,0,2]\nOutput: 3 \nExplanation: transactions = [buy, sell, cooldown, buy, sell]
__label__1 Given a string S and a string T, count the number of distinct subsequences of S which equals T.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).\nExample 1:\nInput: S = "rabbbit", T = "rabbit"\nOutput:\xc2\xa03\nExplanation:\n\nAs shown below, there are 3 ways you can generate "rabbit" from S.\n(The caret symbol ^ means the chosen letters)\n\nrabbbit\n^^^^ ^^\nrabbbit\n^^ ^^^^\nrabbbit\n^^^ ^^^\n\nExample 2:\nInput: S = "babgbag", T = "bag"\nOutput:\xc2\xa05\nExplanation:\n\nAs shown below, there are 5 ways you can generate "bag" from S.\n(The caret symbol ^ means the chosen letters)\n\nbabgbag\n^^ ^\nbabgbag\n^^    ^\nbabgbag\n^    ^^\nbabgbag\n  ^  ^^\nbabgbag\n    ^^^
__label__1 Given two strings str1 and str2,\xc2\xa0return the shortest string that has both str1\xc2\xa0and str2\xc2\xa0as subsequences.\xc2\xa0\xc2\xa0If multiple answers exist, you may return any of them.\n(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)\n\xc2\xa0\nExample 1:\nInput: str1 = "abac", str2 = "cab"\nOutput: "cabac"\nExplanation: \nstr1 = "abac" is a subsequence of "cabac" because we can delete the first "c".\nstr2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".\nThe answer provided is the shortest such string that satisfies these properties.\n\n\xc2\xa0\nNote:\n\n1 <= str1.length, str2.length <= 1000\nstr1 and str2 consist of lowercase English letters.
__label__1 There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.\n\xc2\xa0\nExample 1:\nInput: m = 2, n = 2, N = 2, i = 0, j = 0\nOutput: 6\nExplanation:\n\n\nExample 2:\nInput: m = 1, n = 3, N = 3, i = 0, j = 1\nOutput: 12\nExplanation:\n\n\n\xc2\xa0\nNote:\n\nOnce you move the ball out of boundary, you cannot move it back.\nThe length and height of the grid is in range [1,50].\nN is in range [0,50].
__label__1 You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.\n\n\nNow, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion. \n\n\nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\n\nExample 1:\nInput: [[1,2], [2,3], [3,4]]\nOutput: 2\nExplanation: The longest chain is [1,2] -> [3,4]\n\n\nNote:\n\nThe number of given pairs will be in the range [1, 1000].
__label__1 There are G people in a gang, and a list of various crimes they could commit.\nThe i-th crime generates a profit[i] and requires group[i] gang members to participate.\nIf a gang member participates in one crime, that member can't participate in another crime.\nLet's call a profitable\xc2\xa0scheme\xc2\xa0any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G.\nHow many schemes can be chosen?\xc2\xa0 Since the answer may be very\xc2\xa0large, return it modulo 10^9 + 7.\n\xc2\xa0\nExample 1:\nInput: G = 5, P = 3, group = [2,2], profit = [2,3]\nOutput: 2\nExplanation: \nTo make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\n\nExample 2:\nInput: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]\nOutput: 7\nExplanation: \nTo make a profit of at least 5, the gang could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n\n\xc2\xa0\n\nNote:\n\n1 <= G <= 100\n0 <= P <= 100\n1 <= group[i] <= 100\n0 <= profit[i] <= 100\n1 <= group.length = profit.length <= 100
__label__1 A sequence X_1, X_2, ..., X_n\xc2\xa0is fibonacci-like if:\n\nn >= 3\nX_i + X_{i+1} = X_{i+2}\xc2\xa0for all\xc2\xa0i + 2 <= n\n\nGiven a strictly increasing\xc2\xa0array\xc2\xa0A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.\xc2\xa0 If one does not exist, return 0.\n(Recall that a subsequence is derived from another sequence A by\xc2\xa0deleting any number of\xc2\xa0elements (including none)\xc2\xa0from A, without changing the order of the remaining elements.\xc2\xa0 For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)\n\xc2\xa0\n\n\nExample 1:\nInput: [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation:\nThe longest subsequence that is fibonacci-like: [1,2,3,5,8].\n\nExample 2:\nInput: [1,3,7,11,12,14,18]\nOutput: 3\nExplanation:\nThe longest subsequence that is fibonacci-like:\n[1,11,12], [3,11,14] or [7,11,18].\n\n\xc2\xa0\nNote:\n\n3 <= A.length <= 1000\n1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9\n(The time limit has been reduced by 50% for submissions in Java, C, and C++.)
__label__1 You are given a series of video clips from a sporting event that lasted T seconds.\xc2\xa0\xc2\xa0These video clips can be overlapping with each other and have varied lengths.\nEach video clip clips[i]\xc2\xa0is an interval: it starts at time clips[i][0] and ends at time clips[i][1].\xc2\xa0 We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments\xc2\xa0[0, 1] +\xc2\xa0[1, 3] + [3, 7].\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).\xc2\xa0 If the task is impossible, return -1.\n\xc2\xa0\nExample 1:\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10\nOutput: 3\nExplanation: \nWe take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut [1,9] into segments [1,2] + [2,8] + [8,9].\nNow we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\n\nExample 2:\nInput: clips = [[0,1],[1,2]], T = 5\nOutput: -1\nExplanation: \nWe can't cover [0,5] with only [0,1] and [0,2].\n\nExample 3:\nInput: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9\nOutput: 3\nExplanation: \nWe can take clips [0,4], [4,7], and [6,9].\n\nExample 4:\nInput: clips = [[0,4],[2,8]], T = 5\nOutput: 2\nExplanation: \nNotice you can have extra video after the event ends.\n\n\xc2\xa0\nNote:\n\n1 <= clips.length <= 100\n0 <= clips[i][0], clips[i][1] <= 100\n0 <= T <= 100
__label__1 Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:\nSi % Sj = 0 or Sj % Si = 0.\nIf there are multiple solutions, return any subset is fine.\nExample 1:\n\nInput: [1,2,3]\nOutput: [1,2] (of course, [1,3] will also be ok)\n\n\nExample 2:\nInput: [1,2,4,8]\nOutput: [1,2,4,8]
__label__1 In LeetCode Store, there are some kinds of items to sell. Each item has a price.\n\n\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\n\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\nThe job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.\n\n\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\n\nYou could use any of special offers as many times as you want.\nExample 1:\nInput: [2,5], [[3,0,5],[1,2,10]], [3,2]\nOutput: 14\nExplanation: \nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\n\nExample 2:\nInput: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\nOutput: 11\nExplanation: \nThe price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n\nNote:\n\nThere are at most 6 kinds of items, 100 special offers.\nFor each item, you need to buy at most 6 of them.\nYou are not allowed to buy more items than you want, even if that would lower the overall price.
__label__1 We have a collection of rocks, each rock has a positive integer weight.\nEach turn, we choose any two rocks\xc2\xa0and smash them together.\xc2\xa0 Suppose the stones have weights x and y with x <= y.\xc2\xa0 The result of this smash is:\n\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\n\nAt the end, there is at most 1 stone left.\xc2\xa0 Return the smallest possible weight of this stone (the weight is\xc2\xa00 if there are no stones left.)\n\xc2\xa0\nExample 1:\nInput: [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.\n\n\xc2\xa0\nNote:\n\n1 <= stones.length <= 30\n1 <= stones[i] <= 100
__label__1 There are\xc2\xa0N dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously push\xc2\xa0some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left.\nSimilarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino\xc2\xa0expends no additional force to a falling or already fallen domino.\nGiven a string "S" representing the initial state.\xc2\xa0S[i] = \'L\', if the i-th domino has been pushed to the left; S[i] = \'R\', if the i-th domino has been pushed to the right; S[i] = \'.\',\xc2\xa0if the i-th domino has not been pushed.\nReturn a string representing the final state.\xc2\xa0\nExample 1:\nInput: ".L.R...LR..L.."\nOutput: "LL.RR.LLRRLL.."\n\nExample 2:\nInput: "RR.L"\nOutput: "RR.L"\nExplanation: The first domino expends no additional force on the second domino.\n\nNote:\n\n0 <= N\xc2\xa0<= 10^5\nString\xc2\xa0dominoes contains only\xc2\xa0\'L\', \'R\' and \'.\'
__label__1 Alice and Bob take turns playing a game, with Alice starting first.\nInitially, there is a number N\xc2\xa0on the chalkboard.\xc2\xa0 On each player's turn, that player makes a move\xc2\xa0consisting of:\n\nChoosing\xc2\xa0any x with 0 < x < N and N % x == 0.\nReplacing\xc2\xa0the number\xc2\xa0N\xc2\xa0on the chalkboard with N - x.\n\nAlso, if a player cannot make a move, they lose the game.\nReturn True if and only if Alice wins the game, assuming both players play optimally.\n\xc2\xa0\n\n\n\nExample 1:\nInput: 2\nOutput: true\nExplanation: Alice chooses 1, and Bob has no more moves.\n\n\nExample 2:\nInput: 3\nOutput: false\nExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n\xc2\xa0\nNote:\n\n1 <= N <= 1000
__label__1 Given a 2D grid of 0s and 1s, return the number of elements in\xc2\xa0the largest square\xc2\xa0subgrid that has all 1s on its border, or 0 if such a subgrid\xc2\xa0doesn't exist in the grid.\n\xc2\xa0\nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 9\n\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\n\n\xc2\xa0\nConstraints:\n\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1
__label__1 Given a string, your task is to count how many palindromic substrings in this string.\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.\nExample 1:\nInput: "abc"\nOutput: 3\nExplanation: Three palindromic strings: "a", "b", "c".\n\n\xc2\xa0\nExample 2:\nInput: "aaa"\nOutput: 6\nExplanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".\n\n\xc2\xa0\nNote:\n\nThe input string length won\'t exceed 1000.
__label__1 Given an integer array nums, find the sum of the elements between indices i and j (i \xe2\x89\xa4 j), inclusive.\nExample:\nGiven nums = [-2, 0, 3, -5, 2, -1]\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n\n\nNote:\n\nYou may assume that the array does not change.\nThere are many calls to sumRange function.
__label__1 Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits.\nNote: You should try to optimize your time and space complexity.\nExample 1:\nInput:\nnums1 = [3, 4, 6, 5]\nnums2 = [9, 1, 2, 5, 8, 3]\nk = 5\nOutput:\n[9, 8, 6, 5, 3]\nExample 2:\nInput:\nnums1 = [6, 7]\nnums2 = [6, 0, 4]\nk = 5\nOutput:\n[6, 7, 6, 0, 4]\nExample 3:\nInput:\nnums1 = [3, 9]\nnums2 = [8, 9]\nk = 3\nOutput:\n[9, 8, 9]
__label__1 Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nNote:\n\nYou may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\n0 \xe2\x89\xa4 n \xe2\x89\xa4 500, 0 \xe2\x89\xa4 nums[i] \xe2\x89\xa4 100\n\nExample:\nInput: [3,1,5,8]\nOutput: 167 \nExplanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n\xc2\xa0            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
__label__1 \x00\x00\x00\x01Bud1\x00\x000\x00\x00\x00\x08\x00\x00\x000\x00\x00\x00\x10\x0c\x00\x00\x00\x86\x00\x00 \x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x91\x00\x00\x00\x03\x00\x00\x10\x00\x00.\x00t\x00x\x00tIloc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x06\x006\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x01\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x07\x001\x001\x009\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x08\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00 \x00\x00\x00\x01\x00\x00\x00@\x00\x00\x00\x01\x00\x00\x00\x80\x00\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x01\x00\x00\x02\x00\x00\x00\x00\x01\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x10\x00\x00\x00\x00\x01\x00\x00 \x00\x00\x00\x00\x01\x00\x00@\x00\x00\x00\x00\x01\x00\x00\x80\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x02\x00\x00\x00\x00\x00\x01\x00\x04\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x00\x00\x01\x00\x10\x00\x00\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x01\x00@\x00\x00\x00\x00\x00\x01\x00\x80\x00\x00\x00\x00\x00\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x00\x01\x08\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01 \x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x008\x00\x00\x00\x07\x007\x000\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\n\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x000\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\n\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x000\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\n\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x007\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x01\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x001\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0b\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x001\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0b\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x003\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0b\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x003\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0b\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x003\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0b\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x005\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0b\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x006\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0b\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x006\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0b\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x007\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0b\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x007\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0b\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x008\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0b\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x009\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0b\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x009\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0ch\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x007\x009\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0ch\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x000\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0ch\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x000\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0ch\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x001\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0c\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x001\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0c\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x001\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0c\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x003\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0c\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x008\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x01\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x004\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\rH\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x005\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\rH\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x005\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\rH\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x005\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\rH\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x008\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x01\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x007\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\r\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x007\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\r\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x008\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\r\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x008\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\r\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x008\x009\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0e(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x05\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x009\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x01x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x000\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0e(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x001\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0e(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x001\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0e(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x002\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0e\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x002\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0e\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x002\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0e\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x002\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0e\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x003\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x0f\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x009\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x01x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x004\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x0f\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x004\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x0f\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x009\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x01x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x009\x005\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x0f\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x009\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x01x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x15\x00N\x00e\x00w\x00 \x00F\x00o\x00l\x00d\x00e\x00r\x00 \x00W\x00i\x00t\x00h\x00 \x00I\x00t\x00e\x00m\x00sIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x15\x00N\x00e\x00w\x00 \x00F\x00o\x00l\x00d\x00e\x00r\x00 \x00W\x00i\x00t\x00h\x00 \x00I\x00t\x00e\x00m\x00slg1Scomp\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x15\x00N\x00e\x00w\x00 \x00F\x00o\x00l\x00d\x00e\x00r\x00 \x00W\x00i\x00t\x00h\x00 \x00I\x00t\x00e\x00m\x00smoDDblob\x00\x00\x00\x08b\x02K\xac\x97\xb3\xc1A\x00\x00\x00\x15\x00N\x00e\x00w\x00 \x00F\x00o\x00l\x00d\x00e\x00r\x00 \x00W\x00i\x00t\x00h\x00 \x00I\x00t\x00e\x00m\x00smodDblob\x00\x00\x00\x08b\x02K\xac\x97\xb3\xc1A\x00\x00\x00\x15\x00N\x00e\x00w\x00 \x00F\x00o\x00l\x00d\x00e\x00r\x00 \x00W\x00i\x00t\x00h\x00 \x00I\x00t\x00e\x00m\x00sph1Scomp\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00X\x00\x00\x00\x07\x001\x001\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x01\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x001\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x01\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x002\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x01\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x002\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x01\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x003\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x02X\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x003\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x02X\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x003\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x02X\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x005\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x02X\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x006\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x02\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x007\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x02\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x001\x008\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x02\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x000\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x02\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x001\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x038\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x003\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x038\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x004\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x038\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x005\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x038\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x005\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x03\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x005\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x03\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x006\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x03\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x006\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x03\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x007\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x04\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x007\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x04\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x008\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x04\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x008\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x04\x18\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x009\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x04\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x009\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x04\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x002\x009\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x04\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x04\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x003\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x002\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x003\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x003\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x004\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x004\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x006\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x009\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x05\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x000\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x000\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x002\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x06\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x002\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x06\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x002\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x06\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x004\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x003\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x06\xb8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x004\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x07(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x004\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x07(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x006\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x07(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x007\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x07(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x009\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x07\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x009\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x07\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x000\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x07\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x000\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x07\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x000\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x08\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x000\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x08\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x001\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x08\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x005\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x00\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x002\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x08\x08\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x004\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x08x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x004\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x08x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x004\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x08x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x004\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x08x\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x006\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x08\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x006\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x08\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x006\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x08\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x007\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x08\xe8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x008\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\tX\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x008\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\tX\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x005\x008\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\tX\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x000\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\tX\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x006\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x00\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x006\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x00\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x002\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\t\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x002\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\t\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x006\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x00\x98\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x003\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\t\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x004\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\t\xc8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x004\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\n8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x005\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\n8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x006\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\n8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x007\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\n8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x006\x007\x009\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\n\xa8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x000\x0b\x00\x00\x00E\x00\x00\x10\x0c\x00\x00\x00\x86\x00\x00 \x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x04DSDB\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00 \x00\x00\x00`\x00\x00\x00\x01\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x01\x00\x00\x02\x00\x00\x00\x00\x01\x00\x00\x04\x00\x00\x00\x00\x02\x00\x00\x08\x00\x00\x008\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00@\x00\x00\x00\x00\x01\x00\x00\x80\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x02\x00\x00\x00\x00\x00\x01\x00\x04\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x00\x00\x01\x00\x10\x00\x00\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x01\x00@\x00\x00\x00\x00\x00\x01\x00\x80\x00\x00\x00\x00\x00\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x00\x01\x08\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01 \x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00\x00lob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x04\x88\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x006\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x000\x007\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x06\x003\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x002\x001\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x04\xf8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x003\x002\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x003\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x004\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x004\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x05h\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x006\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x003\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x17\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x005\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x01\x85\x00\x00\x05\xd8\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x008\x008\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x003\x009\x000\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00\xa9\x00\x00\x06H\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x05\x004\x00.\x00t\x00x\x00tIlocblob\x00\x00\x00\x10\x00\x00\x00;\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x07\x004\x000\x001\x00.\x00t\x00x\x00tIloc
__label__1 Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\n\nNote:\nIf n is the length of array, assume the following constraints are satisfied:\n\n1 \xe2\x89\xa4 n \xe2\x89\xa4 1000\n1 \xe2\x89\xa4 m \xe2\x89\xa4 min(50, n)\n\n\nExamples: \nInput:\nnums = [7,2,5,10,8]\nm = 2\n\nOutput:\n18\n\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.
__label__1 We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower.\nHowever, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.\nExample:\nn = 10, I pick 8.\n\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\n\nGame over. 8 is the number I picked.\n\nYou end up paying $5 + $7 + $9 = $21.\n\nGiven a particular n \xe2\x89\xa5 1, find out how much money you need to have to guarantee a win.
__label__1 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nExample 1:\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 \nExplanation: 11 = 5 + 5 + 1\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\n\nNote:\nYou may assume that you have an infinite number of each kind of coin.
__label__1 Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\n\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\n\nExample:\nGiven matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -> 8\nsumRegion(1, 1, 2, 2) -> 11\nsumRegion(1, 2, 2, 4) -> 12\n\n\nNote:\n\nYou may assume that the matrix does not change.\nThere are many calls to sumRegion function.\nYou may assume that row1 \xe2\x89\xa4 row2 and col1 \xe2\x89\xa4 col2.
__label__1 Alex\xc2\xa0and Lee continue their\xc2\xa0games with piles of stones.\xc2\xa0 There are a number of\xc2\xa0piles\xc2\xa0arranged in a row, and each pile has a positive integer number of stones\xc2\xa0piles[i].\xc2\xa0 The objective of the game is to end with the most\xc2\xa0stones.\xc2\xa0\nAlex and Lee take turns, with Alex starting first.\xc2\xa0 Initially, M = 1.\nOn each player's turn, that player\xc2\xa0can take all the stones in the first X remaining piles, where 1 <= X <= 2M.\xc2\xa0 Then, we set\xc2\xa0M = max(M, X).\nThe game continues until all the stones have been taken.\nAssuming Alex and Lee play optimally, return the maximum number of stones Alex can get.\n\xc2\xa0\nExample 1:\nInput: piles = [2,7,9,4,4]\nOutput: 10\nExplanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n\xc2\xa0\nConstraints:\n\n1 <= piles.length <= 100\n1 <= piles[i]\xc2\xa0<= 10 ^ 4
__label__1 A car travels from a starting position to a destination which is target miles east of the starting position.\nAlong the way, there are gas stations.\xc2\xa0 Each station[i]\xc2\xa0represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.\nThe car starts with an infinite tank of gas, which initially has\xc2\xa0startFuel\xc2\xa0liters of fuel in it.\xc2\xa0 It uses 1 liter of gas per 1 mile that it drives.\nWhen the car\xc2\xa0reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\nWhat is the least number of refueling stops the car must make in order to reach its destination?\xc2\xa0 If it cannot reach the destination, return -1.\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there.\xc2\xa0 If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\n\xc2\xa0\n\nExample 1:\nInput: target = 1, startFuel = 1, stations = []\nOutput: 0\nExplanation: We can reach the target without refueling.\n\n\nExample 2:\nInput: target = 100, startFuel = 1, stations = [[10,100]]\nOutput: -1\nExplanation: We can't reach the target (or even the first gas station).\n\n\nExample 3:\nInput: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\nOutput: 2\nExplanation: \nWe start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n\xc2\xa0\nNote:\n\n1 <= target, startFuel, stations[i][1] <= 10^9\n0 <= stations.length <= 500\n0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target
__label__1 Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.\n\xc2\xa0\n\nExample 1:\nInput: 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n\n\nExample 2:\nInput: 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\n\nExample 3:\nInput: 1000\nOutput: 262\n\n\n\xc2\xa0\nNote:\n\n1 <= N <= 10^9
__label__1 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word.\xc2\xa0Return all such possible sentences.\nNote:\n\nThe same word in the dictionary may be reused multiple times in the segmentation.\nYou may assume the dictionary does not contain duplicate words.\n\nExample 1:\nInput:\ns = "catsanddog"\nwordDict = ["cat", "cats", "and", "sand", "dog"]\nOutput:\n[\n\xc2\xa0 "cats and dog",\n\xc2\xa0 "cat sand dog"\n]\n\nExample 2:\nInput:\ns = "pineapplepenapple"\nwordDict = ["apple", "pen", "applepen", "pine", "pineapple"]\nOutput:\n[\n\xc2\xa0 "pine apple pen apple",\n\xc2\xa0 "pineapple pen apple",\n\xc2\xa0 "pine applepen apple"\n]\nExplanation: Note that you are allowed to reuse a dictionary word.\n\nExample 3:\nInput:\ns = "catsandog"\nwordDict = ["cats", "dog", "sand", "and", "cat"]\nOutput:\n[]
__label__1 Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.\nA student attendance record is a string that only contains the following three characters:\n\n\n\'A\' : Absent. \n\'L\' : Late.\n \'P\' : Present. \n\n\n\nA record is regarded as rewardable if it doesn\'t contain more than one \'A\' (absent) or more than two continuous \'L\' (late).\nExample 1:\nInput: n = 2\nOutput: 8 \nExplanation:\nThere are 8 records with length 2 will be regarded as rewardable:\n"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"\nOnly "AA" won\'t be regarded as rewardable owing to more than one absent times. \n\n\nNote:\nThe value of n won\'t exceed 100,000.
__label__1 Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\nExample:\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\n\n\xc2\xa0\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?\nCredits:\nSpecial thanks to @pbrother for adding this problem and creating all test cases.
__label__1 A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\nExample 1:\nInput: [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence.\n\nExample 2:\nInput: [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n\nExample 3:\nInput: [1,2,3,4,5,6,7,8,9]\nOutput: 2\nFollow up:\nCan you do it in O(n) time?
__label__1 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote:\n\nThe same word in the dictionary may be reused multiple times in the segmentation.\nYou may assume the dictionary does not contain duplicate words.\n\nExample 1:\nInput: s = "leetcode", wordDict = ["leet", "code"]\nOutput: true\nExplanation: Return true because "leetcode" can be segmented as "leet code".\n\nExample 2:\nInput: s = "applepenapple", wordDict = ["apple", "pen"]\nOutput: true\nExplanation: Return true because "applepenapple" can be segmented as "apple pen apple".\n\xc2\xa0            Note that you are allowed to reuse a dictionary word.\n\nExample 3:\nInput: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]\nOutput: false
__label__1 Given a list of words, each word consists of English lowercase letters.\nLet\'s say word1 is a predecessor of word2\xc2\xa0if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.\xc2\xa0 For example,\xc2\xa0"abc"\xc2\xa0is a predecessor of "abac".\nA word chain\xc2\xa0is a sequence of words [word_1, word_2, ..., word_k]\xc2\xa0with k >= 1,\xc2\xa0where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.\nReturn the longest possible length of a word chain with words chosen from the given list of words.\n\xc2\xa0\nExample 1:\nInput: ["a","b","ba","bca","bda","bdca"]\nOutput: 4\nExplanation: one of the longest word chain is "a","ba","bda","bdca".\n\n\xc2\xa0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 16\nwords[i] only consists of English lowercase letters.
__label__1 Given an array arr of positive integers, consider all binary trees such that:\n\nEach node has either 0 or 2 children;\nThe values of arr correspond to the values of each\xc2\xa0leaf in an in-order traversal of the tree.\xc2\xa0 (Recall that a node is a leaf if and only if it has 0 children.)\nThe value\xc2\xa0of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.\n\nAmong all possible binary trees considered,\xc2\xa0return the smallest possible sum of the values of each non-leaf node.\xc2\xa0 It is guaranteed this sum fits into a 32-bit integer.\n\xc2\xa0\nExample 1:\nInput: arr = [6,2,4]\nOutput: 32\nExplanation:\nThere are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n    24            24\n   /  \\          /  \\\n  12   4        6    8\n /  \\               / \\\n6    2             2   4\n\n\xc2\xa0\nConstraints:\n\n2 <= arr.length <= 40\n1 <= arr[i] <= 15\nIt is guaranteed that the answer fits into a 32-bit signed integer (ie.\xc2\xa0it is less than 2^31).
__label__1 You have d dice, and each die has f faces numbered 1, 2, ..., f.\nReturn the number of possible ways (out of fd\xc2\xa0total ways) modulo 10^9 + 7 to roll the dice so the sum of the face up numbers equals target.\n\xc2\xa0\nExample 1:\nInput: d = 1, f = 6, target = 3\nOutput: 1\nExplanation: \nYou throw one die with 6 faces.  There is only one way to get a sum of 3.\n\nExample 2:\nInput: d = 2, f = 6, target = 7\nOutput: 6\nExplanation: \nYou throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:\n1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n\nExample 3:\nInput: d = 2, f = 5, target = 10\nOutput: 1\nExplanation: \nYou throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.\n\nExample 4:\nInput: d = 1, f = 2, target = 3\nOutput: 0\nExplanation: \nYou throw one die with 2 faces.  There is no way to get a sum of 3.\n\nExample 5:\nInput: d = 30, f = 30, target = 500\nOutput: 222616187\nExplanation: \nThe answer must be returned modulo 10^9 + 7.\n\n\xc2\xa0\nConstraints:\n\n1 <= d, f <= 30\n1 <= target <= 1000
__label__1 Given two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not).\xc2\xa0A common subsequence\xc2\xa0of two strings is a subsequence that is common to both strings.\n\xc2\xa0\nIf there is no common subsequence, return 0.\n\xc2\xa0\nExample 1:\nInput: text1 = "abcde", text2 = "ace" \nOutput: 3  \nExplanation: The longest common subsequence is "ace" and its length is 3.\n\nExample 2:\nInput: text1 = "abc", text2 = "abc"\nOutput: 3\nExplanation: The longest common subsequence is "abc" and its length is 3.\n\nExample 3:\nInput: text1 = "abc", text2 = "def"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\nThe input strings consist of lowercase English characters only.
__label__1 A message containing letters from A-Z is being encoded to numbers using the following mapping way:\n\n\'A\' -> 1\n\'B\' -> 2\n...\n\'Z\' -> 26\n\n\nBeyond that, now the encoded string can also contain the character \'*\', which can be treated as one of the numbers from 1 to 9.\n\n\nGiven the encoded message containing digits and the character \'*\', return the total number of ways to decode it.\n\n\nAlso, since the answer may be very large, you should return the output mod 109 + 7.\n\nExample 1:\nInput: "*"\nOutput: 9\nExplanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".\n\n\nExample 2:\nInput: "1*"\nOutput: 9 + 9 = 18\n\n\nNote:\n\nThe length of the input string will fit in range [1, 105].\nThe input string will only contain the character \'*\' and digits \'0\' - \'9\'.
__label__1 A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\nNote: m and n will be at most 100.\nExample 1:\nInput:\n[\n\xc2\xa0 [0,0,0],\n\xc2\xa0 [0,1,0],\n\xc2\xa0 [0,0,0]\n]\nOutput: 2\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right
__label__1 You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \n\nExample 1:\nInput: nums is [1, 1, 1, 1, 1], S is 3. \nOutput: 5\nExplanation: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n\n\nNote:\n\nThe length of the given array is positive and will not exceed 20. \nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.
__label__1 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\nInput:\n[\n\xc2\xa0 [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\xe2\x86\x923\xe2\x86\x921\xe2\x86\x921\xe2\x86\x921 minimizes the sum.
__label__1 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n\xc2\xa0            Total amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n\xc2\xa0            Total amount you can rob = 2 + 9 + 1 = 12.
__label__1 Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K.\nNote that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid.\nYou may return the answer in any order.\n\xc2\xa0\nExample 1:\nInput: N = 3, K = 7\nOutput: [181,292,707,818,929]\nExplanation: Note that 070 is not a valid number, because it has leading zeroes.\n\n\nExample 2:\nInput: N = 2, K = 1\nOutput: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]\n\xc2\xa0\n\nNote:\n\n1 <= N <= 9\n0 <= K <= 9
__label__1 Given a string S, count the number of distinct, non-empty subsequences of S .\nSince the result may be large, return the answer modulo 10^9 + 7.\n\xc2\xa0\nExample 1:\nInput: "abc"\nOutput: 7\nExplanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".\n\n\nExample 2:\nInput: "aba"\nOutput: 6\nExplanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".\n\n\nExample 3:\nInput: "aaa"\nOutput: 3\nExplanation: The 3 distinct subsequences are "a", "aa" and "aaa".\n\n\n\n\xc2\xa0\n\xc2\xa0\nNote:\n\nS contains only lowercase letters.\n1 <= S.length <= 2000
__label__1 A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nHow many possible unique paths are there?\n\nAbove is a 7 x 3 grid. How many possible unique paths are there?\nNote: m and n will be at most 100.\nExample 1:\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\nExample 2:\nInput: m = 7, n = 3\nOutput: 28
__label__1 Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\nExample:\nInput: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]\n\nOutput: ["catsdogcats","dogcatsdog","ratcatdogcat"]\n\nExplanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".\n\n\nNote:\n\nThe number of elements of the given array will not exceed 10,000 \nThe length sum of elements in the given array will not exceed 600,000. \nAll the input string will only include lower case letters.\nThe returned elements order does not matter.
__label__1 A chess knight can move as indicated in the chess diagram below:\n\xc2\xa0.\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0\n\xc2\xa0\nThis time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.\xc2\xa0 Each hop must be from one key to another numbered key.\nEach time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total.\nHow many distinct numbers can you dial in this manner?\nSince the answer may be large, output the answer\xc2\xa0modulo 10^9 + 7.\n\xc2\xa0\n\n\n\nExample 1:\nInput: 1\nOutput: 10\n\n\nExample 2:\nInput: 2\nOutput: 20\n\n\nExample 3:\nInput: 3\nOutput: 46\n\n\xc2\xa0\nNote:\n\n1 <= N <= 5000
__label__1 Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.\nExample 1:\nInput:\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\nOutput: 3\nExplanation: \nThe repeated subarray with maximum length is [3, 2, 1].\n\n\xc2\xa0\nNote:\n\n1 <= len(A), len(B) <= 1000\n0 <= A[i], B[i] < 100
__label__1 Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.\n\xc2\xa0\nExample 1:\nInput: nums = [4, 3, 2, 3, 5, 2, 1], k = 4\nOutput: True\nExplanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n\n\xc2\xa0\nNote:\n\n1 <= k <= len(nums) <= 16.\n0 < nums[i] < 10000.
__label__1 Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.\n\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.\n\nExample 1:\nInput: \nS = 'bccb'\nOutput: 6\nExplanation: \nThe 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\n\nExample 2:\nInput: \nS = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\nOutput: 104860361\nExplanation: \nThere are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\n\n\nNote:\nThe length of S will be in the range [1, 1000].\nEach character S[i] will be in the set {'a', 'b', 'c', 'd'}.
__label__1 You are installing a billboard and want it to have the largest height.\xc2\xa0 The billboard will have two steel supports, one on each side.\xc2\xa0 Each steel support must be an equal height.\nYou have a collection of rods which can be welded together.\xc2\xa0 For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation.\xc2\xa0 If you cannot support the billboard, return 0.\n\xc2\xa0\nExample 1:\nInput: [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n\nExample 2:\nInput: [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n\n\nExample 3:\nInput: [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0.\n\n\n\xc2\xa0\nNote:\n\n0 <= rods.length <= 20\n1 <= rods[i] <= 1000\nThe sum of rods is at most 5000.
__label__1 Given a square array of integers A, we want the minimum sum of a falling path through A.\nA falling path starts at any element in the first row, and chooses one element from each row.\xc2\xa0 The next row's choice must be in a column that is different from the previous row's column by at most one.\n\xc2\xa0\nExample 1:\nInput: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 12\nExplanation: \nThe possible falling paths are:\n\n\n[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]\n[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]\n[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]\n\nThe falling path with the smallest sum is [1,4,7], so the answer is 12.\n\xc2\xa0\nNote:\n\n1 <= A.length == A[0].length <= 100\n-100 <= A[i][j] <= 100
__label__1 Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. \nGiven an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. \nExample 1:\nInput: [1, 5, 2]\nOutput: False\nExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.\n\n\nExample 2:\nInput: [1, 5, 233, 7]\nOutput: True\nExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n\nNote:\n\n1 <= length of the array <= 20. \nAny scores in the given array are non-negative integers and will not exceed 10,000,000.\nIf the scores of both players are equal, then player 1 is still the winner.
__label__1 Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following 3 operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n\nExample 1:\nInput: word1 = "horse", word2 = "ros"\nOutput: 3\nExplanation: \nhorse -> rorse (replace \'h\' with \'r\')\nrorse -> rose (remove \'r\')\nrose -> ros (remove \'e\')\n\nExample 2:\nInput: word1 = "intention", word2 = "execution"\nOutput: 5\nExplanation: \nintention -> inention (remove \'t\')\ninention -> enention (replace \'i\' with \'e\')\nenention -> exention (replace \'n\' with \'x\')\nexention -> exection (replace \'n\' with \'c\')\nexection -> execution (insert \'u\')
__label__1 Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.\nExample 1:\nInput: s1 = "sea", s2 = "eat"\nOutput: 231\nExplanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.\nDeleting "t" from "eat" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n\nExample 2:\nInput: s1 = "delete", s2 = "leet"\nOutput: 403\nExplanation: Deleting "dee" from "delete" to turn the string into "let",\nadds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.\nAt the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.\n\n\nNote:\n0 < s1.length, s2.length <= 1000.\nAll elements of each string will have an ASCII value in [97, 122].
__label__1 Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample:\nInput: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\nOutput: 4
__label__1 Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.\nYou may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)\nReturn the maximum profit you can make.\nExample 1:\nInput: prices = [1, 3, 2, 8, 4, 9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\nBuying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n\nNote:\n0 < prices.length <= 50000.\n0 < prices[i] < 50000.\n0 <= fee < 50000.
__label__1 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and\xc2\xa0it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),\n\xc2\xa0            because they are adjacent houses.\n\nExample 2:\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n\xc2\xa0            Total amount you can rob = 1 + 3 = 4.
__label__1 Given an input string (s) and a pattern (p), implement regular expression matching with support for \'.\' and \'*\'.\n\'.\' Matches any single character.\n\'*\' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\nNote:\n\ns\xc2\xa0could be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like\xc2\xa0.\xc2\xa0or\xc2\xa0*.\n\nExample 1:\nInput:\ns = "aa"\np = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n\nExample 2:\nInput:\ns = "aa"\np = "a*"\nOutput: true\nExplanation:\xc2\xa0\'*\' means zero or more of the preceding\xc2\xa0element, \'a\'. Therefore, by repeating \'a\' once, it becomes "aa".\n\nExample 3:\nInput:\ns = "ab"\np = ".*"\nOutput: true\nExplanation:\xc2\xa0".*" means "zero or more (*) of any character (.)".\n\nExample 4:\nInput:\ns = "aab"\np = "c*a*b"\nOutput: true\nExplanation:\xc2\xa0c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".\n\nExample 5:\nInput:\ns = "mississippi"\np = "mis*is*p*."\nOutput: false
__label__1 In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.\n\nAn "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.\n\nExamples of Axis-Aligned Plus Signs of Order k:Order 1:\n000\n010\n000\n\nOrder 2:\n00000\n00100\n01110\n00100\n00000\n\nOrder 3:\n0000000\n0001000\n0001000\n0111110\n0001000\n0001000\n0000000\n\nExample 1:Input: N = 5, mines = [[4, 2]]\nOutput: 2\nExplanation:\n11111\n11111\n11111\n11111\n11011\nIn the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.\n\nExample 2:Input: N = 2, mines = []\nOutput: 1\nExplanation:\nThere is no plus sign of order 2, but there is of order 1.\n\nExample 3:Input: N = 1, mines = [[0, 0]]\nOutput: 0\nExplanation:\nThere is no plus sign, so return 0.\n\nNote:\nN will be an integer in the range [1, 500].\nmines will have length at most 5000.\nmines[i] will be length 2 and consist of integers in the range [0, N-1].\n(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)
__label__1 table.dungeon, .dungeon th, .dungeon td {\n  border:3px solid black;\n}\n\n .dungeon th, .dungeon td {\n    text-align: center;\n    height: 70px;\n    width: 70px;\n}\n\nThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\xc2\xa0\nWrite a function to determine the knight's minimum initial health so that he is able to rescue the princess.\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.\n\n\n\n-2 (K)\n-3\n3\n\n\n-5\n-10\n1\n\n\n10\n30\n-5 (P)\n\n\n\n\xc2\xa0\nNote:\n\nThe knight's health has no upper bound.\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
__label__1 A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, these are arithmetic sequences:\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic.\n1, 1, 2, 5, 7\n\xc2\xa0\n\nA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 \xe2\x89\xa4 P0 < P1 < ... < Pk < N.\nA subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k \xe2\x89\xa5 2.\nThe function should return the number of arithmetic subsequence slices in the array A.\nThe input contains N integers. Every integer is in the range of -231 and 231-1 and 0 \xe2\x89\xa4 N \xe2\x89\xa4 1000. The output is guaranteed to be less than 231-1.\n\xc2\xa0\n\nExample:\nInput: [2, 4, 6, 8, 10]\n\nOutput: 7\n\nExplanation:\nAll arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]
__label__1 There are N piles of stones arranged in a row.\xc2\xa0 The i-th pile has stones[i] stones.\nA move consists of merging exactly\xc2\xa0K\xc2\xa0consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.\nFind the minimum cost to merge all piles of stones into one pile.\xc2\xa0 If it is impossible, return -1.\n\xc2\xa0\n\nExample 1:\nInput: stones = [3,2,4,1], K = 2\nOutput: 20\nExplanation: \nWe start with [3, 2, 4, 1].\nWe merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].\nWe merge [4, 1] for a cost of 5, and we are left with [5, 5].\nWe merge [5, 5] for a cost of 10, and we are left with [10].\nThe total cost was 20, and this is the minimum possible.\n\n\nExample 2:\nInput: stones = [3,2,4,1], K = 3\nOutput: -1\nExplanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n\nExample 3:\nInput: stones = [3,5,1,2,6], K = 3\nOutput: 25\nExplanation: \nWe start with [3, 5, 1, 2, 6].\nWe merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].\nWe merge [3, 8, 6] for a cost of 17, and we are left with [17].\nThe total cost was 25, and this is the minimum possible.\n\n\xc2\xa0\nNote:\n\n1 <= stones.length <= 30\n2 <= K <= 30\n1 <= stones[i] <= 100
__label__1 Given an array A of strings, find any\xc2\xa0smallest string that contains each string in A as a\xc2\xa0substring.\nWe may assume that no string in A is substring of another string in A.\n\xc2\xa0\n\nExample 1:\nInput: ["alex","loves","leetcode"]\nOutput: "alexlovesleetcode"\nExplanation: All permutations of "alex","loves","leetcode" would also be accepted.\n\n\nExample 2:\nInput: ["catg","ctaagt","gcta","ttca","atgcatc"]\nOutput: "gctaagttcatgcatc"\n\xc2\xa0\n\n\nNote:\n\n1 <= A.length <= 12\n1 <= A[i].length <= 20
__label__1 Given an integer array arr\xc2\xa0and an integer k, modify the array by repeating it k times.\nFor example, if arr\xc2\xa0= [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\nReturn the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0\xc2\xa0and its sum in that case is 0.\nAs the answer can be very large, return the answer\xc2\xa0modulo\xc2\xa010^9 + 7.\n\xc2\xa0\nExample 1:\nInput: arr = [1,2], k = 3\nOutput: 9\n\nExample 2:\nInput: arr = [1,-2,1], k = 5\nOutput: 2\n\nExample 3:\nInput: arr = [-1,-2], k = 7\nOutput: 0\n\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= k <= 10^5\n-10^4 <= arr[i] <= 10^4
__label__1 Write a program to find the n-th ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5.\xc2\xa0\nExample:\nInput: n = 10\nOutput: 12\nExplanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\nNote: \xc2\xa0\n\n1 is typically treated as an ugly number.\nn does not exceed 1690.
__label__1 On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n\nExample 1:\nInput: cost = [10, 15, 20]\nOutput: 15\nExplanation: Cheapest is start on cost[1], pay that cost and go to the top.\n\n\nExample 2:\nInput: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nOutput: 6\nExplanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n\n\nNote:\n\ncost will have a length in the range [2, 1000].\nEvery cost[i] will be an integer in the range [0, 999].
__label__1 Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \'?\' and \'*\'.\n\'?\' Matches any single character.\n\'*\' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\nNote:\n\ns\xc2\xa0could be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like ?\xc2\xa0or\xc2\xa0*.\n\nExample 1:\nInput:\ns = "aa"\np = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n\nExample 2:\nInput:\ns = "aa"\np = "*"\nOutput: true\nExplanation:\xc2\xa0\'*\' matches any sequence.\n\nExample 3:\nInput:\ns = "cb"\np = "?a"\nOutput: false\nExplanation:\xc2\xa0\'?\' matches \'c\', but the second letter is \'a\', which does not match \'b\'.\n\nExample 4:\nInput:\ns = "adceb"\np = "*a*b"\nOutput: true\nExplanation:\xc2\xa0The first \'*\' matches the empty sequence, while the second \'*\' matches the substring "dce".\n\nExample 5:\nInput:\ns = "acdcb"\np = "a*c?b"\nOutput: false
__label__1 Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ...\xc2\xa0n.\nExample:\nInput: 3\nOutput:\n[\n\xc2\xa0 [1,null,3,2],\n\xc2\xa0 [3,2,null,1],\n\xc2\xa0 [3,1,null,null,2],\n\xc2\xa0 [2,1,3],\n\xc2\xa0 [1,null,2,null,3]\n]\nExplanation:\nThe above output corresponds to the 5 unique BST's shown below:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3
__label__1 In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. \nWhat if we change the game so that players cannot re-use integers? \nFor example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.\nGiven an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally. \nYou can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\n\nExample\nInput:\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\nOutput:\nfalse\n\nExplanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.
__label__1 A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, these are arithmetic sequence:\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7\n\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.\nA slice (P, Q) of array A is called arithmetic if the sequence:\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\nThe function should return the number of arithmetic slices in the array A. \n\nExample:\nA = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
__label__1 Given n, how many structurally unique BST's (binary search trees) that store values 1 ...\xc2\xa0n?\nExample:\nInput: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3
__label__1 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1:\nInput: "babad"\nOutput: "bab"\nNote: "aba" is also a valid answer.\n\nExample 2:\nInput: "cbbd"\nOutput: "bb"
__label__1 We are given an array\xc2\xa0A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = ["babca","bbazb"] and deletion indices {0, 1, 4}, then the final array after deletions is ["bc","az"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in\xc2\xa0lexicographic order.\nFor clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on.\nReturn the minimum possible value of D.length.\n\xc2\xa0\n\nExample 1:\nInput: ["babca","bbazb"]\nOutput: 3\nExplanation: After deleting columns 0, 1, and 4, the final array is A = ["bc", "az"].\nBoth these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]).\nNote that A[0] > A[1] - the array A isn\'t necessarily in lexicographic order.\n\n\nExample 2:\nInput: ["edcba"]\nOutput: 4\nExplanation: If we delete less than 4 columns, the only row won\'t be lexicographically sorted.\n\n\nExample 3:\nInput: ["ghi","def","abc"]\nOutput: 0\nExplanation: All rows are already lexicographically sorted.\n\n\xc2\xa0\n\n\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100
__label__1 In a N x N grid representing a field of cherries, each cell is one of three possible integers.\n\xc2\xa0\n\n0 means the cell is empty, so you can pass through;\n1 means the cell contains a cherry, that you can pick up and pass through;\n-1 means the cell contains a thorn that blocks your way.\n\n\xc2\xa0\nYour task is to collect maximum number of cherries possible by following the rules below:\n\xc2\xa0\n\nStarting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);\nAfter reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;\nWhen passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);\nIf there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.\n\n\xc2\xa0\n\xc2\xa0\nExample 1:\nInput: grid =\n[[0, 1, -1],\n [1, 0, -1],\n [1, 1,  1]]\nOutput: 5\nExplanation: \nThe player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n\xc2\xa0\nNote:\n\ngrid is an N by N 2D array, with 1 <= N <= 50.\nEach grid[i][j] is an integer in the set {-1, 0, 1}.\nIt is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.
__label__1 Given an array of integers, return the maximum sum for a non-empty\xc2\xa0subarray (contiguous elements) with at most one element deletion.\xc2\xa0In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the\xc2\xa0sum of the remaining elements is maximum possible.\nNote that the subarray needs to be non-empty after deleting one element.\n\xc2\xa0\nExample 1:\nInput: arr = [1,-2,0,3]\nOutput: 4\nExplanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.\nExample 2:\nInput: arr = [1,-2,-2,3]\nOutput: 3\nExplanation: We just choose [3] and it's the maximum sum.\n\nExample 3:\nInput: arr = [-1,-1,-1,-1]\nOutput: -1\nExplanation:\xc2\xa0The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\n\xc2\xa0\nConstraints:\n\n1 <= arr.length <= 10^5\n-10^4 <= arr[i] <= 10^4
__label__1 Given a binary tree, we install cameras on the nodes of the tree.\xc2\xa0\nEach camera at\xc2\xa0a node can monitor its parent, itself, and its immediate children.\nCalculate the minimum number of cameras needed to monitor all nodes of the tree.\n\xc2\xa0\nExample 1:\n\n\nInput: [0,0,null,0,0]\nOutput: 1\nExplanation: One camera is enough to monitor all nodes if placed as shown.\n\n\nExample 2:\n\nInput: [0,0,null,0,null,0,null,null,0]\nOutput: 2\nExplanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n\nNote:\n\nThe number of nodes in the given tree will be in the range\xc2\xa0[1, 1000].\nEvery node has value 0.
__label__1 Given an array of integers A, find the number of\xc2\xa0triples of indices (i, j, k)\xc2\xa0such that:\n\n0 <= i < A.length\n0 <= j < A.length\n0 <= k < A.length\nA[i]\xc2\xa0& A[j]\xc2\xa0& A[k] == 0, where &\xc2\xa0represents the bitwise-AND operator.\n\n\xc2\xa0\nExample 1:\nInput: [2,1,3]\nOutput: 12\nExplanation: We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0, j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 & 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) : 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0, k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 1000\n0 <= A[i] < 2^16
__label__1 We have two integer sequences A and B of the same non-zero length.\nWe are allowed to swap elements A[i] and B[i].\xc2\xa0 Note that both elements are in the same index position in their respective sequences.\nAt the end of some number of swaps, A and B are both strictly increasing.\xc2\xa0 (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].)\nGiven A and B, return the minimum number of swaps to make both sequences strictly increasing.\xc2\xa0 It is guaranteed that the given input always makes it possible.\nExample:\nInput: A = [1,3,5,4], B = [1,2,3,7]\nOutput: 1\nExplanation: \nSwap A[3] and B[3].  Then the sequences are:\nA = [1, 3, 5, 7] and B = [1, 2, 3, 4]\nwhich are both strictly increasing.\n\nNote:\n\nA, B are arrays with the same length, and that length will be in the range [1, 1000].\nA[i], B[i] are integer values in the range [0, 2000].
__label__1 Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\nNote:\n\nEach of the array element will not exceed 100.\nThe array size will not exceed 200.\n\n\xc2\xa0\nExample 1:\nInput: [1, 5, 11, 5]\n\nOutput: true\n\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n\n\xc2\xa0\nExample 2:\nInput: [1, 2, 3, 5]\n\nOutput: false\n\nExplanation: The array cannot be partitioned into equal sum subsets.
__label__1 Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.\n\xc2\xa0\nExample 1:\nInput: [23, 2, 4, 6, 7],  k=6\nOutput: True\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n\nExample 2:\nInput: [23, 2, 6, 4, 7],  k=6\nOutput: True\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n\n\xc2\xa0\nNote:\n\nThe length of the array won't exceed 10,000.\nYou may assume the sum of all the numbers is in the range of a signed 32-bit integer.
__label__1 You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. \n\nFor each move, you could choose any m (1 \xe2\x89\xa4 m \xe2\x89\xa4 n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  \nGiven an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\nExample1\nInput: [1,0,5]\n\nOutput: 3\n\nExplanation: \n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3    \n3rd move:    2     1 <-- 3    =>    2     2     2   \n\nExample2\nInput: [0,3,0]\n\nOutput: 2\n\nExplanation: \n1st move:    0 <-- 3     0    =>    1     2     0    \n2nd move:    1     2 --> 0    =>    1     1     1     \n\nExample3\nInput: [0,2,0]\n\nOutput: -1\n\nExplanation: \nIt's impossible to make all the three washing machines have the same number of dresses. \n\n\nNote:\n\nThe range of n is [1, 10000].\nThe range of dresses number in a super washing machine is [0, 1e5].
__label__1 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\nExample 1:\nInput: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"\nOutput: true\n\nExample 2:\nInput: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\nOutput: false
__label__1 In a country popular for train travel, you\xc2\xa0have planned some train travelling one year in advance.\xc2\xa0 The days of the year that you will travel is given as an array days.\xc2\xa0 Each day is an integer from 1 to 365.\nTrain tickets are sold in 3 different ways:\n\na 1-day pass is sold for costs[0] dollars;\na 7-day pass is sold for costs[1] dollars;\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\xc2\xa0 For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\xc2\xa0\nExample 1:\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total you spent $11 and covered all the days of your travel.\n\n\nExample 2:\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total you spent $17 and covered all the days of your travel.\n\n\xc2\xa0\n\nNote:\n\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000
__label__1 You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nNote: Given n will be a positive integer.\nExample 1:\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step
__label__1 Your music player contains N\xc2\xa0different songs and she wants to listen to L (not necessarily different) songs during your trip. \xc2\xa0You\xc2\xa0create\xc2\xa0a playlist so\xc2\xa0that:\n\nEvery song is played at least once\nA song can only be played again only if\xc2\xa0K\xc2\xa0other songs have been played\n\nReturn the number of possible playlists.\xc2\xa0 As the answer can be very large, return it modulo 10^9 + 7.\n\xc2\xa0\n\n\n\nExample 1:\nInput: N = 3, L = 3, K = 1\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n\n\nExample 2:\nInput: N = 2, L = 3, K = 0\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n\n\nExample 3:\nInput: N = 2, L = 3, K = 1\nOutput: 2\nExplanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]\n\n\n\n\xc2\xa0\nNote:\n\n0 <= K < N <= L <= 100
__label__1 Given two integer arrays\xc2\xa0arr1 and arr2, return the minimum number of operations (possibly zero) needed\xc2\xa0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\xc2\xa00 <=\xc2\xa0i < arr1.length\xc2\xa0and\xc2\xa00 <= j < arr2.length\xc2\xa0and do the assignment\xc2\xa0arr1[i] = arr2[j].\nIf there is no way to make\xc2\xa0arr1\xc2\xa0strictly increasing,\xc2\xa0return\xc2\xa0-1.\n\xc2\xa0\nExample 1:\nInput: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\n\nExample 2:\nInput: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\n\nExample 3:\nInput: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing.\n\xc2\xa0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9
__label__1 Given an array nums of integers, you can perform operations on the array.\nIn each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.\nYou start with 0 points. Return the maximum number of points you can earn by applying such operations.\nExample 1:\nInput: nums = [3, 4, 2]\nOutput: 6\nExplanation: \nDelete 4 to earn 4 points, consequently 3 is also deleted.\nThen, delete 2 to earn 2 points. 6 total points are earned.\n\n\xc2\xa0\nExample 2:\nInput: nums = [2, 2, 3, 3, 3, 4]\nOutput: 9\nExplanation: \nDelete 3 to earn 3 points, deleting both 2's and the 4.\nThen, delete 3 again to earn 3 points, and 3 again to earn 3 points.\n9 total points are earned.\n\n\xc2\xa0\nNote:\n\nThe length of nums is at most 20000.\nEach element nums[i] is an integer in the range [1, 10000].
__label__1 On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).\nA chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n\xc2\xa0\n\n\xc2\xa0\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\n\xc2\xa0\nExample:\nInput: 3, 2, 0, 0\nOutput: 0.0625\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n\xc2\xa0\nNote:\n\nN will be between 1 and 25.\nK will be between 0 and 100.\nThe knight always initially starts on the board.
__label__1 Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\nBelow is one possible representation of s1 = "great":\n    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n\nTo scramble the string, we may choose any non-leaf node and swap its two children.\nFor example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".\n    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n\nWe say that "rgeat" is a scrambled string of "great".\nSimilarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".\n    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n\nWe say that "rgtae" is a scrambled string of "great".\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\nExample 1:\nInput: s1 = "great", s2 = "rgeat"\nOutput: true\n\nExample 2:\nInput: s1 = "abcde", s2 = "caebd"\nOutput: false
__label__1 Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".\nNow we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\nNote: p consists of only lowercase English letters and the size of p might be over 10000.\nExample 1:\nInput: "a"\nOutput: 1\n\nExplanation: Only the substring "a" of string "a" is in the string \x10s.\n\n\nExample 2:\nInput: "cac"\nOutput: 2\nExplanation: There are two substrings "a", "c" of string "cac" in the string s.\n\n\nExample 3:\nInput: "zab"\nOutput: 6\nExplanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
__label__1 In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door.\nGiven a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.\nInitially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.\nAt the stage of rotating the ring to spell the key character key[i]:\n\nYou can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring\'s characters at the 12:00 direction, where this character must equal to the character key[i].\nIf the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you\'ve finished all the spelling.\n\nExample:\n\n\xc2\xa0\n\nInput: ring = "godding", key = "gd"\nOutput: 4\nExplanation:\nFor the first key character \'g\', since it is already in place, we just need 1 step to spell this character. \nFor the second key character \'d\', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\nNote:\n\nLength of both ring and key will be in range 1 to 100.\nThere are only lowercase letters in both strings and might be some duplcate characters in both strings.\nIt\'s guaranteed that string key could always be spelled by rotating the string ring.
__label__1 In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\nFor now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\nNow your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\nNote:\n\nThe given numbers of 0s and 1s will both not exceed 100\nThe size of given string array won\'t exceed 600.\n\n\xc2\xa0\nExample 1:\nInput: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3\nOutput: 4\n\nExplanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \xe2\x80\x9c10,\xe2\x80\x9d0001\xe2\x80\x9d,\xe2\x80\x9d1\xe2\x80\x9d,\xe2\x80\x9d0\xe2\x80\x9d\n\n\xc2\xa0\nExample 2:\nInput: Array = {"10", "0", "1"}, m = 1, n = 1\nOutput: 2\n\nExplanation: You could form "10", but then you\'d have nothing left. Better form "0" and "1".
__label__1 Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc". \nOn the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, \xe2\x80\x9cabc\xe2\x80\x9d  can be obtained from \xe2\x80\x9cabdbec\xe2\x80\x9d based on our definition, but it can not be obtained from \xe2\x80\x9cacbbe\xe2\x80\x9d.\nYou are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 \xe2\x89\xa4 n1 \xe2\x89\xa4 106 and 1 \xe2\x89\xa4 n2 \xe2\x89\xa4 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.\nExample:\nInput:\ns1="acb", n1=4\ns2="ab", n2=2\n\nReturn:\n2
__label__1 Given an integer array\xc2\xa0nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\nExample 1:\nInput: [2,3,-2,4]\nOutput: 6\nExplanation:\xc2\xa0[2,3] has the largest product 6.\n\nExample 2:\nInput: [-2,0,-1]\nOutput: 0\nExplanation:\xc2\xa0The result cannot be 2, because [-2,-1] is not a subarray.
__label__1 We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated.\nXX  <- domino\n\nXX  <- "L" tromino\nX\n\nGiven N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7.\n(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)\nExample:\nInput: 3\nOutput: 5\nExplanation: \nThe five different ways are listed below, different letters indicates different tiles:\nXYZ XXZ XYY XXY XYY\nXYZ YYZ XZZ XYY XXY\nNote:\n\nN\xc2\xa0 will be in range [1, 1000].
__label__1 Say you have an array for which the i-th\xc2\xa0element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nExample 1:\nInput: [2,4,1], k = 2\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\nInput: [3,2,6,5,0,3], k = 2\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n\xc2\xa0            Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
__label__1 A subarray A[i], A[i+1], ..., A[j]\xc2\xa0of A is said to be turbulent if and only if:\n\nFor i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;\nOR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.\n\nThat is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nReturn the length of a\xc2\xa0maximum size turbulent subarray of A.\n\xc2\xa0\n\nExample 1:\nInput: [9,4,2,10,7,8,8,1,9]\nOutput: 5\nExplanation: (A[1] > A[2] < A[3] > A[4] < A[5])\n\n\nExample 2:\nInput: [4,8,12,16]\nOutput: 2\n\n\nExample 3:\nInput: [100]\nOutput: 1\n\n\n\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 40000\n0 <= A[i] <= 10^9
__label__1 In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.\nEach subarray will be of size k, and we want to maximize the sum of all 3*k entries.\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\nExample:\nInput: [1,2,1,2,6,7,5,1], 2\nOutput: [0, 3, 5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n\n\xc2\xa0\nNote:\n\nnums.length will be between 1 and 20000.\nnums[i] will be between 1 and 65535.\nk will be between 1 and floor(nums.length / 3).
__label__1 We are given N different types of stickers.  Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.\n\nYou can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nWhat is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.\n\nExample 1:\nInput:["with", "example", "science"], "thehat"\n\nOutput:3\n\nExplanation:We can use 2 "with" stickers, and 1 "example" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target "thehat".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\nExample 2:\nInput:["notice", "possible"], "basicbasic"\n\nOutput:-1\n\nExplanation:We can\'t form the target "basicbasic" from cutting letters from the given stickers.\n\nNote:\nstickers has length in the range [1, 50].\nstickers consists of lowercase English words (without apostrophes).\ntarget has length in the range [1, 15], and consists of lowercase English letters.\nIn all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.\nThe time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.
__label__1 Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ...\xc2\xa0where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).\xc2\xa0 For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3\xc2\xa0which is a value of 3.\nWhen writing such an expression, we adhere to the following conventions:\n\nThe division operator (/) returns rational numbers.\nThere are no parentheses placed anywhere.\nWe use the usual order of operations: multiplication and division happens before addition and subtraction.\nIt\'s not allowed to use the unary negation\xc2\xa0operator (-).\xc2\xa0 For example, "x\xc2\xa0- x"\xc2\xa0is a valid expression as it only uses subtraction, but "-x +\xc2\xa0x" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given target.\xc2\xa0 Return the least number of operators used.\n\xc2\xa0\n\nExample 1:\nInput: x = 3, target = 19\nOutput: 5\nExplanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.\n\nExample 2:\n\nInput: x = 5, target = 501\nOutput: 8\nExplanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.\n\n\nExample 3:\nInput: x = 100, target = 100000000\nOutput: 3\nExplanation: 100 * 100 * 100 * 100.  The expression contains 3 operations.\n\xc2\xa0\n\n\n\nNote:\n\n2 <= x <= 100\n1 <= target <= 2 * 10^8
__label__1 Given an integer array nums, find the contiguous subarray\xc2\xa0(containing at least one number) which has the largest sum and return its sum.\nExample:\nInput: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation:\xc2\xa0[4,-1,2,1] has the largest sum = 6.\n\nFollow up:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
__label__1 Given a string s, find the longest palindromic subsequence\'s length in s. You may assume that the maximum length of s is 1000.\n\nExample 1:\nInput: \n"bbbab"\n\nOutput: \n4\n\nOne possible longest palindromic subsequence is "bbbb".\n\nExample 2:\nInput:\n"cbbd"\n\nOutput:\n2\n\nOne possible longest palindromic subsequence is "bb".
__label__1 There are n cities connected by\xc2\xa0m flights. Each fight starts from city\xc2\xa0u and arrives at\xc2\xa0v with a price w.\nNow given all the cities and flights, together with starting city src and the destination\xc2\xa0dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.\nExample 1:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\nOutput: 200\nExplanation: \nThe graph looks like this:\n\n\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\nExample 2:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\nOutput: 500\nExplanation: \nThe graph looks like this:\n\n\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\nNote:\n\nThe number of\xc2\xa0nodes\xc2\xa0n will be\xc2\xa0in range [1, 100], with nodes labeled from 0 to n - 1.\nThe\xc2\xa0size of flights will be\xc2\xa0in range [0, n * (n - 1) / 2].\nThe format of each flight will be (src, dst, price).\nThe price of each flight will be in the range [1, 10000].\nk is in the range of [0, n - 1].\nThere\xc2\xa0will\xc2\xa0not\xc2\xa0be\xc2\xa0any\xc2\xa0duplicated\xc2\xa0flights or\xc2\xa0self\xc2\xa0cycles.
__label__1 Given a 2D binary matrix filled with 0\'s and 1\'s, find the largest rectangle containing only 1\'s and return its area.\nExample:\nInput:\n[\n  ["1","0","1","0","0"],\n  ["1","0","1","1","1"],\n  ["1","1","1","1","1"],\n  ["1","0","0","1","0"]\n]\nOutput: 6
__label__1 A message containing letters from A-Z is being encoded to numbers using the following mapping:\n\'A\' -> 1\n\'B\' -> 2\n...\n\'Z\' -> 26\n\nGiven a non-empty string containing only digits, determine the total number of ways to decode it.\nExample 1:\nInput: "12"\nOutput: 2\nExplanation:\xc2\xa0It could be decoded as "AB" (1 2) or "L" (12).\n\nExample 2:\nInput: "226"\nOutput: 3\nExplanation:\xc2\xa0It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
__label__1 You are given an integer array A.\xc2\xa0 From\xc2\xa0some starting index, you can make a series of jumps.\xc2\xa0 The (1st, 3rd, 5th, ...)\xc2\xa0jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.\nYou may from index i\xc2\xa0jump forward to index j\xc2\xa0(with i\xc2\xa0< j) in the following way:\n\nDuring odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j\xc2\xa0such that A[i] <= A[j] and A[j] is the smallest possible value.\xc2\xa0 If there are multiple such indexes j, you can only jump to the smallest such index j.\nDuring even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j\xc2\xa0such that A[i] >= A[j] and A[j] is the largest\xc2\xa0possible value.\xc2\xa0 If there are multiple such indexes j, you can only jump to the smallest such index j.\n(It may be the case that for some index i, there are no legal jumps.)\n\nA starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)\nReturn the number of good starting indexes.\n\xc2\xa0\nExample 1:\nInput: [10,13,12,14,15]\nOutput: 2\nExplanation: \nFrom starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more.\nFrom starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more.\nFrom starting index i = 3, we can jump to i = 4, so we've reached the end.\nFrom starting index i = 4, we've reached the end already.\nIn total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 2:\nInput: [2,3,1,1,4]\nOutput: 3\nExplanation: \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n\nDuring our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].\n\nDuring our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.\n\nDuring our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].\n\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 3:\nInput: [5,1,3,4,2]\nOutput: 3\nExplanation: \nWe can reach the end from starting indexes 1, 2, and 4.\n\n\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 20000\n0 <= A[i] < 100000
__label__1 You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\nNote:\nRotation is not allowed.\nExample:\n\nInput: [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3 \nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
__label__1 There is a strange printer with the following two special requirements:\n\n\nThe printer can only print a sequence of the same character each time.\nAt each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.\n\n\n\nGiven a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.\n\nExample 1:\nInput: "aaabbb"\nOutput: 2\nExplanation: Print "aaa" first and then print "bbb".\n\n\nExample 2:\nInput: "aba"\nOutput: 2\nExplanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character \'a\'.\n\n\nHint: Length of the given string will not exceed 100.
__label__1 Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\nExample 1:\nInput: 5\nOutput: 5\nExplanation: \nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n\n\nNote:\n1 <= n <= 109
__label__1 Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.\nWe define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.\nSince the answer may be very large, the answer should be modulo 109 + 7.\nExample 1:\nInput: n = 3, k = 0\nOutput: 1\nExplanation: \nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\n\n\xc2\xa0\nExample 2:\nInput: n = 3, k = 1\nOutput: 2\nExplanation: \nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\n\n\xc2\xa0\nNote:\n\nThe integer n is in the range [1, 1000] and k is in the range [0, 1000].
__label__1 Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nNote that you cannot sell a stock before you buy one.\nExample 1:\nInput: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n\xc2\xa0            Not 7-1 = 6, as selling price needs to be larger than buying price.\n\nExample 2:\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.
__label__1 Return the largest possible k\xc2\xa0such that there exists\xc2\xa0a_1, a_2, ..., a_k\xc2\xa0such that:\n\nEach a_i is a non-empty string;\nTheir concatenation a_1 + a_2 + ... + a_k is equal to text;\nFor all 1 <= i <= k,\xc2\xa0\xc2\xa0a_i = a_{k+1 - i}.\n\n\xc2\xa0\nExample 1:\nInput: text = "ghiabcdefhelloadamhelloabcdefghi"\nOutput: 7\nExplanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".\n\nExample 2:\nInput: text = "merchant"\nOutput: 1\nExplanation: We can split the string on "(merchant)".\n\nExample 3:\nInput: text = "antaprezatepzapreanta"\nOutput: 11\nExplanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".\n\nExample 4:\nInput: text = "aaa"\nOutput: 3\nExplanation: We can split the string on "(a)(a)(a)".\n\n\xc2\xa0\nConstraints:\n\ntext consists only of lowercase English characters.\n1 <= text.length <= 1000
__label__1 Given an unsorted array of integers, find the length of longest increasing subsequence.\nExample:\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4 \nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \nNote: \n\nThere may be more than one LIS combination, it is only necessary for you to return the length.\nYour algorithm should run in O(n2) complexity.\n\nFollow up: Could you improve it to O(n log n) time complexity?
__label__1 Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.\nExample:\nInput: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2 \nExplanation:\xc2\xa0Because the sum of rectangle [[0, 1], [-2, 3]] is 2,\n\xc2\xa0            and 2 is the max number no larger than k (k = 2).\nNote:\n\nThe rectangle inside the matrix must have an area > 0.\nWhat if the number of rows is much larger than the number of columns?
__label__1 We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].\nWe want to place these books in order\xc2\xa0onto bookcase shelves that have total width shelf_width.\nWe choose\xc2\xa0some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.\xc2\xa0 We repeat this process until there are no more books to place.\nNote again that at each step of the above\xc2\xa0process, the order of the books we place is the same order as the given sequence of books.\xc2\xa0 For example, if we have an ordered list of 5\xc2\xa0books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\nReturn the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n\xc2\xa0\nExample 1:\n\nInput: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4\nOutput: 6\nExplanation:\nThe sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n\xc2\xa0\nConstraints:\n\n1 <= books.length <= 1000\n1 <= books[i][0] <= shelf_width <= 1000\n1 <= books[i][1] <= 1000
__label__1 We have an array A of non-negative integers.\nFor every (contiguous) subarray B =\xc2\xa0[A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].\nReturn the number of possible\xc2\xa0results.\xc2\xa0 (Results that occur more than once are only counted once in the final answer.)\n\xc2\xa0\n\nExample 1:\nInput: [0]\nOutput: 1\nExplanation: \nThere is only one possible result: 0.\n\n\nExample 2:\nInput: [1,1,2]\nOutput: 3\nExplanation: \nThe possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values, so the answer is 3.\n\n\nExample 3:\nInput: [1,2,4]\nOutput: 6\nExplanation: \nThe possible results are 1, 2, 3, 4, 6, and 7.\n\n\n\n\n\xc2\xa0\nNote:\n\n1 <= A.length <= 50000\n0 <= A[i] <= 10^9
__label__1 Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\nNote:\xc2\xa0You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\xc2\xa0            Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\xc2\xa0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\xc2\xa0            engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.
__label__1 Given a matrix, and a target, return the number of non-empty submatrices that sum to target.\nA submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.\nTwo submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate\xc2\xa0that is different: for example, if x1 != x1'.\n\xc2\xa0\nExample 1:\nInput: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\nOutput: 4\nExplanation: The four 1x1 submatrices that only contain 0.\n\n\nExample 2:\nInput: matrix = [[1,-1],[-1,1]], target = 0\nOutput: 5\nExplanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n\n\n\xc2\xa0\nNote:\n\n1 <= matrix.length <= 300\n1 <= matrix[0].length <= 300\n-1000 <= matrix[i] <= 1000\n-10^8 <= target <= 10^8
__label__1 Your car starts at position 0 and speed +1 on an infinite number line.\xc2\xa0 (Your car can go into negative positions.)\nYour car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).\nWhen you get an instruction "A", your car does the following:\xc2\xa0position += speed, speed *= 2.\nWhen you get an instruction "R", your car does the following: if your speed is positive then\xc2\xa0speed = -1\xc2\xa0, otherwise\xc2\xa0speed = 1.\xc2\xa0 (Your position stays the same.)\nFor example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.\nNow for some target position, say the length of the shortest sequence of instructions to get there.\nExample 1:\nInput: \ntarget = 3\nOutput: 2\nExplanation: \nThe shortest instruction sequence is "AA".\nYour position goes from 0->1->3.\n\nExample 2:\nInput: \ntarget = 6\nOutput: 5\nExplanation: \nThe shortest instruction sequence is "AAARA".\nYour position goes from 0->1->3->7->7->6.\n\n\xc2\xa0\nNote: \n\n1 <= target <= 10000.
__label__1 Given several boxes with different colors represented by different positive numbers. \nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points.\nFind the maximum points you can get.\n\nExample 1:\nInput: \n[1, 3, 2, 2, 2, 3, 4, 3, 1]\n\nOutput:\n23\n\nExplanation: \n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----> [1, 3, 3, 3, 1] (1*1=1 points) \n----> [1, 1] (3*3=9 points) \n----> [] (2*2=4 points)\n\n\nNote:\nThe number of boxes n would not exceed 100.
__label__1 Given a string s and a string t, check if s is subsequence of t.\n\n\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).\n\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).\n\nExample 1:\ns = "abc", t = "ahbgdc"\n\n\nReturn true.\n\nExample 2:\ns = "axc", t = "ahbgdc"\n\n\nReturn false.\n\nFollow up:\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.
__label__1 An undirected, connected graph of N nodes (labeled\xc2\xa00, 1, 2, ..., N-1) is given as graph.\ngraph.length = N, and j != i\xc2\xa0is in the list\xc2\xa0graph[i]\xc2\xa0exactly once, if and only if nodes i and j are connected.\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\xc2\xa0\n\n\nExample 1:\nInput: [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]\nExample 2:\nInput: [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]\n\n\xc2\xa0\nNote:\n\n1 <= graph.length <= 12\n0 <= graph[i].length <\xc2\xa0graph.length
__label__1 We partition a row of numbers A\xc2\xa0into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?\nNote that our partition must use every number in A, and that scores are not necessarily integers.\nExample:\nInput: \nA = [9,1,2,3,9]\nK = 3\nOutput: 20\nExplanation: \nThe best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned A into [9, 1], [2], [3, 9], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n\xc2\xa0\nNote: \n\n1 <= A.length <= 100.\n1 <= A[i] <= 10000.\n1 <= K <= A.length.\nAnswers within 10^-6 of the correct answer will be accepted as correct.
__label__1 You are given K eggs, and you have access to a building with N floors from 1 to N.\xc2\xa0\nEach egg is identical in function, and if an egg breaks, you cannot drop it\xc2\xa0again.\nYou know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with\xc2\xa01 <= X <= N).\xc2\xa0\nYour goal is to know\xc2\xa0with certainty\xc2\xa0what the value of F is.\nWhat is the minimum number of moves that you need to know with certainty\xc2\xa0what F is, regardless of the initial value of F?\n\xc2\xa0\n\n\n\nExample 1:\nInput: K = 1, N = 2\nOutput: 2\nExplanation: \nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.\n\n\nExample 2:\nInput: K = 2, N = 6\nOutput: 3\n\n\nExample 3:\nInput: K = 3, N = 14\nOutput: 4\n\n\xc2\xa0\nNote:\n\n1 <= K <= 100\n1 <= N <= 10000
__label__1 In a project, you have a list of required skills req_skills,\xc2\xa0and a list of people.\xc2\xa0 The i-th person people[i]\xc2\xa0contains a list of skills that person has.\nConsider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill.\xc2\xa0 We can represent these teams by the index of each person: for example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\nReturn any\xc2\xa0sufficient team of the smallest possible size, represented by the index of each person.\nYou may return the answer in any order.\xc2\xa0 It is guaranteed an answer exists.\n\xc2\xa0\nExample 1:\nInput: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]\nOutput: [0,2]\nExample 2:\nInput: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]\nOutput: [1,2]\n\n\xc2\xa0\nConstraints:\n\n1 <= req_skills.length <= 16\n1 <= people.length <= 60\n1 <= people[i].length, req_skills[i].length, people[i][j].length\xc2\xa0<= 16\nElements of req_skills and people[i] are (respectively) distinct.\nreq_skills[i][j], people[i][j][k] are\xc2\xa0lowercase English letters.\nEvery skill in people[i]\xc2\xa0is a skill in req_skills.\nIt is guaranteed a sufficient team exists.
__label__1 Given an unsorted array of integers, find the number of longest increasing subsequence.\n\nExample 1:\nInput: [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].\n\n\nExample 2:\nInput: [2,2,2,2,2]\nOutput: 5\nExplanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.\n\n\nNote:\nLength of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
__label__1 Given a non-negative integer n, count all numbers with unique digits, x, where 0 \xe2\x89\xa4 x < 10n.\n\nExample:\nInput: 2\nOutput: 91 \nExplanation: The answer should be the total numbers in the range of 0 \xe2\x89\xa4 x < 100, \n\xc2\xa0            excluding 11,22,33,44,55,66,77,88,99
__label__1 Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\nExample 1:\nInput: n = 12\nOutput: 3 \nExplanation: 12 = 4 + 4 + 4.\nExample 2:\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.
__label__1 Alex and Lee play a game with piles of stones.\xc2\xa0 There are an even number of\xc2\xa0piles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the most\xc2\xa0stones.\xc2\xa0 The total number of stones is odd, so there are no ties.\nAlex and Lee take turns, with Alex starting first.\xc2\xa0 Each turn, a player\xc2\xa0takes the entire pile of stones from either the beginning or the end of the row.\xc2\xa0 This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alex and Lee play optimally, return True\xc2\xa0if and only if Alex wins the game.\n\xc2\xa0\nExample 1:\nInput: [5,3,4,5]\nOutput: true\nExplanation: \nAlex starts first, and can only take the first 5 or the last 5.\nSay he takes the first 5, so that the row becomes [3, 4, 5].\nIf Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.\nIf Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alex, so we return true.\n\n\xc2\xa0\nNote:\n\n2 <= piles.length <= 500\npiles.length is even.\n1 <= piles[i] <= 500\nsum(piles) is odd.
__label__1 We are given S, a length n string of characters from the set {\'D\', \'I\'}. (These letters stand for "decreasing" and "increasing".)\nA\xc2\xa0valid permutation\xc2\xa0is a permutation P[0], P[1], ..., P[n] of integers\xc2\xa0{0, 1, ..., n}, such that for all i:\n\nIf S[i] == \'D\', then P[i] > P[i+1], and;\nIf S[i] == \'I\', then P[i] < P[i+1].\n\nHow many valid permutations are there?\xc2\xa0 Since the answer may be large, return your answer modulo 10^9 + 7.\n\xc2\xa0\nExample 1:\nInput: "DID"\nOutput: 5\nExplanation: \nThe 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\n\xc2\xa0\nNote:\n\n1 <= S.length <= 200\nS consists only of characters from the set {\'D\', \'I\'}.
__label__1 Alice plays the following game, loosely based on the card game "21".\nAlice starts with 0 points, and draws numbers while she has less than K points.\xc2\xa0 During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.\xc2\xa0 Each draw is independent and the outcomes have equal probabilities.\nAlice stops drawing numbers when she gets K or more points.\xc2\xa0 What is the probability\xc2\xa0that she has N or less points?\nExample 1:\nInput: N = 10, K = 1, W = 10\nOutput: 1.00000\nExplanation:  Alice gets a single card, then stops.\n\nExample 2:\nInput: N = 6, K = 1, W = 10\nOutput: 0.60000\nExplanation:  Alice gets a single card, then stops.\nIn 6 out of W = 10 possibilities, she is at or below N = 6 points.\n\nExample 3:\nInput: N = 21, K = 17, W = 10\nOutput: 0.73278\nNote:\n\n0 <= K <= N <= 10000\n1 <= W <= 10000\nAnswers will be accepted as correct if they are within 10^-5 of the correct answer.\nThe judging time limit has been reduced for this question.
__label__1 There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:\n\nServe\xc2\xa0100 ml of soup A and 0 ml of soup B\nServe\xc2\xa075 ml of soup A and 25\xc2\xa0ml of soup B\nServe 50 ml of soup A and 50 ml of soup B\nServe 25\xc2\xa0ml of soup A and 75\xc2\xa0ml of soup B\n\nWhen we serve some soup, we give it to someone and we no longer have it.\xc2\xa0 Each turn,\xc2\xa0we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve\xc2\xa0as much as we can.\xc2\xa0 We stop once we no longer have some quantity of both types of soup.\nNote that we do not have the operation where all 100 ml's of soup B are used first.\xc2\xa0\xc2\xa0\nReturn the probability that soup A will be empty\xc2\xa0first, plus half the probability that A and B become empty at the same time.\n\xc2\xa0\nExample:\nInput: N = 50\nOutput: 0.625\nExplanation: \nIf we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n\n\nNotes: \n\n0 <= N <= 10^9.\xc2\xa0\nAnswers within\xc2\xa010^-6\xc2\xa0of the true value will be accepted as correct.
__label__1 We have a sorted set of digits D, a non-empty subset of {\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\'}.\xc2\xa0 (Note that \'0\' is not included.)\nNow, we write numbers using these digits, using each digit as many times as we want.\xc2\xa0 For example, if D = {\'1\',\'3\',\'5\'}, we may write numbers such as \'13\', \'551\', \'1351315\'.\nReturn the number of positive integers that can be written (using the digits of D) that are less than or equal to N.\n\xc2\xa0\nExample 1:\nInput: D = ["1","3","5","7"], N = 100\nOutput: 20\nExplanation: \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n\nExample 2:\nInput: D = ["1","4","9"], N = 1000000000\nOutput: 29523\nExplanation: \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits of D.\n\n\xc2\xa0\nNote:\n\nD is a\xc2\xa0subset of digits \'1\'-\'9\' in sorted order.\n1 <= N <= 10^9
__label__1 Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\nExample 1:\n\nInput: 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 \xc3\x97 1 = 1.\n\nExample 2:\nInput: 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 \xc3\x97\xc2\xa03 \xc3\x97\xc2\xa04 = 36.\nNote: You may assume that n is not less than 2 and not larger than 58.
__label__1 Given a string containing just the characters \'(\' and \')\', find the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: "(()"\nOutput: 2\nExplanation: The longest valid parentheses substring is "()"\n\nExample 2:\nInput: ")()())"\nOutput: 4\nExplanation: The longest valid parentheses substring is "()()"
__label__1 Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1]\xc2\xa0in clockwise order.\nSuppose you triangulate the polygon into N-2 triangles.\xc2\xa0 For each triangle, the value of that triangle is the product\xc2\xa0of the labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.\n\xc2\xa0\n\n\n\nExample 1:\nInput: [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.\n\n\nExample 2:\n\nInput: [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.  The minimum score is 144.\n\n\nExample 3:\nInput: [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.\n\n\xc2\xa0\nNote:\n\n3 <= A.length <= 50\n1 <= A[i] <= 100
__label__1 Given an array A of integers, return the length of the longest arithmetic subsequence in A.\nRecall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B\xc2\xa0is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).\n\xc2\xa0\nExample 1:\nInput: [3,6,9,12]\nOutput: 4\nExplanation: \nThe whole array is an arithmetic sequence with steps of length = 3.\n\n\nExample 2:\nInput: [9,4,7,2,10]\nOutput: 3\nExplanation: \nThe longest arithmetic subsequence is [4,7,10].\n\n\nExample 3:\nInput: [20,1,15,3,10,5,8]\nOutput: 4\nExplanation: \nThe longest arithmetic subsequence is [20,15,10,5].\n\n\n\xc2\xa0\nNote:\n\n2 <= A.length <= 2000\n0 <= A[i] <= 10000
__label__1 A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\n\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\nNote:\n\nThe number of stones is \xe2\x89\xa5 2 and is < 1,100.\nEach stone's position will be a non-negative integer < 231.\nThe first stone's position is always 0.\n\n\nExample 1:\n[0,1,3,5,6,8,12,17]\n\nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at the 17th unit.\n\nReturn true. The frog can jump to the last stone by jumping \n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n2 units to the 4th stone, then 3 units to the 6th stone, \n4 units to the 7th stone, and 5 units to the 8th stone.\n\n\nExample 2:\n[0,1,2,3,4,8,9,11]\n\nReturn false. There is no way to jump to the last stone as \nthe gap between the 5th and 6th stone is too large.
__label__1 Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nExample:\nInput:\xc2\xa0"aab"\nOutput: 1\nExplanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
__label__1 Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
__label__1 Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:\n\nCopy All: You can copy all the characters present on the notepad (partial copy is not allowed).\nPaste: You can paste the characters which are copied last time.\n\n\xc2\xa0\nGiven a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.\nExample 1:\nInput: 3\nOutput: 3\nExplanation:\nIntitally, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\n\xc2\xa0\nNote:\n\nThe n will be in the range [1, 1000].
__label__1 Given a non negative integer number num. For every numbers i in the range 0 \xe2\x89\xa4 i \xe2\x89\xa4 num calculate the number of 1's in their binary representation and return them as an array.\nExample 1:\nInput: 2\nOutput: [0,1,1]\nExample 2:\nInput: 5\nOutput: [0,1,1,2,1,2]\n\nFollow up:\n\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\nSpace complexity should be O(n).\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
