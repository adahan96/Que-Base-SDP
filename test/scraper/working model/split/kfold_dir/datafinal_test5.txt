__label__Greedy-Algorithms Marc loves cupcakes, but he also likes to stay fit. Each cupcake has a calorie count, and Marc can walk a distance to expend those calories.  If Marc has eaten  cupcakes so far, after eating a cupcake with  calories he must walk at least   miles to maintain his weight. For example, if he eats  cupcakes with calorie counts in the following order: , the miles he will need to walk are .  This is not the minimum, though, so we need to test other orders of consumption.  In this case, our minimum miles is calculated as . Given the individual calorie counts for each of the cupcakes, determine the minimum number of miles Marc must walk to maintain his weight. Note that he can eat the cupcakes in any order.   Function Description  Complete the marcsCakewalk function in the editor below.  It should return a long integer that represents the minimum miles necessary.   marcsCakewalk has the following parameter(s):   calorie: an integer array that represents calorie count for each cupcake   Input Format The first line contains an integer , the number of cupcakes in .  The second line contains  space-separated integers . Constraints   Output Format Print a long integer denoting the minimum number of miles Marc must walk to maintain his weight.  Sample Input 0 Sample Output 0 Explanation 0 Let's say the number of miles Marc must walk to maintain his weight is . He can minimize  by eating the  cupcakes in the following order:  Eat the cupcake with  calories, so . Eat the cupcake with  calories, so . Eat the cupcake with  calories, so . We then print the final value of , which is , as our answer. Sample Input 1 Sample Output 1 Explanation 1
__label__Greedy-Algorithms We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"]. Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]). Return the minimum possible value of D.length.          Example 1: Input: ["ca","bb","ac"] Output: 1 Explanation:  After deleting the first column, A = ["a", "b", "c"]. Now A is in lexicographic order (ie. A[0] <= A[1] <= A[2]). We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.   Example 2: Input: ["xc","yb","za"] Output: 0 Explanation:  A is already in lexicographic order, so we don't need to delete anything. Note that the rows of A are not necessarily in lexicographic order: ie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation:  We have to delete every column.      Note:  1 <= A.length <= 100 1 <= A[i].length <= 100
__label__Array In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy". Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.   Example 1: Input: "abbxxxxzzy" Output: [[3,6]] Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.  Example 2: Input: "abc" Output: [] Explanation: We have "a","b" and "c" but no large group.  Example 3: Input: "abcdddeeeeaabbbcd" Output: [[3,5],[6,9],[12,14]]   Note:  1 <= S.length <= 1000
__label__Strings Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.  Example: Input: s = "abcdefg", k = 2 Output: "bacdfeg"   Restrictions:   The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000]
__label__Array According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?
__label__Search You have a long list of tasks that you need to do today. To accomplish task  you need  minutes, and the deadline for this task is . You need not complete a task at a stretch. You can complete a part of it, switch to another task, and then switch back. You've realized that it might not be possible to complete all the tasks by their deadline. So you decide to do them in such a manner that the maximum amount by which a task's completion time overshoots its deadline is minimized. Input Format The first line contains the number of tasks, . Each of the next  lines contains two integers,  and . Constraints       Output Format Output  lines. The  line contains the value of the maximum amount by which a task's completion time overshoots its deadline, when the first  tasks on your list are scheduled optimally. See the sample input for clarification. Sample Input 5 2 2 1 1 4 3 10 1 2 1  Sample Output 0   1   2   2   3  Explanation The first task alone can be completed in 2 minutes, and so you won't overshoot the deadline.  With the first two tasks, the optimal schedule can be:  time 1: task 2  time 2: task 1   time 3: task 1 We've overshot task 1 by 1 minute, hence returning 1.  With the first three tasks, the optimal schedule can be:  time 1 : task 2  time 2 : task 1  time 3 : task 3  time 4 : task 1  time 5 : task 3  time 6 : task 3 Task 1 has a deadline 2, and it finishes at time 4. So it exceeds its deadline by 2.  Task 2 has a deadline 1, and it finishes at time 1. So it exceeds its deadline by 0.  Task 3 has a deadline 4, and it finishes at time 6. So it exceeds its deadline by 2.   Thus, the maximum time by which you overshoot a deadline is 2. No schedule can do better than this. Similar calculation can be done for the case containing 5 tasks.
__label__Dynamic-Programming You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step
__label__Dynamic-Programming __label__Mathematics Lukas is a Civil Engineer who loves designing road networks to connect  cities numbered from  to . He can build any number of bidirectional roads as long as the resultant network satisfies these constraints: It must be possible to reach any city from any other city by traveling along the network of roads.   No two roads can directly connect the same two cities.    A road cannot directly connect a city to itself.   In other words, the roads and cities must form a simple connected labeled graph. You must answer  queries, where each query consists of some  denoting the number of cities Lukas wants to design a bidirectional network of roads for. For each query, find and print the number of ways he can build roads connecting  cities on a new line; as the number of ways can be quite large, print it modulo . Input Format The first line contains an integer, , denoting the number of queries.  Each of the  subsequent lines contains an integer denoting the value of  for a query. Constraints  Output Format For each of the  queries, print the number of ways Lukas can build a network of bidirectional roads connecting  cities, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 We answer the first two queries like this: When , the only option satisfying Lukas' three constraints is to not build any roads at all. Thus, we print the result of  on a new line.   When , there are four ways for Lukas to build roads that satisfy his three constraints:  Thus, we print the result of  on a new line.  When , there are four ways for Lukas to build roads that satisfy his three constraints:  Thus, we print the result of  on a new line.
__label__Strings Alice has a binary string. She thinks a binary string is beautiful if and only if it doesn't contain the substring .  In one step, Alice can change a  to a  or vice versa. Count and print the minimum number of steps needed to make Alice see the string as beautiful. For example, if Alice's string is  she can change any one element and have a beautiful string. Function Description  Complete the beautifulBinaryString function in the editor below.  It should return an integer representing the minimum moves required.   beautifulBinaryString has the following parameter(s):   b: a string of binary digits   Input Format The first line contains an integer , the length of binary string.  The second line contains a single binary string . Constraints  . Output Format Print the minimum number of steps needed to make the string beautiful. Sample Input 0 7 0101010  Sample Output 0 2    Explanation 0:  In this sample,  The figure below shows a way to get rid of each instance of :  Because we were able to make the string beautiful by changing  characters ( and ), we print . Sample Input 1 5 01100  Sample Output 1 0  Sample Case 1: In this sample   Explanation 1 The substring  does not occur in , so the string is already beautiful and we print . Sample Input 2 10 0100101010  Sample Output 2 3  Explanation 2  In this sample  One solution is to change the values of  to form a beautiful string.
__label__Dynamic-Programming We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated. XX  <- domino  XX  <- "L" tromino X  Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.) Example: Input: 3 Output: 5 Explanation:  The five different ways are listed below, different letters indicates different tiles: XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY Note:  N  will be in range [1, 1000].
__label__Mathematics __label__Binary-Search __label__Greedy-Algorithms Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1
__label__Graph-Algorithms Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from  to , and edges will have varying distances or lengths. For example, consider the following graph of 5 nodes:   Starting at node , the shortest path to  is direct and distance .  Going from  to , there are two paths:  at a distance of  or  at a distance of .  Choose the shortest path, .  From  to , choose the shortest path through  and extend it:  for a distance of   There is no route to node , so the distance is . The distances to all nodes in increasing node order, omitting the starting node, are 5 11 13 -1. 5 11 13 -1 Function Description  Complete the shortestReach function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.   shortestReach has the following parameter(s):   n: the number of nodes in the graph   edges: a 2D array of integers where each  consists of three integers that represent the start and end nodes of an edge, followed by its length   s: the start node number   Input Format The first line contains , the number of test cases.  Each test case is as follows:  - The first line contains two space-separated integers  and , the number of nodes and edges in the graph.  - Each of the next  lines contains three space-separated integers , , and , the beginning and ending nodes of an edge, and the length of the edge.  - The last line of each test case has an integer , denoting the starting position.   Constraints           If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges. Output Format For each of the  test cases, print a single line consisting  space separated integers denoting the shortest distance to the  nodes from starting position  in  increasing order of their labels, excluding .  For unreachable nodes, print . Sample Input 1 4 4 1 2 24 1 4 20 3 1 3 4 3 12 1  Sample Output 24 3 15  Explanation The graph given in the test case is shown as :   * The lines are weighted edges where weight denotes the length of the edge. The shortest paths followed for the three nodes 2, 3 and 4 are as follows : 1/S->2 - Shortest Path Value :  1/S->3 - Shortest Path Value :  1/S->3->4 - Shortest Path Value :
__label__Game-Theory Two players (numbered  and ) are playing a game of Tower Breakers! The rules of the game are as follows: Player  always moves first, and both players always move optimally. Initially there are  towers of various heights. The players move in alternating turns. In each turn, a player can choose a tower of height  and reduce its height to , where  and  evenly divides . If the current player is unable to make any move, they lose the game. Given the value of  and the respective height values for all towers, can you determine who will win? If the first player wins, print ; otherwise, print . Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of towers.  space-separated integers, , where each  describes the height of tower . Constraints    Output Format For each test case, print a single integer denoting the winner (i.e., either  or ) on a new line. Sample Input 2 2  1 2 3  1 2 3  Sample Output 1 2  Explanation Test Case 0:  Player  reduces the second tower to height  and subsequently wins. Test Case 1:  There are two possible moves: Reduce the second tower to   Reduce the third tower to .  Whichever move player  makes, player  will make the other move. Thus, player  wins.
__label__Mathematics __label__Binary-Search Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
__label__Tree __label__Depth-first-Search Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \    / \ 7    2  5   1  Return: [    [5,4,11,2],    [5,8,4,5] ]
__label__Tree Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
__label__Depth-first-Search You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:
__label__Dynamic-Programming Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100
__label__Tree __label__Depth-first-Search Two players play a turn based game on a binary tree.  We are given the root of this binary tree, and the number of nodes n in the tree.  n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x.  The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player.  In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn.  If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player.  If it is possible to choose such a y to ensure you win the game, return true.  If it is not possible, return false.   Example 1:  Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2.    Constraints:  root is the root of a binary tree with n nodes and distinct node values from 1 to n. n is odd. 1 <= x <= n <= 100
__label__Depth-first-Search In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].
__label__Tree Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True    Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False
__label__Search __label__Mathematics A pair of nodes, , is a similar pair if the following conditions are true: node  is the ancestor of node   Given a tree where each node is labeled from  to , find the number of similar pairs in the tree. For example, given the following tree:     We have the following pairs of ancestors and dependents:   If  for example, we have  pairs that are similar, where . Function Description Complete the similarPair function in the editor below.  It should return an integer that represents the number of pairs meeting the criteria. similarPair has the following parameter(s):   n: an integer that represents the number of nodes   k: an integer edges: a two dimensional array where each element consists of two integers that represent connected node numbers   Input Format The first line contains two space-separated integers  and , the number of nodes and the similarity threshold.  Each of the next  lines contains two space-separated integers defining an edge connecting nodes  and , where node  is the parent to node . Constraints       Output Format Print a single integer denoting the number of similar pairs in the tree. Sample Input 5 2 3 2 3 1 1 4 1 5  Sample Output 4  Explanation   The similar pairs are , , , and , so we print  as our answer.  Observe that  and  are not similar pairs because they do not satisfy  for .
__label__Binary-Search __label__Dynamic-Programming __label__Greedy-Algorithms Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases.
__label__Tree Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: Input:      2    / \   2   5      / \     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.    Example 2: Input:      2    / \   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.
__label__Array __label__Two-Pointers Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?
__label__Hash-Table __label__Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.   Example 1:   Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation:  Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2).   Example 2:  Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation:  The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report "[1,5,6]", the node value of 5 comes first since 5 is smaller than 6.     Note:  The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000.
__label__Two-Pointers __label__Strings Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.
__label__Dynamic-Programming __label__Depth-first-Search Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.
__label__Mathematics On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C
__label__Array __label__Binary-Search There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5
__label__Strings Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.
__label__Strings Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 0 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.
__label__Dynamic-Programming Capeta is working part-time for an animal shipping company. He needs to pick up animals from various zoos and drop them to other zoos. The company ships four kinds of animals: elephants, dogs, cats, and mice. There are  zoos, numbered  to . Also, there are  animals. For each animal , Capeta knows its type  (E for elephant, D for dog, C for cat and M for mouse), source zoo  where Capeta has to pick it up from, and destination zoo  where Capeta needs to deliver it to.  E D C M  Capeta is given a truck with a huge capacity where  animals can easily fit. He is also given additional instructions: He must visit the zoos in increasing order. He also cannot skip zoos.  He must visit the zoos in increasing order. He also cannot skip zoos.  Dogs are scared of elephants, so he is not allowed to bring them together at the same time.  Dogs are scared of elephants, so he is not allowed to bring them together at the same time.  Cats are scared of dogs, so he is not allowed to bring them together at the same time.  Mice are scared of cats, so he is not allowed to bring them together at the same time.  Elephants are scared of mice, so he is not allowed to bring them together at the same time.  Also, loading and unloading animals are complicated, so once an animal is loaded onto the truck, that animal will only be unloaded at its destination.  Because of these reasons, Capeta might not be able to transport all animals. He will need to ignore some animals. Which ones? The company decided to leave that decision for Capeta. He is asked to prepare a report and present it at a board meeting of the company. Capeta needs to report the minimum number of zoos that must be reached so that she is able to transport  animals, for each  from  to .  Complete the function minimumZooNumbers and return an integer array where the  integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport  animals, or  if it is impossible to transport  animals.  minimumZooNumbers He is good at driving, but not so much at planning. Hence, he needs your help. Input Format The first line contains a single integer , the number of test cases. Each test case consists of four lines. The first line contains two space-separated integers  and . The second line contains  space-separated characters . The third line contains  space-separated integers . The fourth line contains  space-separated integers .   ,  and  are the details for the th animal, as described in the problem statement. Constraints         is either E, D, C or M E D C M Subtasks  For  of the total score,   Output Format For each case, print a single line containing  space-separated integers, where the  integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport  animals. If it is not possible to transport  animals at all, then put  instead. Sample Input 0 Sample Output 0 Explanation 0 First Test Case Capeta can transport one animal by traveling up to zoo number . Just drop the dog there. Next, in order to transport  animals (elephant and cat), Capeta has to go up to zoo number . Second Test Case  Animal: Drop the elephant to zoo .  Animal: Drop the elephant and cat to zoo .  Animal: Drop the elephant and cat to zoo . Then drop the mouse to zoo .  Animal: Drop the elephant and cat to zoo . Then drop the mouse to zoo . Finally, drop either the elephant or the dog to . It is impossible to transport  or  animals.
__label__Strings Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.
__label__Binary-Search You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.
__label__Hash-Table Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.
__label__Tree __label__Depth-first-Search Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.
__label__Dynamic-Programming In a N x N grid representing a field of cherries, each cell is one of three possible integers.    0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.    Your task is to collect maximum number of cherries possible by following the rules below:    Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.      Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.    Note:  grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.
__label__Graph-Algorithms A clique in a graph is set of nodes such that there is an edge between any two distinct nodes in the set. Finding the largest clique in a graph is a computationally difficult problem. Currently no polynomial time algorithm  is known for solving this. However, you wonder what is the minimum size of the largest clique in any graph with  nodes and  edges.   For example, consider a graph with  nodes and  edges.  The graph below shows  nodes with  edges and no cliques.  It is evident that the addition of any  edge must create two cliques with  members each.    Input Format The first line contains an integer , the number of test cases.   Each of the next  lines contains two space-separated integers  and .   Constraints      Output Format For each test case, print the minimum size of the largest clique that must be formed given  and .    Sample Input 3   3 2   4 6   5 7  Sample Output 2   4   3  Explanation For the first case, we have two cliques with two nodes each:     For the second test case, the only valid graph having  nodes and  edges is one where each pair of nodes is connected. So the size of the largest clique cannot be smaller than .     For the third test case, it is easy to verify that any graph with  nodes and .  The  solid lines in the graph below indicate the maximum edges that can be added without forming a clique larger than .  The dashed lines could connect any two nodes not connected by solid lines producing a clique of size .     Hints  Turan's theorem gives us an upper bound on the number of edges a graph can have if we wish that it should not have a clique of size . Though the bound is not exact, it is easy to extend the statement of the theorem to get an exact bound in terms of  and . Once this is done, we can binary search for the largest  such that . See: Turan's Theorem
__label__Hash-Table A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.
__label__Mathematics __label__Dynamic-Programming Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]
__label__Dynamic-Programming __label__Graph-Algorithms There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things: The minimum number of turns (T) needed to remove all the points. The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn. Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains N on the first line, followed by N lines giving the coordinates of the points. Constraints 1 <= T <= 50  1 <= N <= 16  0 <= xi,yi <= 100  No two points will have the same coordinates. Output Format Output T lines, one for each test case, containing the least number of turns needed to remove all points and the number of ways to do so. As the answers can be large, output them modulo 1000000007. Sample Input 2   3   0 0   0 1   1 0   4   3 4   3 5   3 6   5 5  Sample Output 2 6   2 8  Explanation For the 1st input, Let the points be labelled p1,p2,p3. These are the ways to remove them (first turn's points, followed by second turn's points): a. 1) p1,p2 2) p3  b. 1) p1,p3 2) p2  c. 1) p2,p3 2) p1  d. 1) p3 2) p1,p2  e. 1) p2 2) p1,p3  f. 1) p1 2) p3,p2
__label__Dynamic-Programming Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note:  Each of the array element will not exceed 100. The array size will not exceed 200.    Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].    Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.
__label__Greedy-Algorithms In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: 	A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: 	If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire. Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights any more since his right has been banned.  And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.    Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights anymore since his right has been banned.  And the third senator comes from Dire and he can ban the first senator's right in the round 1.  And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.    Note:  The length of the given string will in the range [1, 10,000].
__label__Dynamic-Programming We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.
__label__Strings X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].
__label__Hash-Table Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.
__label__Hash-Table __label__Two-Pointers __label__Strings You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodgoodgoodbestword",   words = ["word","good","best","word"] Output: []
__label__Strings __label__Dynamic-Programming Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" Output: true  Example 2: Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc" Output: false
__label__Bit Bob has received a binary string of length N transmitted by Alice. He knows that due to errors in transmission, up to K bits might have been corrupted (and hence flipped). However, he also knows that the string Alice had intended to transmit was not periodic. A string is not periodic if it cannot be represented as a smaller string concatenated some number of times. For example, "0001", "0110" are not periodic while "00000", "010101" are periodic strings. Now he wonders how many possible strings could Alice have transmitted. Input Format The first line contains the number of test cases T. T test cases follow. Each case contains two integers N and K on the first line, and a binary string of length N on the next line. Constraints       Output Format Output T lines, one for each test case. Since the answers can be really big, output the numbers modulo 1000000007. Sample Input 0 Sample Output 0 Explanation 0 Explanation: For the second example, Alice could have transmitted "001", or "011" or "101".  For the third example, Alice could have transmitted 001, 010, 100, 011, 101, 110
__label__Strings Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.
__label__Mathematics Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9
__label__Array Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Hash-Table __label__Two-Pointers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A.   Example 1: Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].  Example 2: Input: A = [1,2,1,3,4], K = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].    Note:  1 <= A.length <= 20000 1 <= A[i] <= A.length 1 <= K <= A.length
__label__Two-Pointers Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.    Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.     Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.     Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.      Follow up: Can you solve it using O(1) (i.e. constant) memory?
__label__Strings A weighted string is a string of lowercase English letters where each letter has a weight.  Character weights are  to  from  to  as shown below:  We define the following terms:   The weight of a string is the sum of the weights of all the string's characters.  For example:   The weight of a string is the sum of the weights of all the string's characters.  For example:   A uniform string consists of a single character repeated zero or more times. For example, ccc and a are uniform strings, but bcb and cd are not. ccc a bcb cd Given a string, , let  be the set of weights for all possible uniform contiguous  substrings of string . You have to answer  queries, where each query  consists of a single integer, . For each query, print Yes on a new line if ; otherwise, print No instead. Yes No Note: The  symbol denotes that  is an element of set . Function Description  Complete the weightedUniformStrings function in the editor below. It should return an array of strings, either Yes or No, one for each query.   Yes No weightedUniformStrings has the following parameter(s):   s: a string   queries: an array of integers   Input Format The first line contains a string , the original string.  The second line contains an integer , the number of queries.  Each of the next  lines contains an integer , the weight of a uniform subtring of  that may or may not exist. Constraints    will only contain lowercase English letters, ascii[a-z]. Output Format Print  lines. For each query, print Yes on a new line if .  Otherwise, print No. Yes No Sample Input 0 Sample Output 0 Explanation 0 The weights of every possible uniform substring in the string abccddde are shown below: abccddde  We print Yes on the first four lines because the first four queries match weights of uniform substrings of . We print No for the last two queries because there are no uniform substrings in  that have those weights.  Yes No Note that while de is a substring of  that would have a weight of , it is not a uniform substring.  de Note that we are only dealing with contiguous substrings. So ccc is not a substring of the string ccxxc. ccc ccxxc Sample Input 1 Sample Output 1
__label__Array Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]
__label__Strings Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Burger Town is a city that consists of  special junctions and  pathways. There is exactly one shortest path between each pair of junctions. Junction  is located at  and the distance between two junctions  is defined by the Taxicab geometry.  Tim has recently afforded a taxicab to work as a taxicab driver. His vehicle was very cheap, but has a very big flaw. It can only drive  units horizontally and  units vertically before refueling.  If a customer wants to be brought from a junction  to another junction , then this car is only capable of driving the route, iff the sum of horizontal distances and the sum of vertical distances on this path are less than or equal to  and  respectively.  Also, there is a unique path between any two junctions.    Now he has thoughts about returning the vehicle back to the seller. But he first wants to know, if it's even worth it. That's why he wants to know the number of unordered pairs  such that it is not possible to drive a customer from junction  to junction .  Input Format On the first line you will be given ,  and  separated by a single space.  Each of the next  lines contains two space separated integers , denoting the location of junction . Each of the next  lines contains two space separated integers describing a path existing between , i.e., there is a path between  and .   Output Format Output the number of unordered pairs  such that it is not possible to drive from  to .  Constraints    Sample Input 3 2 1 0 0 1 1 2 0 1 2 2 3  Sample Output 1  Explanation The car is only capable of driving  units horizontally and  unit vertically. The horizontal distance between junction 1 and 3(via 2) is equal to 2(), which fits under the horizontal limit of the car. The vertical distance between 1 and 3 is also equal to 2(), but this is not possible for this car since .
__label__Array This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].
__label__Tree __label__Graph-Algorithms Given a tree with vertices numbered from  to . You need to process  queries. Each query represents a vertex number encoded in the following way: Queries are encoded in the following way: Let,  be the  query and  be the answer for the  query where  and  is always . Then vertex . We are assure that  is between  and , and hasn't been removed before.  Note:  is the bitwise XOR operator. For each query, first decode the vertex  and then perform the following: Print the size of the connected component containing .   Remove vertex  and all edges connected to .   Input Format The first line contains a single integer, , denoting the number of vertices in the tree.  Each line  of the  subsequent lines (where ) contains  space-separated integers describing the respective nodes,  and , connected by edge .  The next line contains a single integer, , denoting the number of queries.  Each line  of the  subsequent lines contains a single integer, vertex number .   Constraints   Output Format For each query, print the size of the corresponding connected component on a new line. Sample Input 0 3 1 2 1 3 3 1 1 2  Sample Output 0 3 1 1  Sample Input 1 4 1 2 1 3 1 4 4 3 6 2 6  Sample Output 1 4 3 2 1  Explanation Sample Case 0:  We have,  = 0 and connected component :    has vertex =  =  = . The size of connected component containing  is .  So,  = . Removing vertex  and all of it's edges, we get two disconnected components :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, we are left with only one component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removed vertex . Sample Case 1:  We have,  =  and connected component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, we get component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, now, we get two disconnected components :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, now we are left with only one component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removed vertex .
__label__Game-Theory Alice and Bob are playing a game with a rooted tree. The tree has  vertices and the first node, , is always the root. Here are the basic rules: They move in alternating turns, and both players always move optimally. During each move, a player removes an edge from the tree, disconnecting one of its leaves or branches. The leaf or branch that was disconnected from the rooted tree is removed from the game.  The first player to be unable to make a move loses the game. Alice always makes the first move.  For example, the diagram below shows a tree of size , where the root is node :  Now, if a player removes the edge between  and , then nodes  and  become disconnected from the root and are removed from the game:  Given the structure of the tree, determine and print the winner of the game. If Alice wins, print ; otherwise print . Input Format The first line contains a single integer, , denoting the number of test cases.  For each test case, the first line contains an integer, , denoting the number of nodes in the tree.  Each of the  subsequent lines contains  space-separated integers,  and , defining an edge connecting nodes  and . Constraints    Output Format For each test case, print the name of the winner (i.e.,  or ) on a new line. Sample Input 1 5 1 2 3 1 3 4 4 5  Sample Output Alice  Explanation Test Case 0: Alice removes the edge connecting node  to node , effectively trimming nodes  and  from the tree. Now the only remaining edges are  and . Because Bob can't remove both of them, Alice will make the last possible move. Because the last player to move wins, we print  on a new line.
__label__Array __label__Two-Pointers Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.  Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.   Example 2: Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).   Example 3: Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).   Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].
__label__Mathematics __label__Greedy-Algorithms Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000
__label__Dynamic-Programming __label__Mathematics Tara has an array, , consisting of  integers where each integer occurs at most  times in the array.  Let's define  to be a permutation of  where  is the  element of permutation . Tara thinks a permutation is beautiful if there is no index  such that  where . You are given  queries where each query consists of some array . For each , help Tara count the number of possible beautiful permutations of the  integers in  and print the count, modulo , on a new line. Note: Two permutations,  and , are considered to be different if and only if there exists an index  such that  and . Input Format The first line contains a single integer, , denoting the number of queries. The  subsequent lines describe each query in the following form: The first line contains an integer, , denoting the number of elements in array .  The second line contains  space-separated integers describing the respective values of  in array . Constraints  Each integer in  can occur at most  times. For  of the maximum score:     The sum of  over all queries does not exceed .   For  of the maximum score:      Output Format For each query, print the the number of possible beautiful permutations, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: Array  and there is only one good permutation:    Thus, we print the result of  on a new line. Array  and there is only one good permutation:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    For demonstration purposes, the following two permutations are invalid (i.e., not good):    Because we only want the number of good permutations, we print the result of  on a new line. Array  and there are two good permutations:    For demonstration purposes, the following two permutations are invalid (i.e., not good):    Because we only want the number of good permutations, we print the result of  on a new line.
__label__Mathematics On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50
__label__Array Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3] Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]
__label__Two-Pointers Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?
__label__Array Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Mathematics Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:  All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.
__label__Data-Structures In this challenge, you must implement a simple text editor. Initially, your editor contains an empty string, . You must perform  operations of the following  types: append  - Append string  to the end of . delete   - Delete the last  characters of . print     - Print the  character of . undo     - Undo the last (not previously undone) operation of type  or , reverting  to the state it was in prior to that operation.  Input Format The first line contains an integer, , denoting the number of operations.  Each line  of the  subsequent lines (where ) defines an operation to be performed. Each operation starts with a single integer,  (where ), denoting a type of operation as defined in the Problem Statement above. If the operation requires an argument,  is followed by its space-separated argument. For example, if  and , line  will be 1 abcd.  1 abcd Constraints     The sum of the lengths of all  in the input .   The sum of  over all delete operations .   All input characters are lowercase English letters.   It is guaranteed that the sequence of operations given as input is possible to perform. Output Format Each operation of type  must print the  character on a new line. Sample Input 8 1 abc 3 3 2 3 1 xy 3 2 4  4  3 1  Sample Output c y a  Explanation Initially,  is empty. The following sequence of  operations are described below: . We append  to , so .  Print the  character on a new line. Currently, the  character is c. c Delete the last  characters in  (), so .  Append  to , so .  Print the  character on a new line. Currently, the  character is y. y Undo the last update to , making  empty again (i.e., ). Undo the next to last update to  (the deletion of the last  characters), making . Print the  character on a new line. Currently, the  character is a. a
__label__Search An English text needs to be encrypted using the following encryption scheme.  First, the spaces are removed from the text. Let  be the length of this text.  Then, characters are written into a grid, whose rows and columns have the following constraints:   For example, the sentence , after removing spaces is  characters long.   is between  and , so it is written in the form of a grid with 7 rows and 8 columns.  ifmanwas   meanttos           tayonthe   groundgo   dwouldha   vegivenu   sroots  Ensure that   If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e. .   The encoded message is obtained by displaying the characters in a column, inserting a space, and then displaying the next column and inserting a space, and so on. For example, the encoded message for the above rectangle is:   imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau  imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau You will be given a message to encode and print. Function Description  Complete the encryption function in the editor below.  It should return a single string composed as described.   encryption has the following parameter(s):   s: a string to encrypt   Input Format One line of text, the string  Constraints    is comprised only of characters in the range ascii[a-z]. Output Format Print the encoded message on one line as described. Sample Input haveaniceday  Sample Output 0 hae and via ecy  Explanation 0  ,  is between  and .  Rewritten with  rows and  columns: have anic eday  Sample Input 1 feedthedog      Sample Output 1 fto ehg ee dd  Explanation 1  ,  is between  and .  Rewritten with  rows and  columns:   feed thed og  Sample Input 2 chillout  Sample Output 2 clu hlt io  Explanation 2  ,  is between  and .  Rewritten with  columns and  rows ( so we have to use .) chi llo ut
__label__Strings __label__Greedy-Algorithms Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].
__label__Strings __label__Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
__label__Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:  You may serialize the following tree:      1    / \   2   3      / \     4   5  as "[1,2,3,null,null,4,5]"  Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__Strings Consider the following game for two players: There are two strings A and B. Initially, some strings A' and B' are written on the sheet of paper. A' is always a substring of A and B' is always a substring of B. A move consists of appending a letter to exactly one of these strings: either to A' or to B'. After the move the constraint of A' being a substring of A and B' is a substring of B should still be satisfied. Players take their moves alternately. We call a pair (A', B') a position. Two players are playing this game optimally. That means that if a player has a move that leads to his/her victory, he/she will definitely use this move. If a player is unable to make a move, he loses.  Alice and Bob are playing this game. Alice makes the first move. As always, she wants to win and this time she does a clever trick. She wants the starting position to be the Kth lexicographically winning position for the first player (i.e. her). Consider two positions (A'1, B'1) and (A'2, B'2). We consider the first position lexicographically smaller than the second if A1 is lexicographically smaller than A2, or if A1 is equal to A2 and B1 is lexicographically smaller than B2. Please help her to find such a position, knowing the strings A, B and the integer K. Note: An empty string has higher precedence than character "a" "a" Input Format The first line of input consists of three integers, separated by a single space: N, M and K denoting the length of A, the length of B and K respectively. The second line consists of N small latin letters, corresponding to the string A. The third line consists of M small latin letters, corresponding to the string B. Constraints 1 <= N, M <= 3 * 105  1 <= K <= 1018 Output Format Output A' on the first line of input and B' on the second line of input. Please, pay attention that some of these strings can be empty. If there's no such pair, output "no solution" without quotes. Sample Input 0 Sample Output 0 Explanation 0 The given strings are  and . So there are  =  ways to fill a starting position (each character has two options, either to be present or not present).     ["", ""] : If this is the start position, Alice will append  to . So, the next two moves will consist of appending  and  to  and  respectively. So, Bob will suffer lack of moves and hence Alice wins.     ["", "c"] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.     ["a", ""] : If Alice appends  to  then Bob will append  to  and if Alice appends  to  then Bob will append  to . So Alices looses.    ["a", "c"] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.    ["ab", ""] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.     ["ab", "c"] : If this is the start position, Alice will suffer lack of moves and hence he looses.     ["b", ""] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.    ["b", "c"] : If this is the start position, Alice will suffer lack of moves and hence he looses.   So, the list of start positions in lexicographical order where Alice wins are: ["", ""], ["", "c"], ["a", "c"], ["ab", ""], ["b", ""]. The  one in this list is ["a", "c"].
__label__Dynamic-Programming Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A common subsequence of two strings is a subsequence that is common to both strings.   If there is no common subsequence, return 0.   Example 1: Input: text1 = "abcde", text2 = "ace"  Output: 3   Explanation: The longest common subsequence is "ace" and its length is 3.  Example 2: Input: text1 = "abc", text2 = "abc" Output: 3 Explanation: The longest common subsequence is "abc" and its length is 3.  Example 3: Input: text1 = "abc", text2 = "def" Output: 0 Explanation: There is no such common subsequence, so the result is 0.    Constraints:  1 <= text1.length <= 1000 1 <= text2.length <= 1000 The input strings consist of lowercase English characters only.
__label__Dynamic-Programming Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may return any of them. (A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)   Example 1: Input: str1 = "abac", str2 = "cab" Output: "cabac" Explanation:  str1 = "abac" is a subsequence of "cabac" because we can delete the first "c". str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac". The answer provided is the shortest such string that satisfies these properties.    Note:  1 <= str1.length, str2.length <= 1000 str1 and str2 consist of lowercase English letters.
__label__Strings A numeric string, , is beautiful if it can be split into a sequence of two or more positive integers, , satisfying the following conditions:  for any  (i.e., each element in the sequence is  more than the previous element). No  contains a leading zero. For example, we can split  into the sequence , but it is not beautiful because  and  have leading zeroes. The contents of the sequence cannot be rearranged. For example, we can split  into the sequence , but it is not beautiful because it breaks our first constraint (i.e., ). The diagram below depicts some beautiful strings:  You must perform  queries where each query consists of some integer string . For each query, print whether or not the string is beautiful on a new line. If it's beautiful, print YES x, where  is the first number of the increasing sequence.  If there are multiple such values of , choose the smallest.  Otherwise, print NO.   YES x NO Function Description  Complete the separateNumbers function in the editor below.  It should print a string as described above.   separateNumbers has the following parameter:   s: an integer value represented as a string   Input Format The first line contains an integer , the number of strings to evaluate.  Each of the next  lines contains an integer string  to query. Constraints    Output Format For each query, print its answer on a new line (i.e., either YES x where  is the smallest first number of the increasing sequence, or NO). YES x NO Sample Input 0 Sample Output 0 Explanation 0 The first three numbers are beautiful (see the diagram above). The remaining numbers are not beautiful: For , all possible splits violate the first and/or second conditions. For , it starts with a zero so all possible splits violate the second condition. For , the only possible split is , which violates the first condition. For , there are no possible splits because  only has one digit. Sample Input 1 Sample Output 1
__label__Hash-Table __label__Two-Pointers __label__Strings You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c.   Example 1: Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500 -105 <= value of elements <= 105.
__label__Tree A full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order.   Example 1: Input: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation:     Note:  1 <= N <= 20
__label__Dynamic-Programming There are  gold mines along a river, and each mine  produces  tons of gold. In order to collect the mined gold, we want to redistribute and consolidate it amongst exactly  mines where it can be picked up by trucks. We do this according to the following rules: You can move gold between any pair of mines (i.e.,  and , where ). All the gold at some pickup mine  must either stay at mine  or be completely moved to some other mine, . Move  tons of gold between the mine at location  and the mine at location  at a cost of . Given , , and the amount of gold produced at each mine, find and print the minimum cost of consolidating the gold into  pickup locations according to the above conditions. Input Format The first line contains two space-separated integers describing the respective values of  (the number of mines) and  (the number of pickup locations).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  (the mine's distance from the mouth of the river) and  (the amount of gold produced in tons) for mine .  Note: It is guaranteed that the mines are will be given in order of ascending location. Constraints   Output Format Print a single line with the minimum cost of consolidating the mined gold amongst  different pickup sites according to the rules stated above. Sample Input 0 3 1 20 1 30 1 40 1  Sample Output 0 20  Explanation 0  We need to consolidate the gold from  mines into a single pickup location (because ). The mines are all equidistant and they all produce the same amount of gold, so we just move the gold from the mines at locations  and  to the mine at  for a minimal cost of . Sample Input 1 3 1 11 3 12 2 13 1  Sample Input 1 4  Explanation 1  We need to consolidate the gold from  mines into a single pickup location (because ). We can achieve a minimum cost of  by moving the gold from mines  and  to the mine at . Sample Input 2 6 2 10 15 12 17 16 18 18 13 30 10 32 1  Sample Output 2 182  Explanation 2  We need to consolidate the gold from  mines into  pickup locations. We can minimize the cost of doing this by doing the following: Move the gold from the mines at locations , , and  to the mine at .    Move the gold from the mine at location  to the mine at .
__label__Greedy-Algorithms Goodland is a country with a number of evenly spaced cities along a line.  The distance between adjacent cities is  unit.  There is an energy infrastructure project planning meeting, and the government needs to know the fewest number of power plants needed to provide electricity to the entire list of cities.  Determine that number.  If it cannot be done, return . You are given a list of city data.  Cities that may contain a power plant have been labeled .  Others not suitable for building a plant are labeled .  Given a distribution range of , find the lowest number of plants that must be built such that all cities are served.  The distribution range limits supply to cities where distance is less than k. For example, you are given  and your city data is .  Each city is  unit distance from its neighbors, and we'll use  based indexing.  We see there are  cities suitable for power plants, cities  and .  If we build a power plant at , it can serve  through  because those endpoints are at a distance of  and .  To serve , we would need to be able to build a plant in city  or .  Since none of those is suitable, we must return .  It cannot be done using the current distribution constraint. Function Description  Complete the pylons function in the editor below.  It should return an integer that represents the minimum number of plants required or -1 if it is not possible.   pylons has the following parameter(s):   k: an integer that represents distribution range   arr: an array of integers that represent suitability as a building site   Input Format The first line contains two space-separated integers  and , the number of cities in Goodland and the plants' range constant.  The second line contains  space-separated binary integers where each integer indicates suitability for building a plant.   Constraints  Each . Subtask  for  of the maximum score. Output Format Print a single integer denoting the minimum number of plants that must be built so that all of Goodland's cities have electricity.  If this is not possible for the given value of , print . Sample Input 6 2 0 1 1 1 1 0  Sample Output 2  Explanation Cities , , , and  are suitable for power plants.  Each plant will have a range of . If we build in cities  cities,  and , then all cities will have electricity.
__label__Array __label__Dynamic-Programming Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
__label__Mathematics Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)
__label__Strings Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].
__label__Game-Theory Kitty and Katty have  plastic blocks. They label the blocks with sequential numbers from  to  and begin playing a game in turns, with Kitty always taking the first turn. The game's rules are as follows: For each turn, the player removes  blocks,  and , from the set. They calculate , write the result on a new block, and insert the new block into the set.  The game ends when only  block is left. The winner is determined by the value written on the final block, : If , then Kitty wins. If , then Katty wins. If , then the player who moved last wins. If , then Kitty wins. If , then Katty wins. If , then the player who moved last wins. Recall that  is the Modulo Operation. Given the value of , can you find and print the name of the winner? Assume that both play optimally. Note: The selection order for  and  matters, as sometimes . The diagram below shows an initial set of blocks where . If  and , then the newly inserted block is labeled ; alternatively, if  and , the newly inserted block is labeled .  Input Format The first line contains a single positive integer,  (the number of test cases or games).  The  subsequent lines each contain an integer,  (the number of blocks for that test case). Constraints    Output Format For each test case, print the name of the winner (i.e.: either Kitty or Katty) on a new line. Sample Input 2 2 3  Sample Output Kitty Katty  Explanation Test Case 0:   so there are two blocks labeled  and . Kitty chooses  and , then inserts a new block with  the label  (the result of ). The game ends, as there is now only  block in the set. The label on the last block, , is , so we calculate . Because  , Kitty wins and we print Kitty on a new line. Kitty Test Case 1:  , so there are three blocks labeled , , and . No matter how Kitty makes the first move, Katty will win. If Kitty chooses  and  on the first move and inserts a block labeled  (the result of ), the set of blocks becomes . Katty then must choose  and  and insert a new block labeled  (the result of ). The game ends, as there is now only  block in the set. The label on the last block, , is , so we calculate . Because  and Katty made the last move, Katty wins and we print Katty on a new line. Katty
__label__Dynamic-Programming A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.  If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction. Note:  The number of stones is ≥ 2 and is < 1,100. Each stone's position will be a non-negative integer < 231. The first stone's position is always 0.   Example 1: [0,1,3,5,6,8,12,17]  There are a total of 8 stones. The first stone at the 0th unit, second stone at the 1st unit, third stone at the 3rd unit, and so on... The last stone at the 17th unit.  Return true. The frog can jump to the last stone by jumping  1 unit to the 2nd stone, then 2 units to the 3rd stone, then  2 units to the 4th stone, then 3 units to the 6th stone,  4 units to the 7th stone, and 5 units to the 8th stone.   Example 2: [0,1,2,3,4,8,9,11]  Return false. There is no way to jump to the last stone as  the gap between the 5th and 6th stone is too large.
__label__Dynamic-Programming Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
__label__Game-Theory Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects.  Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows:  Initially there are  piles of stones; pile  has  stone, pile  has  stones, and so on. Thus, the  pile has  stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy at least half of the stones in it. The winner is the saint who destroys the last available stone .  For example, from a pile of  stones, a saint must destroy at least  stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills. Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?   Input Format First line of the input consists of an integer ,  testcases follow, each in a new line. Each line will contain a single integer , which describes the number of initial piles as explained above. Constraints    Output Format For each line in the input, output the minimum number of stones Ryuho needs to destroy in his first turn, assuming he starts playing and that both he and Koga play always as well as possible. If this is not possible, just print . Sample Input 0 Sample Output 0 Explanation 0 For the first testcase, we can see that the saint can destroy the first stone and win the game.  Sample Input 1 Sample Output 1 Explanation 1 There are three piles with stones  and . Initially Ryuho will remove  stone from the first pile. Now other saint has  options -  First, to remove all stones from second pile. In that case Ryuho will remove all stones from third pile and win the game. Second, to remove all stones from third pile. In that case Ryuho will remove all stones from second pile and win the game. Third, to remove  stone from second pile. In that case Ryuho will remove  stones from third pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. Fourth, to remove  stones from the third pile. In that case Ryuho will remove  stone from second pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. So in all four cases Ryuho will win the game.
__label__Depth-first-Search Given a 2-dimensional grid of integers, each value in the grid represents the color of the grid square at that location. Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions. The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column). Given a square at location (r0, c0) in the grid and a color, color the border of the connected component of that square with the given color, and return the final grid.   Example 1: Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3 Output: [[3, 3], [3, 2]]   Example 2: Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3 Output: [[1, 3, 3], [2, 3, 3]]   Example 3: Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2 Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]     Note:  1 <= grid.length <= 50 1 <= grid[0].length <= 50 1 <= grid[i][j] <= 1000 0 <= r0 < grid.length 0 <= c0 < grid[0].length 1 <= color <= 1000
__label__Dynamic-Programming A war has broken down between Vim and Emacs. Gedit, being Vim's ally, is captured by Emacs as a prisoner of war and it is up to Vim to rescue him by defeating Emacs. For this task, Vim has to assemble an army of appropriate skills. He can choose a non-empty subset of soldiers from a set of  soldiers (numbered from  to ). Each soldier has some subset of skills out of  different skills (numbered from  to ). The skill-set of an army is the union of skill-sets of its constituent soldiers. To win the war, Vim needs to know how many different subsets of soldiers satisfy his skill-set requirement. Since the answer can be huge, print it modulo .  Note : The chosen army's skill-set must exactly match the skill-set requirement of Vim (i.e no extra skills must be present in the army's skill-set than what is required). Input Format The first line contains  and , the number of soldiers to choose from and the number of different skills possible respectively.  The next  lines contain  boolean characters each. If the  character of the  line is , then the  soldier possess the  skill and if it is , then not.  The last line contains  boolean characters denoting the requirement skill-set of Vim where the  character being  signifies that Vim wants the  skill to be present in his final army and not, otherwise. Constraints     Output Format Output in a single line the required answer, as explained above.   Sample Input 4 2   00   10   01   11   11    Sample Output 10  Explanation Vim wants both the skills to be present in his selected army. Hence, he can choose the following subsets of soldiers:
__label__Mathematics Given an array of integers A and let n to be its length.   Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a "rotation function" F on A as follow:   F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1).   Note: n is guaranteed to be less than 105.  Example: A = [4, 3, 2, 6]  F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26  So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
__label__Mathematics Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9
__label__Array Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i]  A[i] > A[i+1] > ... > A[A.length - 1]      Example 1: Input: [2,1] Output: false   Example 2: Input: [3,5,5] Output: false   Example 3: Input: [0,3,2,1] Output: true     Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000
__label__Binary-Search Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.    Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.    Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
__label__Mathematics There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be. Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:  Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...    Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]    Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]    Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].    Note: n and m both fit in range [0, 1000].
__label__Array __label__Two-Pointers __label__Binary-Search Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.
__label__Strings To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. Example 1: Input: S = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"] Output: "eeebffff" Explanation: "a" starts at index 0 in S, so it's replaced by "eee". "cd" starts at index 2 in S, so it's replaced by "ffff".  Example 2: Input: S = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"] Output: "eeecd" Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".  "ec" doesn't starts at index 2 in the original S, so we do nothing.  Notes:  0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters.
__label__Hash-Table In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.    Example 1: Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.   Example 2: Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.   Example 3: Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz" Output: false Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).    Note:  1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in words[i] and order are english lowercase letters.
__label__Array __label__Hash-Table You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words.   Example 1: Input: words = ["cat","bt","hat","tree"], chars = "atach" Output: 6 Explanation:  The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.  Example 2: Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr" Output: 10 Explanation:  The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.    Note:  1 <= words.length <= 1000 1 <= words[i].length, chars.length <= 100 All strings contain lowercase English letters only.
__label__Search Sorting is useful as the first step in many different tasks. The most common task is to make finding things easier, but there are other uses as well.  In this case, it will make it easier to determine which pair or pairs of elements have the smallest absolute difference between them. For example, if you've got the list , sort it as  to see that several pairs have the minimum difference of : .  The return array would be . Given a list of unsorted integers, , find the pair of elements that have the smallest absolute difference between them. If there are multiple pairs, find them all. Function Description  Complete the closestNumbers function in the editor below.  It must return an array of integers as described. closestNumbers has the following parameter(s):   arr: an array of integers   Input Format The first line contains a single integer , the length of .  The second line contains  space-separated integers, . Constraints   All  are unique in . Output Format Output the pairs of elements with the smallest difference. If there are multiple pairs, output all of them in ascending order, all on the same line with just a single space between each pair of numbers. A number may be part of two pairs when paired with its predecessor and its successor. Sample Input 0 10 -20 -3916237 -357920 -3620601 7374819 -7330761 30 6246457 -6461594 266854   Sample Output 0 -20 30  Explanation 0  (30) - (-20) = 50, which is the smallest difference.   Sample Input 1 12 -20 -3916237 -357920 -3620601 7374819 -7330761 30 6246457 -6461594 266854 -520 -470   Sample Output 1 -520 -470 -20 30  Explanation 1  (-470) - (-520) = 30 - (-20) = 50, which is the smallest difference.  Sample Input 2 4 5 4 3 2  Sample Output 2 2 3 3 4 4 5  Explanation 2  Here, the minimum difference will be 1. Valid pairs are (2, 3), (3, 4), and (4, 5). We print the elements of each pair, space-separated on a single line.
__label__Array In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].
__label__Array Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.  Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows  a, b are from arr a < b b - a equals to the minimum absolute difference of any two elements in arr    Example 1: Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2: Input: arr = [1,3,6,10,15] Output: [[1,3]]  Example 3: Input: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]]    Constraints:  2 <= arr.length <= 10^5 -10^6 <= arr[i] <= 10^6
__label__Two-Pointers Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?
__label__Mathematics We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.
__label__Dynamic-Programming You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.
__label__Tree Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]
__label__Tree __label__Depth-first-Search Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5
__label__Graph-Algorithms In order to entertain themselves during the long flight, Alex and Fedor invented the following very simple two players game. The game is:   First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph. First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph. Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.   Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.   We consider two trees different if the sets of the numbers of edges that are included in these trees are different. We consider two sets  and  different if there is at least one element that is present in  and not present in  or vice versa.   We should also mention that the graphs with enormous number of spanning trees upset Alex, as well as Fedor, so they will never have a graph that has more than  spanning trees.   At some point, Fedor became too lazy to look for minimal spanning trees and now he just picks some arbitrary spanning tree from the Alex's graph. Each spanning tree has equal probability to be picked by Fedor. What is the probability of Fedor's victory now?    Input Format The first line of input consists of two single space separated integers  and  - the number of nodes in Alex's graph and the number of edges in that graph, respectively.   Then there are  lines, where the  line has three numbers  with the meaning that the edge with the number  connects the nodes  and  and has the weight of .   Constraints The graph is always connected.       Output Format Output the probability of Fedor's victory, if he picks the spanning tree randomly, as an irreducible fraction. Sample Input 4 4 1 2 1 2 3 4 3 4 3 4 1 2  Sample Output 1/4
__label__Array __label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.              Not 7-1 = 6, as selling price needs to be larger than buying price.  Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Hash-Table __label__Mathematics In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].
__label__Array __label__Binary-Search Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
__label__Dynamic-Programming It is the Indian version of the famous heist “The Italian Job”. N robbers have already broken into the National Museum and are just about to get inside the main vault which is full of jewels. They were lucky that just as they broke into the museum, the guard was leaving the museum for exactly G minutes. But there are other problems too. The main vault has heat sensors that if at any moment of time there are more than two people present in the vault, the alarm goes off.   To collect the jewels, the ith robber needs to be inside the vault for exactly A[i] minutes, 0 <= i < N, in one continuous stretch. As guard will return after G minutes, they have to finish their tasks within G minutes. The robbers want to know if there exists any arrangement such that demands of each robber is satisfied and also they are not caught? Gotchas  If a robber goes inside the vault at a time "X" and at the same time another robber comes out, it's equivalent to saying they were never in the vault at the same time.  Similarly, when the guard gets inside vault at time G and a robber comes out exactly at time G, the guard will not be able see the robber. Input Format The first line contains an integer T denoting the number of testcases. T testcases follow. Each testcase consists of two lines. First line contains two space separated integers denoting N and G denoting the number of thieves and duration for which guard leaves the museum.  The next line contains N space separated numbers where the ith integer, A[i]  represents the time the ith robber needs to be in the vault. Constraints 1 <= T <= 20  1 <= N <= 100  0 <= G <= 1000000 (106)  0 <= A[i] <= 100   Output Format For each testcase print YES if there exists such an arrangement or NO otherwise in a newline.   YES NO Sample Input 2 3 4 2 4 2 3 2 2 4 2  Sample Output YES NO  Explanation Test case #00: In first testcase, one possible arrangement is:  at t=0, robber1 goes inside and comes out at t=2  at t=0, robber2 goes inside and comes out at t=4  at t=2, robber3 goes inside and comes out at t=4   Test case #01: No possible arrangement is possible in second testcase.
__label__Dynamic-Programming A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.
__label__Tree Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.     Example:  BSTIterator iterator = new BSTIterator(root); iterator.next();    // return 3 iterator.next();    // return 7 iterator.hasNext(); // return true iterator.next();    // return 9 iterator.hasNext(); // return true iterator.next();    // return 15 iterator.hasNext(); // return true iterator.next();    // return 20 iterator.hasNext(); // return false    Note:  next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
__label__Dynamic-Programming Little Walter likes playing with his toy scales. He has  types of weights. The  weight type has weight . There are infinitely many weights of each type. Recently, Walter defined a function, , denoting the number of different ways to combine several weights so their total weight is equal to . Ways are considered to be different if there is a type which has a different number of weights used in these two ways. For example, if there are  types of weights with corresonding weights , , and , then there are  ways to get a total weight of : Use  weights of type . Use  weights of type . Use  weight of type  and  weight of type . Use  weight of type . Given , , , and , can you find the value of ? Input Format The first line contains a single integer, , denoting the number of types of weights.  The second line contains  space-separated integers describing the values of , respectively  The third line contains two space-separated integers denoting the respective values of  and . Constraints      Note: The time limit for C/C++ is  second, and for Java it's  seconds.  Output Format Print a single integer denoting the answer to the question. As this value can be very large, your answer must be modulo . Sample Input 3 1 2 3 1 6  Sample Output 22  Explanation
__label__Dynamic-Programming There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100
__label__Game-Theory Two players are playing a game of Tower Breakers! The rules of the game are as follows:   - Player  always moves first, and both players always play optimally.  - Initially there are  towers, where each tower is of height .  - The players move in alternating turns. In each turn, a player can choose a tower of height  and reduce its height to , where  and  evenly divides .  - If the current player is unable to make a move, they lose the game.    Given the values of  and , determine which player will win. If the first player wins, return .  Otherwise, return .   For example, there are  towers, each  high.  Player  can remove  pieces from a tower to leave  as .  Player  can also remove  pieces leaving .  Let Player  remove .  Player  matches the move.  Now Player  has only one move: remove  pieces leaving .  Player  matches again leaving Player  with no move. Function Description  Complete the towerBreakers function in the editor below.  It should return an integer that represents the winning player.   towerBreakers has the following paramter(s):   n: an integer that represents the number of towers   m: an integer that represents the height of each tower   Input Format The first line contains a single integer , the number of test cases.  Each of the next  lines describes a test case in the form of  space-separated integers,  and .   Constraints   Output Format For each test case, if the first player wins, return .  Otherwise, return . Sample Input 2 2 2 1 4  Sample Output 2 1  Explanation We'll refer to player  as  and player  as  In the first test case,  chooses one of the two towers and reduces it to . Then  reduces the remaining tower to a height of . As both towers now have height ,  cannot make a move so  is the winner. In the second test case, there is only one tower of height .  can reduce it to a height of either  or .  chooses  as both players always choose optimally. Because  has no possible move,  wins.
