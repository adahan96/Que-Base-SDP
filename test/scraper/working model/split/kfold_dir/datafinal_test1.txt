__label__Hash-Table Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions:  put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.   Example: MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);           hashMap.put(2, 2);          hashMap.get(1);            // returns 1 hashMap.get(3);            // returns -1 (not found) hashMap.put(2, 1);          // update the existing value hashMap.get(2);            // returns 1  hashMap.remove(2);          // remove the mapping for 2 hashMap.get(2);            // returns -1 (not found)    Note:  All keys and values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashMap library.
__label__Strings Oh!! Mankind is in trouble again. This time, it's a deadly disease spreading at a rate never seen before. The need of the hour is to set up efficient virus detectors. You are the lead at Central Hospital and you need to find a fast and reliable way to detect the footprints of the virus DNA in that of the patient. The DNA of the patient as well as of the virus consists of lowercase letters. Since the collected data is raw, there may be some errors. You will need to find all substrings in the patient DNA that either exactly match the virus DNA or have at most one mismatch, i.e., a difference in at most one location.  For example, "aa" and "aa" are matching, "ab" and "aa" are matching, while "abb" and "bab" are not. aa aa ab aa abb bab Function Description Complete the virusIndices function in the editor below.  It should print a list of space-separated integers that represent the starting indices of matching substrings in increasing order, or No match!. No match! virusIndices has the following parameter(s):   p: a string that represents patient DNA   v: a string that represents virus DNA   Input Format The first line contains an integer , the number of test cases.   .  Each of the next  lines contains two space-separated strings  (the patient DNA) and  (the virus DNA).   Constraints    All characters in  and . Output Format For each test case, output a single line containing a space-delimited list of starting indices (-indexed) of substrings of  which are matching with  according to the condition mentioned above. The indices have to be in increasing order. If there is no matching substring, output No Match!.   No Match! Sample Input 0 Sample Output 0 Explanation 0 For the first case, the substrings of  starting at indices  and  are "bb" and "ba" and they are matching with the string  which is "ba".  For the second case, there are no matching substrings so the output is No Match!.  For the third case, the substrings of  starting at indices  and  are "ban" and "nan" and they are matching with the string  which is "nan".   bb ba ba No Match! ban nan nan Sample Input 1 Sample Output 1 Explanation 1 For the first case, the substrings of  starting at indices  and  are "ga" and "gc" and they are matching with the string  which is "gc".  For the second case, the substrings of  starting at indices  and  are "cga" and "cga" and they are matching with the string  which is "cgg".  For the third case, the substrings of  starting at indices ,  and  are "aa", "ar" and "ar" and they are matching with the string  which is "ab".  ga gc gc cga cga cgg aa ar ar ab
__label__Dynamic-Programming Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false
__label__Data-Structures An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  (you may also see it written as ). Given an array, , of  integers, print each element in reverse order as a single line of space-separated integers. Note: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this. Input Format The first line contains an integer,  (the number of integers in ).  The second line contains  space-separated integers describing . Constraints   Output Format Print all  integers in  in reverse order as a single line of space-separated integers.
__label__Two-Pointers Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL
__label__Tree __label__Data-Structures You are given a pointer to the root of a binary tree. Print the top view of the binary tree.  Top view means when you look the tree from the top the nodes, what you will see will be called the top view of the tree. See the example below.  You only have to complete the function.  For example :    1     \      2       \        5       /  \      3    6       \        4  Top View : 1 -> 2 -> 5 -> 6 Input Format You are given a function, void topView(node * root) {  }  Constraints 1 Nodes in the tree   500 Output Format Print the values on a single line separated by space. Sample Input    1     \      2       \        5       /  \      3    6       \        4  Sample Output 1 2 5 6 Explanation    1     \      2       \        5       /  \      3    6       \        4  From the top only nodes 1,2,5,6 will be visible.
__label__Graph-Algorithms The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two "somewhat near" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as "somewhat near" each other. Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this? Input Format The first line contains the number of test cases T. T test cases follow. The first line contains N, the number of cities in Byteland. The following N - 1 lines contain the description of the roads. The ith line contains two integers ai and bi, meaning that there was originally a road connecting cities with numbers ai and bi. Constraints 1 <= T <= 20  1 <= N <= 10000  0 <= ai,bi < N   Output Format Output T lines, one corresponding to each test case containing the required answer for that test case. Since the answers can be huge, output them modulo 1000000007. Sample Input 2  3  0 1  1 2  5  0 1  1 2  2 3  2 4 Sample Output 2  4 Explanation For the first case, a new road was build between cities 0 and 2. Now, the salesman has two tour possibilities: 0-1-2-0 or 0-2-1-0.
__label__Graph-Algorithms The country of Byteland contains  cities and  bidirectional roads. There is a path between any two cities. The roads in Byteland were built long ago, and now they are in need of repair. You have been hired to fix all the roads. You intend to do this by dispatching robots on some of the roads. Each robot will repair the road he is currently on and then moves to one of the adjacent unrepaired roads. After repairing that, it will move to another adjacent unrepaired road, repair that and so on. Two roads are adjacent if they have the same city at one of their endpoints. For the process to be efficient, no two robots will ever repair the same road, and no road can be visited twice. What is the minimum number of robots needed to accomplish the task? Input Format The first line contains the number of test cases .  test cases follow. The first line of each test case contains , the number of cities in Byteland. The cities are numbered . The following  lines contain the description of the roads. The  line contains two integers  and , meaning that there is a road connecting cities with numbers  and . Constraints      Output Format Print  lines, one corresponding to each test case containing the required answer for that test case. Sample Input 3   4   0 1   0 2   0 3   6   0 1   1 2   2 3   2 4   4 5   7   0 1   1 2   2 3   2 4   4 5   3 6  Sample Output 1   1   2  Explanation For the first case, one robot is enough to repair all roads:   For the second case, one robot is again enough:   The the third case, there is no way to repair all the roads with one robot and at least two are needed.
__label__Greedy-Algorithms __label__Bit You are given  non-negative integers, . We define the score for some permutation () of length  to be the maximum of  for .  Find the permutation with the minimum possible score and print its score. Note:  is the exclusive-OR (XOR) operator. Input Format The first line contains single integer, , denoting the number of integers.  The second line contains  space-separated integers, , describing the respective integers. Constraints   Output Format Print a single integer denoting the minimum possible score. Sample Input 0 4 1 2 3 4  Sample Output 0 5  Sample Input 1 3 1 2 3  Sample Output 1 2  Explanation Sample Case 0:  The permutation with the minimum score is :        Because the permutation's score is the maximum of these values, we print  on a new line. Sample Case 1:  The permutation with the minimum score is :     Because the permutation's score is the maximum of these values, we print  on a new line.
__label__Mathematics __label__Strings Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = "11", b = "1" Output: "100" Example 2: Input: a = "1010", b = "1011" Output: "10101"
__label__Mathematics __label__Strings Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
__label__Mathematics __label__Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__Dynamic-Programming __label__Depth-first-Search In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.
__label__Binary-Search Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i. For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.    Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.    Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.    Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.  NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Mathematics __label__Dynamic-Programming Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.  Example: Input: 2 Output: 91  Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,               excluding 11,22,33,44,55,66,77,88,99
__label__Dynamic-Programming Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.   Example 1: Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9  Example 2: Input: grid = [[1,1,0,0]] Output: 1    Constraints:  1 <= grid.length <= 100 1 <= grid[0].length <= 100 grid[i][j] is 0 or 1
__label__Data-Structures __label__Advanced-Data-Structures Given a tree of N nodes, where each node is uniquely numbered in between [1, N]. Each node also has a value which is initially 0. You need to perform following two operations in the tree.   Update Operation Report Operation Update Operation U r t a b  Adds ab + (a+1)b + (b+1)a to all nodes in the subtree rooted at t, considering that tree is rooted at r (see explanation for more details).   ab + (a+1)b + (b+1)a t r Report Operation R r t m  Output the sum of all nodes in the subtree rooted at t, considering that tree is rooted at r. Output the sum modulo m (see explanation for more details). t r m Input Format First line contains N, number of nodes in the tree.  Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, number of queries to follow.  Next Q lines follow, each line will be either a report operation or an update operation.   Output Format For each report query output the answer in a separate line. Constraints 1 ≤ N ≤ 100000  1 ≤ Q ≤ 100000  1 ≤ m ≤ 101  1 ≤ r, t, x, y ≤ N  x ≠ y  1 ≤ a, b ≤ 1018  Notes There will be at most one edge between a pair of nodes. There will be no loop. Tree will be completely connected.  Sample Input 4 1 2 2 3 3 4 4 U 3 2 2 2 U 2 3 2 2 R 1 2 8 R 4 3 9  Sample Output 2 3  Explanation Initially Values in each node : [0,0,0,0]  The first query is U 3 2 2 2. Here, tree is rooted at 3. It looks like  U 3 2 2 2     3(0)    / \   /   \  2(0)  4(0)  |  |  1(0)  For the sub tree rooted at 2 ( nodes 2 and 1 ), we add ab  + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After first update operation, nodes 1, 2, 3, and 4 will have values 22, 22, 0 and 0 respectively.       3(0)    / \   /   \  2(22) 4(0)  |  |  1(22)  The second query is U 2 3 2 2. Here, tree is rooted at 2. It looks like U 2 3 2 2     2(22)    / \   /   \  1(22) 3(0)        |        |        4(0)  For the sub tree rooted at 3 (nodes 3 and 4), we add ab + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After second update operation, nodes 1, 2, 3, and 4 each have values 22,22,22,22 respectively.       2(22)    / \   /   \  1(22) 3(22)        |        |        4(22)  The first report query is R 1 2 8 asks for the sum modulo 8 of the subtree rooted at 2, when the tree is rooted at 1. The tree looks like  R 1 2 8 1(22)  \   \    2*(22)    |    |    3*(22)    |    |    4*(22)  The sum of the values of nodes 2, 3 and 4 are  (22 + 22 + 22) % 8 = 2  The second report query is R 4 3 9 asks for the sum modulo 9 of the subtree rooted at 3 when the tree is rooted at 4. The tree looks like  R 4 3 9 4(22)  \   \    3*(22)    |    |    2*(22)    |    |    1*(22)  The sum of the values of nodes 3, 2 and 1 are  (22 + 22 + 22) % 9 = 3  Time Limits:  C, C++: 4s | Java and other JVM based languages: 10s | Python, Python3 = 45s | Other interpreted Language: 30s | C#, Haskell: 10s | Rest: 3 times of default.
__label__Array __label__Greedy-Algorithms Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks.   Example: Input: tasks = ["A","A","A","B","B","B"], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.    Note:  The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100].
__label__Array Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].
__label__Tree In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.
__label__Strings Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.
__label__Tree A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued.   Example 1:  Input: [1,1,1,1,1,null,1] Output: true   Example 2:  Input: [2,2,2,5,2] Output: false     Note:  The number of nodes in the given tree will be in the range [1, 100]. Each node's value will be an integer in the range [0, 99].
__label__Strings The Kingdom of Gridland contains  provinces. Each province is defined as a  grid where each cell in the grid represents a city. Every cell in the grid contains a single lowercase character denoting the first character of the city name corresponding to that cell. From a city with the coordinates , it is possible to move to any of the following cells in  unit of time (provided that the destination cell is within the confines of the grid):     A knight wants to visit all the cities in Gridland. He can start his journey in any city and immediately stops his journey after having visited each city at least once. Moreover, he always plans his journey in such a way that the total time required to complete it is minimum. After completing his tour of each province, the knight forms a string by concatenating the characters of all the cells in his path. How many distinct strings can he form in each province? Input Format The first line contains a single integer, , denoting the number of provinces. The  subsequent lines describe each province over the following three lines:  The first line contains an integer, , denoting the number of columns in the province.  Each of the next two lines contains a string, , of length  denoting the characters for the first and second row of the province. Constraints       Output Format For each province, print the number of distinct strings the knight can form on a new line. Sample Input 3 1 a a 3 dab abd 5 ababa babab  Sample Output 1 8 2  Explanation Province 0:   The knight can only form one string (aa), so we print  on a new line. aa Province 1:   The knight can form eight different strings (abdbad, adabdb, badabd, bdbada, dababd, dabdba, dbabad, and dbadab), so we print  on a new line.  abdbad adabdb badabd bdbada dababd dabdba dbabad dbadab Province 2:   The knight can form two different strings (ababababab and bababababa), so we print  on a new line. ababababab bababababa
__label__Strings A gene is represented as a string of length  (where  is divisible by ), composed of the letters , , , and . It is considered to be steady if each of the four letters occurs exactly  times.  For example,  and  are both steady genes. Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string .  It is not necessarily steady.  Fortunately, Limak can choose one (maybe empty) substring of  and replace it with any string of the same length. Modifying a large substring of bear genes can be dangerous. Given a string , can you help Limak find the length of the smallest possible substring that he can replace to make  a steady gene? Note: A substring of a string  is a subsequence made up of zero or more contiguous characters of . As an example, consider .  The substring  just before or after  can be replaced with  or .  One selection would create . Function Description Complete the  function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.   steadyGene has the following parameter:   gene: a string Input Format The first line contains an interger  divisible by , that denotes the length of a string .  The second line contains a string  of length . Constraints    is divisible by     Subtask   in tests worth  points. Output Format Print the length of the minimum length substring that can be replaced to make  stable. Sample Input 8   GAAATAAA  Sample Output 5  Explanation One optimal solution is to replace  with  resulting in .  The replaced substring has length .
__label__Data-Structures __label__Advanced-Data-Structures Two positive integers  and  are given.   is decimal representation of integer .  Lets define . For example, if :   For each query you will be given two integers  and  that define a substring equal to .  Your task is to calculate divisibility of given substring.  Divisibility of given substring is equal to number of  pairs such that:   and   is divisible by , assuming that  is divisible by any other integer. Timelimits  Timelimits for this challenge is given here Input Format First line contains two integers  and  separated by a single space.  is the number of queries.  Second line contains a big integer .  Next  lines contains two integers  and  separated by a single space each - begin and end points of substring. Constraints   Output Format Output  lines, the -th line of the output should contain single integer  divisibility of the -th query substring. Sample Input 3 5 4831318 3 5 5 7 1 7 1 2 2 3  Sample Output 2 3 9 1 1  Explanation In the first query, b = 3 and e = 5. Two such pairs that are divisible by P = 3 are   f(3, 3) = 3 and f(5, 5). Hence the answer 2.   In the second query, b = 5 and e = 7. Three such pairs that are divisible by P are   F(5, 5) = 3, f(6, 7) = 18 and f(5, 7) = 318
__label__Mathematics Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.
__label__Depth-first-Search There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.
__label__Data-Structures Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed. There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by . If you join  adjacent buildings, they will form a solid rectangle of area .   For example, the heights array .  A rectangle of height  and length  can be constructed within the boundaries.  The area formed is .   Function Description Complete the function largestRectangle int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.   largestRectangle largestRectangle has the following parameter(s): h: an array of integers representing building heights Input Format The first line contains , the number of buildings.  The second line contains  space-separated integers, each representing the height of a building.    Constraints    Output Format Print a long integer representing the maximum area of rectangle formed. Sample Input 5 1 2 3 4 5  Sample Output 9  Explanation An illustration of the test case follows.
__label__Strings We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.
__label__Game-Theory Bob and Ben are playing a game with forests! The game's rules are as follows: The game starts with a forest of  trees. Bob always moves first and they take alternating turns. The first player with no available move loses the game. During each move, the player removes one node. If the node is not a leaf, then the whole tree vanishes; otherwise, the rest of the tree remains in the forest. We define a leaf to be a node with exactly  connected edge. Both players play optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists. We define each tree  in the -tree forest as follows: Tree  is defined by two integers,  (the number of nodes in the tree) and  (a constant).  Its nodes are numbered sequentially from  to . Its edges are numbered sequentially from  to , and each edge  connects node  to node . Given the values of  and  for each tree in the forest, can you determine who will win the game? Input Format The first line contains an integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of trees in the forest.      Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  for tree .  Constraints     The sum of  over all games is at most . Subtasks For  of the maximum score: The sum of  over all games is at most .  For  of the maximum score:  Output Format For each game, print the name of the winner on a new line (i.e., BOB or BEN). BOB BEN Sample Input 2 2 1 2 1 3 1 3 2  Sample Output BEN BOB  Explanation Bob and Ben play the following two games: The forest consists of  trees containing one node each, and each tree has no edges as  and  are both  (so both trees have  edges). The sequence of moves is as follows:    We then print the name of the winner, BEN, on a new line. BEN The forest consists of  tree containing three nodes. We find the  edges like so:  Edge  connects node  to node . Edge  connects node  to node .        The game then plays out as follows:    We then print the name of the winner, BOB, on a new line. The forest consists of  tree containing three nodes. We find the  edges like so:  Edge  connects node  to node . Edge  connects node  to node .        The game then plays out as follows:    We then print the name of the winner, BOB, on a new line. BOB
__label__Mathematics Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0.      Example 1: Input: [2,1,2] Output: 5   Example 2: Input: [1,2,1] Output: 0   Example 3: Input: [3,2,3,4] Output: 10   Example 4: Input: [3,6,2,3] Output: 8    Note:  3 <= A.length <= 10000 1 <= A[i] <= 10^6
__label__Strings __label__Dynamic-Programming __label__Greedy-Algorithms Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false
__label__Strings Two strings A and B, consisting of small English alphabet letters are called pseudo-isomorphic if   Their lengths are equal For every pair (i,j), where 1 <= i < j <= |A|, B[i] = B[j], iff A[i] = A[j] For every pair (i,j), where 1 <= i < j <= |A|, B[i] != B[j] iff A[i] != A[j] Naturally, we use 1-indexation in these definitions and |A| denotes the length of the string A.   You are given a string S, consisting of no more than 105 lowercase alphabetical characters. For every prefix of S denoted by S', you are expected to find the size of the largest possible set of strings , such that all elements of the set are substrings of S' and no two strings inside the set are pseudo-isomorphic to each other.   if S = abcde  then, 1st prefix of S is 'a'  then, 2nd prefix of S is 'ab'  then, 3rd prefix of S is 'abc'  then, 4th prefix of S is 'abcd' and so on..   Input Format The first and only line of input will consist of a single string S. The length of S will not exceed 10^5.   Constraints   S contains only lower-case english alphabets ('a' - 'z').   Output Format Output N lines. On the ith line, output the size of the largest possible set for the first i alphabetical characters of S such that no two strings in the set are pseudo-isomorphic to each other. Sample Input abbabab    Sample Output 1    2    4    6    9    12    15     Explanation The first character is 'a', the set is {a} hence 1.  The first 2 characters are 'ab', the set is {a, b, ab} but 'a' is pseudo-isomorphic to 'b'. So, we can remove either 'a' or 'b' from the set. We get {a,ab} or {b,ab}, hence 2.  Similarly, the first 3 characters are 'abb', the set is {a, ab, abb, b, bb} and as 'a' is pseudo-isomorphic to 'b', we have to remove either 'a' or 'b' from the set. We get {a,ab, abb, bb}, hence 4. and so on...
__label__Mathematics Given a positive integer n and you can do operations as follow:    If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.    What is the minimum number of replacements needed for n to become 1?   Example 1: Input: 8  Output: 3  Explanation: 8 -> 4 -> 2 -> 1   Example 2: Input: 7  Output: 4  Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1
__label__Data-Structures There are a number of plants in a garden. Each of these plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.   You are given the initial values of the pesticide in each of the plants. Print the number of days after which no plant dies, i.e. the time after which there are no plants with more pesticide content than the plant to their left.   For example, pesticide levels .  Using a -indexed array, day  plants  and  die leaving .  On day , plant  of the current array dies leaving .  As there is no plant with a higher concentration of pesticide than the one to its left, plants stop dying after day .   Function Description  Complete the function poisonousPlants in the editor below.  It must return an integer representing the number of days until plants no longer die from pesticide. poisonousPlants has the following parameter(s): p: an array of integers representing pesticide levels in each plant Input Format The first line contains an integer , the size of the array .  The next line contains  space-separated integers .   Constraints    Output Format Output an integer equal to the number of days after which no plants die. Sample Input 7 6 5 8 4 7 10 9  Sample Output 2  Explanation Initially all plants are alive.   Plants = {(6,1), (5,2), (8,3), (4,4), (7,5), (10,6), (9,7)}    Plants[k] = (i,j) => jth plant has pesticide amount = i.   After the 1st day, 4 plants remain as plants 3, 5, and 6 die.   Plants = {(6,1), (5,2), (4,4), (9,7)}   After the 2nd day, 3 plants survive as plant 7 dies. Plants = {(6,1), (5,2), (4,4)}   After the 2nd day the plants stop dying.
__label__Tree Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)   Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12]     Note:   1 <= preorder.length <= 100 The values of preorder are distinct.
__label__Strings Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.
__label__Depth-first-Search Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
__label__Game-Theory Consider the following game: There are two players, First and Second, sitting in front of a pile of  stones. First always plays first. There is a set, , of  distinct integers defined as . The players move in alternating turns. During each turn, a player chooses some  and splits one of the piles into exactly  smaller piles of equal size. If no  exists that will split one of the available piles into exactly  equal smaller piles, the player loses. Both players always play optimally. Given , , and the contents of , find and print the winner of the game. If First wins, print First; otherwise, print Second. First Second Input Format The first line contains two space-separated integers describing the respective values of  (the size of the initial pile) and  (the size of the set).  The second line contains  distinct space-separated integers describing the respective values of . Constraints    Output Format Print First if the First player wins the game; otherwise, print Second. First Second Sample Input 0 Sample Output 0 Explanation 0 The initial pile has  stones, and . During First's initial turn, they have two options: Split the initial pile into  equal piles, which forces them to lose after the following sequence of turns:   Split the initial pile into  equal piles, which forces them to lose after the following sequence of turns:   Because First never has any possible move that puts them on the path to winning, we print Second as our answer. Second
__label__Tree Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.   Example 1:  Input: [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22    Note:  The number of nodes in the tree is between 1 and 1000. node.val is 0 or 1. The answer will not exceed 2^31 - 1.
__label__Dynamic-Programming Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
__label__Dynamic-Programming Li and Lu have  integers, , that they want to divide fairly between the two of them. They decide that if Li gets integers with indices  (which implies that Lu gets integers with indices ), then the measure of unfairness of this division is:    Find the minimum measure of unfairness that can be obtained with some division of the set of integers where Li gets exactly  integers.  Note  means Set complement Input Format The first line contains two space-separated integers denoting the respective values of  (the number of integers Li and Lu have) and  (the number of integers Li wants).  The second line contains  space-separated integers describing the respective values of . Constraints   For  of the test cases, . For  of the test cases, . Output Format Print a single integer denoting the minimum measure of unfairness of some division where Li gets  integers. Sample Input 0 4 2 4 3 1 2  Sample Output 0  6  Explanation 0  One possible solution for this input is .  Sample Input 1  4 1 3 3 3 1  Sample Output 1 2  Explanation 1  The following division of numbers is optimal for this input: .
__label__Graph-Algorithms In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the red knight.   The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below.   The board is a grid of size . Each cell is identified with a pair of coordinates , where  is the row number and  is the column number, both zero-indexed. Thus,  is the upper-left corner and  is the bottom-right corner.  Complete the function printShortestPath, which takes as input the grid size , and the coordinates of the starting and ending position  and  respectively, as input. The function does not return anything.      printShortestPath Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word "Impossible".  Note: There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority: UL, UR, R, LR, LL, L. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input  for an illustration. Input Format The first line of input contains a single integer . The second line contains four space-separated integers .  denotes the coordinates of the starting position and  denotes the coordinates of the final position. Constraints     the starting and the ending positions are different Output Format If the destination can be reached, print two lines. In the first line, print a single integer denoting the minimum number of moves that the red knight has to make in order to reach the destination. In the second line, print the space-separated sequence of moves.  If the destination cannot be reached, print a single line containing only the word Impossible. Impossible Sample Input 0 Sample Output 0 Explanation 0  Sample Input 1 Sample Output 1 Explanation 1  Sample Input 2 Sample Output 2 Explanation 2
__label__Data-Structures A bracket is considered to be any one of the following characters: (, ), {, }, [, or ].  ( ) { } [ ] Two brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and (). ( [ { ) ] } [] {} () A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ]. {[(])} { } ( ] By this logic, we say a sequence of brackets is balanced if the following conditions are met: It contains no unmatched brackets. The subset of brackets enclosed within the confines of a matched pair of brackets  is also a matched pair of brackets. Given  strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return YES.  Otherwise, return NO.   YES NO Function Description  Complete the function isBalanced in the editor below.  It must return a string: YES if the sequence is balanced or NO if it is not.   YES NO isBalanced has the following parameter(s): s: a string of brackets Input Format The first line contains a single integer , the number of strings.  Each of the next  lines contains a single string , a sequence of brackets. Constraints   , where  is the length of the sequence.   All chracters in the sequences ∈ { {, }, (, ), [, ] }. Output Format For each string, return YES or NO. YES NO Sample Input 3 {[()]} {[(])} {{[[(())]]}}  Sample Output YES NO YES  Explanation The string {[()]} meets both criteria for being a balanced string, so we print YES on a new line.     {[()]} YES The string {[(])} is not balanced because the brackets enclosed by the matched pair { and } are not balanced: [(]).       {[(])} { } [(]) The string {{[[(())]]}} meets both criteria for being a balanced string, so we print YES on a new line.   {{[[(())]]}} YES
__label__Greedy-Algorithms There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.
__label__Dynamic-Programming Bill Gates is on one of his philanthropic journeys to a village in Utopia. He has brought a box of packets of candies and would like to distribute one packet to each of the children.  Each of the packets contains a number of candies.  He wants to minimize the cumulative difference in the number of candies in the packets he hands out.  This is called the unfairness sum.  Determine the minimum unfairness sum achievable.  For example, he brings  packets where the number of candies is .  There are  children.  The minimum difference between all packets can be had with  from indices  and .  We must get the difference in the following pairs: .  We calculate the unfairness sum as: Function Description Complete the angryChildren function in the editor below.  It should return an integer that represents the minimum unfairness sum achievable. angryChildren has the following parameter(s): k: an integer that represents the number of children   packets:  an array of integers that represent the number of candies in each packet   Input Format The first line contains an integer .  The second line contains an integer .  Each of the next  lines contains an integer . Constraints       Output Format A single integer representing the minimum achievable unfairness sum. Sample Input 0  7 3 10 100 300 200 1000 20 30  Sample Output 0  40  Explanation 0 Bill Gates will choose packets having 10, 20 and 30 candies.  The unfairness sum is .   Sample Input 1  10 4 1 2 3 4 10 20 30 40 100 200  Sample Output 1  10  Explanation 1  Bill Gates will choose 4 packets having 1,2,3 and 4 candies. The unfairness sum i .
__label__Game-Theory Our unsung tower-breaking heroes (players  and ) only have one tower left, and they've decided to break it for a special game commemorating the end of  days of Game Theory! The rules are as follows:  always moves first, and both players always move optimally. Initially there is  tower of height . The players move in alternating turns. The moves performed by each player are different: At each turn,  divides the current tower into some number of smaller towers. If the turn starts with a tower of height  and  breaks it into  smaller towers, the following condition must apply: , where  denotes the height of the  new tower. At each turn,  chooses some tower  of the  new towers made by  (where ). Then  must pay  coins to . After that,  gets another turn with tower  and the game continues. At each turn,  divides the current tower into some number of smaller towers. If the turn starts with a tower of height  and  breaks it into  smaller towers, the following condition must apply: , where  denotes the height of the  new tower. At each turn,  chooses some tower  of the  new towers made by  (where ). Then  must pay  coins to . After that,  gets another turn with tower  and the game continues. The game is over when no valid move can be made by , meaning that . 's goal is to pay as few coins as possible, and 's goal is to earn as many coins as possible.  Can you predict the number of coins that  will earn? Input Format The first line contains a single integer, , denoting the number of test cases.  Each of the  subsequent lines contains a single integer, , defining the initial tower height for a test case. Constraints   Output Format For each test case, print a single integer denoting the number of coins earned by  on a new line. Sample Input 3 4 2 7  Sample Output 6 4 8  Explanation Test Case 0:  Our players make the following moves:   splits the initial tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.   splits the initial tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.    splits the tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.  splits the tower into  smaller towers of sizes  and .   chooses the first tower and earns  coin.   splits the tower into  smaller towers of size .   chooses the second tower and earns  coins.  splits the tower into  smaller towers of size .   chooses the second tower and earns  coins. The total number of coins earned by  is , so we print  on a new line.
__label__Dynamic-Programming Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A.    Example 1: Input: ["alex","loves","leetcode"] Output: "alexlovesleetcode" Explanation: All permutations of "alex","loves","leetcode" would also be accepted.   Example 2: Input: ["catg","ctaagt","gcta","ttca","atgcatc"] Output: "gctaagttcatgcatc"     Note:  1 <= A.length <= 12 1 <= A[i].length <= 20
__label__Array Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]
__label__Hash-Table Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.
__label__Search __label__Dynamic-Programming There are  variables and  requirements. Requirements are represented as , meaning that the  variable must be less than or equal to the  variable.  Your task is to assign non-negative numbers smaller than  to each variable and then calculate the number of different assignments satisfying all requirements. Two assignments are different if and only if at least one variable is assigned to a different number in both assignments. Print your answer modulo . Input Format The first line contains  space-separated integers,  and , respectively. Each of the  subsequent lines contains  space-seperated integers describing the respective  and  values for an  requirement. Constraints    Output Format Print your answer modulo . Sample Input 0 Sample Output 0 Explanation 0 There are  variables and  requirements. Let the variables be in the array . Requirements are -  One of the assignments is -  Similarly there are  assignments possible. Result = .
__label__Strings Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1
__label__Bit An XOR operation on a list is defined here as the xor () of all its elements (e.g.: ).  The  of set  is defined here as the sum of the s of all non-empty subsets of  known as . The set  can be expressed as:   For example: Given set  The set of possible non-empty subsets is:   The set of possible non-empty subsets is:   The  of these non-empty subsets is then calculated as follows:   =  The  of these non-empty subsets is then calculated as follows:   =  Given a list of  space-separated integers, determine and print .     For example, .  There are three possible subsets, .  The XOR of , of  and of .  The XorSum is the sum of these:  and .   Note: The cardinality of powerset is , so the set of non-empty subsets of set  of size  contains  subsets. Function Description  Complete the xoringNinja function in the editor below.  It should return an integer that represents the XorSum of the input array, modulo .   xoringNinja has the following parameter(s):   arr: an integer array Input Format The first line contains an integer , the number of test cases.        Each test case consists of two lines:  -  The first line contains an integer , the size of the set .  -  The second line contains  space-separated integers .   Constraints       Output Format For each test case, print its  on a new line.  The  line should contain the output for the  test case. Sample Input 0 Sample Output 0 Explanation 0 The input set, , has  possible non-empty subsets: . We then determine the  of each subset in :                Then sum the results of the  of each individual subset in , resulting in  and . Sample Input 1 Sample Output 1
__label__Depth-first-Search Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
__label__Mathematics Meereen is famous for its fighting pits where fighters fight each other to the death. Initially, there are  fighters and each fighter has a strength value. The  fighters are divided into  teams, and each fighter belongs exactly one team. For each fight, the Great Masters of Meereen choose two teams,  and , that must fight each other to the death. The teams attack each other in alternating turns, with team  always launching the first attack. The fight ends when all the fighters on one of the teams are dead. Assume each team always attacks optimally. Each attack is performed as follows: The attacking team chooses a fighter from their team with strength . The chosen fighter chooses at most  fighters from other team and kills all of them.  The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries: 1 p x Add a new fighter with strength  to team . It is guaranteed that this new fighter's strength value will not be less than any current member of team . 1 p x 2 x y Print the name of the team that would win a matchup between teams  and  in their current state (recall that team  always starts first). It is guaranteed that .  2 x y Given the initial configuration of the teams and  queries, perform each query so the Great Masters can plan the next fight. Note: You are determining the team that would be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups. Input Format The first line contains three space-separated integers describing the respective values of  (the number of fighters),  (the number of teams), and  (the number of queries).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of fighter 's strength, , and team number, .  Each of the  subsequent lines contains a space-separated query in one of the two formats defined in the Problem Statement above (i.e., 1 p x or 2 x y). 1 p x 2 x y Constraints     It is guaranteed that both teams in a query matchup will always have at least one fighter. Scoring  This challange has binary scoring. This means you will get a full score if your solution passes all test cases; otherwise, you will get  points. Output Format After each type  query, print the name of the winning team on a new line. For example, if  and  are matched up and  wins, you would print . Sample Input 7 2 6 1 1 2 1 1 1 1 2 1 2 1 2 2 2 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2 2 2 1  Sample Output 1 2 1 1  Explanation Team  has three fighters with the following strength levels: .  Team  has four fighters with the following strength levels: .       The first query matching up team  and  would play out as follows: Team  attacks  The fighter with strength  can kill one fighter with strength  and one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the last fighter with strength . Now, , and . After this last attack, all of Team 's fighters would be dead. Thus, we print  as team  would win that fight.
__label__Tree __label__Data-Structures Given an array, your goal is to find, for each element, the largest subarray containing it whose cost is at least . Specifically, let  be an array of length , and let  be the subarray from index  to index . Also, Let  be the largest number in . Let  be the smallest number in . Let  be the bitwise OR of the elements of . Let  be the bitwise AND of the elements of . The cost of , denoted , is defined as   You are given the array  and and an integer . For each index  from  to , your goal is to find the largest size of any subarray  such that  and . Consider, array  and . The possible sub-arrays and their costs would be as follows:   Complete the function costlyIntervals which takes two integers  and  as first line of input, and array  in the second line of input. Return an array of  integers, where the  element contains the answer for index  of the input array, . Every element of the output array denotes the largest size of a subarray containing  whose cost is at least , or  if there is no such subarray. costlyIntervals Constraints     Subtasks  For  of the maximum score, . For  of the maximum score, . Sample Input ,     Sample Output   Explanation In this example, we have . There is only one subarray whose cost is at least , and that is , since . Its size is . Thus, for  and , the answer is , and for the others, .
__label__Dynamic-Programming You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width): Using these blocks, you want to make a wall of height  and width . Features of the wall are:   - The wall should not have any holes in it.  - The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks.  - The bricks must be laid horizontally.    How many ways can the wall be built? For example, the wall's height  and its width .  Here are some configurations:     These are not all of the valid permutations. Function Description  Complete the legoBlocks function in the editor below.  It should return an integer that represents the number of valid wall formations for the given wall dimensions modulo . legoBlocks has the following parameter(s): n: an integer that represents the height of the wall   m: an integer that represents the width of the wall   Input Format The first line contains the number of test cases .   Each of the next  lines contains two space-separated integers  and .   Constraints     Output Format Output one line for each test case containing the number of ways to build the wall. As the numbers can be very large, output the result modulo 1000000007. Sample Input 4   2 2   3 2   2 3   4 4  Sample Output 3   7   9   3375  Explanation For the first case, we can have:       For the second case, each row of the wall can contain either two blocks of width 1, or one block of width 2. However, the wall where all rows contain two blocks of width 1 is not a solid one as it can be divided vertically. Thus, the number of ways is  and .
__label__Binary-Search Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?
__label__Dynamic-Programming Given an array of integers and a target sum, determine the sum nearest to but not exceeding the target that can be created.  To create the sum, use any element of your array zero or more times. For example, if  and your target sum is , you might select  or .  In this case, you can arrive at exactly the target.   Function Description  Complete the unboundedKnapsack function in the editor below.  It must return an integer that represents the sum nearest to without exceeding the target value.   unboundedKnapsack has the following parameter(s):   k: an integer   arr: an array of integers   Input Format The first line contains an integer , the number of test cases.     Each of the next  pairs of lines are as follows:  - The first line contains two integers  and , the length of  and the target sum.  -  The second line contains  space separated integers .  Constraints     Output Format Print the maximum sum for each test case which is as near as possible, but not exceeding, to the target sum on a separate line. Sample Input 2 3 12 1 6 9 5 9 3 4 4 4 8  Sample Output 12 9  Explanation In the first test case, one can pick {6, 6}. In the second, we can pick {3,3,3}.
__label__Strings You are given string  and number .  Consider a substring  of string . For each position of string  mark it if there is an occurence of the substring that covers the position. More formally, position  will be marked if there exists such index  that:  and . We will tell  produce  islands if all the marked positions form  groups of contiguous positions.  For example, if we have a string ababaewabaq the substring aba marks the positions 1, 2, 3, 4, 5, 8, 9, 10; that is XXXXXewXXXq (X denotes marked position). We can see 2 groups of contiguous positions, that is 2 islands. Finally, substring aba produces 2 islands in the string ababaewabaq. ababaewabaq aba XXXXXewXXXq X aba ababaewabaq Calculate and print the number of different substrings of string  that produce exactly  islands. Input Format The first line contains string  . The string consists of lowercase letters only. The second line contains an integer  . Output Format Output a single integer  the answer to the problem. Sample Input abaab 2  Sample Output 3  Explanation All the suitable substrings are: a, ab, b. a ab b
__label__Mathematics Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.  You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1: Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.   Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.
__label__Array Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]
__label__Search The median of a list of numbers is essentially it's middle element after sorting.  The same number of elements occur after it as before.  Given a list of numbers with an odd number of elements, can you find the median? For example, the median of  is , the middle element in the sorted array. Function Description Complete the findMedian function in the editor below.  It must return an integer that represents the median of the array.  findMedian has the following parameter(s):   arr: an unsorted array of integers Input Format The first line contains the integer , the size of .  The second line contains  space-separated integers  Constraints    is odd   Output Format Output one integer, the median. Sample Input 0 Sample Output 0 Explanation 0 The sorted .  It's middle element is at .
__label__Dynamic-Programming Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4
__label__Two-Pointers A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.
__label__Tree __label__Depth-first-Search We are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.      Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2  Output: [7,4,1]  Explanation:  The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.    Note that the inputs "root" and "target" are actually TreeNodes. The descriptions of the inputs above are just serializations of these objects.    Note:  The given tree is non-empty. Each node in the tree has unique values 0 <= node.val <= 500. The target node is a node in the tree. 0 <= K <= 1000.
__label__Tree __label__Depth-first-Search Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its minimum depth = 2.
__label__Graph-Algorithms __label__Graph-Algorithms Daniel loves graphs. He thinks a graph is special if it has the following properties: It is undirected. The length of each edge is . It includes exactly  different lovely triplets.  A triplet is a set of  different nodes. A triplet is lovely if the minimum distance between each pair of nodes in the triplet is exactly . Two triplets are different if  or more of their component nodes are different.  Given  and , help Daniel draw a special graph. Input Format A single line containing  space-separated integers,  (the number of different lovely triplets you must have in your graph) and  (the required distance between each pair of nodes in a lovely triplet), respectively. Constraints   Output Format For the first line, print  space-separated integers,  (the number of nodes in the graph) and  (the number of edges in the graph), respectively.  On each line  of the  subsequent lines, print two space-separated integers,  and , describing an edge between nodes  and . Your output must satisfy the following conditions:   If there is more than one correct answer, print any one of them. Sample Input 3 2  Sample Output 7 7 1 2 2 3 3 4 4 5 5 6 6 1 1 7  Explanation There are exactly  lovely triplets in this graph: , , and .  Observe that each node in a lovely triplet is  edges away from the other nodes composing the lovely triplet.
__label__Mathematics A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].
__label__Dynamic-Programming You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height. You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.   Example 1: Input: [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.   Example 2: Input: [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.    Example 3: Input: [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0.     Note:  0 <= rods.length <= 20 1 <= rods[i] <= 1000 The sum of rods is at most 5000.
__label__Mathematics __label__Strings Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.
__label__Dynamic-Programming Red John has committed another murder. This time, he doesn't leave a red smiley behind. Instead he leaves a puzzle for Patrick Jane to solve. He also texts Teresa Lisbon that if Patrick is successful, he will turn himself in. The puzzle begins as follows.   There is a wall of size 4xn in the victim's house. The victim has an infinite supply of bricks of size 4x1 and 1x4 in her house. There is a hidden safe which can only be opened by a particular configuration of bricks. First we must calculate the total number of ways in which the bricks can be arranged so that the entire wall is covered.  The following diagram shows how bricks might be arranged to cover walls where :  There is one more step to the puzzle.  Call the number of possible arrangements .   Patrick must calculate the number of prime numbers  in the inclusive range .   As an example, assume .  From the diagram above, we determine that there is only one configuration that will cover the wall properly.   is not a prime number, so . A more complex example is .  The bricks can be oriented in  total configurations that cover the wall.  The two primes  and  are less than or equal to , so .  Function Description  Complete the redJohn function in the editor below.  It should return the number of primes determined, as an integer.   redJohn has the following parameter(s):   n: an integer that denotes the length of the wall   Input Format The first line contains the integer , the number of test cases.  Each of the next  lines contains an integer , the length of the  wall. Constraints   Output Format Print the integer  on a separate line for each test case. Sample Input 2 1 7  Sample Output 0 3  Explanation For , the brick can be laid in 1 format only: vertically.   The number of primes  is .  For , one of the ways in which we can lay the bricks is   There are  ways of arranging the bricks for  and there are  primes .
__label__Dynamic-Programming Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation:  Here are the non-negative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.    Note: 1 <= n <= 109
__label__Dynamic-Programming The evil forest is guarded by vicious mandragoras. Garnet and her pet must make a journey through.  She starts with  health point () and  experience points.     As she encouters each mandragora, her choices are: Garnet's pet eats mandragora . This increments  by  and defeats mandragora .   Garnet's pet battles mandragora . This increases  by  experience points and defeats mandragora .  Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.   For example, as always, she starts out with  health point and  experience points.  Mandragoras have the following health values: .  For each of the beings, she has two choices, at or attle.  We have the following permutations of choices and outcomes: Action  s   p _______ _   __ e, e, e 4   0 e, e, b 3   15 e, b, b 2   14 b, b, b 1   10 b, b, e 2   10 b, e, e 3   9 b, e, b 2   16 e, b, e 3   6  Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have  health points, then battles the beast with  heatlth points to gain  experience points.  We see that the best option is to eat the beast with  points and battle the others to achieve  experience points. Function Description  Complete the mandragora function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn. mandragora has the following parameter(s):   H: an array of integers that represents the health values of mandragoras   Input Format The first line contains an integer, , denoting the number of test cases. Each test case is described over two lines: The first line contains a single integer , the number of mandragoras in the forest.  The second line contains  space-separated integers describing the respective health points for the mandragoras .     Constraints     , where   The sum of all s in a single test case is   Output Format For each test case, print a single line with an integer denoting the maximum number of experience points that Garnet can earn. Sample Input 1 3 3 2 2  Sample Output 10   Explanation There are  mandragoras having the following health points: . Initially,  and . The following is an optimal sequence of actions for achieving the maximum number of experience points possible:   Eat the second mandragora ().  is increased from  to , and  is still .  Battle the first mandragora ().  remains the same, but  increases by  experience points.  Battle the third mandragora ().  remains the same, but  increases by  experience points.  Garnet earns  experience points.
__label__Depth-first-Search Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].
__label__Dynamic-Programming __label__Mathematics __label__Game-Theory __label__Game-Theory It's New Year's Day, and Balsa and Koca are stuck inside watching the rain. They decide to invent a game, the rules for which are described below. Given array  containing  integers, they take turns making a single move. Balsa always moves first, and both players are moving optimally (playing to win and making no mistakes). During each move, the current player chooses one element from , adds it to their own score, and deletes the element from ; because the size of  decreases by  after each move, 's size will be  after  moves and the game ends (as all elements were deleted from ). We refer to Balsa's score as  and Koca's score as . Koca wins the game if |-| is divisible by ; otherwise Balsa wins.  Given , determine the winner. Note: . Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is comprised of two lines; the first line has an integer , and the second line has  space-separated integers  describing array . Constraints    Subtasks For  score:  For  score:  Output Format For each test case, print the winner's name on a single line; if Balsa wins print Balsa, otherwise print Koca. Sample Input 2  3 7 6 18 1 3  Sample Output Balsa Koca  Explanation Test Case 1 Array . The possible play scenarios are: , , , and . , , , and . , , , and . , , , and . , , -, and . , , -, and . In this case, it doesn't matter what Balsa chooses because the difference between their scores isn't divisible by . Thus, Balsa wins. Test Case 2 Array . Balsa must choose that element, the first move ends the game.  , , , and . Thus, Koca wins.
__label__Strings Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.
__label__Array Given an array A of integers, a ramp is a tuple (i, j) for which i < j and A[i] <= A[j].  The width of such a ramp is j - i. Find the maximum width of a ramp in A.  If one doesn't exist, return 0.   Example 1: Input: [6,0,8,2,1,5] Output: 4 Explanation:  The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.   Example 2: Input: [9,8,1,0,1,9,4,0,4,1] Output: 7 Explanation:  The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.       Note:  2 <= A.length <= 50000 0 <= A[i] <= 50000
__label__Strings __label__Dynamic-Programming Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"
__label__Dynamic-Programming Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
__label__Tree Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.
__label__Dynamic-Programming Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1] in clockwise order. Suppose you triangulate the polygon into N-2 triangles.  For each triangle, the value of that triangle is the product of the labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation. Return the smallest possible total score that you can achieve with some triangulation of the polygon.      Example 1: Input: [1,2,3] Output: 6 Explanation: The polygon is already triangulated, and the score of the only triangle is 6.   Example 2:  Input: [3,7,4,5] Output: 144 Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.  The minimum score is 144.   Example 3: Input: [1,3,1,4,1,5] Output: 13 Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.    Note:  3 <= A.length <= 50 1 <= A[i] <= 100
__label__Greedy-Algorithms An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].
__label__Data-Structures __label__Advanced-Data-Structures Jaggu is a little kid and he likes playing with water balloons. He took 1 million ( 106 ) empty buckets and he filled the bucket with water balloons under the instruction of his sister Ishika.  His sister gives him two types of commands: R pos1 pos2 which implies that jaggu needs to tell her what is the total number of water balloons in the bucket from pos1 to pos2 (both included). R pos1 pos2 U pos M plus which implies that he has to work like the function  U pos M plus Update(pos,M,plus) void Update(int pos,int M,int plus) {     int N=1000000;  //1 million     for (int i=1;i<=50;i++)     {         int back = pos         for(int j=1;j<=1000;j++)         {             add M water ballons at bucket pos             int s,in=__builtin_popcount(pos);             for(int k=0;;k++)             {                 s=pos+pow(2,k)                 if( __builtin_popcount(s) <= in )                 {                     in = __builtin_popcount(s)                     pos = s;                     if(pos>N)       break;                     add M water ballons at bucket pos                 }             }             pos = pos - N         }         pos = back+plus;         if(pos>N) pos-=N;     } }  Jaggu is too lazy to put the water ballons in the bucket. Afraid that he might be caught for not doing what his sister told him to do so, he asks your help to provide correct answers  for each of his sister's query. . Input Format First line contains Q, number of queries to follow. Next Q line follows , which can be either an Update Query or Report Query.Each Update Query is followed by atleast 1 report query. Output Format For each report query , output the answer in a separate line. Constraints 1 ≤ Q ≤ 2 * 105 1 ≤ pos1,pos2,pos ≤ 106 pos1 ≤ pos2 1 ≤ M ≤ 10 1 ≤ plus ≤ 999999 Sample Input 2 U 692778 7 291188 R 636916 747794  Sample Output 378   Explanation Follow the code above to get the answer. Note  Input is randomly generated. Input is randomly generated. __builtin_popcount(x) gives the number of set bits in binary representation of x. __builtin_popcount(x) gives the number of set bits in binary representation of x. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. Timelimit is 3 times the timelimit mentioned here
__label__Bit Understanding 's complement representation is fundamental to learning about Computer Science. It allows us to write negative numbers in binary.  The leftmost digit is used as a sign bit.  If it is , we have a negative number and it is represented as the two's complement of its absolute value.  Let's say you wrote down the 's complement representation for each -bit integer in the inclusive range from  to .  How many 's would you write down in all?   For example, using an -bit byte rather than  bit integer, the two's complement of a number can be found by reversing all its bits and adding .  The two's complement representations for a few numbers are shown below:           |Number|                Representation in Number   Binary     Inverse     Two's Complement -3      00000011    11111100    11111101 -2      00000010    11111101    11111110 -1      00000001    11111110    11111111  0      00000000                00000000  1      00000001                00000001  2      00000010                00000010  3      00000011                00000011  To write down that range of numbers' two's complements in  bits, we wrote 's.  Remember to use  bits rather than  in your solution.  The logic is the same, so the  bit representation was chosen to reduce apparent complexity in the example.   Function Description  Complete the twosCompliment function in the editor below.  It should return an integer.   twosCompliment has the following parameter(s):  - a: an integer, the range minimum  - b: an integer, the range maximum   Input Format The first line contains an integer , the number of test cases.    Each of the next  lines contains two space-separated integers,  and .   Constraints   Output Format For each test case, print the number of 's in the -bit 's complement representation for integers in the inclusive range from  to  on a new line. Sample Input 0 Sample Output 0 Explanation 0 Test case 0  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  31+32+0 = 63  Test case 1  -3 has 31 ones  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  31+31+32+0+1+1+2+1 = 99  Test case 2  -1 has 32 ones  0 has 0 ones  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  32+0+1+1+2+1 = 37   Sample Input 1 Sample Output 1 Explanation 1 Test case 0  -5 has 31 ones  -4 has 30 ones  -3 has 31 ones  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  31+30+31+31+32+0 = 155  Test case 1  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  5 has 2 ones  6 has 2 ones  7 has 3 ones  1+1+2+1+2+2+3 = 12  Test case 2  -6 has 30 ones  -5 has 31 ones  -4 has 30 ones  -3 has 31 ones  30+31+30+31 = 122  Test case 3  3 has 2 ones  4 has 1 ones  5 has 2 ones  6 has 2 ones  2+1+2+2 = 7
__label__Strings Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?     Example 1: Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails    Note:  1 <= emails[i].length <= 100 1 <= emails.length <= 100 Each emails[i] contains exactly one '@' character. All local and domain names are non-empty. Local names do not start with a '+' character.
__label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:  You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)  Example: Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell]
__label__Hash-Table __label__Two-Pointers __label__Strings Given a string, find the length of the longest substring without repeating characters.  Example 1: Input: "abcabcbb" Output: 3  Explanation: The answer is "abc", with the length of 3.    Example 2: Input: "bbbbb" Output: 1 Explanation: The answer is "b", with the length of 1.   Example 3: Input: "pwwkew" Output: 3 Explanation: The answer is "wke", with the length of 3.               Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Tree Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Data-Structures __label__Advanced-Data-Structures You are given a list of  numbers . For each element at position  (), we define  and  as:   = closest index j such that j < i and . If no such j exists then  = 0.   = closest index k such that k > i and . If no such k exists then  = 0.    We define  =  * . You need to find out the maximum  among all i. Input Format The first line contains an integer , the number of integers. The next line contains the  integers describing the list a[1..N]. Constraints     Output Format Output the maximum  among all indices from  to .  Sample Input 5 5 4 3 4 5  Sample Output 8  Explanation We can compute the following:          The largest of these is 8, so it is the answer.
__label__Graph-Algorithms __label__Tree You have a rooted tree with  vertices numbered from  through  where the root is vertex .  You are given  triplets, the  triplet is denoted by three integers . The  triplet represents a simple path in the tree with endpoints in  and  such that  is ancestor of . The cost of the path is .  You have to select a subset of the paths such that the sum of path costs is maximum and the  edge of the tree belongs to at most  paths from the subset. Print the sum as the output. Input Format The first line contains a single integer, , denoting the number of testcases. Each testcase is defined as follows: The first line contains two space-separated integers,  (the number of vertices) and  (the number of paths), respectively. Each line  of the  subsequent lines contains three space-separated integers describing the respective values of , , and  where (, ) is an edge in the tree and  is maximum number of paths which can include this edge. Each line of the  subsequent lines contains three space-separated integers describing the respective values of , , and  () that define the  path and its cost. Constraints Let  be the sum of  over all the trees.  Let  be the sum of  over all the trees.          Output Format You must print  lines, where each line contains a single integer denoting the answer for the corresponding testcase. Sample Input 1 8 8 1 2 3 1 3 1 2 4 5 2 5 1 2 6 1 3 7 2 4 8 1 1 2 3 2 8 5 1 8 7 1 5 8 1 6 10 3 7 5 1 7 6 1 7 6  Sample Output 37  Explanation  One of the possible subsets contains paths . Its total cost is .
__label__Graph-Algorithms __label__Greedy-Algorithms __label__Graph-Algorithms The Ruler of HackerLand believes that every citizen of the country should have access to a library. Unfortunately, HackerLand was hit by a tornado that destroyed all of its libraries and obstructed its roads! As you are the greatest programmer of HackerLand, the ruler wants your help to repair the roads and build some new libraries efficiently.  HackerLand has  cities numbered from  to . The cities are connected by  bidirectional roads. A citizen has access to a library if: Their city contains a library. They can travel by road from their city to a city containing a library. The following figure is a sample map of HackerLand where the dotted lines denote obstructed roads:  The cost of repairing any road is  dollars, and the cost to build a library in any city is  dollars.  If in the above example  and , we would build  roads at a cost of  and  libraries for a cost of .  We don't need to rebuild one of the roads in the cycle .     You are given  queries, where each query consists of a map of HackerLand and value of  and . For each query, find the minimum cost of making libraries accessible to all the citizens and print it on a new line. Function Description Complete the function roadsAndLibraries in the editor below.  It must return the minimal cost of providing libraries to all, as an integer. roadsAndLibraries has the following parameters: n: integer, the number of cities   c_lib: integer, the cost to build a library   c_road: integer, the cost to repair a road   cities: 2D array of integers where each  contains two integers that represent cities connected by an obstructed road .  Input Format The first line contains a single integer , that denotes the number of queries.  The subsequent lines describe each query in the following format:  - The first line contains four space-separated integers that describe the respective values of , ,  and , the number of cities, number of roads, cost of a library and cost of a road.  - Each of the next  lines contains two space-separated integers,  and , that describe a bidirectional road that connects cities  and . Constraints       Each road connects two distinct cities. Output Format For each query, print an integer that denotes the minimum cost to make libraries accessible to all the citizens on a new line. Sample Input 2 3 3 2 1 1 2 3 1 2 3 6 6 2 5 1 3 3 4 2 4 1 2 2 3 5 6  Sample Output 4 12  Explanation Perform the following  queries: HackerLand contains  cities connected by  bidirectional roads. The price of building a library is  and the price for repairing a road is .    The cheapest way to make libraries accessible to all is to: Build a library in city  at a cost of . Repair the road between cities  and  at a cost of . Repair the road between cities  and  at a cost of . This gives a total cost of . Note that the road between cities  and  does not need to be repaired each is connected to city .   HackerLand contains  cities connected by  bidirectional roads. The price of building a library is  and the price for repairing a road is .    The cheapest way to make libraries accessible to all is to: Build a library in city  at a cost of . Repair the road between cities  and  at a cost of . Repair the road between cities  and  at a cost of . This gives a total cost of . Note that the road between cities  and  does not need to be repaired each is connected to city .   In this scenario it is optimal to build a library in each city because the cost of building a library () is less than the cost of repairing a road ().   There are  cities, so the total cost is . In this scenario it is optimal to build a library in each city because the cost of building a library () is less than the cost of repairing a road ().   There are  cities, so the total cost is .
__label__Tree __label__Depth-first-Search Given the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, "ab" is lexicographically smaller than "aba".  A leaf of a node is a node that has no children.)          Example 1:  Input: [0,1,2,3,4,3,4] Output: "dba"   Example 2:  Input: [25,1,3,1,3,0,2] Output: "adz"   Example 3:  Input: [2,2,1,null,1,0,null,0] Output: "abc"    Note:  The number of nodes in the given tree will be between 1 and 8500. Each node in the tree will have a value between 0 and 25.
__label__Hash-Table Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4
__label__Strings Two words are anagrams of one another if their letters can be rearranged to form the other word.   In this challenge, you will be given a string.  You must split it into two contiguous substrings, then determine the minimum number of characters to change to make the two substrings into anagrams of one another. For example, given the string 'abccde', you would break it into two parts: 'abc' and 'cde'.  Note that all letters have been used, the substrings are contiguous and their lengths are equal.  Now you can change 'a' and 'b' in the first substring to 'd' and 'e' to have 'dec' and 'cde' which are anagrams.  Two changes were necessary. Function Description Complete the anagram function in the editor below.  It should return the minimum number of characters to change to make the words anagrams, or  if it's not possible.   anagram has the following parameter(s):   s: a string   Input Format The first line will contain an integer, , the number of test cases.  Each test case will contain a string  which will be concatenation of both the strings described above in the problem.  The given string will contain only characters in the range ascii[a-z]. Constraints      consists only of characters in the range ascii[a-z].   Output Format For each test case, print an integer representing the minimum number of changes required to make an anagram. Print  if it is not possible. Sample Input 6 aaabbb ab abc mnop xyyx xaxbbbxx  Sample Output 3 1 -1 2 0 1  Explanation Test Case #01: We split  into two strings ='aaa' and ='bbb'.  We have to replace all three characters from the first string with 'b' to make the strings anagrams.   Test Case #02: You have to replace 'a' with 'b', which will  generate "bb".   Test Case #03: It is not possible for two strings of unequal length to be anagrams of one another.   Test Case #04: We have to replace both the characters of first string ("mn") to make it an anagram of the other one.   Test Case #05:  and  are already anagrams of one another.   Test Case #06: Here S1 = "xaxb" and S2 = "bbxx". You must replace 'a' from S1 with 'b' so that S1 = "xbxb".
__label__Game-Theory Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as to find tactical ideas. Consider the following simplified version of chess: Board:  It's played on a  board between two players named Black and White. Rows are numbered from  to , where the top row is  and the bottom row is .   Columns are lettered from  to , where the leftmost column is  and the rightmost column is . It's played on a  board between two players named Black and White. Rows are numbered from  to , where the top row is  and the bottom row is .   Columns are lettered from  to , where the leftmost column is  and the rightmost column is . Pieces and Movement:  White initially has  pieces and Black initially has  pieces. There are no Kings on the board. Each player initially has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). White's Pawns move up the board, while Black's Pawns move down the board. Each move made by any player counts as a single move. Each piece's possible moves are the same as in classical chess, with the following exceptions: Pawns cannot move two squares forward. The en passant move is not possible. Promotion: Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  White initially has  pieces and Black initially has  pieces. There are no Kings on the board. Each player initially has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). White's Pawns move up the board, while Black's Pawns move down the board. Each move made by any player counts as a single move. Each piece's possible moves are the same as in classical chess, with the following exceptions: Pawns cannot move two squares forward. The en passant move is not possible. Pawns cannot move two squares forward. The en passant move is not possible. Promotion: Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).  The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row.  Objective:  The goal of the game is to capture the opponent’s Queen without losing your own. There will never be a draw or tie scenario like you might see in classical chess. The goal of the game is to capture the opponent’s Queen without losing your own. There will never be a draw or tie scenario like you might see in classical chess. Given  and the layout of pieces for  games, implement a very basic engine for our simplified version of chess that determines whether or not White can win in  moves (regardless of how Black plays) if White always moves first. For each game, print YES on a new line if White can win in  moves; otherwise, print NO. YES NO Input Format The first line contains an integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains three space-separated integers describing the respective values of  (the number of white pieces),  (the number of black pieces), and  (the maximum number of moves we want to know if White can win in). The  subsequent lines describe each chess piece in the form t c r, where  is a character  denoting the type of piece (where  is Queen,  is Knight,  is Bishop,  is Rook, and  is a Pawn), and  and  denote the respective column and row on the board where the figure is located (where  and ). These inputs are  given as follows:  Each of the first  lines describes the type and location of a White piece. Each of the subsequent  lines describes the type and location of a Black piece. t c r Each of the first  lines describes the type and location of a White piece. Each of the subsequent  lines describes the type and location of a Black piece. Constraints       Each player has exactly  Queen, at most  Pawns, at most  Rooks, and at most  minor pieces (i.e., a Bishop and/or Knight). It is guaranteed that the initial location of each chess piece is distinct. No pawn is initially placed in a row where it would promote. Output Format For each of the  games of simplified chess, print whether or not White can win in  moves on a new line. If it's possible, print YES; otherwise, print NO instead. YES NO Sample Input 0 Sample Output 0 Explanation 0 We play the following  game of simplified chess:  White wins by moving their Pawn to  and capturing Black's Queen, so we print YES on a new line. YES
__label__Mathematics There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.
__label__Strings International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.
__label__Array __label__Dynamic-Programming A sequence X_1, X_2, ..., X_n is fibonacci-like if:  n >= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 <= n  Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)     Example 1: Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].  Example 2: Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].    Note:  3 <= A.length <= 1000 1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.)
__label__Array Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.
__label__Binary-Search Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head nodes of two sorted linked lists. The data in both lists will be sorted in ascending order. Change the next pointers to obtain a single, merged linked list which also has data in ascending order. Either head pointer given may be null meaning that the corresponding list is empty. next Input Format You have to complete the SinglyLinkedListNode MergeLists(SinglyLinkedListNode headA, SinglyLinkedListNode headB) method which takes two arguments - the heads of the two sorted linked lists to merge. You should NOT read any input from stdin/console. SinglyLinkedListNode MergeLists(SinglyLinkedListNode headA, SinglyLinkedListNode headB) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases.  The format for each test case is as follows:   The first line contains an integer , denoting the length of the first linked list.  The next  lines contain an integer each, denoting the elements of the linked list.  The next line contains an integer , denoting the length of the second linked list.  The next  lines contain an integer each, denoting the elements of the second linked list.   Constraints    , where  is the  element of the list. Output Format Change the next pointer of individual nodes so that nodes from both lists are merged into a single list. Then return the head of this merged list. Do NOT print anything to stdout/console. next return The output is handled by the editor and the format is as follows:   For each test case, print in a new line, the linked list after merging them separated by spaces.   Sample Input 1 3 1 2 3 2 3 4  Sample Output 1 2 3 3 4   Explanation The first linked list is: 1 -> 2 -> 3 -> NULL The second linked list is: 3 -> 4 -> NULL Hence, the merged linked list is: 1 -> 2 -> 3 -> 3 -> 4 -> NULL
__label__Two-Pointers Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.     Example 1: Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation:  [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.  Example 2: Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 Output: 10 Explanation:  [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.    Note:  1 <= A.length <= 20000 0 <= K <= A.length A[i] is 0 or 1
__label__Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?
__label__Dynamic-Programming Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []
__label__Dynamic-Programming __label__Graph-Algorithms You are playing a game of Nim with a friend. The rules are are follows: 1) Initially, there are N piles of stones. Two players play alternately. 2) In each turn, a player can choose one non empty pile and remove any number of stones from it. At least one stone must be removed. 3) The player who picks the last stone from the last non empty pile wins the game. It is currently your friend's turn. You suddenly realize that if your friend was to play optimally in that position, you would lose the game. So while he is not looking, you decide to cheat and add some (possibly 0) stones to each pile. You want the resultant position to be such that your friend has no guaranteed winning strategy, even if plays optimally. You cannot create a new pile of stones. You can only add stones, and not remove stones from a pile. What is the least number of stones you need to add? Input Format The first line contains the number of cases T. T cases follow. Each case contains the number N on the first line followed by N numbers on the second line. The ith number denotes si, the number of stones in the ith pile currently. Constraints 1 <= T <= 20 2 <= N <= 15 1 <= si < 1000000000 (10^9) Output Format Output T lines, containing the answer for each case. If the current position is already losing for your friend, output 0. Sample Input 3 2 1 3 3 1 1 1 4 10 4 5 1 Sample Output 2 3 6 Explanation For the first case, add 2 stones to the first pile. Then, both piles will have 3 stones each. It is easy to verify that your friend cannot win the game unless you make a mistake. For the second case, add 1 stone to the first pile, and 2 stones to the second pile.
__label__Hash-Table __label__Two-Pointers __label__Binary-Search Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.
__label__Array __label__Hash-Table Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.  Example 1: Input: nums = [1,2,3,1], k = 3 Output: true   Example 2: Input: nums = [1,0,1,1], k = 1 Output: true   Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false
__label__Data-Structures You are a waiter at a party. There are  stacked plates on pile . Each plate has a number written on it. Then there will be  iterations. In -th iteration, you start picking up the plates in  from the top one by one and check whether the number written on the plate is divisible by the -th prime. If the number is divisible, you stack that plate on pile . Otherwise, you stack that plate on pile . After  iterations, plates can only be on pile , . Output numbers on these plates from top to bottom of each piles in order of , . Input Format The first line contains two space separated integers,  and .  The next line contains  space separated integers representing the initial pile of plates, i.e., . The leftmost value represents the bottom plate of the pile. Constraints        Output Format Output  lines. Each line contains a number written on the plate. Printing should be done in the order defined above. Sample Input 0 Sample Output 0 Explanation 0 Initially:  = [3, 4, 7, 6, 5]<-TOP After 1 iteration:  = []<-TOP  = [6, 4]<-TOP  = [5, 7, 3]<-TOP We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom. Sample Input 1 Sample Output 1 Explanation 1 Initially:  = [3, 3, 4, 4, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<-TOP  = [3, 3, 9]<-TOP After  iteration:  = []<-TOP  = [4, 4]<- TOP  = [3, 3, 9]<-TOP  We should output numbers in  first from top to bottom, and then output numbers in  from top to bottom.
__label__Dynamic-Programming There are  bulbs in a straight line, numbered from  to .  Each bulb  has a button associated with it, and there is a cost, , for pressing this button. When some button  is pressed, all the bulbs at a distance  from bulb  will be toggled(off->on, on->off).  Given , , and the costs for each button, find and print the minimum cost of turning off all  bulbs if they're all on initially. Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains  space-separated integers describing the respective costs of each bulb (i.e., ). Constraints    Output Format Print a long integer denoting the minimum cost of turning off all  bulbs. Sample Input 3 1 1 1 1  Sample Output 1  Explanation If we press the middle switch, the middle bulb and the  closest adjacent bulbs (i.e., the first and third) will turn off. Because all bulbs will be off in one button press, this cost is minimal. Thus, we print  as our answer.
__label__Dynamic-Programming Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.  For example, if the string is , the substrings are  and .  Their sum is . Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo .   Function Description Complete the substrings function in the editor below.  It should return the sum of the integer values of all substrings in a string representation of a number, modulo .   substrings has the following parameter(s):   n: the string representation of an integer   Input Format A single line containing an integer as a string without leading zeros.   Constraints  Output Format A single line which is sum of the substrings,  Sample Input 0 Sample Output 0 Explanation 0 The substring of number 16 are 16, 1 and 6 which sums to 23. 16 16, 1 6 23 Sample Input 1 Sample Output 1 Explanation 1 The sub-strings of 123 are 1, 2, 3, 12, 23, 123 which sums to 164.  123 1, 2, 3, 12, 23, 123 164
__label__Array Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1
__label__Array __label__Hash-Table Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();
__label__Array __label__Hash-Table __label__Two-Pointers Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]
__label__Strings Given a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.   Example 1: Input: S = "0110", N = 3 Output: true  Example 2: Input: S = "0110", N = 4 Output: false    Note:  1 <= S.length <= 1000 1 <= N <= 10^9
__label__Game-Theory __label__Game-Theory Two HackerRank staffers found a secret room with a mysterious  square board and decided to play a game with it. The game has the following rules: At the beginning of the game, the players write a single digit (given as input) ranging from  to  in each  cell composing the  square board.  The players move in alternating turns. In each move, the current player performs the following actions: Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions ).  Cuts the chosen board into  smaller boards by breaking it along any horizontal or vertical line at the edge of a cell. Note: Although the game starts with one  board, that board is split in two during each move. At the beginning of the  move, a player can choose any one of the  pieces of the original board (as long as it can have a legal move performed on it). The players move in alternating turns. In each move, the current player performs the following actions: Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions ).  Cuts the chosen board into  smaller boards by breaking it along any horizontal or vertical line at the edge of a cell. Note: Although the game starts with one  board, that board is split in two during each move. At the beginning of the  move, a player can choose any one of the  pieces of the original board (as long as it can have a legal move performed on it). The game ends when there are no more cuttable boards (i.e., there are  boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses. The game ends when there are no more cuttable boards (i.e., there are  boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses. Given the value of  and the respective numbers written in each  cell of the board, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Time Limit Python: 18 seconds Pypy2: 5 seconds For other languages, the time limit is standard. Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is defined as follows over the subsequent lines: An integer, , denoting the length of each of the board's sides. Each line  of the  subsequent lines contains  space-separated integers describing , where each  describes the number written in cell  of the board. Constraints    Output Format For each test case, print the name of the player with the winning strategy on a new line (i.e., either  or ). Sample Input 2 3 2 7 5 2 7 5 7 7 7 2 4 3 1 2  Sample Output Second First  Explanation We'll refer to the two players as  and . Test Case 0:  All cells contain prime numbers, so there are no valid moves available to . As  wins by default, we print  on a new line. Test Case 1:  In this test case, the two players perform the following sequence of moves:  makes a horizontal cut, splitting the board into two  boards. This is demonstrated in the following diagram:   makes a horizontal cut, splitting the board into two  boards. This is demonstrated in the following diagram:   now chooses one of the two  rectangles and cuts it vertically, splitting it into two  squares.       now chooses one of the two  rectangles and cuts it vertically, splitting it into two  squares.       chooses remaining  rectangle and cuts it vertically, splitting it into two  squares.  After the above  moves take place, the board is split into four  squares and no more moves are available for  to make. Thus,  wins and we print  on a new line.
__label__Two-Pointers __label__Greedy-Algorithms The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000
__label__Strings __label__Dynamic-Programming Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false
