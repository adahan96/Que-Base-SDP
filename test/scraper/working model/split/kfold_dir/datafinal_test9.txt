__label__Array Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.
__label__Dynamic-Programming Given an array nums of integers, you can perform operations on the array. In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1. You start with 0 points. Return the maximum number of points you can earn by applying such operations. Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.    Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.    Note:  The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].
__label__Strings We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9
__label__Data-Structures Suppose there is a circle. There are  petrol pumps on that circle. Petrol pumps are numbered  to  (both inclusive). You have two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give, and (2) the distance from that petrol pump to the next petrol pump.  Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps. The truck will move one kilometer for each litre of the petrol. Input Format The first line will contain the value of . The next  lines will contain a pair of integers each, i.e. the amount of petrol that petrol pump will give and the distance between that petrol pump and the next petrol pump. Constraints:   Output Format An integer which will be the smallest index of the petrol pump from which we can start the tour. Sample Input 3 1 5 10 3 3 4  Sample Output 1  Explanation We can start the tour from the second petrol pump.
__label__Dynamic-Programming You are working at the cash counter at a fun-fair, and you have different types of coins available to you in infinite quantities. The value of each coin is already given. Can you determine the number of ways of making change for a particular number of units using the given types of coins?  For example, if you have  types of coins, and the value of each type is given as  respectively, you can make change for  units in three ways:  , , and . Function Description  Complete the getWays function in the editor below.  It must return an integer denoting the number of ways to make change.   getWays has the following parameter(s): n: an integer, the amount to make change for   c: an array of integers representing available denominations   Input Format The first line contains two space-separated integers describing the respective values of  and , where:   is the number of units   is the number of coin types  The second line contains  space-separated integers describing the respective values of each coin type :  (the list of distinct coins available in infinite amounts). Constraints    Each  is guaranteed to be distinct. Hints Solve overlapping subproblems using Dynamic Programming (DP):      You can solve this problem recursively but will not pass all the test cases without optimizing to eliminate the overlapping subproblems. Think of a way to store and reference previously computed solutions to avoid solving the same subproblem multiple times. * Consider the degenerate cases:      - How many ways can you make change for  cents?      - How many ways can you make change for  cents if you have no coins? * If you're having trouble defining your solutions store, then think about it in terms of the base case . - The answer may be larger than a -bit integer. Output Format Print a long integer denoting the number of ways we can get a sum of  from the given infinite supply of  types of coins. Sample Input 0 Sample Output 0 Explanation 0 There are four ways to make change for  using coins with values given by :      Thus, we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 There are five ways to make change for  units using coins with values given by :        Thus, we print  as our answer.
__label__Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.
__label__Mathematics __label__Dynamic-Programming Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.
__label__Strings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.
__label__Graph-Algorithms Given an undirected weighted connected graph, find the Really Special SubTree in it. The Really Special SubTree is defined as a subgraph consisting of all the nodes in the graph and:  There is only one exclusive path from a node to every other node.  The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.   No cycles are formed To create the Really Special SubTree, always pick the edge with smallest weight. Determine if including it will create a cycle.  If so, ignore the edge.  If there are edges of equal weight available: Choose the edge that minimizes the sum  where  and  are vertices and  is the edge weight. If there is still a collision, choose any of them. Print the overall weight of the tree formed using the rules. For example, given the following edges: First choose  at weight .  Next choose  at weight .  All nodes are connected without cycles for a total weight of .   Function Description  Complete the  function in the editor below.  It should return an integer that represents the total weight of the subtree formed.   kruskals has the following parameters:   g_nodes: an integer that represents the number of nodes in the tree   g_from: an array of integers that represent beginning edge node numbers   g_to: an array of integers that represent ending edge node numbers   g_weight: an array of integers that represent the weights of each edge   Input Format The first line has two space-separated integers  and , the number of nodes and edges in the graph.   The next  lines each consist of three space-separated integers ,  and , where  and  denote the two nodes between which the undirected edge exists and  denotes the weight of that edge.   Constraints         **Note: ** If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges. Output Format Print a single integer denoting the total weight of the Really Special SubTree.
__label__Strings Given an input string, reverse the string word by word.   Example 1: Input: "the sky is blue" Output: "blue is sky the"  Example 2: Input: "  hello world!  " Output: "world! hello" Explanation: Your reversed string should not contain leading or trailing spaces.  Example 3: Input: "a good   example" Output: "example good a" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.    Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.    Follow up: For C programmers, try to solve it in-place in O(1) extra space.
__label__Greedy-Algorithms N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.
__label__Array __label__Two-Pointers Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6
__label__Dynamic-Programming You are given an integer array A.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps. You may from index i jump forward to index j (with i < j) in the following way:  During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j. During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j. (It may be the case that for some index i, there are no legal jumps.)  A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.) Return the number of good starting indexes.   Example 1: Input: [10,13,12,14,15] Output: 2 Explanation:  From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more. From starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more. From starting index i = 3, we can jump to i = 4, so we've reached the end. From starting index i = 4, we've reached the end already. In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.   Example 2: Input: [2,3,1,1,4] Output: 3 Explanation:  From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:  During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].  During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.  During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].  We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.  In a similar manner, we can deduce that: From starting index i = 1, we jump to i = 4, so we reach the end. From starting index i = 2, we jump to i = 3, and then we can't jump anymore. From starting index i = 3, we jump to i = 4, so we reach the end. From starting index i = 4, we are already at the end. In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.   Example 3: Input: [5,1,3,4,2] Output: 3 Explanation:  We can reach the end from starting indexes 1, 2, and 4.      Note:  1 <= A.length <= 20000 0 <= A[i] < 100000
__label__Binary-Search __label__Dynamic-Programming Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.  The update query is of the format i j X  This means you'd have to add a GP series to the nodes which lie in the path from node i to node j (both inclusive) with first term of the GP as X on node i and the common ratio as R (given in the input) i j X i R The retrieval query is of the format i j You need to return the sum of the node values (S) lying in the path from node i to node j modulo 100711433.  Input Format  The first line contains two integers (N and R respectively) separated by a space.  In the next N-1 lines, the ith line describes the ith edge: a line with two integers a b separated by a single space denotes an edge between a, b.  The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.  U lines follow. Each of the next U lines contains 3 space separated integers (i,j, and X respectively).  Each of the next Q lines contains 2 space separated integers, i and j respectively.  Output Format  It contains exactly Q lines and each line containing the answer of the ith query. Constraints 2 <= N <= 100000  2 <= R <= 109  1 <= U <= 100000  1 <= Q <= 100000  1 <= X <= 10  1 <= a, b, i, j <= N   Sample Input  6 2 1 2 1 4 2 6 4 5 4 3 2 2 1 6 3 5 3 5 6 4 5 1  Sample Output 31 18  Explanation The node values after the first updation becomes :   3 6 0 0 0 12    The node values after second updation becomes :   3 6 20 10 5 12    Answer to Query #1: 12 + 6 + 3 + 10 = 31  Answer to Query #2: 5 + 10 +3 = 18
__label__Graph-Algorithms There are N cities in Hacker Country. Each pair of cities are directly connected by a unique directed road, and each road has its own toll that must be paid every time it is used. You're planning a road trip in Hacker Country, and its itinerary must satisfy the following conditions:   You can start in any city. You must use  or more different roads (meaning you will visit  or more cities). At the end of your trip, you should be back in your city of origin. The average cost (sum of tolls paid per road traveled) should be minimum. Can you calculate the minimum average cost of a trip in Hacker Country? Time Limits  Time limits for this challenge are provided here. Input Format The first line is an integer,  (number of cities).  The  subsequent lines of   space-separated integers each describe the respective tolls or traveling from city  to city ; in other words, the  integer of the  line denotes the toll for traveling from city  to city .   Note: As there are no roads connecting a city to itself, the  integer of line  will always be . Constraints       Output Format Print the minimum cost as a rational number  (tolls paid over roads traveled). The greatest common divisor of  and  should be .  Sample Input 2 0 1 2 0  Sample Output 3/2  Explanation The toll from city  to city  is . The toll from  to  is . Your travel cost . Your number of roads traveled is . Thus, we print 3/2 as our answer. 3/2
__label__Mathematics Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000
__label__Graph-Algorithms Sophia is playing a game on the computer. There are two random arrays A & B, each having the same number of elements. The game begins with Sophia removing a pair (Ai, Bj) from the array if they are not co-prime. She keeps a count on the number of times this operation is done.  Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value? Input Format The first line contains an integer n. 2 lines follow, each line containing n numbers separated by a single space. The format is shown below.  n A[0] A[1] ... A[n - 1] B[0] B[1] ... B[n - 1]  Constraints 0 < n <= 105  2 <= A[i], B[i] <= 109  Each element in both arrays are generated randomly between 2 and 109 Output Format Output S which is the maximum number of times the above operation can be made. Sample Input 4 2 5 6 7 4 9 10 12  Sample Output 3  Explanation You can remove: (2, 4) (5, 10) (6, 9)  hence 3.
__label__Bit Consider an array, , of  integers ().  We take all consecutive subsequences of integers from the array that satisfy the following:   For example, if  our subsequences will be:          For each subsequence, we apply the bitwise XOR () operation on all the integers and record the resultant value. Since there are  subsequences, this will result in  numbers.    Given array , find the XOR sum of every subsequence of  and determine the frequency at which each number occurs. Then print the number and its respective frequency as two space-separated values on a single line.   Input Format The first line contains an integer, , denoting the size of the array.  Each line  of the  subsequent lines contains a single integer describing element . Constraints   Output Format Print  space-separated integers on a single line. The first integer should be the number having the highest frequency, and the second integer should be the number's frequency (i.e., the number of times it appeared). If there are multiple numbers having maximal frequency, choose the smallest one. Sample Input 0 Sample Output 0 Explanation 0 Let's find the XOR sum for all consecutive subsequences. We'll refer to the frequency of some number  as , and keep a running sum for each frequency:   , frequencies:  , frequencies:  and  , frequencies:  and  , frequencies: , , and  , frequencies: , , and  , frequencies: , , , and  , frequencies: , , , and  , frequencies: , , , and   , frequencies: , , , and   , frequencies: , , , and   Our maximal frequency is , and the integers , , and  all have this frequency. Because more than one integer has this frequency, we choose the smallest one, which is . We then print the respective smallest number having the maximal frequency and the maximal frequency as a single line of space-separated values.
__label__Greedy-Algorithms There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head node of a linked list and a specific position. Counting backwards from the tail node of the linked list, get the value of the node at the given position. A position of 0 corresponds to the tail, 1 corresponds to the node before the tail and so on. Input Format You have to complete the int getNode(SinglyLinkedListNode* head, int positionFromTail) method which takes two arguments - the head of the linked list and the position of the node from the tail. positionFromTail will be at least 0 and less than the number of nodes in the list. You should NOT read any input from stdin/console.  int getNode(SinglyLinkedListNode* head, int positionFromTail) The first line will contain an integer , the number of test cases.  Each test case has the following format:  The first line contains an integer , the number of elements in the linked list.  The next  lines contains, an element each denoting the element of the linked list.  The last line contains an integer  denoting the position from the tail, whose value needs to be found out and returned.    Constraints     , where  is the  element of the linked list.    Output Format Find the node at the given position counting backwards from the tail. Then return the data contained in this node. Do NOT print anything to stdout/console. return data The code in the editor handles output.  For each test case, print the value of the node, each in a new line.   Sample Input 2 1 1 0 3 3 2 1 2  Sample Output 1 3  Explanation In first case, there is one element in linked list with value 1. Hence, last element is 1. In second case, there are 3 elements with values 3, 2 and 1 (3 -> 2 -> 1). Hence, element with position of 2 from tail is 3.
__label__Array __label__Hash-Table Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.    Example 1: Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]    Note:  1 <= A.length <= 30000 -10000 <= A[i] <= 10000 2 <= K <= 10000
__label__Mathematics There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p
__label__Mathematics __label__Data-Structures You will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:   The elements of the first array are all factors of the integer being considered The integer being considered is a factor of all elements of the second array These numbers are referred to as being between the two arrays.  You must determine how many such numbers exist. For example, given the arrays  and , there are two numbers between them:  and .  , ,  and  for the first value.  Similarly, ,  and , .   Function Description  Complete the getTotalX function in the editor below.  It should return the number of integers that are betwen the sets.   getTotalX has the following parameter(s):   a: an array of integers   b: an array of integers   Input Format The first line contains two space-separated integers,  and , the number of elements in array  and the number of elements in array .  The second line contains  distinct space-separated integers describing  where .  The third line contains  distinct space-separated integers describing  where . Constraints    Output Format Print the number of integers that are considered to be between  and . Sample Input 2 3 2 4 16 32 96  Sample Output 3  Explanation 2 and 4 divide evenly into 4, 8, 12 and 16.  4, 8 and 16 divide evenly into 16, 32, 96.   4, 8 and 16 are the only three numbers for which each element of a is a factor and each is a factor of all elements of b.
__label__Tree Given an n-ary tree, return the postorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its postorder traversal as: [5,6,3,2,4,1].    Note: Recursive solution is trivial, could you do it iteratively?
__label__Array A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.   Example 1: Input: matrix = [   [1,2,3,4],   [5,1,2,3],   [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]". In each diagonal all elements are the same, so the answer is True.  Example 2: Input: matrix = [   [1,2],   [2,2] ] Output: False Explanation: The diagonal "[1, 2]" has different elements.   Note:  matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99].   Follow up:  What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?
__label__Dynamic-Programming In a tournament,  players play against each other exactly once. Each game results in exactly one player winning. There are no ties. You have been given a scorecard containing the scores of each player at the end of the tournament. The score of a player is the total number of games the player won in the tournament. However, the scores of some players might have been erased from the scorecard. How many possible scorecards are consistent with the input scorecard? Input Format The first line contains a single integer  denoting the number of test cases.  test cases follow.   The first line of each test case contains a single integer . The second line contains  space-separated integers .  denotes the score of the th player. If the score of the th player has been erased, it is represented by . Constraints    Output Format For each test case, output a single line containing the answer for that test case modulo .  Sample Input 0 Sample Output 0 Explanation 0 For the first case, there are 2 scorecards possible: (0,1,2) or (1,0,2).  For the second case, the valid scorecards are (1,1,1), (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0).  For the third case, the only valid scorecard is (0,1,2,3).  For the fourth case, there is no valid scorecard. It is not possible for both players to have score of 1.  For the fifth case, 6-variations of {(3,1,0)[2]}, and 3 variations each of {(2,2,0)[2]} and {(2,1,1)[2]}.
__label__Tree __label__Data-Structures You are given pointer to the root of the binary search tree and two values  and . You need to return the lowest common ancestor (LCA) of  and  in the binary search tree.     In the diagram above, the lowest common ancestor of the nodes  and  is the node .  Node  is the lowest node which has nodes  and  as descendants. Function Description  Complete the function lca in the editor below.  It should return a pointer to the lowest common ancestor node of the two values given.   lca has the following parameters:  -  root: a pointer to the root node of a binary search tree  -  v1: a node.data value  -  v2: a node.data value   Input Format The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers representing  values.  The third line contains two space-separated integers,  and .   To use the test data, you will have to create the binary search tree yourself.  Here on the platform, the tree will be created for you. Constraints       The tree will contain nodes with data equal to  and .   Output Format Return the a pointer to the node that is the lowest common ancestor of  and . Sample Input 6 4 2 3 1 7 6 1 7     and . Sample Output [reference to node 4] Explanation LCA of  and  is , the root in this case.  Return a pointer to the node.
__label__Depth-first-Search Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.
__label__Greedy-Algorithms There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
__label__Dynamic-Programming __label__Tree Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3
__label__Mathematics You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False
__label__Tree Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.
__label__Tree __label__Data-Structures A binary tree is a tree which is characterized by one of the following properties: It can be empty (null). It contains a root node only. It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees. In-order traversal is performed as Traverse the left subtree. Visit root. Traverse the right subtree. For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true: it is the first node visited, the first time visited  it is a leaf, should only be visited once   all of its subtrees have been explored, should only be visited once while this is true   it is the root of the tree, the first time visited   Swapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L. L R R L For example, in the following tree, we swap children of node 1. 1                                 Depth     1               1            [1]    / \             / \   2   3     ->    3   2          [2]    \   \           \   \     4   5           5   4        [3]  In-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4. 2 4 1 3 5 3 5 1 2 4 Swap operation:  We define depth of a node as follows: The root node is at depth 1. If the depth of the parent node is d, then the depth of current node will be d+1. d d+1 Given a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h ∈ [k, 2k, 3k,...].  In other words, if h is a multiple of k, swap the left and right subtrees of that level. k h h ∈ [k, 2k, 3k,...] h k You are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree. n [1..n] 1 t Function Description Complete the swapNodes function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation. swapNodes has the following parameter(s):  - indexes: an array of integers representing index values of each , beginning with , the first element, as the root.  - queries: an array of integers, each representing a  value. Input Format  The first line contains n, number of nodes in the tree.    n Each of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.    n a b a b Note: -1 is used to represent a null node.    -1 The next line contains an integer, t, the size of .  Each of the next t lines contains an integer , each being a value .   t t Output Format  For each k, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.   k Constraints        Either  or   Either  or   The index of a non-null child will always be greater than that of its parent.   Sample Input 0  3 2 3 -1 -1 -1 -1 2 1 1  Sample Output 0  3 1 2 2 1 3  Explanation 0 As nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.     1   [s]       1    [s]       1       / \      ->   / \        ->  / \     2   3 [s]     3   2  [s]     2   3  Note: [s] indicates that a swap operation is done at this depth. [s] Sample Input 1  5 2 3 -1 4 -1 5 -1 -1 -1 -1 1 2  Sample Output 1  4 2 1 5 3  Explanation 1 Swapping child nodes of node 2 and 3 we get     1                  1      / \                / \    2   3   [s]  ->    2   3    \   \            /   /      4   5          4   5    Sample Input 2  11 2 3 4 -1 5 -1 6 -1 7 8 -1 9 -1 -1 10 11 -1 -1 -1 -1 -1 -1 2 2 4  Sample Output 2  2 9 6 4 1 3 7 5 11 8 10 2 6 9 4 1 3 7 5 10 8 11  Explanation 2  Here we perform swap operations at the nodes whose depth is either 2 or 4 for  and then at nodes whose depth is 4 for .          1                     1                          1                      / \                   / \                        / \                    /   \                 /   \                      /   \                  2     3    [s]        2     3                    2     3                /      /                \     \                    \     \              /      /                  \     \                    \     \            4      5          ->        4     5          ->        4     5          /      / \                  /     / \                  /     / \        /      /   \                /     /   \                /     /   \      6      7     8   [s]        6     7     8   [s]        6     7     8  \          / \            /           / \              \         / \      \        /   \          /           /   \              \       /   \      9      10   11        9           11   10              9     10   11
__label__Greedy-Algorithms The city of Gridland is represented as an  matrix where the rows are numbered from  to  and the columns are numbered from  to . Gridland has a network of train tracks that always run in straight horizontal lines along a row. In other words, the start and end points of a train track are  and , where  represents the row number,  represents the starting column, and  represents the ending column of the train track.  The mayor of Gridland is surveying the city to determine the number of locations where lampposts can be placed. A lamppost can be placed in any cell that is not occupied by a train track. Given a map of Gridland and its  train tracks, find and print the number of cells where the mayor can place lampposts. Note: A train track may overlap other train tracks within the same row.  For example, if Gridland's data is the following:   In this case, there are five open cells (red) where lampposts can be placed. Function Description Complete the gridlandMetro function in the editor below.  It should return an integer that denotes the number of cells where lampposts can be installed.   gridlandMetro has the following parameter(s):   n: an integer, the number of rows in Gridland m: an integer, the number of columns in Gridland k: an integer, the number of tracks track: a 2 dimensional array of integers where each element contains  integers that represent   Input Format The first line contains three space-separated integers  and , the number of rows, columns and tracks to be mapped.    Each of the next  lines contains three space-separated integers,  and , the row number and the track column start and end.   Constraints     Output Format Print a single integer denoting the number of cells where the mayor can install lampposts. Sample Input 4 4 3 2 2 3 3 1 4 4 4 4  Sample Output 9  Explanation   In the diagram above, the yellow cells denote the first train track, green denotes the second, and blue denotes the third. Lampposts can be placed in any of the nine red cells.
__label__Mathematics Given two arrays of integers with equal lengths, return the maximum value of: |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| where the maximum is taken over all 0 <= i, j < arr1.length.   Example 1: Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6] Output: 13  Example 2: Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4] Output: 20    Constraints:  2 <= arr1.length == arr2.length <= 40000 -10^6 <= arr1[i], arr2[i] <= 10^6
__label__Strings You are given a string containing characters  and  only.  Your task is to change it into a string such that there are no matching adjacent characters. To do this, you are allowed to delete zero or more characters in the string.   Your task is to find the minimum number of required deletions. For example, given the string , remove an  at positions  and  to make  in  deletions. Function Description Complete the alternatingCharacters function in the editor below.  It must return an integer representing the minimum number of deletions to make the alternating string.   alternatingCharacters has the following parameter(s): s: a string Input Format The first line contains an integer , the number of queries.  The next  lines each contain a string . Constraints    Each string  will consist only of characters  and  Output Format For each query, print the minimum number of deletions required on a new line.   Sample Input 5 AAAA BBBBB ABABABAB BABABA AAABBB  Sample Output 3 4 0 0 4  Explanation The characters marked red are the ones that can be deleted so that the string doesn't have matching consecutive characters.
__label__Strings Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.   Example 1: Input: "/home/" Output: "/home" Explanation: Note that there is no trailing slash after the last directory name.  Example 2: Input: "/../" Output: "/" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.  Example 3: Input: "/home//foo/" Output: "/home/foo" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.  Example 4: Input: "/a/./b/../../c/" Output: "/c"  Example 5: Input: "/a/../../b/../c//.//" Output: "/c"  Example 6: Input: "/a//b////c/d//././/.." Output: "/a/b/c"
__label__Mathematics __label__Strings Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.
__label__Array Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1. Return the least number of moves to make every value in A unique.   Example 1: Input: [1,2,2] Output: 1 Explanation:  After 1 move, the array could be [1, 2, 3].   Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values.     Note:  0 <= A.length <= 40000 0 <= A[i] < 40000
__label__Dynamic-Programming __label__Strings __label__Mathematics Given a string consisting of the letters ,  and , we can perform the following operation:  Take any two adjacent distinct characters and replace them with the third character.  Find the shortest string obtainable through applying this operation repeatedly.   For example, given the string  we can reduce it to a  character string by replacing  with  and  with : .   Function Description  Complete the stringReduction function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.   stringReduction has the following parameter:  - s: a string   Input Format The first line contains the number of test cases .   Each of the next  lines contains a string  to process. Constraints   Output Format For each test case, print the length of the resultant minimal string on a new line.   Sample Input 3   cab   bcab   ccccc  Sample Output 2   1   5  Explanation For the first case, there are two solutions:   or .  For the second case, one optimal solution is: .  For the third case, no operations can be performed so the answer is .
__label__Tree __label__Depth-first-Search Given the root of a binary tree, each node in the tree has a distinct value. After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees). Return the roots of the trees in the remaining forest.  You may return the result in any order.   Example 1:  Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]]    Constraints:  The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length <= 1000 to_delete contains distinct values between 1 and 1000.
__label__Hash-Table You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.   Example: Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:
__label__Depth-first-Search You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.
__label__Strings Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]
__label__Search is a chess piece that moves in an L shape. We define the possible moves of  as any movement from some position  to some  satisfying either of the following: L  and , or    and   Note that  and  allow for the same exact set of movements. For example, the diagram below depicts the possible locations that  or  can move to from its current location at the center of a  chessboard:  Observe that for each possible movement, the Knight moves  units in one direction (i.e., horizontal or vertical) and  unit in the perpendicular direction. Given the value of  for an  chessboard, answer the following question for each  pair where : What is the minimum number of moves it takes for  to get from position  to position ? If it's not possible for the Knight to reach that destination, the answer is -1 instead. -1 Then print the answer for each  according to the Output Format specified below. Input Format A single integer denoting . Constraints  Output Format Print exactly  lines of output in which each line  (where ) contains  space-separated integers describing the minimum number of moves  must make for each respective  (where ). If some  cannot reach position , print -1 instead.   -1 For example, if , we organize the answers for all the  pairs in our output like this: (1,1) (1,2) (2,1) (2,2)  Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts possible minimal paths for , , and :  One minimal path for  is:   We then print 4 4 2 8 as our first line of output because  took  moves,  took  moves,  took  moves, and  took  moves.  4 4 2 8 In some of the later rows of output, it's impossible for  to reach position . For example,  can only move back and forth between  and  so it will never reach .
__label__Tree Print a binary tree in an m*n 2D string array following these rules:   The row number m should be equal to the height of the given binary tree. The column number n should always be an odd number. The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them.  Each unused space should contain an empty string "". Print the subtrees following the same rules.  Example 1: Input:      1     /    2 Output: [["", "1", ""],  ["2", "", ""]]   Example 2: Input:      1     / \    2   3     \      4 Output: [["", "", "", "1", "", "", ""],  ["", "2", "", "", "", "3", ""],  ["", "", "4", "", "", "", ""]]   Example 3: Input:       1      / \     2   5    /    3   /  4  Output:  [["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]  ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]  ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]  ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]   Note: The height of binary tree is in the range of [1, 10].
__label__Data-Structures Consider an -integer sequence, . We perform a query on  by using an integer, , to calculate the result of the following expression:   In other words, if we let , then you need to calculate .   Given  and  queries (each query consists of an integer, ), print the result of each query on a new line. Input Format The first line consists of two space-separated integers describing the respective values of  and .  The second line consists of  space-separated integers describing the respective values of .  Each of the  subsequent lines contains a single integer denoting the value of  for that query.  Constraints     Output Format For each query, print an integer denoting the query's answer on a new line. After completing all the queries, you should have printed  lines. Sample Input 0 Sample Output 0 Explanation 0 For , the answer is   Sample Input 1 Sample Output 1 Explanation 1 For each query, the "prefix" has the least maximum value among the consecutive subsequences of the same size.
__label__Mathematics Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Strings Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
__label__Depth-first-Search Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]
__label__Tree Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.  Example 1:  Given tree s:      3     / \    4   5   / \  1   2  Given tree t:    4    / \  1   2  Return true, because t has the same structure and node values with a subtree of s.  Example 2:  Given tree s:      3     / \    4   5   / \  1   2     /    0  Given tree t:    4   / \  1   2  Return false.
__label__Hash-Table __label__Mathematics The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.
__label__Strings __label__Mathematics __label__Data-Structures A border of a string is a proper prefix of it that is also a suffix. For example: a and abra are borders of abracadabra, a abra abracadabra kan and kankan are borders of kankankan.  kan kankan kankankan de is a border of decode.  de decode Note that decode is not a border of decode because it's not proper. decode decode A palindromic border is a border that is palindromic. For example, a and ana are palindromic borders of anabanana,  a ana anabanana l, lol and lolol are palindromic borders of lololol. l lol lolol lololol Let's define  as the number of palindromic borders of string . For example, if  lololol, then .  lololol Now, a string of length  has exactly  non-empty substrings (we count substrings as distinct if they are of different lengths or are in different positions, even if they are the same string). Given a string , consisting only of the first 8 lowercase letters of the English alphabet, your task is to find the sum of  for all the non-empty substrings  of . In other words, you need to find:   Since the answer can be very large, output the answer modulo . Input Format  The first line contains a string consisting of  characters. Output Format  Print a single integer: the remainder of the division of the resulting number by . Constraints    All characters in the string can be any of the first 8 lowercase letters of the English alphabet (abcdefgh).   abcdefgh Sample Input 1  ababa  Sample Output 1  5  Sample Input 2  aaaa  Sample Output 2  10  Sample Input 3  abcacb  Sample Output 3  3  Explanation   ababa has 15 substrings but only 4 substrings have palindromic borders.   ababa  aba    ababa    bab    aba   aba ababa bab aba
__label__Strings Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50
__label__Tree Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.
__label__Mathematics Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
__label__Hash-Table __label__Mathematics Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i >= 0 and j >= 0. Return a list of all powerful integers that have value less than or equal to bound. You may return the answer in any order.  In your answer, each value should occur at most once.    Example 1: Input: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation:  2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2   Example 2: Input: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14]      Note:  1 <= x <= 100 1 <= y <= 100 0 <= bound <= 10^6
__label__Greedy-Algorithms Priyanka works for an international toy company that ships by container.  Her task is to the determine the lowest cost way to combine her orders for shipping.  She has a list of item weights.  The shipping company has a requirement that all items loaded in a container must weigh less than or equal to 4 units plus the weight of the minimum weight item.  All items meeting that requirement will be shipped in one container. What is the smallest number of containers that can be contracted to ship the items based on the given list of weights? For example, there are items with weights .  This can be broken into two containers:  and .  Each container will contain items weighing within  units of the minimum weight item.   Function Description  Complete the toys function in the editor below.  It should return the minimum number of containers required to ship.   toys has the following parameter(s):   w: an array of integers that represent the weights of each order to ship   Input Format The first line contains an integer , the number of orders to ship.  The next line contains  space-separated integers, ,  representing the orders in a weight array. Constraints     Output Format Return the integer value of the number of containers Priyanka must contract to ship all of the toys.  Sample Input 8 1 2 3 21 7 12 14 21  Sample Output 4  Explanation The first container holds items weighing ,  and . (weights in range )  The second container holds the items weighing  units. ()  The third container holds the item weighing  units.  ()  The fourth container holds the items weighing  and  units. ()    containers are required.
__label__Depth-first-Search On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone. Now, a move consists of removing a stone that shares a column or row with another stone on the grid. What is the largest possible number of moves we can make?    Example 1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5   Example 2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3   Example 3: Input: stones = [[0,0]] Output: 0    Note:  1 <= stones.length <= 1000 0 <= stones[i][j] < 10000
__label__Data-Structures Alexa has two stacks of non-negative integers, stack  and stack  where index  denotes the top of the stack. Alexa challenges Nick to play the following game: In each move, Nick can remove one integer from the top of either stack  or stack . Nick keeps a running sum of the integers he removes from the two stacks. Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer  given at the beginning of the game. Nick's final score is the total number of integers he has removed from the two stacks. Given , , and  for  games, find the maximum possible score Nick can achieve (i.e., the maximum number of integers he can remove without being disqualified) during each game and print it on a new line. Input Format The first line contains an integer,  (the number of games). The  subsequent lines describe each game in the following format: The first line contains three space-separated integers describing the respective values of  (the number of integers in stack ),  (the number of integers in stack ), and  (the number that the sum of the integers removed from the two stacks cannot exceed). The second line contains  space-separated integers describing the respective values of . The third line contains  space-separated integers describing the respective values of . Constraints     Subtasks  for  of the maximum score. Output Format For each of the  games, print an integer on a new line denoting the maximum possible score Nick can achieve without being disqualified. Sample Input 0 Sample Output 0 Explanation 0 The two stacks initially look like this:  The image below depicts the integers Nick should choose to remove from the stacks. We print  as our answer, because that is the maximum number of integers that can be removed from the two stacks without the sum exceeding .  (There can be multiple ways to remove the integers from the stack, the image shows just one of them.)
__label__Array __label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Dynamic-Programming There are N users registered on a website CuteKittens.com. Each of them has a unique password represented by pass[1], pass[2], ..., pass[N]. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin does not want the site to be available to the general public, so only those people who have passwords can access it. Yu, being an awesome hacker finds a loophole in the password verification system. A string which is a concatenation of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear  or more times in that string. Given access to each of the  passwords, and also have a string loginAttempt$ string can be created by concatenating password strings, it is accepted. For example, if there are 3 users with , then some of the valid combinations are abra , kaabra , kadabraka , kadabraabra  and so on.  Supplying abra ka dabra, concatenated, passes authentication. abra kaabra kadabraka kadabraabra abra ka dabra Function Description Complete the passwordCracker function in the editor below.  It should return the passwords as a single string in the order required for the password to be accepted, each separated by a space. If it is not possible to form the string, return the string WRONG PASSWORD.   WRONG PASSWORD passwordCracker has the following parameters:  - passwords: a list of password strings  - loginAttempt: the string to attempt to create   Input Format The first line contains an integer t, the total number of test cases.   Each of the next  sets of three lines is as follows:  - The first line of each test case contains n, the number of users with passwords.  - The second line contains n space-separated strings, passwords[i], that represent  the passwords of each user.  - The third line contains a string, loginAttempt, which Yu must test for acceptance.   Constraints       , where     loginAttempt and passwords[i] contain only lowercase latin characters ('a'-'z'). Output Format For each valid string, Yu has to print the actual order of passwords, separated by space, whose concatenation results into loginAttempt. If there are multiple solutions, print any of them.  If loginAttempt can't be accepted by the password verification system, then print WRONG PASSWORD. WRONG PASSWORD Sample Input 0 Sample Output 0 Explanation 0 Sample Case #00: "wedowhatwemustbecausewecan" is the concatenation of passwords {"we", "do", "what", "we", "must", "because", "we", "can"}. That is  "wedowhatwemustbecausewecan" "we" "do" "what" "we" "must" "because" "we" "can" loginAttempt = pass[5] + pass[3] + pass[6] + pass[5] +  pass[4] + pass[1] + pass[5] + pass[2]  Note that any password can repeat any number of times.   Sample Case #01: We can't create string "helloworld" using the strings {"hello", "planet"}.   "helloworld" "hello" "planet" Sample Case #02: There are two ways to create loginAttempt ("abcd"). Both pass[2] = "abcd" and pass[1] + pass[3] = "ab cd" are valid answers. "abcd" pass[2] = "abcd" pass[1] + pass[3] = "ab cd" Sample Input 1 Sample Output 1
__label__Array We write the integers of A and B (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:  A[i] == B[j]; The line we draw does not intersect any other connecting (non-horizontal) line.  Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line. Return the maximum number of connecting lines we can draw in this way.   Example 1:  Input: A = [1,4,2], B = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.   Example 2: Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2] Output: 3   Example 3: Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1] Output: 2     Note:  1 <= A.length <= 500 1 <= B.length <= 500 1 <= A[i], B[i] <= 2000
__label__Data-Structures __label__Advanced-Data-Structures Roy has taken a liking to the Binary Search Trees(BST). He is interested in knowing the number of ways an array  of  integers can be arranged to form a BST. Thus, he tries a few combinations, and notes down the numbers at the odd levels and the numbers at the even levels.  You're given two values, alpha and beta. Can you calculate the sum of Liking of all possible BST's that can be formed from an array of  integers? Liking of each BST is defined as follows  (sum of numbers on even levels * alpha) - (sum of numbers on odd levels * beta)  Note  The root element is at level  ( Even ) The elements smaller or equal to the parent element are present in the left subtree, elements greater than or equal to the parent element are present in the right subtree.  Explained here If the answer is no less than , output the answer % .  (If the answer is less than , keep adding  until the value turns non negative.) Input Format  The first line of input file contains an integer, , denoting the number of test cases to follow.  Each testcase comprises of  lines.  The first line contains , the number of integers.  The second line contains two space separated integers, alpha and beta.  The third line contains space separated  integers_, denoting the  integer in array .   Output Format  Output  lines. Each line contains the answer to its respective test case.  Constraints          Sample Input Sample Output Explanation There are  test cases in total.  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  For the first test case, only  BST can be formed with 1 as the root node. Hence the Liking / sum is .  1 For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the second test case, we get 2 BSTs of the form, the Liking of the first tree is  and , this sums to , hence the answer.  For the third test case, we get  BSTs. The Liking of each of the BST from left  to right are  which sums to  and hence the answer.   Similarly, for the fourth test case, the answer is .
__label__Mathematics __label__Game-Theory HackerChess is a variant of chess played at HackerRank. It is a game played between two players who make moves in turns until one of them cannot make any move. The player who cannot make a move loses the game and the other player is declared the winner. The game is played on a board with  rows and  columns. The only pieces used in the game are rooks. A rook in HackerChess moves only vertically, which means that in never leaves a column to which it belongs. Moreover, in a single move, a rook moves through any number of unoccupied cells. Notice that there are no captures in HackerChess, two rooks cannot occupy the same cell, and a rook cannot jump over another rook. Each player has exactly one rook in each of the  columns of the board. Given the initial position of the rooks and knowing that the second player makes the first move, decide who will win the game if both players play optimally. Input Format In the first line, there is a single integer  denoting the number of games to be played. After that, descriptions of  games follow: In the first line, there is a single integer  denoting the size of the board. Next,  lines follow. In the -th of them there is a single integer  denoting the row of the rook belonging to the first player placed in the -th column. After that, another  lines follow. In the -th of them there is a single integer  denoting the row of the rook belonging to the second player placed in the -th column. Constraints      Output Format Print exactly  lines. In the -th of them, print player-1 if the first player will win the -th game. Otherwise, print player-2 in this line. player-1 player-2 Sample Input 0 Sample Output 0 Explanation 0 There is only one game player in the sample input. The game is played on the board with  rows and  columns. Let's denote the first player's rooks as red rooks and the second player's rooks as green ones. Then the initial position of the game looks like this:  The second player moves first and he can move his rook in the first column to the second row. After this move, the position looks as follows:  Next, it is the first player's turn. He cannot make any move with his rook in the first column, so he has to make a move in the second or the third column. Without the loss of generality, let's assume that he makes a move in the second column. He can only make one such move, i.e. move the rook from the second to the third row. This results in the following position:  After that, the best move for the second player is to move his rook in the second column from the first to the second row. After this move, the position looks like this:  Next, it is again the first player's move. The only move he can make is to move his rook in the third column from the second to the third row. It results in the following position:  Then, the best move for the second player is to move his rook in the third column from the first to the second row. After that, the position looks as follows:  Next, it is the first player's move, but since he is unable to make any valid move, he loses and the second player is declared a winner. It shows that regardless of the first player's moves, the second player has a strategy leading to his victory. Sample Input 1 Sample Output 1 Explanation 1 Second player cannot make a move so  is the winner.
__label__Dynamic-Programming A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target
__label__Mathematics Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".
__label__Array __label__Hash-Table Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,  Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].
__label__Dynamic-Programming Nina received an odd New Year's present from a student: a set of  unbreakable sticks. Each stick has a length, , and the length of the  stick is . Deciding to turn the gift into a lesson, Nina asks her students the following: How many ways can you build a square using exactly  of these unbreakable sticks?  Note: Two ways are distinct if they use at least one different stick. As there are  choices of sticks, we must determine which combinations of sticks can build a square. Input Format The first line contains an integer, , denoting the number of sticks. The second line contains  space-separated integers  describing the length of each stick in the set. Constraints   Output Format On a single line, print an integer representing the number of ways that  unbreakable sticks can be used to make a square. Sample Input 0 8 4 5 1 5 1 9 4 5   Sample Output 0 3  Sample Input 1 6 1 2 3 4 5 6   Sample Output 1 0      Explanation Sample 0  Given  sticks (), the only possible side length for our square is . We can build square  in  different ways:         In order to build a square with side length  using exactly  sticks,  and  must always build two of the sides. For the remaining two sides, you must choose  of the remaining  sticks of length  ( and ). Sample 1  We have to use all  sticks, making the largest stick length () the minimum side length for our square. No combination of the remaining sticks can build  more sides of length  (total length of all other sticks is  and we need at least length ), so we print .
__label__Array __label__Mathematics Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]
__label__Mathematics __label__Dynamic-Programming Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.    Example 1: Input: 20 Output: 1 Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.   Example 2: Input: 100 Output: 10 Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.   Example 3: Input: 1000 Output: 262     Note:  1 <= N <= 10^9
__label__Array Given an array A, we can perform a pancake flip: We choose some positive integer k <= A.length, then reverse the order of the first k elements of A.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A. Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.   Example 1: Input: [3,2,4,1] Output: [4,2,4,3] Explanation:  We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: A = [3, 2, 4, 1] After 1st flip (k=4): A = [1, 4, 2, 3] After 2nd flip (k=2): A = [4, 1, 2, 3] After 3rd flip (k=4): A = [3, 2, 1, 4] After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted.    Example 2: Input: [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted.     Note:  1 <= A.length <= 100 A[i] is a permutation of [1, 2, ..., A.length]
__label__Hash-Table Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:  Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.  Empty cells are indicated by the character '.'.  A sudoku puzzle...  ...and its solution numbers marked in red. Note:  The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9.
__label__Dynamic-Programming There are  pairs of hard disk drives (HDDs) in a cluster. Each HDD is located at an integer coordinate on an infinite straight line, and each pair consists of one primary HDD and one backup HDD. Next, you want to place  computers at integer coordinates on the same infinite straight line. Each pair of HDDs must then be connected to a single computer via wires, but a computer can have any number (even zero) of HDDs connected to it. The length of a wire connecting a single HDD to a computer is the absolute value of the distance between their respective coordinates on the infinite line. We consider the total length of wire used to connect all the HDDs to computers to be the sum of the lengths of all the wires used to connect HDDs to computers. Note that both the primary and secondary HDDs in a pair must connect to the same computer. Given the locations of  pairs (i.e., primary and backup) of HDDs and the value of , place all  computers in such a way that the total length of wire needed to connect each pair of HDDs to computers is minimal. Then print the total length on a new line. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of pairs of HDDs) and  (the number of computers).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  (coordinate of the primary HDD) and  (coordinate of the backup HDD) for a pair of HDDs. Constraints       Output Format Print a single integer denoting the minimum total length of wire needed to connect all the pairs of HDDs to computers. Sample Input 5 2 6 7 -1 1 0 1 5 2 7 3  Sample Output 13  Explanation For the given Sample Case, it's optimal to place computers at positions  and  on our infinite line. We then connect the second () and the third () pairs of HDDs to the first computer (at position ) and then connect the remaining pairs to the second computer (at position ).     We calculate the wire lengths needed to connect the drives to each computer. The amount of wire needed to connect the second and third drives to the first computer is , and the amount of wire needed to connect the rest of the drives to the second computer is . When we sum the lengths of wire needed to connect all pairs of drives to the two computers, we get a total length of . Thus, we print  as our answer.
__label__Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13
__label__Depth-first-Search In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1
__label__Array __label__Dynamic-Programming A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:  For i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even; OR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.  That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. Return the length of a maximum size turbulent subarray of A.    Example 1: Input: [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: (A[1] > A[2] < A[3] > A[4] < A[5])   Example 2: Input: [4,8,12,16] Output: 2   Example 3: Input: [100] Output: 1       Note:  1 <= A.length <= 40000 0 <= A[i] <= 10^9
__label__Data-Structures __label__Advanced-Data-Structures Jim has invented a new flying object called HZ42. HZ42 is like a broom and can only fly horizontally, independent of the environment. One day, Jim started his flight from Dubai's highest skyscraper, traveled some distance and landed on another skyscraper of same height! So much fun! But unfortunately, new skyscrapers have been built recently. Let us describe the problem in one dimensional space. We have in total  skyscrapers aligned from left to right. The th skyscraper has a height of . A flying route can be described as  with , which means, Jim starts his HZ42 at the top of the skyscraper  and lands on the skyscraper . Since HZ42 can only fly horizontally, Jim will remain at the height  only. Thus the path  can be valid, only if each of the skyscrapers  is not strictly greater than  and if the height of the skyscraper he starts from and arrives on have the same height. Formally,  is valid iff  and . Help Jim in counting the number of valid paths represented by ordered pairs .   Input Format The first line contains , the number of skyscrapers. The next line contains  space separated integers representing the heights of the skyscrapers.  Output Format Print an integer that denotes the number of valid routes. Constraints  and no skyscraper will have height greater than  and less than . Sample Input #00 6 3 2 1 2 3 3  Sample Output #00 8  Sample Input #01 3 1 1000 1  Sample Output #01 0  Explanation First testcase: (1, 5), (1, 6) (5, 6) and (2, 4) and the routes in the opposite directions are the only valid routes.  Second testcase: (1, 3) and (3, 1) could have been valid, if there wasn't a big skyscraper with height 1000 between them.
__label__Data-Structures Given a  2D Array, :  1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  We define an hourglass in  to be a subset of values with indices falling in this pattern in 's graphical representation: a b c   d e f g  There are  hourglasses in , and an hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. For example, given the 2D array: -9 -9 -9  1 1 1   0 -9  0  4 3 2 -9 -9 -9  1 2 3  0  0  8  6 6 0  0  0  0 -2 0 0  0  0  1  2 4 0  We calculate the following  hourglass values: -63, -34, -9, 12,  -10, 0, 28, 23,  -27, -11, -2, 10,  9, 17, 25, 18  Our highest hourglass value is  from the hourglass: 0 4 3   1 8 6 6  Note: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge. Function Description Complete the function hourglassSum in the editor below.  It should return an integer, the maximum hourglass sum in the array.   hourglassSum has the following parameter(s): arr: an array of integers  Input Format Each of the  lines of inputs  contains  space-separated integers . Constraints    Output Format Print the largest (maximum) hourglass sum found in . Sample Input 1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 2 4 4 0 0 0 0 2 0 0 0 0 1 2 4 0  Sample Output 19  Explanation  contains the following hourglasses:   The hourglass with the maximum sum () is: 2 4 4   2 1 2 4
__label__Array A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.
__label__Dynamic-Programming In the middle of a nightmare, Maxine suddenly finds herself in a mysterious room with the following items:  A piece of paper with the word score and the integer  written on it. A map of the castle where the room is located. There are  rooms uniquely labeled from  to .   There are  bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction. Every room is reachable from every other room.   Maxine is located in the room labeled .   The exit is located in the room labeled . Once this room is reached, score is reduced modulo  and Maxine can (but is not required to) exit that level!  There are  rooms uniquely labeled from  to .   There are  bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction. Every room is reachable from every other room.   Maxine is located in the room labeled .   The exit is located in the room labeled . Once this room is reached, score is reduced modulo  and Maxine can (but is not required to) exit that level!  Assume some corridor  (where ) is associated with an integer, , and connects rooms  and . Then: Traveling corridor  from room  to room  increases score by . Traveling corridor  from room  to room  decreases score by .  There are  levels to Maxine's nightmare castle, and each one has a different set of values for , , and . Given the above information, help Maxine by finding and printing her maximum possible score for each level. Only you can help her wake up from this nightmare! Note: Recall that the result of a modulo operation is always non-negative.  For example, .   Input Format The first line contains a single integer, , denoting the number of rooms.  Each of the  subsequent lines describes a corridor in the form of three space-separated integers denoting the respective values for , , and .  The next line contains a single integer, , denoting the number of queries.  Each of the  subsequent lines describes a level in the form of three space-separated integers denoting its respective , , and  values.  Constraints   ,       For each level: The room layout is the same     Subtask  for  of max score. Output Format For each of the  levels, print the maximum possible score for that level on a new line. Sample Input 3 1 3 5 2 3 8 2 1 31 1 1 2 13  Sample Output 12  Explanation The Sample Input represents the following setup:    We want to travel from room  to room  while maximizing the value of score. There are at least two ways to achieve the maximum score value of :   Travel through corridors  times:   .   Travel through corridors  times:   .   Travel through corridors  times:   , because  is the smallest non-negative integer  such that  divides .   Travel through corridors  times:   , because  is the smallest non-negative integer  such that  divides .
__label__Array You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps.   Example 1: Input: s = "dcab", pairs = [[0,3],[1,2]] Output: "bacd" Explaination:  Swap s[0] and s[3], s = "bcad" Swap s[1] and s[2], s = "bacd"  Example 2: Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]] Output: "abcd" Explaination:  Swap s[0] and s[3], s = "bcad" Swap s[0] and s[2], s = "acbd" Swap s[1] and s[2], s = "abcd" Example 3: Input: s = "cba", pairs = [[0,1],[1,2]] Output: "abc" Explaination:  Swap s[0] and s[1], s = "bca" Swap s[1] and s[2], s = "bac" Swap s[0] and s[1], s = "abc"     Constraints:  1 <= s.length <= 10^5 0 <= pairs.length <= 10^5 0 <= pairs[i][0], pairs[i][1] < s.length s only contains lower case English letters.
__label__Graph-Algorithms You are a real estate broker in ancient Knossos. You have  unsold houses, and each house  has an area, , and a minimum price, . You also have  clients, and each client  wants a house with an area greater than  and a price less than or equal to . Each client can buy at most one house, and each house can have at most one owner. What is the maximum number of houses you can sell? Input Format The first line contains two space-separated integers describing the respective values of  (the number of clients) and  (the number of houses).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for client .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for house . Constraints  , where . , where . Output Format Print a single integer denoting the maximum number of houses you can sell. Sample Input 0 Sample Output 0 Explanation 0 Recall that each client  is only interested in some house  where  and . The diagram below depicts which clients will be interested in which houses:  Client  will be interested in house  because it has more than  units of space and costs less than . Both of the other houses are outside of this client's price range. Client  will be interested in houses  and , as both these houses have more than  units of space and cost less than . They will not be interested in the remaining house because it's too small. Client  will be interested in house  because it has more than  units of space and costs less than . They will not be interested in the other two houses because they are too small. All three clients are interested in the same two houses, so you can sell at most two houses in the following scenarios:    Client  buys house  and client  buys house . Client  buys house  and client  buys house . Client  buys house  and client  buys house . Thus, we print the maximum number of houses you can sell, , on a new line.
__label__Data-Structures __label__Advanced-Data-Structures Our lazy white falcon finally decided to learn heavy-light decomposition. Her teacher gave an assignment for her to practice this new technique. Please help her by solving this problem.  You are given a tree with  nodes and each node's value is initially . The problem asks you to operate the following two types of queries: "1 u x" assign  to the value of the node . "2 u v" print the maximum value of the nodes on the unique path between  and . Input Format First line consists of two integers seperated by a space:  and . Following  lines consisting of two integers denotes the undirectional edges of the tree.  Following  lines consist of the queries you are asked to operate.  Constraints  It is guaranteed that input denotes a connected tree with  nodes. Nodes are enumerated with 0-based indexing. Output Format For each second type of query print single integer in a single line, denoting the asked maximum value. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 2  Explanation After the first two updates value of the th node is  and st node is . That is why maxiumum value on the path between  and  is .
__label__Mathematics Every non-negative integer N has a binary representation.  For example, 5 can be represented as "101" in binary, 11 as "1011" in binary, and so on.  Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  For example, the complement of "101" in binary is "010" in binary. For a given number N in base-10, return the complement of it's binary representation as a base-10 integer.      Example 1: Input: 5 Output: 2 Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.   Example 2: Input: 7 Output: 0 Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.   Example 3: Input: 10 Output: 5 Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.    Note:  0 <= N < 10^9
__label__Strings __label__Data-Structures Sherlock considers a string to be valid if all characters of the string appear the same number of times.  It is also valid if he can remove just  character at  index in the string, and the remaining characters will occur the same number of times.  Given a string , determine if it is valid.  If so, return YES, otherwise return NO. YES NO For example, if , it is a valid string because frequencies are .  So is  because we can remove one  and have  of each character in the remaining string.  If  however, the string is not valid as we can only remove  occurrence of .  That would leave character frequencies of .   Function Description  Complete the isValid function in the editor below.  It should return either the string YES or the string NO.   YES NO isValid has the following parameter(s):   s: a string   Input Format A single string . Constraints   Each character  Output Format Print YES if string  is valid, otherwise, print NO. YES NO Sample Input 0 Sample Output 0 Explanation 0 Given , we would need to remove two characters, both c and d  aabb or a and b  abcd, to make it valid. We are limited to removing only one character, so  is invalid. c d aabb a b abcd Sample Input 1 Sample Output 1 Explanation 1 Frequency counts for the letters are as follows:   {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 1, 'g': 1, 'h': 1, 'i': 1} {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 1, 'g': 1, 'h': 1, 'i': 1} There are two ways to make the valid string: Remove  characters with a frequency of : .    Remove  characters of frequency : .   Neither of these is an option. Sample Input 2 Sample Output 2 Explanation 2 All characters occur twice except for  which occurs  times.  We can delete one instance of  to have a valid string.
__label__Dynamic-Programming __label__Mathematics Mr K has a rectangular plot of land which may have marshes where fenceposts cannot be set. He wants you to find the perimeter of the largest rectangular fence that can be built on this land. For example, in the following  grid,  marks a marsh and  marks good land. .... ..x. ..x. x...  If we number the rows and columns starting with , we see that there are two main areas that can be fenced:  and .  The longest perimeter is .   Function Description Complete the kMarsh function in the editor below.  It should print either an integer or impossible. impossible kMarsh has the following parameter(s):   grid: an array of strings that represent the grid   Input Format The first line contains two space-separated integers  and , the grid rows and columns.  Each of the next  lines contains  characters each describing the state of the land. 'x' (ascii value: 120) if it is a marsh and '.' ( ascii value:46) otherwise.   Constraints   Output Format Output contains a single integer - the largest perimeter. If the rectangular fence cannot be built, print impossible. Sample Input 0 4 5 ..... .x.x. ..... .....  Sample Output 0 14  Explanation 0  The fence can be put up around the entire field. The perimeter is . Sample Input 1 2 2 .x x.  Sample Output 1 impossible  Explanation 1 We need a minimum of 4 points to place the 4 corners of the fence. Hence, impossible.  Sample Input 2 2 5 ..... xxxx.  Sample Output 2 impossible
__label__Tree Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.
__label__Dynamic-Programming A tree, , has  vertices numbered from  to  and is rooted at vertex . Each vertex  has an integer weight, , associated with it, and 's total weight is the sum of the weights of its nodes. A single remove operation removes the subtree rooted at some arbitrary vertex  from tree .  Given , perform up to  remove operations so that the total weight of the remaining vertices in  is maximal. Then print 's maximal total weight on a new line. Note: If 's total weight is already maximal, you may opt to remove  nodes. Input Format The first line contains two space-separated integers,  and , respectively.  The second line contains  space-separated integers describing the respective weights for each node in the tree, where the  integer is the weight of the  vertex.  Each of the  subsequent lines contains a pair of space-separated integers,  and , describing an edge connecting vertex  to vertex .   Constraints       Output Format Print a single integer denoting the largest total weight of 's remaining vertices. Sample Input 5 2 1 1 -1 -1 -1 1 2 2 3 4 1 4 5  Sample Output 2  Explanation We perform  remove operations:  Remove the subtree rooted at node . Losing this subtree's  weight increases the tree's total weight by .  Remove the subtree rooted at node . Losing this subtree's  weight increases the tree's total weight by .  The sum of our remaining positively-weighted nodes is , so we print  on a new line.
__label__Array __label__Two-Pointers Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3,  Your function should return length = 2, with the first two elements of nums being 2.  It doesn't matter what you leave beyond the returned length.  Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2,  Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.  Note that the order of those five elements can be arbitrary.  It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.
__label__Hash-Table Given words first and second, consider occurrences in some text of the form "first second third", where second comes immediately after first, and third comes immediately after second. For each such occurrence, add "third" to the answer, and return the answer.   Example 1: Input: text = "alice is a good girl she is a good student", first = "a", second = "good" Output: ["girl","student"]   Example 2: Input: text = "we will we will rock you", first = "we", second = "will" Output: ["we","rock"]    Note:  1 <= text.length <= 1000 text consists of space separated words, where each word consists of lowercase English letters. 1 <= first.length, second.length <= 10 first and second consist of lowercase English letters.
__label__Hash-Table In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times.      Example 1: Input: [1,2,3,3] Output: 3   Example 2: Input: [2,1,2,5,3,2] Output: 2   Example 3: Input: [5,1,5,2,5,3,5,4] Output: 5    Note:  4 <= A.length <= 10000 0 <= A[i] < 10000 A.length is even
__label__Data-Structures Tieu owns a pizza restaurant and he manages it in his own way.  While in a normal restaurant, a customer is served by following the first-come, first-served rule, Tieu simply minimizes the average waiting time of his customers. So he gets to decide who is served first, regardless of how sooner or later a person comes.  Different kinds of pizzas take different amounts of time to cook. Also, once he starts cooking a pizza, he cannot cook another pizza until the first pizza is completely cooked. Let's say we have three customers who come at time t=0, t=1, & t=2 respectively, and the time needed to cook their pizzas is 3, 9, & 6 respectively. If Tieu applies first-come, first-served rule, then the waiting time of three customers is 3, 11, & 16  respectively. The average waiting time in this case is (3 + 11 + 16) / 3 = 10. This is not an optimized solution. After serving the first customer at time t=3, Tieu can choose to serve the third customer. In that case, the waiting time will be 3, 7, & 17 respectively. Hence the average waiting time is (3 + 7 + 17) / 3 = 9. Help Tieu achieve the minimum average waiting time. For the sake of simplicity, just find the integer part of the minimum average waiting time. Input Format The first line contains an integer N, which is the number of customers.  In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   The  customer is not the customer arriving at the  arrival time.  The  customer is not the customer arriving at the  arrival time.  Output Format Display the integer part of the minimum average waiting time. Constraints 1 ≤ N ≤ 105 0 ≤ Ti ≤ 109 1 ≤ Li ≤ 109 Note The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. Cook does not know about the future orders. Cook does not know about the future orders. Sample Input #00 3 0 3 1 9 2 6  Sample Output #00 9  Sample Input #01 3 0 3 1 9 2 5  Sample Output #01 8  Explanation #01 Let's call the person ordering at time = 0 as A, time = 1 as B and time = 2 as C. By delivering pizza for A, C and B we get the minimum average wait time to be  (3 + 6 + 16)/3 = 25/3 = 8.33   the integer part is 8 and hence the answer.  8
__label__Array Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
__label__Tree Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. Example: Input:     1     \      3     /    2  Output: 1  Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).    Note: There are at least two nodes in this BST.
__label__Dynamic-Programming Mr. Road Runner bought a piece of land in the middle of a desert for a nominal amount. It turns out that the piece of land is now worth millions of dollars as it has an oil reserve under it. Mr. Road Runner contacts the ACME corp to set up the oil wells on his land. Setting up oil wells is a costly affair and the charges of setting up oil wells are as follows.  The rectangular plot bought by Mr. Road Runner is divided into r * c blocks. Only some blocks are suitable for setting up the oil well and these blocks have been marked. ACME charges nothing for building the first oil well. For every subsequent oil well built, the cost would be the maximum ACME distance between the new oil well and the existing oil wells.  If (x,y) is the position of the block where a new oil well is setup and (x1, y1) is the position of the block of an existing oil well, the ACME distance is given by  max(|x-x1|, |y-y1|)  the maximum ACME distance is the maximum among all the ACME distance between existing oil wells and new wells.  If the distance of any two adjacent blocks (horizontal or vertical) is considered 1 unit, what is the minimum cost (E) in units it takes to set up oil wells across all the marked blocks? Input Format The first line of the input contains two space separated integers r *c*.  r lines follow each containing c space separated integers.  1 indicates that the block is suitable for setting up an oil well, whereas 0 isn't.  r c   M11 M12 ... M1c   M21 M22 ... M2c   ...   Mr1 Mr2 ... Mrc    Constraints 1 <= r, c <= 50  Output Format Print the minimum value E as the answer.  Sample Input 3 4 1 0 0 0 1 0 0 0 0 0 1 0  Sample Output 3    Explanation (1, 1) (2, 1) (3, 3) are the places where are to be setup.  There are 3! = 6 ways to do it.  (1, 1) (2, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3  (1, 1) (3, 3) (2, 1) ==> cost = 0 + 2 + 2 = 4  (2, 1) (1, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3  (2, 1) (3, 3) (1, 1) ==> cost = 0 + 2 + 2 = 4  (3, 3) (1, 1) (2, 1) ==> cost = 0 + 2 + 2 = 4  (3, 3) (2, 1) (1, 1) ==> cost = 0 + 2 + 2 = 4   So E = 3
__label__Advanced-Data-Structures Let's define a function, , on a string, , of length  as follows:   where  denotes the ASCII value of the  character in string , , and .  Nikita has a string, , consisting of  lowercase letters that she wants to perform  queries on. Each query consists of an integer, , and you have to find the value of  where  is the  alphabetically smallest palindromic substring of . If  doesn't exist, print  instead. Input Format The first line contains  space-separated integers describing the respective values of  (the length of string ) and  (the number of queries).  The second line contains a single string denoting .  Each of the  subsequent lines contains a single integer denoting the value of  for a query.  Constraints     It is guaranteed that string  consists of lowercase English alphabetic letters only (i.e.,  to ).  .  Scoring  for  of the test cases.  for  of the test cases. Output Format For each query, print the value of function  where  is the  alphabetically smallest palindromic substring of ; if  doesn't exist, print  instead. Sample Input 5 7 abcba 1 2 3 4 6 7 8         Sample Output 97 97 696207567 98 29493435 99 -1  Explanation There are  palindromic substrings of . Let's list them in lexicographical order and find value of : ,   ,   ,   ,   ,   ,   ,    doesn't exist, so we print  for .
__label__Array __label__Hash-Table __label__Binary-Search __label__Dynamic-Programming Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].    Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100
__label__Binary-Search In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].
__label__Graph-Algorithms Allison loves graph theory and just started learning about Minimum Spanning Trees(MST). She has three integers, , , and , and uses them to construct a graph with the following properties: The graph has  nodes and  undirected edges where each edge has a positive integer length. No edge may directly connect a node to itself, and each pair of nodes can only be directly connected by at most one edge. The graph is connected, meaning each node is reachable from any other node. The value of the minimum spanning tree is . Value of the MST is the sum of all the lengths of all edges of which are part of the tree. The sum of the lengths of all edges is as small as possible. For example, let's say ,  and . We need to construct a graph with  nodes and  edges. The value of minimum spanning tree must be . The diagram belows shows a way to construct such a graph while keeping the lengths of all edges is as small as possible:  Here the sum of lengths of all edges is . Given , , and  for  graphs satisfying the conditions above, find and print the minimum sum of the lengths of all the edges in each graph on a new line. Note: It is guaranteed that, for all given combinations of , , and , we can construct a valid graph. Input Format The first line contains an integer, , denoting the number of graphs.  Each of the  subsequent lines contains three space-separated integers describing the respective values of  (the number of nodes in the graph),  (the number of edges in the graph), and  (the value of the MST graph). Constraints For  of the maximum score:                      For  of the maximum score:                      For  of the maximum score:                      For  of the maximum score:                      Output Format For each graph, print an integer on a new line denoting the minimum sum of the lengths of all edges in a graph satisfying the given conditions. Sample Input 2 4 5 4 4 3 6  Sample Output 7 6  Explanation Graph : The answer for this sample is already explained the problem statement. Graph : We must construct a graph with  nodes,  edges, and an MST value of . Recall that a connected graph with  nodes and  edges is already a tree, so the MST will contain all  edges and the total length of all the edges of the graph will be equal to the value of the minimum spanning tree. So the answer is .
__label__Depth-first-Search Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5
__label__Mathematics __label__Strings Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.
__label__Strings Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true
__label__Dynamic-Programming Consider an array, , of  integers. We define the following terms: Subsequence  A subsequence of  is an array that's derived by removing zero or more elements from  without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence. Subsequence  A subsequence of  is an array that's derived by removing zero or more elements from  without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence. Strictly Increasing Subsequence  A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element.  Strictly Increasing Subsequence  A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element.  Subarray  A subarray of  is an array consisting of a contiguous block of 's elements in the inclusive range from index  to index . Any subarray of  can be denoted by . Subarray  A subarray of  is an array consisting of a contiguous block of 's elements in the inclusive range from index  to index . Any subarray of  can be denoted by . The diagram below shows all possible subsequences and subarrays of :   We define the following functions:   = the maximum sum of some strictly increasing subsequence in subarray   We define the goodness, , of array  to be:   In other words,  is the maximum possible value of  for all possible subarrays of array .  Let  be the length of the smallest subarray such that . Given , find the value of  as well as the number of subarrays such that  and , then print these respective answers as space-separated integers on a single line. Input Format The first line contains an integer, , denoting number of elements in array .  The second line contains  space-separated integers describing the respective values of . Constraints   Subtasks  For the  of the maximum score:     For the  of the maximum score:     Output Format Print two space-seperated integers describing the respective values of  and the number of subarrays satisfying  and . Sample Input 0 Sample Output 0 Explanation 0 The figure below shows how to calculate :   is the length of the smallest subarray satisfying . From the table, we can see that . There is only one subarray of length  such that .
__label__Tree Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1
__label__Dynamic-Programming Chinese Version Russian Version Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that: Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.   All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component The absolute difference between the number of chocolates in pieces should be at most K After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this:  XX  XX Input Format The first line of the input contains 3 integers M, N and K separated by a single space.  M lines follow, each of which contains N characters.  Each character is 'T','D' or 'U'. Constraints 0≤ M, N ≤8  0≤ K ≤ M * N Output Format A single line containing the number of ways to divide the chocolate bar. Sample Input 2 2 4 UU UU  Sample Output 12  Explanation Note: In the explanation T and D are used to represent, which parts belong to Tom and Derpina respectively. There are 24 = 16 possible separations.  The 4 invalid are: TT TT  DD DD  DT TD  TD DT  Some of the valid ones are: TD TD  TT DD  DD TT  DT DT
__label__Dynamic-Programming There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.
__label__Data-Structures __label__Greedy-Algorithms You have three stacks of cylinders where each cylinder has the same diameter, but they may vary in height. You can change the height of a stack by removing and discarding its topmost cylinder any number of times.  Find the maximum possible height of the stacks such that all of the stacks are exactly the same height. This means you must remove zero or more cylinders from the top of zero or more of the three stacks until they're all the same height, then print the height. The removals must be performed in such a way as to maximize the height.  Note: An empty stack is still a stack. Input Format The first line contains three space-separated integers, , , and , describing the respective number of cylinders in stacks , , and . The subsequent lines describe the respective heights of each cylinder in a stack from top to bottom:       The second line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   The third line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.    The fourth line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   Constraints   Output Format Print a single integer denoting the maximum height at which all stacks will be of equal height. Sample Input 5 3 4 3 2 1 1 1 4 3 2 1 1 4 1  Sample Output 5  Explanation Initially, the stacks look like this:  Observe that the three stacks are not all the same height. To make all stacks of equal height, we remove the first cylinder from stacks  and , and then remove the top two cylinders from stack  (shown below).  As a result, the stacks undergo the following change in height:    All three stacks now have . Thus, we print  as our answer.
__label__Array __label__Mathematics In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000
__label__Graph-Algorithms There are  people at the railway station, and each one wants to buy a ticket to go to one of  different destinations. The  people are in a queue.   There are  ticket windows from which tickets can be purchased. The  people will be distributed in the windows such that the order is maintained. In other words, suppose we number the people  to  from front to back. If person  and person  go to the same window and , then person  should still be ahead of person  in the window.   Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.   For example, suppose there are  people in the queue for a single ticket window, all with the same destination which costs  bucks. Then the first person in the queue pays  bucks, and the 2nd and 3rd persons get a discount of 20% on  bucks, so they end up paying  bucks each instead of  bucks.   Try to distribute the  people across the  windows such that the total cost  paid by all  people is minimized.   Input Format The first line contains  integers:  is the number of people    is the number of ticket windows    is the number of destinations separated by a single space (in the same order)  Then  lines follow. The  line contains an alphanumeric string  and an integer :  is the  destination    is the ticket price for   Then  lines follow. The  line contains an alphanumeric string  which is the destination of the  person.   Constraints       The  available destinations have nonempty and distinct names.   Each person's destination appears in the list of  available destinations.     Output Format Output  lines. The first line contains , the total cost that is to be minimized. In the  following line, print the ticket window which the  person goes to. The windows are indexed  to . There may be multiple ways to distribute the people among the windows such that the total cost is minimized; any one will be accepted.   The answer  will be accepted if it is within an error of  of the true answer.   Sample Input 5 2 3 CALIFORNIA 10 HAWAII 8 NEWYORK 12 NEWYORK NEWYORK CALIFORNIA NEWYORK HAWAII  Sample Output 49.2 1 1 2 1 1  Explanation At the beginning, all the people are in the same queue, and will go to the ticket windows one by one in the initial order.    will buy ticket in the first window.   will buy ticket in the second window.   In the first ticket window, #1 will pay  bucks to go to NEWYORK, and #2 and #4 have the same destination with the person in front of them, so they will get 20% off, and will pay  bucks each. #5 has a different destination, so it will cost him  bucks to go to HAWAII.   NEWYORK HAWAII In the second ticket window, #3 will pay  bucks to go to CALIFORNIA.   CALIFORNIA
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a 3-D Matrix in which each block contains 0 initially. The first block is defined by the coordinate (1,1,1) and the last block is defined by the coordinate (N,N,N). There are two types of queries. UPDATE x y z W  updates the value of block (x,y,z) to W. QUERY x1 y1 z1 x2 y2 z2  calculates the sum of the value of blocks whose x coordinate is between x1 and x2 (inclusive), y coordinate between y1 and y2 (inclusive) and z coordinate between z1 and z2 (inclusive).  Input Format  The first line contains an integer T, the number of test-cases. T testcases follow.  For each test case, the first line will contain two integers N and M separated by a single space.  N defines the N * N * N matrix.  M defines the number of operations.  The next M lines will contain either    1. UPDATE x y z W  2. QUERY  x1 y1 z1 x2 y2 z2   Output Format  Print the result for each QUERY. Constrains  1 <= T <= 50  1 <= N <= 100  1 <= M <= 1000  1 <= x1 <= x2 <= N  1 <= y1 <= y2 <= N  1 <= z1 <= z2 <= N  1 <= x,y,z <= N  -109 <= W <= 109  Sample Input 2 4 5 UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3 2 4 UPDATE 2 2 2 1 QUERY 1 1 1 1 1 1 QUERY 1 1 1 2 2 2 QUERY 2 2 2 2 2 2  Sample Output 4 4 27 0 1 1  Explanation  First test case, we are given a cube of 4 * 4 * 4 and 5 queries.  Initially all the cells (1,1,1) to (4,4,4) are 0.  UPDATE 2 2 2 4 makes the cell (2,2,2) = 4  QUERY 1 1 1 3 3 3. As (2,2,2) is updated to 4 and the rest are all 0. The answer to this query is 4.  UPDATE 1 1 1 23. updates the cell (1,1,1) to 23.  QUERY 2 2 2 4 4 4. Only the cell (1,1,1) and (2,2,2) are non-zero and (1,1,1) is not between (2,2,2) and (4,4,4). So, the answer is 4.  QUERY 1 1 1 3 3 3. 2 cells are non-zero and their sum is 23+4 = 27.  UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3
__label__Graph-Algorithms There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the ith problem has estimated difficulty level i. You have also assigned a rating vi to each problem. Problems with similar vi values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their vi rating by at least K. What is the least number of days in which you can solve all problems? Input Format The first line contains the number of test cases T. T test cases follow. Each case contains an integer N and K on the first line, followed by integers v1,...,vn on the second line. Constraints 1 <= T <= 100  1 <= N <= 300  1 <= vi <= 1000  1 <= K <= 1000 Output Format Output T lines, one for each test case, containing the minimum number of days in which all problems can be solved. Sample Input 2   3 2   5 4 7   5 1   5 3 4 5 6  Sample Output 2   1  Explanation For the first example, you can solve the problems with rating 5 and 7 on the first day and the problem with rating 4 on the next day. Note that the problems with rating 5 and 4 cannot be completed consecutively because the ratings should differ by at least K (which is 2). Also, the problems cannot be completed in order 5,7,4 in one day because the problems solved on a day should be in increasing difficulty level. For the second example, all problems can be solved on the same day.
__label__Tree __label__Data-Structures You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function. Input Format You are given a function, Node * insert (Node * root ,int data) {  }  Constraints No. of nodes in the  tree  500 Output Format Return the root of the binary search tree after inserting the value into the tree. Sample Input         4        / \       2   7      / \     1   3  The value to be inserted is 6. Sample Output          4        /   \       2     7      / \   /     1   3 6
__label__Array __label__Two-Pointers Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]
__label__Hash-Table Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.
__label__Tree Given a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.   Example 1:  Input: [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.   Example 2:  Input: [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn't as far left as possible.     Note:  The tree will have between 1 and 100 nodes.
__label__Tree __label__Depth-first-Search Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3] is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.
