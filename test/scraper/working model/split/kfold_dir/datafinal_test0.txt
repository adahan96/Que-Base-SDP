__label__Two-Pointers Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)    Example 1:  Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.    Note:  0 <= A.length < 1000 0 <= B.length < 1000 0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9  NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Bit Sansa has an array. She wants to find the value obtained by XOR-ing the contiguous subarrays, followed by XOR-ing the values thus obtained. Determine this value.   For example, if :  Now we take the resultant values and XOR them together:   Function Description  Complete the sansaXor function in the editor below.  It should return an integer that represents the results of the calculations.   sansaXor has the following parameter(s):   arr:  an array of integers   Input Format The first line contains an integer , the number of the test cases.    Each of the next  pairs of lines is as follows:  - The first line of each test case contains an integer , the number of elements in .  - The second line of each test case contains  space-separated integers .     Constraints       Output Format Print the results of each test case on a separate line.   Sample Input 0 Sample Output 0 Explanation 0 Test case 0:     Test case 1:    Sample Input 1 Sample Output 1 Explanation 1 Test Case 0:   Test Case 1:
__label__Data-Structures __label__Advanced-Data-Structures Coolguy gives you a simple problem. Given a -indexed array, , containing  elements, what will  be after this pseudocode is implemented and executed? Print . //f(a, b) is a function that returns the minimum element in interval [a, b]  ans = 0  for a -> [1, n]     for b -> [a, n]         for c -> [b + 1, n]             for d -> [c, n]                 ans = ans + min(f(a, b), f(c, d))  Input Format The first line contains  (the size of array ).  The second line contains  space-separated integers describing . Constraints  ≤  ≤   ≤  ≤  Note:  is -indexed (i.e.: ). Output Format Print the integer result of . Sample Input 3 3 2 1  Sample Output 6  Explanation       We then sum these numbers () and print , which is .
__label__Array __label__Depth-first-Search Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,1,1,0,1,0,0,0,0,0,0,0,0],  [0,1,0,0,1,1,0,0,1,0,1,0,0],  [0,1,0,0,1,1,0,0,1,1,1,0,0],  [0,0,0,0,0,0,0,0,0,0,1,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,0,0,0,0,0,0,1,1,0,0,0,0]]  Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.  Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0.  Note: The length of each dimension in the given grid does not exceed 50.
__label__Tree __label__Depth-first-Search Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3]         1       / \      2   3  Output: 6  Example 2: Input: [-10,9,20,null,null,15,7]     -10    / \   9  20     /  \    15   7  Output: 42
__label__Search Two spies in a grid will have their covers blown if: They are both in the same row.   They are both in the same column.   They can see each other diagonally (i.e., lie in a line inclined ° or ° to the base of the grid). The level of danger is now increased! In addition to the conditions above, no  spies may lie in any straight line. This line need not be aligned ° or ° to the base of grid. Write a program in the language of your choice to place  spies (one spy per row) on an  grid without blowing anyone's cover. Your program must then print the following  lines describing a valid configuration: The value of . A space-separated list of -indexed column numbers, where each value  is the column number of the spy in row  (where ). Solve this problem for  as large as possible, up to (and including) . Note: Run and Custom Input are not available for this challenge; you must click Submit Code for your submission to be scored. Your score for this challenge will always be the maximum value scored by any of your submissions. Examples  In the examples below,  denotes a spy and * denotes an empty cell. Sample Configuration 0  A valid configuration for :   Sample Output 0  This C++ code: Produces this output: 11 2 4 7 1 8 11 5 3 9 6 10   This configuration will earn a score of . Sample Configuration 1  A valid configuration for : Sample Output 1  This Python code: Produces this output: 13 1 3 12 10 7 2 11 5 8 13 9 4 6  This configuration will earn a score of . Sample Configuration 2  An invalid configuration for : Sample Output 2  The following output: 7 1 3 5 7 2 4 6   will earn a score of  because the spies in the first  rows are in a straight line as are the spies in the next  rows.       Input Format There is no input for this challenge. Constraints  is odd.  (Do not submit for any value of  larger than ) Scoring  A correct configuration will get a score of . Output Format Print the following  lines of output: The first line should be a single integer denoting the value of .  The second line should contain a space-separated list of integers. Each integer  (where ) should be the -indexed column number where the spy in row  is located.
__label__Greedy-Algorithms Lena is preparing for an important coding competition that is preceded by a number of sequential preliminary contests. Initially, her luck balance is 0. She believes in "saving luck", and wants to check her theory. Each contest is described by two integers,  and :  is the amount of luck associated with a contest. If Lena wins the contest, her luck balance will decrease by ; if she loses it, her luck balance will increase by .  denotes the contest's importance rating. It's equal to  if the contest is important, and it's equal to  if it's unimportant. If Lena loses no more than  important contests, what is the maximum amount of luck she can have after competing in all the preliminary contests? This value may be negative. For example,  and: If Lena loses all of the contests, her will be .  Since she is allowed to lose  important contests, and there are only  important contests.  She can lose all three contests to maximize her luck at .  If , she has to win at least  of the  important contests.  She would choose to win the lowest value important contest worth .  Her final luck will be .   Function Description  Complete the luckBalance function in the editor below.  It should return an integer that represents the maximum luck balance achievable.   luckBalance has the following parameter(s):   k: the number of important contests Lena can lose   contests: a 2D array of integers where each  contains two integers that represent the luck balance and importance of the  contest.   Input Format The first line contains two space-separated integers  and , the number of preliminary contests and the maximum number of important contests Lena can lose.  Each of the next  lines contains two space-separated integers,  and , the contest's luck balance and its importance rating. Constraints     Output Format Print a single integer denoting the maximum amount of luck Lena can have after all the contests. Sample Input 6 3 5 1 2 1 1 1 8 1 10 0 5 0  Sample Output 29  Explanation There are  contests. Of these contests,  are important and she cannot lose more than  of them. Lena maximizes her luck if she wins the  important contest (where ) and loses all of the other five contests for a total luck balance of .
__label__Binary-Search __label__Depth-first-Search On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].
__label__Tree Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7
__label__Tree Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]
__label__Tree __label__Data-Structures Jenny loves experimenting with trees. Her favorite tree has  nodes connected by  edges, and each edge is  unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius  from this tree by performing the following two steps: Choose a node, , from the tree. Cut a subtree consisting of all nodes which are not further than  units from node .  For example, the blue nodes in the diagram below depict a subtree centered at  that has radius :  Given , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not  isomorphic. Input Format The first line contains two space-separated integers denoting the respective values of  and .  Each of the next  subsequent lines contains two space-separated integers,  and , describing a bidirectional edge in Jenny's tree having length . Constraints      Subtasks For  of the max score:     Output Format Print the total number of different possible subtrees. Sample Input 0 Sample Output 0 Explanation 0 In the diagram below, blue nodes denote the possible subtrees:  The last  subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 In the diagram below, blue nodes denote the possible subtrees:  Here, we have four possible different subtrees.
__label__Mathematics __label__Dynamic-Programming We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9
__label__Strings __label__Greedy-Algorithms You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.
__label__Dynamic-Programming We define subsequence as any subset of an array.  We define a subarray as a contiguous subsequence in an array.   Given an array, find the maximum possible sum among: all nonempty subarrays.  all nonempty subsequences.  Print the two values as space-separated integers on one line.  Note that empty subarrays/subsequences should not be considered.  For example, given an array , the maximum subarray sum is comprised of element inidices  and the sum is .  The maximum subsequence sum is comprised of element indices  and the sum is .   Function Description  Complete the maxSubarray function in the editor below.  It should return an array of two integers: the maximum subarray sum and the maximum subsequence sum of .   maxSubarray has the following parameter(s):   arr: an array of integers   Input Format The first line of input contains a single integer , the number of test cases. The first line of each test case contains a single integer .  The second line contains  space-separated integers  where .    Constraints      The subarray and subsequences you consider should have at least one element. Output Format Print two space-separated integers denoting the maximum sums of nonempty subarrays and nonempty subsequences, respectively.  Sample Input 0 Sample Output 0 Explanation 0 In the first case: The maximum sum for both types of subsequences is just the sum of all the elements since they are all positive. In the second case: The subarray  is the subarray with the maximum sum, and  is the subsequence with the maximum sum. Sample Input 1 Sample Output 1 Explanation 1 Since all of the numbers are negative, both the maximum subarray and maximum subsequence sums are made up of one element, .
__label__Data-Structures You are given  queries. Each query consists of a single number . You can perform any of the  operations on  in each move: 1: If we take 2 integers  and  where , , then we can change  2: Decrease the value of  by .  Determine the minimum number of moves required to reduce the value of  to . Input Format The first line contains the integer .  The next  lines each contain an integer, .   Constraints     Output Format Output  lines. Each line containing the minimum number of moves required to reduce the value of  to . Sample Input 2 3 4  Sample Output 3 3  Explanation For test case 1, We only have one option that gives the minimum number of moves.  Follow  ->  ->  -> . Hence,  moves. For the case 2, we can either go  ->  ->  ->  ->  or  ->  ->  -> . The 2nd option is more optimal. Hence,  moves.
__label__Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4
__label__Dynamic-Programming Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100
__label__Search __label__Bit The Tower of Hanoi is a famous game consisting of  rods and a number of discs of incrementally different diameters. The puzzle starts with the discs neatly stacked on one rod, ordered by ascending size with the smallest disc at the top. The game's objective is to move the entire stack to another rod, obeying the following rules: Only one disc can be moved at a time. Each move consists of taking the topmost disc from a stack and moving it to the top of another stack. No disc may be placed on top of a smaller disc. Gena has a modified version of the Tower of Hanoi. His Hanoi has  rods and  discs ordered by ascending size. He made a few moves (following the rules above), but stopped and lost his place. He wants to restore the tower to its original state by making valid moves. Given the state of Gena's Hanoi, help him calculate the minimum number of moves needed to restore the tower to its original state. Note: Gena's rods are numbered from  to . All discs are initially located on rod . Input Format The first line contains a single integer, , denoting the number of discs.  The second line contains  space-separated integers, where the  integer is the index of the rod where the disk with diameter  is located. Constraints  Output Format Print the minimum number of moves Gena must make to restore the tower to its initial, ordered state on the first rod. Sample Input 3 1 4 1  Sample Output 3  Explanation  moves are enough to build the tower. Here is one possible solution:
__label__Search We take a line segment of length  on a one-dimensional plane and bend it to create a circle with circumference  that's indexed from  to . For example, if :  We denote a pair of points,  and , as . We then plot  pairs of points (meaning a total of  individual points) at various indices along the circle's circumference. We define the distance  between points  and  in pair  as . Next, let's consider two pairs:  and . We define distance  as the minimum of the six distances between any two points among points , , , and . In other words:    For example, consider the following diagram in which the relationship between points in pairs at non-overlapping indices is shown by a connecting line:  Given  pairs of points and the value of , find and print the maximum value of , where , among all pairs of points. Input Format The first line contains two space-separated integers describing the respective values of  (the number of pairs of points) and  (the circumference of the circle).  Each line  of the  subsequent lines contains two space-separated integers describing the values of  and  (i.e., the locations of the points in pair ). Constraints    Output Format Print a single integer denoting the maximum , , where . Sample Input 0 Sample Output 0 Explanation 0 In the diagram below, the relationship between points in pairs at non-overlapping indices is shown by a connecting line:  As you can see, the maximum distance between any two pairs of points is , so we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 In the diagram below, we have four individual points located at three indices:  Because two of the points overlap, the minimum distance between the two pairs of points is . Thus, we print  as our answer.
__label__Depth-first-Search Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.    Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
__label__Greedy-Algorithms There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day. Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken. Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.    Note:  The integer 1 <= d, t, n <= 10,000. You can't take two courses simultaneously.
__label__Strings You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20
__label__Mathematics Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true  Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.  Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome.  Follow up: Coud you solve it without converting the integer to a string?
__label__Dynamic-Programming One day, Wet Shark was given an array . As always, he started playing with its subsequences.   When you came to know about this habit, you presented him a task of finding all pairs of subsequences, , which satisfies all of the following constraints. We will represent a pair of subsequence as  and    and  must be of same length, i.e., .   Please help Wet Shark determine how many possible subsequences  and  can exist. Because the number of choices may be big, output your answer modulo .  Note:  Two segments are different if there's exists at least one index  such that element  is present in exactly one of them. Both subsequences can overlap each other. Subsequences do not necessarily have to be distinct Input Format The first line consists of 3 space-separated integers , , , where  denotes the length of the original array, , and  and  are as defined above.  The next line contains  space-separated integers,  , representing the elements of . Constraints       Output Format Output total number of pairs of subsequences, , satisfying the above conditions. As the number can be large, output it's modulo  Sample Input 0 Sample Output 0 Explanation 0 For array  there are three pairs of subsequences:
__label__Array Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input:  [   [1,1,1],   [1,0,1],   [1,1,1] ] Output:  [   [1,0,1],   [0,0,0],   [1,0,1] ]  Example 2: Input:  [   [0,1,2,0],   [3,4,5,2],   [1,3,1,5] ] Output:  [   [0,0,0,0],   [0,4,5,0],   [0,3,1,0] ]  Follow up:  A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?
__label__Array __label__Two-Pointers __label__Binary-Search Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note:  Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.  Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
__label__Greedy-Algorithms Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].
__label__Greedy-Algorithms Given two integers A and B, return any string S such that:  S has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters; The substring 'aaa' does not occur in S; The substring 'bbb' does not occur in S.    Example 1: Input: A = 1, B = 2 Output: "abb" Explanation: "abb", "bab" and "bba" are all correct answers.   Example 2: Input: A = 4, B = 1 Output: "aabaa"    Note:  0 <= A <= 100 0 <= B <= 100 It is guaranteed such an S exists for the given A and B.
__label__Dynamic-Programming Given two strings,  and , find and print the total number of ways to insert a character at any position in string  such that the length of the Longest Common Subsequence of characters in the two strings increases by one. Input Format The first line contains a single string denoting .  The second line contains a single string denoting . Constraints Scoring   Strings  and  are alphanumeric (i.e., consisting of arabic digits and/or upper and lower case English letters). The new character being inserted must also be alphanumeric (i.e., a digit or upper/lower case English letter). Subtask   for  of the maximum score.   Output Format Print a single integer denoting the total number of ways to insert a character into string  in such a way that the length of the longest common subsequence of  and  increases by one. Sample Input aa baaa  Sample Output 4  Explanation The longest common subsequence shared by  and  is aa, which has a length of . There are two ways that the length of the longest common subsequence can be increased to  by adding a single character to : aa There are  different positions in string  where we could insert an additional a to create longest common subsequence aaa (i.e., at the beginning, middle, and end of the string).  a aaa We can insert a b at the beginning of the string for a new longest common subsequence of baa. b baa As we have  ways to insert an alphanumeric character into  and increase the length of the longest common subsequence by one, we print  on a new line.
__label__Search Lauren has a chart of distinct projected prices for a house over the next several years.  She must buy the house in one year and sell it in another, and she must do so at a loss.  She wants to minimize her financial loss.   For example, the house is valued at  over the next  years.  She can purchase the home in any year, but she must resell the house at a loss in one of the following years.  Her minimum loss would be incurred by purchasing in year  at  and reselling in year  at . Find and print the minimum amount of money Lauren must lose if she buys the house and resells it within the next  years. Note: It's guaranteed that a valid answer exists. Function Description  Complete the minimumLoss function in the editor below.  It should return an integer that represents the minimum loss that can be achieved.   minimumLoss has the following parameter(s):   price: an array of integers that represent prices at each year   Input Format The first line contains an integer , the number of years of house data.  The second line contains  space-separated long integers describing each . Constraints   All the prices are distinct.  A valid answer exists. Subtasks  for  of the maximum score.  Output Format Print a single integer denoting the minimum amount of money Lauren must lose if she buys and resells the house within the next  years. Sample Input 0 Sample Output 0 Explanation 0 Lauren buys the house in year  at  and sells it in year  at  for a minimal loss of . Sample Input 1 Sample Output 1 Explanation 1 Lauren buys the house in year  at  and sells it in year  at  for a minimal loss of .
__label__Hash-Table Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.
__label__Dynamic-Programming Zurikela is creating a graph with a special graph maker. At the begining, it is empty and has no nodes or edges. He can perform  types of operations:      : Create a set of  new nodes and name it -.       : Create edges between nodes of - and -.        : Create a set composed of nodes from - and its directly and indirectly connected nodes, called -. Note that each node can only exist in one set, so other sets become empty.      The first 's name will be -. In first and third operation  is referring to the index of new set: K = [index of last created set] + 1  Create the graph by completing the  operations specified during input. Then calculate the maximum number of independent nodes (i.e.:how many nodes in the final graph which don't have direct edge between them). Input Format The first line contains .  The  subsequent lines each contain an operation to be performed. Constraints  . For the first operation, .  For the second operation,  and all s are distinct. For the second and third operation, it's guaranteed that - and - exist.      Output Format Print maximum number of independent nodes in the final graph (i.e.: nodes which have no direct connection to one another). Sample Input 8 A 1 A 2 B 1 2 C 1 A 2 A 3 B 3 4 B 4 5  Sample Output 5  Explanation There are  operations. After first operation:  After second operation:  After third operation:  After fourth operation:  After fifth and sixth operation  and :  After seventh operation:  After eigth operation:  There are  independent nodes in - and  independent nodes in -, so we print their sum () as our answer.
__label__Data-Structures There are  values to represent nodes in a graph. They are divided into two sets  and . Each set has exactly  values. Set  is represent by .  can contain any value between  to (inclusive). Set  is represented by .  can contain any value between  to (inclusive). Same value can be chosen any number of times.   Here  represents the edges of the graph.   Your task is to print the number of vertices in the smallest and the largest connected components of the graph.   Note Single nodes should not be considered in the answer.  For more clarity look at the following figure.    For the above graph smallest connected component is 7 and largest connected component is 17.   Input Format First line contains an integer .  Each of the next  lines contain two space-separated integers,  line contains  and .   Constraints       Output Format Print two space separated integers, the number of vertices in the smallest and the largest components. Sample Input 5 1 6  2 7 3 8 4 9 2 6  Sample Output 2 4  Explanation The number of vertices in the smallest connected component in the graph is  i.e. either  or .  The number of vertices in the largest connected component in the graph is  i.e. .
__label__Mathematics On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.  Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.                                          Example 1: Input: [[2]] Output: 5   Example 2: Input: [[1,2],[3,4]] Output: 17 Explanation:  Here are the three projections ("shadows") of the shape made with each axis-aligned plane.    Example 3: Input: [[1,0],[0,2]] Output: 8   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21       Note:  1 <= grid.length = grid[0].length <= 50 0 <= grid[i][j] <= 50
__label__Two-Pointers Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?
__label__Array Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3   Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].
__label__Array __label__Dynamic-Programming Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.
__label__Strings John has collected various rocks. Each rock has various minerals embeded in it.  Each type of mineral is designated by a lowercase letter in the range . There may be multiple occurrences of a mineral in a rock. A mineral is called a gemstone if it occurs at least once in each of the rocks in John's collection. Given a list of minerals embedded in each of John's rocks, display the number of types of gemstones he has in his collection. For example, the array of mineral composition strings .  The minerals  and  appear in each composite, so there are  gemstones. Function Description  Complete the gemstones function in the editor below.  It should return an integer representing the number of gemstones found in the list of rocks.   gemstones has the following parameter(s):   arr: an array of strings   Input Format The first line consists of an integer , the size of .  Each of the next  lines contains a string  where each letter represents an occurence of a mineral in the current rock. Constraints    | arr[i] |   Each composition  consists of only lower-case Latin letters ('a'-'z').   Output Format Print the number of types of gemstones in John's collection. If there are none, print . Sample Input 3 abcdde baccd eeabg  Sample Output 2  Explanation Only  and  are gemstones because they are the only types that occur in every rock.
__label__Dynamic-Programming You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].
__label__Bit Johnny is playing with a large binary number, . The number is so large that it needs to be compressed into an array of integers, , where the values in even indices () represent some number of consecutive  bits and the values in odd indices () represent some number of consecutive  bits in alternating substrings of .        For example, suppose we have array .  represents ,  represents ,  represents ,  represents , and  represents . The number of consecutive binary characters in the  substring of  corresponds to integer , as shown in this diagram:  When we assemble the sequential alternating sequences of 's and 's, we get . We define setCount() to be the number of 's in a binary number, . Johnny wants to find a binary number, , that is the smallest binary number  where setCount() = setCount(). He then wants to compress  into an array of integers,  (in the same way that integer array  contains the compressed form of binary string ). Johnny isn't sure how to solve the problem. Given array , find integer array  and print its length on a new line. Then print the elements of array  as a single line of space-separated integers. Input Format The first line contains a single positive integer, , denoting the number of test cases. Each of the  subsequent lines describes a test case over  lines: The first line contains a single positive integer, , denoting the length of array .  The second line contains  positive space-separated integers describing the respective elements in integer array  (i.e., ). Constraints   Subtasks For a  score, . For a  score, . Output Format For each test case, print the following  lines:   Print the length of integer array  (the array representing the compressed form of binary integer ) on a new line.  Print each element of  as a single line of space-separated integers. It is guaranteed that a solution exists. Sample Input 0 Sample Output 0 Explanation 0 , which expands to . We then find setCount() . The smallest binary number  which also has eleven 's is . This can be reduced to the integer array . This is demonstrated by the following figure:  Having found , we print its length () as our first line of output, followed by the space-separated elements in  as our second line of output.
__label__Strings Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
__label__Array __label__Dynamic-Programming Given a matrix, and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.   Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0.   Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.     Note:  1 <= matrix.length <= 300 1 <= matrix[0].length <= 300 -1000 <= matrix[i] <= 1000 -10^8 <= target <= 10^8
__label__Bit __label__Tree Xorq has invented an encryption algorithm which uses bitwise XOR operations extensively. This encryption algorithm uses a sequence of non-negative integers  as its key. To implement this algorithm efficiently, Xorq needs to find maximum value of  for given integers ,  and , such that, . Help Xorq implement this function.   For example, , ,  and .  We test each  for all values of  between  and  inclusive: j   x[j]    x[j]^4 1   3       7 2   5       1 3   9       13  Our maximum value is . Function Description Complete the xorKey function in the editor below.  It should return an integer array where each value is the response to a query. xorKey has the following parameters:   x: a list of integers   queries: a two dimensional array where each element is an integer array that consists of  for the  query at indices  and  respectively.   Input Format The first line contains an integer , the number of test cases.  The first line of each test case contains two space-separated integers  and , the size of the integer array  and the number of queries against the test case.  The next line contains  space-separated integers .  Each of next  lines describes a query which consists of three integers  and .    Constraints         Output Format For each query, print the maximum value for , such that,  on a new line.   Sample Input 0 Sample Output 0 Explanation 0 First Query (10 6 10): .  The maximum is .   First Query (10 6 10): .  The maximum is .   Second Query (1023 7 7):   Second Query (1023 7 7):   Third Query (33 5 8):   Third Query (33 5 8):   Fourth Query (182 5 10):  Fourth Query (182 5 10):
__label__Mathematics Alef the Frog is in an  two-dimensional maze represented as a table.  The maze has the following characteristics:  Each cell can be free or can contain an obstacle, an exit, or a mine. Any two cells in the table considered adjacent if they share a side.   The maze is surrounded by a solid wall made of obstacles.  Some pairs of free cells are connected by a bidirectional tunnel.   When Alef is in any cell, he can randomly and with equal probability choose to move into one of the adjacent cells that don't contain an obstacle in it. If this cell contains a mine, the mine explodes and Alef dies. If this cell contains an exit, then Alef escapes the maze.   When Alef lands on a cell with an entrance to a tunnel, he is immediately transported through the tunnel and is thrown into the cell at the other end of the tunnel. Thereafter, he won't fall again, and will now randomly move to one of the adjacent cells again. (He could possibly fall in the same tunnel later.)    It's possible for Alef to get stuck in the maze in the case when the cell in which he was thrown into from a tunnel is surrounded by obstacles on all sides.   Your task is to write a program which calculates and prints a probability that Alef escapes the maze. Input Format The first line contains three space-separated integers ,  and  denoting the dimensions of the maze and the number of bidirectional tunnels.   The next  lines describe the maze. The 'th line contains a string of length  denoting the 'th row of the maze. The meaning of each character is as follows: # denotes an obstacle. # A denotes a free cell where Alef is initially in.   A * denotes a cell with a mine.  * % denotes a cell with an exit.   % O denotes a free cell (which may contain an entrance to a tunnel).   O The next  lines describe the tunnels. The 'th line contains four space-separated integers , , , . Here,  and  denote the coordinates of both entrances of the tunnel.  denotes the row and column number, respectively.   Constraints         and  are distinct.   A appears exactly once.   A Each free cell contains at most one entrance to a tunnel.   If a cell contains an entrance to a tunnel, then it doesn't contain an obstacle, mine or exit, and Alef doesn't initially stand in it. Tunnels don't connect adjacent cells. Output Format Print one real number denoting the probability that Alef escapes the maze. Your answer will be considered to be correct if its (absolute) difference from the true answer is not greater than .   Sample Input 0 Sample Output 0 Explanation 0 The following depicts this sample case:  In this case, Alef will randomly choose one of four adjacent cells. If he goes up or down, he will explode and die. If he goes right, he will escape. If he goes left, he will go through a tunnel and get stuck in cell . So the probability of Alef escaping is .
__label__Game-Theory General Iroh and Commandant Bumi are heading to the Republic City to stop a rebellion. But it's quite a long travel, so in the meantime they have started discussing about possible attacking plans. Right now, they're arguing about best ways for moving soldiers during the battle. Tired of not getting a final and concise strategy, Iroh proposed a particularly original idea. Iroh: Bumi, look at this map: here we have all possible locations in the battle field soldiers can occupy. I know a game which can give us some ideas.  Bumi: A game? How will a game help us here?  Iroh: It's pretty simple, we know which location is connected to each one, and also, that all those paths between locations are one-way (it's too dangerous to have two ways paths), so we place some soldiers at random initial locations, take turns, and in each turn, we try to make a valid move with one soldier from one location to another. Eventually, we won't be able to move any man so, the first one which is not able to perform any valid move, loses. One important thing is, at some moment, we may have some men at the same field location.  Bumi: Are you sure we are gonna end this? We have so many locations and paths... don't know, soldiers could be moving in circles for ever.  Iroh: Take it easy man, those paths were built by the best architects I've ever known, so there is no way that could happen.  Bumi: Well, I still don't get how does this help us.  Iroh: Me neither, but greatest generals from the Earth Kingdom created their strategies from this game, so, who knows?  Bumi: Ok, I'm in. Who plays first?  Iroh: You go first my friend. Just make sure you always do your best, because I will show no mercy to you :).  Input Format First line in the input contains two integers N and M, describing the number of locations and paths between them, respectively. M lines follow, each one with two integers u and v, denoting a one-way path from u to v.  Then comes a line with a single integer Q, denoting how many times Bumi and Iroh played the game over the given field. Q queries follow each one with two lines, first one with a single integer K, the number of soldiers in the field; and second one with K integers b_i separated by space, each one denoting the initial location of some soldier. Constraints 1 < N <= 105  1 <= M <= 106  1 <= u, v, b_i <= N  1 <= K <= 102  1 <= Q <= 105  Output Format Output Q lines, each one saying Bumi if Bumi should be the winner of the corresponding game or Iroh otherwise.  Remember that, being both top strategy masters, they will always perform the best possible move each turn. Sample Input 10 10 1 10 3 10 7 8 6 8 7 4 9 4 7 6 5 8 1 8 2 8 5 4 10 7 6 4 3 1 9 4 3 8 3 5 3 4 9 7 3 7 9 10  Sample Output Bumi Iroh Iroh Bumi Bumi
__label__Binary-Search Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]
__label__Greedy-Algorithms Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"
__label__Tree __label__Depth-first-Search In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.
__label__Dynamic-Programming We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.
__label__Depth-first-Search Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4]. Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
__label__Strings Given a string text, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters.   Example 1: Input: text = "ababa" Output: 3 Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa", which its length is 3.  Example 2: Input: text = "aaabaaa" Output: 6 Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa", which its length is 6.  Example 3: Input: text = "aaabbaaa" Output: 4  Example 4: Input: text = "aaaaa" Output: 5 Explanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.  Example 5: Input: text = "abcdef" Output: 1    Constraints:  1 <= text.length <= 20000 text consist of lowercase English characters only.
__label__Data-Structures __label__Advanced-Data-Structures You are given a sequence . The task is to perform the following queries on it: Type 1. Given two integers  and  . Reorder the elements of the sequence in such a way (changed part of the sequence is in brackets):   Type 2. Given two integers  and , print the value of sum . Input Format  The first line contains two integers  and . The second line contains  integers , denoting initial sequence. Each of the next  lines contains three integers , where  denotes the type of the query, and  are parameters of the query. It's guaranteed that for a first-type query  will be even.   Constraints           Output Format For each query of the second type print the required sum. Sample Input 6 4 1 2 3 4 5 6 1 2 5 2 2 3 2 3 4 2 4 5  Example Output 5 7 9  Explanation After the first query the sequence becomes [1, 3, 2, 5, 4, 6].
__label__Array __label__Dynamic-Programming A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right  Example 2: Input: m = 7, n = 3 Output: 28
__label__Mathematics Given an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5.  If no valid time can be made, return an empty string.    Example 1: Input: [1,2,3,4] Output: "23:41"   Example 2: Input: [5,5,5,5] Output: ""    Note:  A.length == 4 0 <= A[i] <= 9
__label__Depth-first-Search Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.
__label__Array Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].
__label__Dynamic-Programming __label__Depth-first-Search You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Enter-View  is a linear, street-like country. By linear, we mean all the cities of the country are placed on a single straight line - the -axis. Thus every city's position can be defined by a single coordinate, , the distance from the left borderline of the country. You can treat all cities as single points. Unfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if  people are living in city , there must be at least  cables from city  to every other city of EV - this way he can guarantee no congestion will ever occur! Mr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population.  Note that The connections between the cities can be shared. Look at the example for the detailed explanation. Input Format  A number  is given in the first line and then comes  blocks, each representing a scenario. Each scenario consists of three lines. The first line indicates the number of cities (N). The second line indicates the coordinates of the N cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input. Output Format  For each scenario of the input, write the length of cable needed in a single line modulo . Constraints        Border to border length of the country  Sample Input  2   3   1 3 6   10 20 30   5   5 55 555 55555 555555   3333 333 333 33 35  Sample Output  280   463055586  Explanation For the first test case, having  cities requires  sets of cable connections. Between city  and , which has a population of  and , respectively, Mr. Treat believes at least  cables should come out of city 1 for this connection, and at least 20 cables should come out of city  for this connection. Thus, the connection between city  and city  will require  cables, each crossing a distance of  km. Applying this absurd logic to connection 2,3 and 1,3, we have  =>  connections   km of cable  =>  connections   km of cable  =>  connections   km of cable For a total of  , Output is  km of cable
__label__Mathematics We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.   Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.  Example: Input: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14   Note: The input number n will not exceed 100,000,000. (1e8)
__label__Data-Structures __label__Advanced-Data-Structures Alice purchased an array of  wooden boxes that she indexed from  to . On each box , she writes an integer that we'll refer to as . Alice wants you to perform  operations on the array of boxes. Each operation is in one of the following forms: (Note: For each type of operations, ) 1 l r c: Add  to each . Note that  can be negative. 1 l r c 2 l r d: Replace each  with .  2 l r d 3 l r: Print the minimum value of any . 3 l r 4 l r: Print the sum of all . 4 l r Recall that  is the maximum integer  such that  (e.g.,  and ). Given , the value of each , and  operations, can you perform all the operations efficiently?  Input Format The first line contains two space-separated integers denoting the respective values of  (the number of boxes) and  (the number of operations).  The second line contains  space-separated integers describing the respective values of  (i.e., the integers written on each box).  Each of the  subsequent lines describes an operation in one of the four formats defined above. Constraints      Output Format For each operation of type  or type , print the answer on a new line. Sample Input 0 Sample Output 0 Explanation 0 Initially, the array of boxes looks like this:  We perform the following sequence of operations on the array of boxes: The first operation is 1 0 4 1, so we add  to each  where :   The first operation is 1 0 4 1, so we add  to each  where :   1 0 4 1 The second operation is 1 5 9 1, so we add  to each  where :   The second operation is 1 5 9 1, so we add  to each  where :   1 5 9 1 The third operation is 2 0 9 3, so we divide each  where  by  and take the floor:   2 0 9 3 The fourth operation is 3 0 9, so we print the minimum value of  for , which is the result of . 3 0 9 The fifth operation is 4 0 9, so we print the sum of  for , which is the result of . 4 0 9 ... and so on.
__label__Tree __label__Depth-first-Search You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node {   int val;   Node *left;   Node *right;   Node *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.   Example:  Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}  Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}  Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.    Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__Search __label__Dynamic-Programming __label__Strings Consider a string, , of  lowercase English letters where each character,  (, denotes the letter at index  in . We define an  palindromic tuple of  to be a sequence of indices in  satisfying the following criteria: , meaning the characters located at indices  and  are the same. , meaning the characters located at indices  and  are the same. , meaning that , , , and  are ascending in value and are valid indices within string . Given , find and print the number of  tuples satisfying the above conditions. As this value can be quite large, print it modulo . Input Format A single string denoting .  Constraints  It is guaranteed that  only contains lowercase English letters. Output Format Print the the number of  tuples satisfying the conditions in the Problem Statement above. As this number can be very large, your answer must be modulo . Sample Input 0 kkkkkkz  Sample Output 0 15  Explanation 0 The letter z will not be part of a valid tuple because you need at least two of the same character to satisfy the conditions defined above. Because all tuples consisting of four k's are valid, we just need to find the number of ways that we can choose four of the six k's. This means our answer is . z k k Sample Input 1 ghhggh  Sample Output 1 4  Explanation 1 The valid tuples are:     Thus, our answer is . Sample Input 0 Sample Output 0 Sample Input 1 Sample Output 1 Sample Input 2 Sample Output 2 Explanation 2 Tuples possible are
__label__Binary-Search Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix: [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]  Given target = 5, return true. Given target = 20, return false.
__label__Hash-Table __label__Strings Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]
__label__Dynamic-Programming There is a huge blanket on your bed but unfortunately it has N stains. You cover them using  a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly K stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth. Let X denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove K stains so that the remaining N-K stains can be covered with silk of area strictly less than X (We are looking for any configuration that will reduce the cost). Assume that each stain is a point and that the rectangle is aligned parallel to the axes.   Input Format The first line contains two integers N (1<=N<=1000) and K (0<=K<=N).  Next follow N lines, one for each stain. Each line contains two integers in the form 'X Y', (0<=X,Y<100000), the coordinates of each stain into the blanket. Each pair of coordinates is unique. Output Format Output a single integer. The remainder of the division by 1000000007 of the answer. Sample Input 5 2 0 1 3 3 2 0 0 3 2 3  Sample Output 8  Explanation We can clean two spots. So removing any of the following set of stains will lead us to a conbination that will need less amount of silk.(The numbers refer to the indices of the stains in the input and they begin from 1). 1, 4 2, 1 2, 3 2, 4 2, 5 3, 1 3, 4 3, 5  So there are 8 ways.
__label__Strings In this challenge, you will determine whether a string is funny or not.  To determine whether a string is funny, create a copy of the string in reverse e.g. .  Iterating through each string, compare the absolute difference in the ascii values of the characters at positions 0 and 1, 1 and 2 and so on to the end.  If the list of absolute differences is the same for both strings, they are funny. Determine whether a give string is funny.  If it is, return Funny, otherwise return Not Funny. Funny Not Funny For example, given the string , the ordinal values of the charcters are .   and the ordinals are .  The absolute differences of the adjacent elements for both strings are , so the answer is Funny. Funny Function Description Complete the funnyString function in the editor below.  For each test case, it should return a string, either Funny or Not Funny. Funny Not Funny funnyString has the following parameter(s):   s: a string to test Input Format The first line contains an integer , the number of queries.  The next  lines each contain a string, .    Constraints     Output Format For each string   print whether it is Funny or Not Funny on a new line. Funny Not Funny Sample Input 2 acxz bcxz  Sample Output Funny Not Funny  Explanation You can use  to store the reverse of . Test Case 0:  ,   Corresponding ASCII values of characters of the strings:   and   For both the strings the adjacent difference list is [2, 21, 2] so we print Funny.   Funny Test Case 1:  ,   Corresponding ASCII values of characters of the strings:   and   The adjacent difference list for string  is [1, 21, 2] and for string  it is [2, 21, 1]. Since they are not the same we print Not Funny.  Not Funny
__label__Binary-Search Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2.
__label__Mathematics You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].
__label__Dynamic-Programming Ma5termind is crazy about Action Games. He just bought a new one and got down to play it. Ma5termind usually finishes all the levels of a game very fast. But, This time however he got stuck at the very first level of this new game. Can you help him play this game.   To finish the game, Ma5termind has to cross  levels. At each level of the game, Ma5termind has to face  enemies. Each enemy has its associated power  and some number of bullets . To knock down an enemy, Ma5termind needs to shoot him with one or multiple bullets whose collective count is equal to the power of the enemy. If Ma5termind manages to knock down any one enemy at a level, the rest of them run away and the level is cleared.    Here comes the challenging part of the game.  Ma5termind acquires all the bullets of an enemy once he has knocked him down. Ma5termind can use the bullets acquired after killing an enemy at  level only till the  level.   However, the bullets Ma5termind carried before the start of the game can be taken forward and can be used to kill more enemies.   Now, Ma5termind has to guess the minimum number of bullets he must have before the start of the game so that he clears all the  levels successfully.   NOTE  Bullets carried before the start of the game can be used to kill an enemy at any level.   One bullet decreases the power of an enemy by 1 Unit.   For better understanding of the problem look at the sample testcases.   Input Format First line of input contains a single integer  denoting the number of test cases.  First line of each test case contains two space separated integers  and  denoting the number of levels and number of enemies at each level respectively.  Each of next  lines of a test case contain  space separated integers, where  integer in the  line denotes the power  of  enemy on the  level.  Each of the next  lines of a test case contains  space separated integers, where  integer in the  line denotes the number of bullets   enemy of  level has.   Constraints          For each test file, sum of  over all the test cases does not exceed .    Output Format For each test case, print the required answer.   Sample Input 2 3 3 3 2 1  1 2 3 3 2 1 1 2 3 3 2 1 1 2 3 3 3  3 2 5  8 9 1  4 7 6  1 1 1  1 1 1  1 1 1   Sample Output 1 5     Explanation For the First test case , Ma5termind kills the enemy in the following order: Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. So this way Ma5termind can successfully finish this game with only  bullet in hand before the start of the game. For the second test case , Ma5termind kills the enemy in the following order: Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. So this way Ma5termind can successfully finish this game with only  bullet in hand before the start of the game. NOTE:  There can be more than one way of getting the optimal answer but that does not matter in our case, because we need to answer the minimum number of bullets required.
__label__Dynamic-Programming Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible. Note that the subarray needs to be non-empty after deleting one element.   Example 1: Input: arr = [1,-2,0,3] Output: 4 Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value. Example 2: Input: arr = [1,-2,-2,3] Output: 3 Explanation: We just choose [3] and it's the maximum sum.  Example 3: Input: arr = [-1,-1,-1,-1] Output: -1 Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.    Constraints:  1 <= arr.length <= 10^5 -10^4 <= arr[i] <= 10^4
__label__Array Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]
__label__Tree __label__Depth-first-Search Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.
__label__Dynamic-Programming Given an  cube, let  (where ) denote the value stored in cell .  A  sub-cube (where ) of an  cube is considered to be special if the maximum value stored in any cell in the sub-cube is equal to . For each  in the inclusive range , calculate the number of special sub-cubes. Then print each  as a single line of space-separated integers (i.e., ). Input Format The first line contains an integer, , denoting the number of queries. The  subsequent lines describe each query over two lines: The first line contains an integer, , denoting the side length of the initial cube. The second line contains  space-separated integers describing an array of  integers in the form . The integer in some cell  is calculated using the formula . Constraints    where  Output Format For each query, print  space-separated integers where the  integer denotes the number of special sub-cubes for . Sample Input 2 2 2 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 2  Sample Output 7 1 6 1  Explanation We must perform the following  queries: We have a cube of size  and must calculate the number of special sub-cubes for the following values of : : There are  sub-cubes of size  and seven of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .     We then print the respective values for each  as a single line of space-separated integers (i.e., 7 1). We have a cube of size  and must calculate the number of special sub-cubes for the following values of : : There are  sub-cubes of size  and seven of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .     We then print the respective values for each  as a single line of space-separated integers (i.e., 7 1). 7 1 We have a cube of size  and must calculate the number of special sub-cubes for the following values of :    : There are  sub-cubes of size  and six of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .         We then print the respective values for each  as a single line of space-separated integers (i.e., 6 1). We have a cube of size  and must calculate the number of special sub-cubes for the following values of :    : There are  sub-cubes of size  and six of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .         We then print the respective values for each  as a single line of space-separated integers (i.e., 6 1). 6 1
__label__Graph-Algorithms __label__Tree Byteland has  cities (numbered from  to ) and  bidirectional roads. It is guaranteed that there is a route from any city to any other city.  Jeanie is a postal worker who must deliver  letters to various cities in Byteland. She can start and end her delivery route in any city. Given the destination cities for  letters and the definition of each road in Byteland, find and print the minimum distance Jeanie must travel to deliver all  letters. Note: The letters can be delivered in any order. Input Format The first line contains two space-separated integers,  (the number of cities) and  (the number of letters), respectively.  The second line contains  space-separated integers describing the delivery city for each letter.  Each line  of the  subsequent lines contains  space-separated integers describing a road as , where  is the distance (length) of the bidirectional road between cities  and . Constraints    Output Format Print the minimum distance Jeanie must travel to deliver all  letters. Sample Input 0 Sample Output 0 Explanation 0 Jeanie has  letters she must deliver to cities , , and  in the following map of Byteland:  One of Jeanie's optimal routes is , for a total distanced traveled of . Thus, we print  on a new line.
__label__Hash-Table Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].
__label__Two-Pointers __label__Strings Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false
__label__Bit Consider a zero-indexed matrix with  rows and  columns, where each row is filled gradually. Given the first row of the matrix, you can generate the elements in the subsequent rows using the following formula:   Each row is generated one by one, from the second row through the last row. Given the first row of the matrix, find and print the elements of the last row as a single line of space-separated integers. Note: The  operator denotes bitwise XOR. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of columns in the matrix) and  (the number of rows in the matrix).  The second line contains  space-separated integers denoting the respective values of the elements in the matrix's first row. Constraints    Output Format Print  space-separated integers denoting the respective values of the elements in the last row of the matrix. Sample Input 0 Sample Output 0 Explanation 0 We use the formula given above to calculate the  values in the last row of the matrix:         We then print each value (in order) as a single line of space-separated integers.
__label__Two-Pointers __label__Dynamic-Programming There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'
__label__Dynamic-Programming Let's talk about binary numbers. We have an -digit binary number, , and we denote the digit at index  (zero-indexed from right to left) to be . We can find the decimal value of  using the following formula:   For example, if binary number , we compute its decimal value like so:   Meanwhile, in our well-known decimal number system where each digit ranges from  to , the value of some decimal number, , can be expanded in the same way:   Now that we've discussed both systems, let's combine decimal and binary numbers in a new system we call decibinary! In this number system, each digit ranges from  to  (like the decimal number system), but the place value of each digit corresponds to the one in the binary number system. For example, the decibinary number  represents the decimal number  because:   Pretty cool system, right? Unfortunately, there's a problem: two different decibinary numbers can evaluate to the same decimal value! For example, the decibinary number  also evaluates to the decimal value :   This is a major problem because our new number system has no real applications beyond this challenge!  Consider an infinite list of non-negative decibinary numbers that is sorted according to the following rules: The decibinary numbers are sorted in increasing order of the decimal value that they evaluate to.  Any two decibinary numbers that evaluate to the same decimal value are ordered by increasing decimal value, meaning the equivalent decibinary values are strictly interpreted and compared as decimal values and the smaller decimal value is ordered first. For example,  and  both evaluate to . We would order  before  because . Here is a list of first few decibinary numbers properly ordered:  You will be given  queries in the form of an integer, . For each , find and print the the  decibinary number in the list on a new line.   Function Description Complete the decibinaryNumbers function in the editor below.  For each query, it should return the decibinary number at that one-based index.   decibinaryNumbers has the following parameter(s): x: the index of the decibinary number to return    Input Format The first line contains an integer, , the number of queries.  Each of the next  lines contains an integer, , describing a query. Constraints   Subtasks  for  of the maximum score  for  of the maximum score  for  of the maximum score Output Format For each query, print a single integer denoting the the  decibinary number in the list. Note that this must be the actual decibinary number and not its decimal value.  Use 1-based indexing. Sample Input 0 Sample Output 0 Explanation 0 For each , we print the  decibinary number on a new line. See the figure in the problem statement.  Sample Input 1 Sample Output 1 Sample Input 2 Sample Output 2
__label__Array Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]
__label__Data-Structures __label__Graph-Algorithms __label__Graph-Algorithms We define the diameter of a strongly-connected oriented graph, , as the minimum integer  such that for each  there is a path from  to  of length  (recall that a path's length is its number of edges).   Given two integers,  and , build a strongly-connected oriented graph with  vertices where each vertex has outdegree  and the graph's diameter is as small as possible (see the Scoring section below for more detail). Then print the graph according to the Output Format specified below.   Here's a sample strongly-connected oriented graph with  nodes, whose outdegree is  and diameter is .    Note: Cycles and multiple edges between vertices are allowed. Input Format Two space-separated integers describing the respective values of  (the number of vertices) and  (the outdegree of each vertex). Constraints   Scoring  We denote the diameter of your graph as  and the diameter of the graph in the author's solution as . Your score for each test case (as a real number from  to ) is:  if   if   if  Output Format First, print an integer denoting the diameter of your graph on a new line.  Next, print  lines where each line  () contains  space-separated integers in the inclusive range from  to  describing the endpoints for each of vertex 's outbound edges. Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts a strongly-connected oriented graph with  nodes where each node has an outdegree of :  The diameter of this graph is , which is minimal as the outdegree of each node must be . We cannot construct a graph with a smaller diameter of  because it requires an outbound edge from each vertex to each other vertex in the graph (so the outdegree of that graph would be ).
__label__Hash-Table __label__Two-Pointers __label__Strings Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = "ADOBECODEBANC", T = "ABC" Output: "BANC"  Note:  If there is no such window in S that covers all characters in T, return the empty string "". If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
__label__Hash-Table There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.
__label__Graph-Algorithms __label__Mathematics __label__Greedy-Algorithms You're researching friendships between groups of  new college students where each student is distinctly numbered from  to . At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: Bidirectional. If student  is friends with student , then student  is also friends with student . Transitive. If student  is friends with student  and student  is friends with student , then student  is friends with student . In other words, two students are considered to be friends even if they are only indirectly linked through a network of mutual (i.e., directly connected) friends.  The purpose of your research is to find the maximum total value of a group's friendships, denoted by . Each time a direct friendship forms between two students, you sum the number of friends that each of the  students has and add the sum to .  You are given  queries, where each query is in the form of an unordered list of  distinct direct friendships between  students. For each query, find the maximum value of  among all possible orderings of formed friendships and print it on a new line. Input Format The first line contains an integer, , denoting the number of queries. The subsequent lines describe each query in the following format: The first line contains two space-separated integers describing the respective values of  (the number of students) and  (the number of distinct direct friendships). Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  (where ) describing a friendship between student  and student . Constraints       Output Format For each query, print the maximum value of  on a new line. Sample Input 0 Sample Output 0 Explanation 0  The value of  is maximal if the students form the  direct friendships in the following order: Students  and  become friends:   We then sum the number of friends that each student has to get . Students  and  become friends:   We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . When we add the sums from each step, we get . We then print  on a new line.
__label__Greedy-Algorithms Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.    Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
__label__Hash-Table A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.   Example 1:  Input: {"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}  Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself.    Note:  You must return the copy of the given head as a reference to the cloned list.
__label__Hash-Table __label__Mathematics Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
__label__Mathematics __label__Game-Theory Laurel and Hardy have  piles of chocolates with each pile containing some number of chocolates. The piles are arranged from left to right in a non decreasing order based on the number of chocolates in each pile. They play the following game.  For every continuous subsequence of chocolate piles (at least 2 piles form a subsequence), Laurel and Hardy will play game on this subsequence of chocolate piles, Laurel plays first, and they play in turn. In one move, the player can choose one of the piles and remove at least one chocolate from it, but the non-decreasing order of the chocolate piles must be maintained. The last person to make a valid move wins.  How many continuous subsequences of chocolate piles will Laurel win if both of them play optimally? The number of chocolates of each pile will be recovered after the game ends for each subsequences.  Input Format The first line contains an integer  denoting the number of piles.  The second line contains the number of chocolates in each pile, arranged from left to right and separated by a single space between them.  Constraints  ≤  ≤    ≤     ≤  Output Format A single integer denoting the number of continuous subsequences of chocolate piles in which Laurel will win. Sample Input 5 1 1 2 2 3  Sample Output 5  Explanation Of the 10 continuous-sub-sequence of chocolate piles,  Laurel loses in [1,1], [1,1,2], [1,1,2,2], [1,2,2,3], [2,2] and  wins in [1,1,2,2,3], [1,2], [1,2,2], [2,2,3] and [2,3] and hence 5.
__label__Mathematics Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"
__label__Array Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])   Example 1: Input: [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1   Example 2: Input: [0,2,1,-6,6,7,9,-1,2,0,1] Output: false   Example 3: Input: [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4      Note:  3 <= A.length <= 50000 -10000 <= A[i] <= 10000
__label__Data-Structures __label__Advanced-Data-Structures In this problem you operate on two arrays of  integers. We will call them the  and the  respectively.  Your goal is just to maintain them under the modification operations, such as:    1   : Reverse the subarray of the  array, starting at the  number, ending at the  number, inclusively;   2     : Swap two consecutive fragments of the  array, the first is from the  number to the , the second is from the  number to the ;   3  : Swap the piece that starts at the  number and end at the  one between the  and the  array;   4  : We consider only the piece from the  number to the  one. The numbers in the  array are -coordinates of some set of points and the numbers in the  array are -coordinates of them. For the obtained set of points we would like to place such a circle on a plane that would contain all the points in it and would have the minimal radius. Find this minimal radius.   Input Format  The first line of input contains two space separated integers  and  denoting the number of integers in arrays and the number of queries respectively.  The second line contains  space separated integers: the initial elements of the  array.  The third line contains  space separated integers: the initial elements of the  array.  Then there are  lines containing queries in the format listed above.   Output Format  For each type-4 query output the sought minimal radius with exactly two symbols after the decimal point precision.   Constraints    All the numbers in arrays are non-negative and don't exceed .  The sum of  over the type-4 queries won't exceed .  In the query of the type 2, .  In the queries of the types 1, 3, 4, ; . Sample Input 10 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 3 2 6 1 0 9 9 4 6 9 2 0 2 7 9 9 1 0 3 6 2 1 2 3 4 5 1 1 7 10 2 1 8 8 9 10 4 6 9 2 0 2 2 4 6  Example Output 2.12 2.50
__label__Dynamic-Programming Given an array, we define its value to be the value obtained by following these instructions: Write down all pairs of numbers from this array.   Compute the product of each pair.   Find the sum of all the products. For example, for a given array, for a given array [, , , ],  Note that  is listed twice, one for each occurrence of .   Given an array of integers, find the largest value of any of its nonempty subarrays. Note: A subarray is a contiguous subsequence of the array. Complete the function largestValue which takes an array and returns an integer denoting the largest value of any of the array's nonempty subarrays.   largestValue Input Format The first line contains a single integer , denoting the number of integers in array .  The second line contains  space-separated integers  denoting the elements of array .   Constraints     Subtasks   for 20% of the points.    for 70% of the points. Output Format Print a single line containing a single integer denoting the largest value of any of the array's nonempty subarrays. Sample Input 0 Sample Output 0 Explanation 0 In this case, we have . The largest-valued subarray turns out to be  with value .   Sample Input 1 Sample Output 1
__label__Hash-Table __label__Dynamic-Programming Given a list of words, each word consists of English lowercase letters. Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, "abc" is a predecessor of "abac". A word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on. Return the longest possible length of a word chain with words chosen from the given list of words.   Example 1: Input: ["a","b","ba","bca","bda","bdca"] Output: 4 Explanation: one of the longest word chain is "a","ba","bda","bdca".    Note:  1 <= words.length <= 1000 1 <= words[i].length <= 16 words[i] only consists of English lowercase letters.
__label__Two-Pointers Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.
__label__Mathematics Solve a given equation and return the value of x in the form of string "x=#value". The equation contains only '+', '-' operation, the variable x and its coefficient.   If there is no solution for the equation, return "No solution".   If there are infinite solutions for the equation, return "Infinite solutions".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.  Example 1: Input: "x+5-3+x=6+x-2" Output: "x=2"   Example 2: Input: "x=x" Output: "Infinite solutions"   Example 3: Input: "2x=x" Output: "x=0"   Example 4: Input: "2x+3x-6x=x+2" Output: "x=-1"   Example 5: Input: "x=x+2" Output: "No solution"
__label__Array Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Simon received the board game Ticket to Ride as a birthday present. After playing it with his friends, he decides to come up with a strategy for the game. There are  cities on the map and  road plans. Each road plan consists of the following:  Two cities which can be directly connected by a road. The length of the proposed road.  The entire road plan is designed in such a way that if one builds all the roads, it will be possible to travel between any pair of cities.  A ticket enables you to travel between two different cities. There are  tickets, and each ticket has a cost associated with it. A ticket is considered to be useful if there is a path between those cities. Simon wants to choose two cities,  and , and build a minimal number of roads so that they form a simple path between them. Let  be the sum of costs of all useful tickets and  be the sum of lengths of all the roads Simon builds. The profit for pair  is defined as . Note that  and  are not necessarily unique and may be the same cities. Given  road plans and  ticket prices, help Simon by printing the value of his maximum possible profit on a new line. Input Format The first line contains single positive integer, , denoting the number of cities.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a road plan, where , , and . Here,  and  are two cities that the road plan proposes to connect and  is the length of the proposed road.  The next line contains a single positive integer, , denoting the number of tickets.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a ticket from city  to city  (where  is the cost of the ticket). Constraints    Output Format Print a single integer denoting the the maximum profit Simon can make. Time Limits   seconds for Java and C#. Please refer to our Environment page to see time limits for other languages. Sample Input 7 1 2 1 1 3 1 1 4 4 4 5 1 4 6 1 4 7 1 5 5 7 3 3 6 2 3 4 10 2 7 15 1 6 7  Sample Output 13  Explanation  Simon can maximize his profit by choosing the pair .  The roads on the path between them are , , and . The total road length is .  The useful tickets are , , and . The total ticket cost is .  The profit is .
__label__Greedy-Algorithms Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.
__label__Search We call an quadruple of positive integers, , beautiful if the following condition is true:   Note:  is the bitwise XOR operator. Given , , , and , count the number of beautiful quadruples of the form  where the following constraints hold:     When you count the number of beautiful quadruples, you should consider two quadruples as same if the following are true: They contain same integers. Number of times each integers occur in the quadruple is same. For example  and  should be considered as same. Input Format A single line with four space-separated integers describing the respective values of , , , and . Constraints  For  of the maximum score,  Output Format Print the number of beautiful quadruples. Sample Input 1 2 3 4  Sample Output 11  Explanation There are  beautiful quadruples for this input:            Thus, we print  as our output. Note that  is same as .
__label__Binary-Search __label__Dynamic-Programming Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?
__label__Dynamic-Programming We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:  If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.  At the end, there is at most 1 stone left.  Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)   Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation:  We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.    Note:  1 <= stones.length <= 30 1 <= stones[i] <= 100
__label__Graph-Algorithms A crab is an undirected graph which has two kinds of vertices: 1 head, and K feet , and exactly K edges which join the head to each of the feet.( 1 <= K <= T, where T is given) Given an undirected graph, you have to find in it some vertex-disjoint subgraphs where each one is a crab . The goal is to select those crabs in such a way that the total number of vertices covered by them is maximized. Note: two graphs are vertex-disjoint if they do not have any vertices in common.  Input Format The first line of input contains a single integer C. C test-cases follow. The first line of each test-case contains three integers N, T, and M (the number of nodes, max number of feet in the crab graph, and number of edges, respectively). Each of next M lines contains two space separated values v1i, v2i meaning that the there is an edge between vertices v1i and v2i. Note that the graph doesn't have parallel edges or loops. Constraints 1 <= C <= 10   2 <= T <= 100   2 <= N <= 100   0 <= M <= N * (N-1)/2   1 <= v1i <= N   1 <= v2i <= N Output Format For each test-case, output a single integer indicating the maximum number of vertices which can be covered by vertex-disjoint sub-graphs of crab- graphs. Sample Input 2   8 2 7   1 4   2 4   3 4   5 4   5 8   5 7   5 6   6 3 8   1 2   2 3   3 4   4 5   5 6   6 1   1 4   2 5  Sample Output 6   6  Explanation Test #1: The graph for this test-case below. Because T = 2, each crab can have a maximum of 2 feet => each crab can cover a maximum of 3 nodes. We can cover 6 nodes of this graph with these two crabs: One of the crabs has 4 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 7 and 8 as its feet. No additional crabs can be added. The above is not a unique solution: any combination of two crabs, with one head at 4 and one head at 5, will suffice. We could have also chosen Head[4]feet[1,2] and Head[5]feet[6,7] as our two crabs.  Test #2: The graph for this test-case below. We can cover all 6 nodes using two crabs. One of the crabs has 2 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 4 and 6 as its feet.
__label__Depth-first-Search In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.     Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0  Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0  Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Dynamic-Programming Your goal is to find the number of ways to construct an array such that consecutive positions contain different values. Specifically, we want to construct an array with  elements such that each element between  and , inclusive. We also want the first and last elements of the array to be  and .   Given ,  and , find the number of ways to construct such an array. Since the answer may be large, only find it modulo .  For example, for , , , there are  ways, as shown here:  Complete the function countArray which takes input ,  and . Return the number of ways to construct the array such that consecutive elements are distinct.  countArray Constraints       Subtasks For  of the maximum score,  and   Sample Input , ,   Sample Output  Explanation Refer to the diagram in the challenge statement.
__label__Array __label__Mathematics We have some permutation A of [0, 1, ..., N - 1], where N is the length of A. The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j]. The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1]. Return true if and only if the number of global inversions is equal to the number of local inversions. Example 1: Input: A = [1,0,2] Output: true Explanation: There is 1 global inversion, and 1 local inversion.  Example 2: Input: A = [1,2,0] Output: false Explanation: There are 2 global inversions, and 1 local inversion.  Note:  A will be a permutation of [0, 1, ..., A.length - 1]. A will have length in range [1, 5000]. The time limit for this problem has been reduced.
__label__Bit Consider an array of  binary integers (i.e., 's and 's) defined as . Let  be the bitwise XOR of all elements in the inclusive range between index  and index  in array . In other words, . Next, we'll define another function, :   Given array  and  independent queries, perform each query on  and print the result on a new line. A query consists of three integers, , , and , and you must find the maximum possible  you can get by changing at most  elements in the array from  to  or from  to .  Note: Each query is independent and considered separately from all other queries, so changes made in one query have no effect on the other queries.  Input Format The first line contains two space-separated integers denoting the respective values of  (the number of elements in array ) and  (the number of queries).  The second line contains  space-separated integers where element  corresponds to array element  .  Each line  of the  subsequent lines contains  space-separated integers, ,  and  respectively, describing query  . Constraints     Subtask  and  for  of the maximum score ,  and  for  of the maximum score Output Format Print  lines where line  contains the answer to query  (i.e., the maximum value of  if no more than  bits are changed). Sample Input 3 2 0 0 1 0 2 1 0 1 0  Sample Output 4 0  Explanation Given , we perform the following  queries: If we change  to , then we get  and . In this query, .
__label__Mathematics Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c. Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5    Example 2: Input: 3 Output: False
__label__Mathematics Given a non-empty array of unique positive integers A, consider the following graph:  There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.  Return the size of the largest connected component in the graph.      Example 1: Input: [4,6,15,35] Output: 4    Example 2: Input: [20,50,9,63] Output: 2    Example 3: Input: [2,3,6,7,4,12,21,39] Output: 8   Note:  1 <= A.length <= 20000 1 <= A[i] <= 100000
__label__Mathematics __label__Dynamic-Programming Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.
__label__Array __label__Dynamic-Programming In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.    Note:  nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3).
__label__Hash-Table You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.
__label__Array Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person.  Person A will NOT friend request person B (B != A) if any of the following conditions are true:  age[B] <= 0.5 * age[A] + 7 age[B] > age[A] age[B] > 100 && age[A] < 100  Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves. How many total friend requests are made? Example 1: Input: [16,16] Output: 2 Explanation: 2 people friend request each other.  Example 2: Input: [16,17,18] Output: 2 Explanation: Friend requests are made 17 -> 16, 18 -> 17. Example 3: Input: [20,30,100,110,120] Output:  Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.    Notes:  1 <= ages.length <= 20000. 1 <= ages[i] <= 120.
__label__Array Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.
__label__Data-Structures __label__Advanced-Data-Structures White Falcon was amazed by what she can do with heavy-light decomposition on trees. As a resut, she wants to improve her expertise on heavy-light decomposition. Her teacher gave her an another assignment which requires path updates. As always, White Falcon needs your help with the assignment. You are given a tree with  nodes and each node's value  is initially . Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   The problem asks you to operate the following two types of queries on the tree: "1 u v x" Add  to ,  to ,  to , ...,   to .  "2 u v" print the sum of the nodes' values on the path between  and  at modulo . Input Format First line cosists of two integers  and  seperated by a space. Following  lines contains two integers which denote the undirectional edges of the tree. Following  lines contains one of the query types described above. Note: Nodes are numbered by using 0-based indexing.  Constraints   Output Format For every query of second type print a single integer. Sample Input 3 2 0 1 1 2 1 0 2 1 2 1 2  Sample Output 5  Explanation After the first type of query, . Hence the answer of the second query is .
__label__Dynamic-Programming Given an array A of integers, return the length of the longest arithmetic subsequence in A. Recall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).   Example 1: Input: [3,6,9,12] Output: 4 Explanation:  The whole array is an arithmetic sequence with steps of length = 3.   Example 2: Input: [9,4,7,2,10] Output: 3 Explanation:  The longest arithmetic subsequence is [4,7,10].   Example 3: Input: [20,1,15,3,10,5,8] Output: 4 Explanation:  The longest arithmetic subsequence is [20,15,10,5].     Note:  2 <= A.length <= 2000 0 <= A[i] <= 10000
__label__Array Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000
__label__Strings We consider two strings to be anagrams of each other if the first string's letters can be rearranged to form the second string. In other words, both strings must contain the same exact letters in the same exact frequency. For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not. bacdc dcbac bacdc dcbad Alice is taking a cryptography class and finding anagrams to be very useful. She decides on an encryption scheme involving two large strings where encryption is dependent on the minimum number of character deletions required to make the two strings anagrams. Can you help her find this number?  Given two strings,  and , that may not be of the same length, determine the minimum number of character deletions required to make  and  anagrams. Any characters can be deleted from either of the strings.  For example,  and .  The only characters that match are the 's so we have to remove  from  and  from  for a total of  deletions.   Function Description  Complete the makingAnagrams function in the editor below.  It should return an integer representing the minimum number of deletions needed to make the strings anagrams.   makingAnagrams has the following parameter(s):   s1: a string   s2: a string   Input Format The first line contains a single string, .  The second line contains a single string, . Constraints   It is guaranteed that  and  consist of lowercase English letters, ascii[a-z]. Output Format Print a single integer denoting the minimum number of characters which must be deleted to make the two strings anagrams of each other. Sample Input cde abc  Sample Output 4  Explanation We delete the following characters from our two strings to turn them into anagrams of each other: Remove d and e from cde to get c. d e cde c Remove a and b from abc to get c. a b abc c We had to delete  characters to make both strings anagrams.
__label__Graph-Algorithms Let  be a connected, directed graph with vertices numbered from  to  such that any vertex is reachable from vertex . In addition, any two distinct vertices,  and , are connected by at most one edge . Consider the standard DFS (Depth-First Search) algorithm starting from vertex . As every vertex is reachable, each edge  of  is classified by the algorithm into one of four groups: tree edge: If  was discovered for the first time when we traversed . back edge: If  was already on the stack when we tried to traverse . forward edge: If  was already discovered while  was on the stack. cross edge: Any edge that is not a tree, back, or forward edge. To better understand this, consider the following C++ pseudocode: Given four integers, , , , and , construct any graph  having exactly  tree edges, exactly  back edges, exactly  forward edges, and exactly  cross edges. Then print  according to the Output Format specified below. Input Format A single line of four space-separated integers describing the respective values of , , , and . Constraints  Output Format If there is no such graph , print -1; otherwise print the following: -1 The first line must contain an integer, , denoting the number of vertices in . Each line  of the  subsequent lines must contain the following space-separated integers: The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. Sample Input 0 Sample Output 0 Explanation 0 The DFS traversal order is: . Thus, ,  and  are tree edges;  is a back edge;  is a forward edge; and  is a cross edge. This is demonstrated by the diagram below, in which tree edges are black, forward edges are blue, back edges are red, and cross edges are green.  Sample Input 1 Sample Output 1 Explanation 1 No such graph exists satisfying the given values.
__label__Tree __label__Depth-first-Search You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]
