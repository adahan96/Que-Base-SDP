__label__Hash-Table __label__Mathematics Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: "0.5"  Example 2: Input: numerator = 2, denominator = 1 Output: "2" Example 3: Input: numerator = 2, denominator = 3 Output: "0.(6)"
__label__Greedy-Algorithms Given an array of stick lengths, use  of them to construct a non-degenerate triange with the maximum possible perimeter. Print the lengths of its sides as  space-separated integers in non-decreasing order. If there are several valid triangles having the maximum perimeter:  Choose the one with the longest maximum side.  If more than one has that maximum, choose from them the one with the longest minimum side.  If more than one has that maximum as well, print any one them. If no non-degenerate triangle exists, print -1. -1 For example, assume there are stick lengths .  The triplet  will not form a triangle.  Neither will  or , so the problem is reduced to  and .  The longer perimeter is .   Function Description  Complete the maximumPerimeterTriangle function in the editor below.  It should return an array of  integers that represent the side lengths of the chosen triangle in non-decreasing order.   maximumPerimeterTriangle has the following parameter(s):   sticks: an integer array that represents the lengths of sticks available   Input Format The first line contains single integer , the size of array .  The second line contains  space-separated integers , each a stick length. Constraints   Output Format Print the lengths of the  chosen sticks as space-separated integers in non-decreasing order. If no non-degenerate triangle can be formed, print -1. -1 Sample Input 0 Sample Output 0 Explanation 0 There are  possible unique triangles:     The second triangle has the largest perimeter, so we print its side lengths on a new line in non-decreasing order. Sample Input 1 Sample Output 1 Explanation 1 The triangle  is degenerate and thus can't be constructed, so we print -1 on a new line. -1 Sample Input 2 Sample Output 2 Explanation 2 The triangle (1,1,1) is the only valid triangle.
__label__Data-Structures __label__Advanced-Data-Structures Shik loves sorted intervals. But currently he does not have enough time to sort all the numbers. So he decided to use Almost sorted intervals. An Almost sorted interval is a consecutive subsequence in a sequence which satisfies the following property: The first number is the smallest. The last number is the largest. Please help him count the number of almost sorted intervals in this permutation.   Note: Two intervals are different if at least one of the starting or ending indices are different. Input Format  The first line contains an integer N.  The second line contains a permutation from 1 to N. Output Format  Output the number of almost sorted intervals.   Constraints  1 ≤ N ≤ 106  Sample Input  5 3 1 2 5 4  Sample Output  8  Explanation  The subsequences [3], [1], [1 2], [1 2 5], [2], [2 5], [5], [4] are almost sorted intervals.
__label__Dynamic-Programming Divide-and-Conquer on a tree is a powerful approach to solving tree problems.  Imagine a tree, , with  vertices. Let's remove some vertex  from tree , splitting  into zero or more connected components, , with vertices . We can prove that there is a vertex, , such that the size of each formed components is at most . The Divide-and-Conquer approach can be described as follows: Initially, there is a tree, , with  vertices. Find vertex  such that, if  is removed from the tree, the size of each formed component after removing  is at most . Remove  from tree . Perform this approach recursively for each of the connected components. We can prove that if we find such a vertex  in linear time (e.g., using DFS), the entire approach works in . Of course, sometimes there are several such vertices  that we can choose on some step, we can take and remove any of them. However, right now we are interested in trees such that at each step there is a unique vertex  that we can choose. Given , count the number of tree 's such that the Divide-and-Conquer approach works determinately on them. As this number can be quite large, your answer must be modulo . Input Format A single line of two space-separated positive integers describing the respective values of  (the number of vertices in tree ) and  (the modulo value). Constraints    is a prime number. Subtasks  for  of the maximum score.  for  of the maximum score.  Output Format Print a single integer denoting the number of tree 's such that vertex  is unique at each step when applying the Divide-and-Conquer approach, modulo . Sample Input 0 1 103  Sample Output 0  1  Explanation 0 For , there is only one way to build a tree so we print the value of  as our answer. Sample Input 1 2 103  Sample Output 1 0  Explanation 1 For , there is only one way to build a tree:  This tree is not valid because we can choose to remove either node  or node  in the first step. Thus, we print  as no valid tree exists. Sample Input 2 3 103  Sample Output 2 3   Explanation 2 For , there are  valid trees depicted in the diagram below (the unique vertex removed in the first step is shown in red):  Thus, we print the value of  as our answer. Sample Input 3 4 103  Sample Output 3 4  Explanation 3 For , there are  valid trees depicted in the diagram below (the unique vertex removed in the first step is shown in red):  The figure below shows an invalid tree with :  This tree is not valid because we can choose to remove node  or node  in the first step. Because we had four valid trees, we print the value of  as our answer.
__label__Data-Structures __label__Advanced-Data-Structures Jaggu is a little kid and he likes playing with water balloons. He took 1 million ( 106 ) empty buckets and he filled the bucket with water balloons under the instruction of his sister Ishika.  His sister gives him two types of commands: R pos1 pos2 which implies that jaggu needs to tell her what is the total number of water balloons in the bucket from pos1 to pos2 (both included). R pos1 pos2 U pos M plus which implies that he has to work like the function  U pos M plus Update(pos,M,plus) void Update(int pos,int M,int plus) {     int N=1000000;  //1 million     for (int i=1;i<=50;i++)     {         int back = pos         for(int j=1;j<=1000;j++)         {             add M water ballons at bucket pos             int s,in=__builtin_popcount(pos);             for(int k=0;;k++)             {                 s=pos+pow(2,k)                 if( __builtin_popcount(s) <= in )                 {                     in = __builtin_popcount(s)                     pos = s;                     if(pos>N)       break;                     add M water ballons at bucket pos                 }             }             pos = pos - N         }         pos = back+plus;         if(pos>N) pos-=N;     } }  Jaggu is too lazy to put the water ballons in the bucket. Afraid that he might be caught for not doing what his sister told him to do so, he asks your help to provide correct answers  for each of his sister's query. . Input Format First line contains Q, number of queries to follow. Next Q line follows , which can be either an Update Query or Report Query.Each Update Query is followed by atleast 1 report query. Output Format For each report query , output the answer in a separate line. Constraints 1 ≤ Q ≤ 2 * 105 1 ≤ pos1,pos2,pos ≤ 106 pos1 ≤ pos2 1 ≤ M ≤ 10 1 ≤ plus ≤ 999999 Sample Input 2 U 692778 7 291188 R 636916 747794  Sample Output 378   Explanation Follow the code above to get the answer. Note  Input is randomly generated. Input is randomly generated. __builtin_popcount(x) gives the number of set bits in binary representation of x. __builtin_popcount(x) gives the number of set bits in binary representation of x. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2. Timelimit is 3 times the timelimit mentioned here
__label__Strings Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = "abcd" and B = "cdabcdab". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd"). Note: The length of A and B will be between 1 and 10000.
__label__Mathematics There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be. Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:  Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...    Example 1: Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]    Example 2: Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]    Example 3: Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].    Note: n and m both fit in range [0, 1000].
__label__Data-Structures Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value  and insert it into a sorted linked list while maintaining the sort. Function Description Complete the sortedInsert function in the editor below. It must return a reference to the head of your modified DoublyLinkedList. sortedInsert has two parameters: head: A reference to the head of a doubly-linked list of DoublyLinkedListNode objects. data: An integer denoting the value of the  field for the DoublyLinkedListNode you must insert into the list. Note: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.  Input Format The first line contains an integer , the number of test cases. Each of the test case is in the following format:   The first line contains an integer , the number of elements in the linked list.   Each of the next  lines contains an integer, the data for each node of the linked list.   The last line contains an integer  which needs to be inserted into the sorted doubly-linked list. Constraints      Output Format Do not print anything to stdout. Your method must return a reference to the  of the same list that was passed to it as a parameter. The ouput is handled by the code in the editor and is as follows:  For each test case, print the elements of the sorted doubly-linked list separated by spaces on a new line.   Sample Input 1 4 1 3 4 10 5  Sample Output 1 3 4 5 10  Explanation The initial doubly linked list is:  .  The doubly linked list after insertion is:
__label__Dynamic-Programming You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),              because they are adjacent houses.  Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4.
__label__Search You have a long list of tasks that you need to do today. To accomplish task  you need  minutes, and the deadline for this task is . You need not complete a task at a stretch. You can complete a part of it, switch to another task, and then switch back. You've realized that it might not be possible to complete all the tasks by their deadline. So you decide to do them in such a manner that the maximum amount by which a task's completion time overshoots its deadline is minimized. Input Format The first line contains the number of tasks, . Each of the next  lines contains two integers,  and . Constraints       Output Format Output  lines. The  line contains the value of the maximum amount by which a task's completion time overshoots its deadline, when the first  tasks on your list are scheduled optimally. See the sample input for clarification. Sample Input 5 2 2 1 1 4 3 10 1 2 1  Sample Output 0   1   2   2   3  Explanation The first task alone can be completed in 2 minutes, and so you won't overshoot the deadline.  With the first two tasks, the optimal schedule can be:  time 1: task 2  time 2: task 1   time 3: task 1 We've overshot task 1 by 1 minute, hence returning 1.  With the first three tasks, the optimal schedule can be:  time 1 : task 2  time 2 : task 1  time 3 : task 3  time 4 : task 1  time 5 : task 3  time 6 : task 3 Task 1 has a deadline 2, and it finishes at time 4. So it exceeds its deadline by 2.  Task 2 has a deadline 1, and it finishes at time 1. So it exceeds its deadline by 0.  Task 3 has a deadline 4, and it finishes at time 6. So it exceeds its deadline by 2.   Thus, the maximum time by which you overshoot a deadline is 2. No schedule can do better than this. Similar calculation can be done for the case containing 5 tasks.
__label__Hash-Table We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words.  You may return the list in any order.      Example 1: Input: A = "this apple is sweet", B = "this apple is sour" Output: ["sweet","sour"]   Example 2: Input: A = "apple apple", B = "banana" Output: ["banana"]    Note:  0 <= A.length <= 200 0 <= B.length <= 200 A and B both contain only spaces and lowercase letters.
__label__Mathematics __label__Two-Pointers We sampled integers between 0 and 255, and stored the results in an array count:  count[k] is the number of integers we sampled equal to k. Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers.  The mode is guaranteed to be unique. (Recall that the median of a sample is:  The middle element, if the elements of the sample were sorted and the number of elements is odd; The average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)    Example 1: Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,3.00000,2.37500,2.50000,3.00000] Example 2: Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,4.00000,2.18182,2.00000,1.00000]    Constraints:  count.length == 256 1 <= sum(count) <= 10^9 The mode of the sample that count represents is unique. Answers within 10^-5 of the true value will be accepted as correct.
__label__Tree Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \       2      6      / \         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.  Note:  The size of the BST will be between 2 and 100. The BST is always valid, each node's value is an integer, and each node's value is different.
__label__Hash-Table A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.   Example 1:  Input: {"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}  Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself.    Note:  You must return the copy of the given head as a reference to the cloned list.
__label__Hash-Table Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.   A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: true  Example 2: Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9.
__label__Data-Structures Create a list, , of  empty sequences, where each sequence is indexed from  to . The elements within each of the  sequences also use -indexing. Create an integer, , and initialize it to . The  types of queries that can be performed on your list of sequences () are described below: Query: 1 x y Find the sequence, , at index  in . Append integer  to sequence . Query: 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line Query: 1 x y Find the sequence, , at index  in . Append integer  to sequence . 1 x y Find the sequence, , at index  in . Append integer  to sequence . Query: 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line 2 x y Find the sequence, , at index  in . Find the value of element  in  (where  is the size of ) and assign it to . Print the new value of  on a new line Task  Given , , and  queries, execute each query. Note:  is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia.  ^ Input Format The first line contains two space-separated integers,  (the number of sequences) and  (the number of queries), respectively.  Each of the  subsequent lines contains a query in the format defined above. Constraints    It is guaranteed that query type  will never query an empty sequence or index. Output Format For each type  query, print the updated value of  on a new line. Sample Input 2 5 1 0 5 1 1 7 1 0 3 2 1 0 2 1 1  Sample Output 7 3  Explanation Initial Values:       = [ ]   = [ ]   Query 0: Append  to sequence .     = [5]   = [ ]      Query 1: Append  to sequence .   = [5]   = [7]   Query 2: Append  to sequence .     = [5, 3]   = [7]    Query 3: Assign the value at index  of sequence  to , print .     = [5, 3]   = [7]   7  Query 4: Assign the value at index  of sequence  to , print .     = [5, 3]   = [7]   3
__label__Dynamic-Programming Nikita just came up with a new array game. The rules are as follows: Initially, Nikita has an array of integers. Initially, Nikita has an array of integers. In each move, Nikita must partition the array into  non-empty contiguous parts such that the sum of the elements in the left partition is equal to the sum of the elements in the right partition. If Nikita can make such a move, she gets  point; otherwise, the game ends. In each move, Nikita must partition the array into  non-empty contiguous parts such that the sum of the elements in the left partition is equal to the sum of the elements in the right partition. If Nikita can make such a move, she gets  point; otherwise, the game ends. After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array . After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array . Nikita loves this game and wants your help getting the best score possible. Given , can you find and print the maximum number of points she can score? For example, Nikita starts with the array .  She first splits it into  and , then discards .  .  Discard  leaving .  This cannot be further split, so Nikita scored .    Function Description  Complete the arraySplitting function in the editor below.  It should return an integer that reperesents the number of times Nikita can split the array.   arraySplitting has the following parameter(s):   arr: an array of integers   Input Format The first line contains an integer , the number of test cases.  Each of the next  pairs of lines is as follows:   The first line contains an integer , the size of array . The next line contains  space-separated integers .   Constraints    Scoring   for  of the test data  for  of the test data  for  of the test data Output Format For each test case, print Nikita's maximum possible score on a new line. Sample Input 3 3 3 3 3 4 2 2 2 2 7 4 1 0 1 1 0 1  Sample Output 0 2 3  Explanation Test Case 0:  Nikita cannot partition  into  parts having equal sums. Therefore, her maximum possible score is  and we print  on a new line. Test Case 1:  Initially,  looks like this:   She splits the array into  partitions having equal sums, and then discards the left partition:     She then splits the new array into  partitions having equal sums, and then discards the left partition:        At this point the array only has  element and can no longer be partitioned, so the game ends. Because Nikita successfully split the array twice, she gets  points and we print  on a new line. Test Case 2: The answer is .
__label__Mathematics Given a string S that only contains "I" (increase) or "D" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:  If S[i] == "I", then A[i] < A[i+1] If S[i] == "D", then A[i] > A[i+1]    Example 1: Input: "IDID" Output: [0,4,1,3,2]   Example 2: Input: "III" Output: [0,1,2,3]   Example 3: Input: "DDI" Output: [3,2,0,1]     Note:  1 <= S.length <= 10000 S only contains characters "I" or "D".
__label__Tree __label__Data-Structures You are given pointer to the root of the binary search tree and two values  and . You need to return the lowest common ancestor (LCA) of  and  in the binary search tree.     In the diagram above, the lowest common ancestor of the nodes  and  is the node .  Node  is the lowest node which has nodes  and  as descendants. Function Description  Complete the function lca in the editor below.  It should return a pointer to the lowest common ancestor node of the two values given.   lca has the following parameters:  -  root: a pointer to the root node of a binary search tree  -  v1: a node.data value  -  v2: a node.data value   Input Format The first line contains an integer, , the number of nodes in the tree.  The second line contains  space-separated integers representing  values.  The third line contains two space-separated integers,  and .   To use the test data, you will have to create the binary search tree yourself.  Here on the platform, the tree will be created for you. Constraints       The tree will contain nodes with data equal to  and .   Output Format Return the a pointer to the node that is the lowest common ancestor of  and . Sample Input 6 4 2 3 1 7 6 1 7     and . Sample Output [reference to node 4] Explanation LCA of  and  is , the root in this case.  Return a pointer to the node.
__label__Strings Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.  Example 1: Input: "aba" Output: True   Example 2: Input: "abca" Output: True Explanation: You could delete the character 'c'.   Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
__label__Search Sorting is useful as the first step in many different tasks. The most common task is to make finding things easier, but there are other uses as well.  In this case, it will make it easier to determine which pair or pairs of elements have the smallest absolute difference between them. For example, if you've got the list , sort it as  to see that several pairs have the minimum difference of : .  The return array would be . Given a list of unsorted integers, , find the pair of elements that have the smallest absolute difference between them. If there are multiple pairs, find them all. Function Description  Complete the closestNumbers function in the editor below.  It must return an array of integers as described. closestNumbers has the following parameter(s):   arr: an array of integers   Input Format The first line contains a single integer , the length of .  The second line contains  space-separated integers, . Constraints   All  are unique in . Output Format Output the pairs of elements with the smallest difference. If there are multiple pairs, output all of them in ascending order, all on the same line with just a single space between each pair of numbers. A number may be part of two pairs when paired with its predecessor and its successor. Sample Input 0 10 -20 -3916237 -357920 -3620601 7374819 -7330761 30 6246457 -6461594 266854   Sample Output 0 -20 30  Explanation 0  (30) - (-20) = 50, which is the smallest difference.   Sample Input 1 12 -20 -3916237 -357920 -3620601 7374819 -7330761 30 6246457 -6461594 266854 -520 -470   Sample Output 1 -520 -470 -20 30  Explanation 1  (-470) - (-520) = 30 - (-20) = 50, which is the smallest difference.  Sample Input 2 4 5 4 3 2  Sample Output 2 2 3 3 4 4 5  Explanation 2  Here, the minimum difference will be 1. Valid pairs are (2, 3), (3, 4), and (4, 5). We print the elements of each pair, space-separated on a single line.
__label__Game-Theory Two players (numbered  and ) are playing a game of Tower Breakers! The rules of the game are as follows: Player  always moves first, and both players always move optimally. Initially there are  towers of various heights. The players move in alternating turns. In each turn, a player can choose a tower of height  and reduce its height to , where  and  evenly divides . If the current player is unable to make any move, they lose the game. Given the value of  and the respective height values for all towers, can you determine who will win? If the first player wins, print ; otherwise, print . Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of towers.  space-separated integers, , where each  describes the height of tower . Constraints    Output Format For each test case, print a single integer denoting the winner (i.e., either  or ) on a new line. Sample Input 2 2  1 2 3  1 2 3  Sample Output 1 2  Explanation Test Case 0:  Player  reduces the second tower to height  and subsequently wins. Test Case 1:  There are two possible moves: Reduce the second tower to   Reduce the third tower to .  Whichever move player  makes, player  will make the other move. Thus, player  wins.
__label__Depth-first-Search Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order. Example 1: Input:  accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]] Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]] Explanation:  The first and third John's are the same person as they have the common email "johnsmith@mail.com". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.   Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30].
__label__Search We call an quadruple of positive integers, , beautiful if the following condition is true:   Note:  is the bitwise XOR operator. Given , , , and , count the number of beautiful quadruples of the form  where the following constraints hold:     When you count the number of beautiful quadruples, you should consider two quadruples as same if the following are true: They contain same integers. Number of times each integers occur in the quadruple is same. For example  and  should be considered as same. Input Format A single line with four space-separated integers describing the respective values of , , , and . Constraints  For  of the maximum score,  Output Format Print the number of beautiful quadruples. Sample Input 1 2 3 4  Sample Output 11  Explanation There are  beautiful quadruples for this input:            Thus, we print  as our output. Note that  is same as .
__label__Binary-Search __label__Dynamic-Programming __label__Greedy-Algorithms Given a string s and a string t, check if s is subsequence of t.   You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  Example 1: s = "abc", t = "ahbgdc"   Return true.  Example 2: s = "axc", t = "ahbgdc"   Return false.  Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases.
__label__Dynamic-Programming Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1] in clockwise order. Suppose you triangulate the polygon into N-2 triangles.  For each triangle, the value of that triangle is the product of the labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation. Return the smallest possible total score that you can achieve with some triangulation of the polygon.      Example 1: Input: [1,2,3] Output: 6 Explanation: The polygon is already triangulated, and the score of the only triangle is 6.   Example 2:  Input: [3,7,4,5] Output: 144 Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.  The minimum score is 144.   Example 3: Input: [1,3,1,4,1,5] Output: 13 Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.    Note:  3 <= A.length <= 50 1 <= A[i] <= 100
__label__Strings __label__Dynamic-Programming A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26  Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: "12" Output: 2 Explanation: It could be decoded as "AB" (1 2) or "L" (12).  Example 2: Input: "226" Output: 3 Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
__label__Mathematics __label__Dynamic-Programming Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note:    1 is typically treated as an ugly number. n does not exceed 1690.
__label__Mathematics __label__Dynamic-Programming Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.    Example 1: Input: 20 Output: 1 Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.   Example 2: Input: 100 Output: 10 Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.   Example 3: Input: 1000 Output: 262     Note:  1 <= N <= 10^9
__label__Array __label__Two-Pointers Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You are given the pointer to the head node of a linked list and you need to print all its elements in reverse order from tail to head, one element per line. The head pointer may be null meaning that the list is empty - in that case, do not print anything! Input Format You have to complete the void reversePrint(SinglyLinkedListNode* head) method which takes one argument - the head of the linked list. You should NOT read any input from stdin/console. void reversePrint(SinglyLinkedListNode* head) The first line of input contains , the number of test cases.  The input of each test case is as follows:   The first line contains an integer , denoting the number of elements in the list.   The next n lines contain one element each, denoting the elements of the linked list in the order. Constraints   , where  is the  element in the list.   Output Format Complete the reversePrint function in the editor below and print the elements of the linked list in the reverse order, each in a new line.  Sample Input 3 5 16 12 4 2 5 3 7 3 9 5 5 1 18 3 13  Sample Output 5 2 4 12 16 9 3 7 13 3 18 1 5  Explanation There are three test cases.  The first linked list has  elements: 16 -> 12 -> 4 -> 2 -> 5. Printing this in reverse order will produce: 5 -> 2 -> 4 -> 12 -> 16.  The second linked list has  elements: 7 -> 3 -> 9. Printing this in reverse order will produce: 9 -> 3 -> 7.  The third linked list has  elements: 5 -> 1 -> 18 -> 3 -> 13. Printing this in reverse order will produce: 13 -> 3 -> 18 -> 1 -> 5.   16 -> 12 -> 4 -> 2 -> 5 5 -> 2 -> 4 -> 12 -> 16 7 -> 3 -> 9 9 -> 3 -> 7 5 -> 1 -> 18 -> 3 -> 13 13 -> 3 -> 18 -> 1 -> 5
__label__Array In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.    Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.    Note:  nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99].
__label__Data-Structures Alice was given the  integers from  to . She wrote all possible permutations in increasing lexicographical order, and wrote each permutation in a new line. For example, for , there are  possible permutations:       She then chose one permutation among them as her favorite permutation. After some time, she forgot some elements of her favorite permutation. Nevertheless, she still tried to write down its elements. She wrote a  in every position where she forgot the true value. She wants to know the sum of the line numbers of the permutations which could possibly be her favorite permutation, i.e., permutations which can be obtained by replacing the s. Can you help her out?  Since the sum can be large, find it modulo . Input Format The first line contains a single integer . The next line contains  space-separated integers  denoting Alice's favorite permutation with some positions replaced by .   Constraints   The positive values appearing in  are distinct. Subtask  For ~33% of the total points,   Output Format Print a single line containing a single integer denoting the sum of the line numbers of the permutations which could possibly be Alice's favorite permutation. Sample Input 0 Sample Output 0 Explanation 0 The possible permutations are  and . The permutation  occurs on line  and the permutation  occurs on line . Therefore the sum is . Sample Input 1 Sample Output 1 Explanation 1 There is no missing number in the permutation. Therefore, the only possible permutation is , and it occurs on line . Therefore the sum is .
__label__Dynamic-Programming Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.  Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.  Example 1: Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.   Example 2: Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.   Note:  1 <= length of the array <= 20.  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.
__label__Depth-first-Search In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)   Example 1: Input: [[0,1],[1,0]] Output: 1   Example 2: Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2   Example 3: Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1     Note:  1 <= A.length = A[0].length <= 100 A[i][j] == 0 or A[i][j] == 1
__label__Mathematics __label__Dynamic-Programming A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7  A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A.   Example: A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
__label__Array Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: True   Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: False   Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.
__label__Array __label__Two-Pointers Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]
__label__Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1]  Output: [5,6]
__label__Strings Given an input string, reverse the string word by word.   Example 1: Input: "the sky is blue" Output: "blue is sky the"  Example 2: Input: "  hello world!  " Output: "world! hello" Explanation: Your reversed string should not contain leading or trailing spaces.  Example 3: Input: "a good   example" Output: "example good a" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.    Note:  A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.    Follow up: For C programmers, try to solve it in-place in O(1) extra space.
__label__Graph-Algorithms __label__Greedy-Algorithms __label__Graph-Algorithms The Ruler of HackerLand believes that every citizen of the country should have access to a library. Unfortunately, HackerLand was hit by a tornado that destroyed all of its libraries and obstructed its roads! As you are the greatest programmer of HackerLand, the ruler wants your help to repair the roads and build some new libraries efficiently.  HackerLand has  cities numbered from  to . The cities are connected by  bidirectional roads. A citizen has access to a library if: Their city contains a library. They can travel by road from their city to a city containing a library. The following figure is a sample map of HackerLand where the dotted lines denote obstructed roads:  The cost of repairing any road is  dollars, and the cost to build a library in any city is  dollars.  If in the above example  and , we would build  roads at a cost of  and  libraries for a cost of .  We don't need to rebuild one of the roads in the cycle .     You are given  queries, where each query consists of a map of HackerLand and value of  and . For each query, find the minimum cost of making libraries accessible to all the citizens and print it on a new line. Function Description Complete the function roadsAndLibraries in the editor below.  It must return the minimal cost of providing libraries to all, as an integer. roadsAndLibraries has the following parameters: n: integer, the number of cities   c_lib: integer, the cost to build a library   c_road: integer, the cost to repair a road   cities: 2D array of integers where each  contains two integers that represent cities connected by an obstructed road .  Input Format The first line contains a single integer , that denotes the number of queries.  The subsequent lines describe each query in the following format:  - The first line contains four space-separated integers that describe the respective values of , ,  and , the number of cities, number of roads, cost of a library and cost of a road.  - Each of the next  lines contains two space-separated integers,  and , that describe a bidirectional road that connects cities  and . Constraints       Each road connects two distinct cities. Output Format For each query, print an integer that denotes the minimum cost to make libraries accessible to all the citizens on a new line. Sample Input 2 3 3 2 1 1 2 3 1 2 3 6 6 2 5 1 3 3 4 2 4 1 2 2 3 5 6  Sample Output 4 12  Explanation Perform the following  queries: HackerLand contains  cities connected by  bidirectional roads. The price of building a library is  and the price for repairing a road is .    The cheapest way to make libraries accessible to all is to: Build a library in city  at a cost of . Repair the road between cities  and  at a cost of . Repair the road between cities  and  at a cost of . This gives a total cost of . Note that the road between cities  and  does not need to be repaired each is connected to city .   HackerLand contains  cities connected by  bidirectional roads. The price of building a library is  and the price for repairing a road is .    The cheapest way to make libraries accessible to all is to: Build a library in city  at a cost of . Repair the road between cities  and  at a cost of . Repair the road between cities  and  at a cost of . This gives a total cost of . Note that the road between cities  and  does not need to be repaired each is connected to city .   In this scenario it is optimal to build a library in each city because the cost of building a library () is less than the cost of repairing a road ().   There are  cities, so the total cost is . In this scenario it is optimal to build a library in each city because the cost of building a library () is less than the cost of repairing a road ().   There are  cities, so the total cost is .
__label__Graph-Algorithms You are given  unweighted, undirected graphs, , , and , with  vertices each, where the  graph has  edges and the vertices in each graph are numbered from  through . Find the number of ordered triples , where , , such that there is an edge  in , an edge  in , and an edge  in . Input Format The first line contains single integer, , denoting the number of vertices in the graphs. The subsequent lines define , , and . Each graph is defined as follows: The first line contains an integer, , describing the number of edges in the graph being defined. Each line  of the  subsequent lines (where ) contains  space-separated integers describing the respective nodes,  and  connected by edge . Constraints  , and  Each graph contains no cycles and any pair of directly connected nodes is connected by a maximum of  edge. Output Format Print a single integer denoting the number of distinct  triples as described in the Problem Statement above. Sample Input 3 2 1 2 2 3 3 1 2 1 3 2 3 2 1 3 2 3  Sample Output 3  Explanation There are three possible triples in our Sample Input:     Thus, we print  as our output.
__label__Tree Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 9  Output: True    Example 2: Input:      5    / \   3   6  / \   \ 2   4   7  Target = 28  Output: False
__label__Tree __label__Depth-first-Search Two players play a turn based game on a binary tree.  We are given the root of this binary tree, and the number of nodes n in the tree.  n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x.  The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player.  In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn.  If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player.  If it is possible to choose such a y to ensure you win the game, return true.  If it is not possible, return false.   Example 1:  Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2.    Constraints:  root is the root of a binary tree with n nodes and distinct node values from 1 to n. n is odd. 1 <= x <= n <= 100
__label__Graph-Algorithms The country of Byteland contains  cities and  bidirectional roads. There is a path between any two cities. The roads in Byteland were built long ago, and now they are in need of repair. You have been hired to fix all the roads. You intend to do this by dispatching robots on some of the roads. Each robot will repair the road he is currently on and then moves to one of the adjacent unrepaired roads. After repairing that, it will move to another adjacent unrepaired road, repair that and so on. Two roads are adjacent if they have the same city at one of their endpoints. For the process to be efficient, no two robots will ever repair the same road, and no road can be visited twice. What is the minimum number of robots needed to accomplish the task? Input Format The first line contains the number of test cases .  test cases follow. The first line of each test case contains , the number of cities in Byteland. The cities are numbered . The following  lines contain the description of the roads. The  line contains two integers  and , meaning that there is a road connecting cities with numbers  and . Constraints      Output Format Print  lines, one corresponding to each test case containing the required answer for that test case. Sample Input 3   4   0 1   0 2   0 3   6   0 1   1 2   2 3   2 4   4 5   7   0 1   1 2   2 3   2 4   4 5   3 6  Sample Output 1   1   2  Explanation For the first case, one robot is enough to repair all roads:   For the second case, one robot is again enough:   The the third case, there is no way to repair all the roads with one robot and at least two are needed.
__label__Strings Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.   Example 1: Input: ["23:59","00:00"] Output: 1   Note:  The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59.
__label__Depth-first-Search A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.  The world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.  Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.  Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.  Example 1: Input: grid =  [[0,1,0,0,0,0,0,1],  [0,1,0,0,0,0,0,1],  [0,0,0,0,0,0,0,1],  [0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:  [[0,1,0,0,0,0,1,1],  [0,1,0,0,0,0,1,1],  [0,0,0,0,0,0,1,1],  [0,0,0,0,0,0,0,1]]  On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.   Example 2: Input: grid =  [[1,1,1],  [1,0,1],  [1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells.   Example 3: Input: grid =  [[1,1,1,0,0,0,0,0,0],  [1,0,1,0,1,1,1,1,1],  [1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls.   Note:  The number of rows and columns of grid will each be in the range [1, 50]. Each grid[i][j] will be either 0 or 1. Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.
__label__Data-Structures Consider an array of integers, . We define the absolute difference between two elements,  and  (where ), to be the absolute value of . Given an array of integers, find and print the minimum absolute difference between any two elements in the array.  For example, given the array  we can create  pairs of numbers:  and .  The absolute differences for these pairs are ,  and .  The minimum absolute difference is . Function Description  Complete the minimumAbsoluteDifference function in the editor below.  It should return an integer that represents the minimum absolute difference between any pair of elements.   minimumAbsoluteDifference has the following parameter(s):   n: an integer that represents the length of arr  arr: an array of integers   Input Format The first line contains a single integer , the size of .  The second line contains  space-separated integers .    Constraints     Output Format Print the minimum absolute difference between any two elements in the array. Sample Input 0 Sample Output 0 Explanation 0 With  integers in our array, we have three possible pairs: , , and . The absolute values of the differences between these pairs are as follows:       Notice that if we were to switch the order of the numbers in these pairs, the resulting absolute values would still be the same. The smallest of these possible absolute differences is . Sample Input 1 Sample Output 1 Explanation 1 The smallest absolute difference is . Sample Input 2 Sample Output 2 Explanation 2 The minimum absolute difference is .
__label__Hash-Table __label__Tree Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.  Examples 1 Input:   5  /  \ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.  Examples 2 Input:   5  /  \ 2   -5  return [2], since 2 happens twice, however -5 only occur once.  Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.
__label__Dynamic-Programming Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.  Example 1: Input:  "bbbab"  Output:  4  One possible longest palindromic subsequence is "bbbb".  Example 2: Input: "cbbd"  Output: 2  One possible longest palindromic subsequence is "bb".
__label__Strings In this challenge, you will determine whether a string is funny or not.  To determine whether a string is funny, create a copy of the string in reverse e.g. .  Iterating through each string, compare the absolute difference in the ascii values of the characters at positions 0 and 1, 1 and 2 and so on to the end.  If the list of absolute differences is the same for both strings, they are funny. Determine whether a give string is funny.  If it is, return Funny, otherwise return Not Funny. Funny Not Funny For example, given the string , the ordinal values of the charcters are .   and the ordinals are .  The absolute differences of the adjacent elements for both strings are , so the answer is Funny. Funny Function Description Complete the funnyString function in the editor below.  For each test case, it should return a string, either Funny or Not Funny. Funny Not Funny funnyString has the following parameter(s):   s: a string to test Input Format The first line contains an integer , the number of queries.  The next  lines each contain a string, .    Constraints     Output Format For each string   print whether it is Funny or Not Funny on a new line. Funny Not Funny Sample Input 2 acxz bcxz  Sample Output Funny Not Funny  Explanation You can use  to store the reverse of . Test Case 0:  ,   Corresponding ASCII values of characters of the strings:   and   For both the strings the adjacent difference list is [2, 21, 2] so we print Funny.   Funny Test Case 1:  ,   Corresponding ASCII values of characters of the strings:   and   The adjacent difference list for string  is [1, 21, 2] and for string  it is [2, 21, 1]. Since they are not the same we print Not Funny.  Not Funny
__label__Greedy-Algorithms Given an array nums sorted in ascending order, return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers and has length at least 3.   Example 1: Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5   Example 2: Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5   Example 3: Input: [1,2,3,4,4,5] Output: False    Constraints:  1 <= nums.length <= 10000
__label__Array Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.   Example 2: Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.   Example 3: Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.
__label__Greedy-Algorithms In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.   Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2].   Example 2: Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].   Example 3: Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]      Note:  1 <= A.length <= 30000 1 <= K <= A.length
__label__Dynamic-Programming A car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.    Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling.   Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can't reach the target (or even the first gas station).   Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation:  We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2.    Note:  1 <= target, startFuel, stations[i][1] <= 10^9 0 <= stations.length <= 500 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target
__label__Data-Structures People connect with each other in a social network. A connection between Person  and Person  is represented as . When two persons belonging to different communities connect, the net effect is the merger of both communities which  and  belongs to.  At the beginning, there are  people representing  communities. Suppose person  and  connected and later  and  connected, then ,, and  will belong to the same community. There are two type of queries:  communities containing person  and  merged (if they belong to different communities).  communities containing person  and  merged (if they belong to different communities).  print the size of the community to which person  belongs.   print the size of the community to which person  belongs.  Input Format The first line of input will contain integers  and , i.e. the number of people and the number of queries. The next  lines will contain the queries. Constraints :   Output Format The output of the queries. Sample Input 3 6 Q 1 M 1 2 Q 2 M 2 3 Q 3 Q 2  Sample Output 1 2 3 3  Explanation Initial size of each of the community is .
__label__Dynamic-Programming __label__Tree __label__Depth-first-Search Given a binary tree, we install cameras on the nodes of the tree.  Each camera at a node can monitor its parent, itself, and its immediate children. Calculate the minimum number of cameras needed to monitor all nodes of the tree.   Example 1:   Input: [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown.   Example 2:  Input: [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.   Note:  The number of nodes in the given tree will be in the range [1, 1000]. Every node has value 0.
__label__Graph-Algorithms There are  colors of beads. You have  beads of the  color. You want to make an ornament by joining all the beads together. You create the ornament by using the following algorithm: Step # Arrange all the beads in any order such that beads of the same color are placed together. Step # Arrange all the beads in any order such that beads of the same color are placed together. Step # The ornament initially consists of only the first bead from the arrangement. Step # The ornament initially consists of only the first bead from the arrangement. Step # For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament. Step # For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament. All beads are distinct, even if they have the same color. How many different ornaments can be formed by following the above algorithm? Two ornaments are considered different if two beads are joined by a thread in one configuration, but not in the other. Update/clarification Think of the bead formation as a tree and not as a straight line. Any number of beads can be connected to a bead. Input Format The first line contains the number of test cases .  test cases follow. Each test case contains  on the first line - the number of colors of beads. The next line contains  integers, where the  integer  denotes the number of beads of the  color. Constraints    Output Format Output  lines, one for each test case. All answers should be output modulo . Sample Input 5 2 2 1 2 2 2 1 4 2 3 1 5 1 1 1 1 1  Sample Output Explanation Testcase 1: Let us label the beads A1,A2 and B1. Initially, they can be arranged in  ways - "A1,A2,B1", "A2,A1,B1", "B1,A1,A2", and "B1,A2,A1".  For each of the first two arrangements, an ornament can be formed in  ways (A1-A2-B1 or B1-A1-A2 from the first one and A2-A1-B1 or B1-A2-A1 from the second one).  For each of the last two arrangements, an ornament can be formed in  way.  However, of the total  possible ornaments, there are only  unique ones : A1 - A2 - B1, and A2 - A1 - B1. Testcase 2: The possible unique ornaments are A1 - A2 - B1 - B2, A1 - A2 - B2 - B1, A2 - A1 - B1 - B2, and A2 - A1 - B2 - B1. Testcase 3: For the third test-case, it might be easier to see there are only  types of graphs on  vertices: the path or the star. It's not hard to see that there are  paths and  stars (explanation courtesy: zlangley) Testcase 5: For the fifth test-case, a lot of people claimed that the total number of possible ways is . But that is wrong. The correct answer is . Here's the hint: Once again, you've to think of it as a tree.  So one possible arrangement can be: A is a root node and has two edges (A-B and A-C). Now, think of B as a sub-root node with two edges (B-D and B-E). Similarly, you can figure out the other possible bead arrangements. This will lead you to the correct answer.
__label__Dynamic-Programming Ma5termind is crazy about Action Games. He just bought a new one and got down to play it. Ma5termind usually finishes all the levels of a game very fast. But, This time however he got stuck at the very first level of this new game. Can you help him play this game.   To finish the game, Ma5termind has to cross  levels. At each level of the game, Ma5termind has to face  enemies. Each enemy has its associated power  and some number of bullets . To knock down an enemy, Ma5termind needs to shoot him with one or multiple bullets whose collective count is equal to the power of the enemy. If Ma5termind manages to knock down any one enemy at a level, the rest of them run away and the level is cleared.    Here comes the challenging part of the game.  Ma5termind acquires all the bullets of an enemy once he has knocked him down. Ma5termind can use the bullets acquired after killing an enemy at  level only till the  level.   However, the bullets Ma5termind carried before the start of the game can be taken forward and can be used to kill more enemies.   Now, Ma5termind has to guess the minimum number of bullets he must have before the start of the game so that he clears all the  levels successfully.   NOTE  Bullets carried before the start of the game can be used to kill an enemy at any level.   One bullet decreases the power of an enemy by 1 Unit.   For better understanding of the problem look at the sample testcases.   Input Format First line of input contains a single integer  denoting the number of test cases.  First line of each test case contains two space separated integers  and  denoting the number of levels and number of enemies at each level respectively.  Each of next  lines of a test case contain  space separated integers, where  integer in the  line denotes the power  of  enemy on the  level.  Each of the next  lines of a test case contains  space separated integers, where  integer in the  line denotes the number of bullets   enemy of  level has.   Constraints          For each test file, sum of  over all the test cases does not exceed .    Output Format For each test case, print the required answer.   Sample Input 2 3 3 3 2 1  1 2 3 3 2 1 1 2 3 3 2 1 1 2 3 3 3  3 2 5  8 9 1  4 7 6  1 1 1  1 1 1  1 1 1   Sample Output 1 5     Explanation For the First test case , Ma5termind kills the enemy in the following order: Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. So this way Ma5termind can successfully finish this game with only  bullet in hand before the start of the game. For the second test case , Ma5termind kills the enemy in the following order: Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. Ma5termind kills the  enemy at the  level, takes all his bullets and moves to the next level. So this way Ma5termind can successfully finish this game with only  bullet in hand before the start of the game. NOTE:  There can be more than one way of getting the optimal answer but that does not matter in our case, because we need to answer the minimum number of bullets required.
__label__Tree __label__Depth-first-Search We are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.      Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2  Output: [7,4,1]  Explanation:  The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.    Note that the inputs "root" and "target" are actually TreeNodes. The descriptions of the inputs above are just serializations of these objects.    Note:  The given tree is non-empty. Each node in the tree has unique values 0 <= node.val <= 500. The target node is a node in the tree. 0 <= K <= 1000.
__label__Strings Alice wrote a sequence of words in CamelCase as a string of letters, , having the following properties: It is a concatenation of one or more words consisting of English letters. All letters in the first word are lowercase.  For each of the subsequent words, the first letter is uppercase and rest of the letters are lowercase. Given , print the number of words in  on a new line. For example, .  There are  words in the string.   Function Description Complete the camelcase function in the editor below.  It must return the integer number of words in the input string.   camelcase has the following parameter(s): s: the string to analyze   Input Format A single line containing string . Constraints  Output Format Print the number of words in string . Sample Input saveChangesInTheEditor  Sample Output 5  Explanation String  contains five words: save Changes In The Editor Thus, we print  on a new line. Need help? Try this problem first to get familiar with HackerRank environment.
__label__Dynamic-Programming Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days. Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy? For example, if you know that prices for the next two days are , you should buy one share day one, and sell it day two for a profit of .  If they are instead , no profit can be made so you don't buy or sell stock those days.   Function Description  Complete the stockmax function in the editor below.  It must return an integer that represents the maximum profit achievable.   stockmax has the following parameter(s):   prices: an array of integers that represent predicted daily stock prices     Input Format The first line contains the number of test cases . Each of the next  pairs of lines contain:  - The first line contains an integer , the number of predicted prices for WOT.  - The next line contains n space-separated integers , each a predicted stock price for day .   Constraints     Output Format Output  lines, each containing the maximum profit which can be obtained for the corresponding test case. Sample Input 3 3 5 3 2 3 1 2 100 4 1 3 1 2  Sample Output 0 197 3  Explanation For the first case, you cannot obtain any profit because the share price never rises.  For the second case, you can buy one share on the first two days and sell both of them on the third day.  For the third case, you can buy one share on day 1, sell one on day 2, buy one share on day 3, and sell one share on day 4.
__label__Graph-Algorithms Alex has a board game consisting of: A chip for marking his current location on the board.  fields numbered from  to . Each position  has a value, , denoting the next position for the chip to jump to from that field. A die with  faces numbered from  to . Each face  has a probability, , of being rolled. Alex then performs the following actions: Begins the game by placing the chip at a position in a field randomly and with equiprobability.  Takes  turns; during each turn he: Rolls the die. We'll denote the number rolled during a turn as . Jumps the chip  times. Recall that each field contains a value denoting the next field number to jump to. Rolls the die. We'll denote the number rolled during a turn as . Jumps the chip  times. Recall that each field contains a value denoting the next field number to jump to. After completing  turns, the game ends and he must calculate the respective probabilities for each field as to whether the game ended with the chip in that field. Given , , , the game board, and the probabilities for each die face, print  lines where each line  contains the probability that the chip is on field  at the end of the game. Note: All the probabilities in this task are rational numbers modulo . That is, if the probability can be expressed as the irreducible fraction  where , then it corresponds to the number  (or, alternatively, ). Click here to learn about Modular Multiplicative Inverse. Input Format The first line contains three space-separated integers describing the respective values of  (the number of positions),  (the number of die faces), and  (the number of turns).  The second line contains  space-separated integers describing the respective values of each  (i.e., the index of the field that field  can transition to).  The third line contains  space-separated integers describing the respective values of each  (where ) describing the probabilities of the faces of the -sided die.   Constraints         The sum of  is   Note: The time limit for this challenge is doubled for all languages. Read more about standard time limits at our environment page. Output Format Print  lines of output in which each line  contains a single integer,  (where ), denoting the probability that the chip will be on field  after  turns. Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts the respective probabilities of each die face being rolled:  The diagram below depicts each field with an arrow pointing to the next field:  There are four equiprobable initial fields, so each field has a  probability of being the chip's initial location. Next, we calculate the probability that the chip will end up in each field after  turn: The only way the chip ends up in this field is if it never jumps from the field, which only happens if Alex rolls a . So, this field's probability is . We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . Start in field  and roll a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . Start in field  and roll a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. The chip can end up in field  after one turn in the following scenarios: Start in field  and roll a , the probability for which is . Start in field  and roll a , the probability for which is . Start in field  and roll a  or a , the probability for which is . After summing these probabilities, we get a total probability of  for the field. We then calculate and print the result of  on a new line. If the chip is initially placed in field , it will always end up in field  regardless of how many turns are taken (because this field loops back onto itself). Thus, this field's probability is . We then calculate and print the result of  on a new line.
__label__Tree We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree. Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:  If A is empty, return null. Otherwise, let A[i] be the largest element of A.  Create a root node with value A[i]. The left child of root will be Construct([A[0], A[1], ..., A[i-1]]) The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) Return root.  Note that we were not given A directly, only a root node root = Construct(A). Suppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values. Return Construct(B).   Example 1:  Input: root = [4,1,3,null,null,2], val = 5 Output: [5,4,null,1,3,null,null,2] Explanation: A = [1,4,2,3], B = [1,4,2,3,5]   Example 2:  Input: root = [5,2,4,null,1], val = 3 Output: [5,2,4,null,1,null,3] Explanation: A = [2,1,5,4], B = [2,1,5,4,3]   Example 3:  Input: root = [5,2,3,null,1], val = 4 Output: [5,2,4,null,1,3] Explanation: A = [2,1,5,3], B = [2,1,5,3,4]      Note:  1 <= B.length <= 100
__label__Tree A full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order.   Example 1: Input: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation:     Note:  1 <= N <= 20
__label__Search __label__Data-Structures __label__Advanced-Data-Structures There is an integer array  which does not contain more than two elements of the same value. How many distinct ascending triples () are present?  Input format  The first line contains an integer, , denoting the number of elements in the array. This is followed by a single line, containing  space-separated integers. Please note that there are no leading spaces before the first number, and there are no trailing spaces after the last number. Output format:  A single integer that denotes the number of distinct ascending triplets present in the array. Constraints:    Every element of the array is present at most twice.  Every element of the array is a 32-bit non-negative integer. Sample input:  6   1 1 2 2 3 4    Sample output:  4  Explanation  The distinct triplets are  (1,2,3)  (1,2,4)  (1,3,4)  (2,3,4) The elements of the array might not be sorted. Make no assumptions of the same.
__label__Array __label__Greedy-Algorithms Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.    Example 1: Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15]   Example 2: Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12]    Note:  1 <= A.length = B.length <= 10000 0 <= A[i] <= 10^9 0 <= B[i] <= 10^9
__label__Depth-first-Search You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.  Example 1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24   Example 2: Input: [1, 2, 1, 2] Output: False   Note:  The division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12. Every operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. You cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.
__label__Array We write the integers of A and B (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:  A[i] == B[j]; The line we draw does not intersect any other connecting (non-horizontal) line.  Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line. Return the maximum number of connecting lines we can draw in this way.   Example 1:  Input: A = [1,4,2], B = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.   Example 2: Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2] Output: 3   Example 3: Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1] Output: 2     Note:  1 <= A.length <= 500 1 <= B.length <= 500 1 <= A[i], B[i] <= 2000
__label__Hash-Table Implement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions:  push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack. 	 If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.      Example 1: Input:  ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:  pop() -> returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].  pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].  pop() -> returns 5. The stack becomes [5,7,4].  pop() -> returns 4. The stack becomes [5,7].    Note:  Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9. It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.
__label__Graph-Algorithms Allison loves graph theory and just started learning about Minimum Spanning Trees(MST). She has three integers, , , and , and uses them to construct a graph with the following properties: The graph has  nodes and  undirected edges where each edge has a positive integer length. No edge may directly connect a node to itself, and each pair of nodes can only be directly connected by at most one edge. The graph is connected, meaning each node is reachable from any other node. The value of the minimum spanning tree is . Value of the MST is the sum of all the lengths of all edges of which are part of the tree. The sum of the lengths of all edges is as small as possible. For example, let's say ,  and . We need to construct a graph with  nodes and  edges. The value of minimum spanning tree must be . The diagram belows shows a way to construct such a graph while keeping the lengths of all edges is as small as possible:  Here the sum of lengths of all edges is . Given , , and  for  graphs satisfying the conditions above, find and print the minimum sum of the lengths of all the edges in each graph on a new line. Note: It is guaranteed that, for all given combinations of , , and , we can construct a valid graph. Input Format The first line contains an integer, , denoting the number of graphs.  Each of the  subsequent lines contains three space-separated integers describing the respective values of  (the number of nodes in the graph),  (the number of edges in the graph), and  (the value of the MST graph). Constraints For  of the maximum score:                      For  of the maximum score:                      For  of the maximum score:                      For  of the maximum score:                      Output Format For each graph, print an integer on a new line denoting the minimum sum of the lengths of all edges in a graph satisfying the given conditions. Sample Input 2 4 5 4 4 3 6  Sample Output 7 6  Explanation Graph : The answer for this sample is already explained the problem statement. Graph : We must construct a graph with  nodes,  edges, and an MST value of . Recall that a connected graph with  nodes and  edges is already a tree, so the MST will contain all  edges and the total length of all the edges of the graph will be equal to the value of the minimum spanning tree. So the answer is .
__label__Mathematics __label__Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = "2", num2 = "3" Output: "6" Example 2: Input: num1 = "123", num2 = "456" Output: "56088"  Note:  The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__Depth-first-Search There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]]  Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible.  Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.
__label__Mathematics __label__Bit Some scientists are working on protein recombination, and during their research, they have found a remarkable fact: there are 4 proteins in the protein ring that mutate after every second according to a fixed pattern. For simplicity, proteins are called  (you know, protein names can be very complicated). A protein mutates into another one depending on itself and the protein right after it. Scientists determined that the mutation table goes like this:       A   B   C   D     _   _   _   _ A|  A   B   C   D B|  B   A   D   C C|  C   D   A   B D|  D   C   B   A  Here rows denote the protein at current position, while columns denote the protein at the next position. And the corresponding value in the table denotes the new protein that will emerge. So for example, if protein i is A, and protein i + 1 is B, protein i will change to B. All mutations take place simultaneously. The protein ring is seen as a circular list, so last protein of the list mutates depending on the first protein.  Using this data, they have written a small simulation software to get mutations second by second. The problem is that the protein rings can be very long (up to 1 million proteins in a single ring) and they want to know the state of the ring after upto  seconds. Thus their software takes too long to report the  results. They ask you for your help.   Input Format Input contains 2 lines.  First line has 2 integers  and ,  being the length of the protein ring and  the desired number of seconds.  Second line contains a string of length  containing uppercase letters ,,  or  only, describing the ring.  Constraints     Output Format Output a single line with a string of length , describing the state of the ring after  seconds. Sample Input 0 Sample Output 0 Explanation 0 The complete sequence of mutations is: AAADD AADAD ADDDD DAAAD DAADA DADDD DDAAA ADAAD DDADD ADDAA DADAA DDDAD AADDA ADADA DDDDA
__label__Dynamic-Programming __label__Strings Square Subsequences A string is called a square string if it can be obtained by concatenating two copies of the same string. For example, "abab", "aa" are square strings, while "aaa", "abba" are not. Given a string, how many (non-empty) subsequences of the string are square strings? A subsequence of a string can be obtained by deleting zero or more characters from it, and maintaining the relative order of the remaining characters. Input Format The first line contains the number of test cases, .   test cases follow. Each case contains a string, . Output Format Output  lines, one for each test case, containing the required answer modulo 1000000007. Constraints:     will have at most  lowercase characters ('a' - 'z'). Sample Input 3  aaa  abab  baaba Sample Output 3  3  6 Explanation For the first case, there are 3 subsequences of length 2, all of which are square strings.  For the second case, the subsequences "abab", "aa", "bb" are square strings.  Similarly, for the third case, "bb", "baba" (twice), and "aa" (3 of them) are the square subsequences.
__label__Mathematics __label__Data-Structures You will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:   The elements of the first array are all factors of the integer being considered The integer being considered is a factor of all elements of the second array These numbers are referred to as being between the two arrays.  You must determine how many such numbers exist. For example, given the arrays  and , there are two numbers between them:  and .  , ,  and  for the first value.  Similarly, ,  and , .   Function Description  Complete the getTotalX function in the editor below.  It should return the number of integers that are betwen the sets.   getTotalX has the following parameter(s):   a: an array of integers   b: an array of integers   Input Format The first line contains two space-separated integers,  and , the number of elements in array  and the number of elements in array .  The second line contains  distinct space-separated integers describing  where .  The third line contains  distinct space-separated integers describing  where . Constraints    Output Format Print the number of integers that are considered to be between  and . Sample Input 2 3 2 4 16 32 96  Sample Output 3  Explanation 2 and 4 divide evenly into 4, 8, 12 and 16.  4, 8 and 16 divide evenly into 16, 32, 96.   4, 8 and 16 are the only three numbers for which each element of a is a factor and each is a factor of all elements of b.
__label__Dynamic-Programming We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".) A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:  If S[i] == 'D', then P[i] > P[i+1], and; If S[i] == 'I', then P[i] < P[i+1].  How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.   Example 1: Input: "DID" Output: 5 Explanation:  The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0)    Note:  1 <= S.length <= 200 S consists only of characters from the set {'D', 'I'}.
__label__Hash-Table __label__Mathematics In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest. Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered "1" could both be the same color, say red. The rabbit than answered "2" can't be red or the answers would be inconsistent. Say the rabbit that answered "2" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.  Input: answers = [10, 10, 10] Output: 11  Input: answers = [] Output: 0  Note:  answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999].
__label__Strings A regular expression is used to describe a set of strings. For this problem the alphabet is limited to 'a' and 'b'. We define  to be a valid regular expression if:  1)  is "" or "".  2)  is of the form "", where  and  are regular expressions.  3)  is of the form "" where  and  are regular expressions.  4)  is of the form "" where  is a regular expression. Regular expressions can be nested and will always have have two elements in the parentheses. ('' is an element, '' is not; basically, there will always be pairwise evaluation) Additionally, '' will always be the second element; '' is invalid.   The set of strings recognized by  are as follows:  1) If  is "", then the set of strings recognized .  2) If  is "", then the set of strings recognized .  3) If  is of the form "" then the set of strings recognized = all strings which can be obtained by a concatenation of strings  and , where  is recognized by  and  by .  4) If  is of the form "" then the set of strings recognized = union of the set of strings recognized by  and .  5) If  is of the form "" then the the strings recognized are the empty string and the concatenation of an arbitrary number of copies of any string recognized by . Task  Given a regular expression and an integer, , count how many strings of length  are recognized by it. Input Format The first line contains the number of test cases .  test cases follow.  Each test case contains a regular expression, , and an integer, . Constraints      It is guaranteed that  will conform to the definition provided above. Output Format Print  lines, one corresponding to each test case containing the required answer for the corresponding test case. As the answers can be very big, output them modulo . Sample Input 3   ((ab)|(ba)) 2   ((a|b)*) 5   ((a*)(b(a*))) 100  Sample Output 2   32   100  Explanation For the first case, the only strings recognized are "" and "". Of the  possible strings of length ,  of them fit that expression.  For the second case, the RegEx recognizes any string of any length containing only 's and 's. The number of strings of length  recognized by this expression is .  For the third case, the RegEx recognizes any string having one , preceeded and followed by any number of 's. There are  strings of length  which have a single  in them.
__label__Hash-Table Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate  Here, for letters we ignore case.  For example, "P" on the licensePlate still matches "p" on the word.  It is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.  The license plate might have the same letter occurring multiple times.  For example, given a licensePlate of "PP", the word "pair" does not complete the licensePlate, but the word "supper" does.  Example 1: Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"] Output: "steps" Explanation: The smallest length word that contains the letters "S", "P", "S", and "T". Note that the answer is not "step", because the letter "s" must occur in the word twice. Also note that we ignored case for the purposes of comparing whether a letter exists in the word.   Example 2: Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"] Output: "pest" Explanation: There are 3 smallest length words that contains the letters "s". We return the one that occurred first.   Note:  licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15].
__label__Hash-Table Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = "egg", t = "add" Output: true  Example 2: Input: s = "foo", t = "bar" Output: false Example 3: Input: s = "paper", t = "title" Output: true Note: You may assume both s and t have the same length.
__label__Tree In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.   Example 1:  Input: root = [1,2,3,4], x = 4, y = 3 Output: false   Example 2:  Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true   Example 3:  Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false     Note:  The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100.
__label__Graph-Algorithms Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in  houses in Happy Harbor that are numbered sequentially from  to . There are  roads, and each road  connects two different houses,  and . Each superhero house  (where ) has  dollars stashed away for a rainy day. As long as a superhero is home at house , Killgrave knows they will hand over all of their saved money, . Once he gets money from them, he moves on to the next house. However, the superheroes are cunning; when Killgrave comes to house , every neighbor immediately connected to house  by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road. What is the maximum amount of money Killgrave can collect from the superheroes, and how many different ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different. Note: Killgrave can start at an arbitrary house and doesn't have to only use the roads. Input Format The first line contains two space-separated integers,  (the number of houses) and  (the number of roads), respectively.  The second line contains  space-separated integers, where each integer  describes the amount of money, , at house .  Each line  of the  subsequent lines contains two space-separated integers defining a road connecting houses  and . Every road connects a different pair of houses. Constraints    , where  No unordered pair  will appear more than once. Output Format Print two space-separated integers: The first integer must denote the maximum amount of money Killgrave can get out of the Justice League. The second integer must denote the number of different ways he can collect that amount of money. Sample Input 3 2 6 8 2 1 2 3 2  Sample Output 8 2  Explanation  Killgrave has two possible courses of action: Visit house  and get  dollars. Visit houses  and  and get  dollars.  Both of these options result in  dollars, so we know that this is maximal. Thus, we print the maximum amount of money () followed by the number of ways he can get that amount of money () as two space-separated values on a single line.
__label__Strings Given a string of lowercase letters in the range ascii[a-z], determine a character that can be removed to make the string a palindrome.  There may be more than one solution, but any will do.  For example, if your string is "bcbc", you can either remove 'b' at index  or 'c' at index .  If the word is already a palindrome or there is no solution, return -1.  Otherwise, return the index of a character to remove.   Function Description  Complete the palindromeIndex function in the editor below.  It must return the index of the character to remove or .   palindromeIndex has the following parameter(s):   s: a string to analyze Input Format The first line contains an integer , the number of queries.  Each of the next  lines contains a query string . Constraints     All characters are in the range ascii[a-z]. Output Format Print an integer denoting the zero-indexed position of the character to remove to make   a palindrome.  If  is already a palindrome or no such character exists, print .  Sample Input 3 aaab baa aaa  Sample Output 3 0 -1  Explanation Query 1: "aaab"  Removing 'b' at index  results in a palindrome, so we print  on a new line.      Query 2: "baa"  Removing 'b' at index  results in a palindrome, so we print  on a new line. Query 3: "aaa"  This string is already a palindrome, so we print .  Removing any one of the characters would result in a palindrome, but this test comes first. Note: The custom checker logic for this challenge is available here.
__label__Array Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.    Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].    The largest rectangle is shown in the shaded area, which has area = 10 unit.   Example: Input: [2,1,5,6,2,3] Output: 10
__label__Graph-Algorithms Airports are being built on a straight road according to a new construction plan. For convenience, imagine a number line on which at different points airports can be positioned. Because a plane can't take off and start landing immediately, there will be flight between two airports in locations  and  if and only if , where  is a constant. Changing the position of an airport from  to  costs . The cost to fix a certain plan is the minimum total cost of changing the positions of airports. After the changes, it should be possible to travel between any pair of airports, possibly taking flights through some intermediate airports. Note that it's possible that two airports have the same initial position, and this can be the case  after changes too. On  day, a plan to build a new airport with position  is announced. On each day that a new airport is announced, print the smallest cost to fix the set of airports announced so far . Note that you should not change the positions of any airports, just calculate the cost to do it.  Input Format Input contains multiple queries.  The first line consists of an integer  which is the number of queries. Each query is given as follows.  The first line of each query contains two integers  and , the number of days, and the minimum distance respectively.  The second line of each test case contains  space-separated integers  denoting the position of the airport that was announced on  day. Constraints    the sum of  over all test cases in a file will not exceed  Output Format Print one line for each query.  A line for a query with  airports should have  numbers on it where the  one should be the minimum cost to fix airports in positions . Sample Input 0 Sample Output 0 Explanation 0 The answer for a single airport is always zero. When we have many airports in the same position, it's enough to move only one of them to satisfy the condition from the statement. Sample Input 1 Sample Output 1 Explanation 1  For each new day that an airport is inserted, the cheapest rearranging of existing airports is shown on the diagram above. Note that cost changes for every day and travelling between airports can be done possibly flying through some intermediate ones. Costs are calculated without changing actual positions of the airports.
__label__Strings Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note:  A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.  Example 1: Input: words = ["This", "is", "an", "example", "of", "text", "justification."] maxWidth = 16 Output: [    "This    is    an",    "example  of text",    "justification.  " ]  Example 2: Input: words = ["What","must","be","acknowledgment","shall","be"] maxWidth = 16 Output: [   "What   must   be",   "acknowledgment  ",   "shall be        " ] Explanation: Note that the last line is "shall be    " instead of "shall     be",              because the last line must be left-justified instead of fully-justified.              Note that the second line is also left-justified becase it contains only one word.  Example 3: Input: words = ["Science","is","what","we","understand","well","enough","to","explain",          "to","a","computer.","Art","is","everything","else","we","do"] maxWidth = 20 Output: [   "Science  is  what we",   "understand      well",   "enough to explain to",   "a  computer.  Art is",   "everything  else  we",   "do                  " ]
__label__Mathematics Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true  Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.  Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome.  Follow up: Coud you solve it without converting the integer to a string?
__label__Mathematics __label__Binary-Search A positive integer is magical if it is divisible by either A or B. Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 1, A = 2, B = 3 Output: 2   Example 2: Input: N = 4, A = 2, B = 3 Output: 6   Example 3: Input: N = 5, A = 2, B = 4 Output: 10   Example 4: Input: N = 3, A = 6, B = 4 Output: 8    Note:  1 <= N <= 10^9 2 <= A <= 40000 2 <= B <= 40000
__label__Mathematics There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.
__label__Mathematics Given two numbers arr1 and arr2 in base -2, return the result of adding them together. Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1. Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.   Example 1: Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1] Output: [1,0,0,0,0] Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.    Note:  1 <= arr1.length <= 1000 1 <= arr2.length <= 1000 arr1 and arr2 have no leading zeros arr1[i] is 0 or 1 arr2[i] is 0 or 1
__label__Array In a deck of cards, every card has a unique integer.  You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed:  Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1.  Otherwise, stop.  Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck.    Example 1: Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation:  We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom.  The deck is now [13,17]. We reveal 13, and move 17 to the bottom.  The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct.     Note:  1 <= A.length <= 1000 1 <= A[i] <= 10^6 A[i] != A[j] for all i != j
__label__Tree Given an n-ary tree, return the postorder traversal of its nodes' values. For example, given a 3-ary tree:      Return its postorder traversal as: [5,6,3,2,4,1].    Note: Recursive solution is trivial, could you do it iteratively?
__label__Tree Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1: Input:     3    / \   9  20     /  \    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].   Note:  The range of node's value is in the range of 32-bit signed integer.
__label__Tree Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its bottom-up level order traversal as: [   [15,7],   [9,20],   [3] ]
__label__Greedy-Algorithms Priyanka works for an international toy company that ships by container.  Her task is to the determine the lowest cost way to combine her orders for shipping.  She has a list of item weights.  The shipping company has a requirement that all items loaded in a container must weigh less than or equal to 4 units plus the weight of the minimum weight item.  All items meeting that requirement will be shipped in one container. What is the smallest number of containers that can be contracted to ship the items based on the given list of weights? For example, there are items with weights .  This can be broken into two containers:  and .  Each container will contain items weighing within  units of the minimum weight item.   Function Description  Complete the toys function in the editor below.  It should return the minimum number of containers required to ship.   toys has the following parameter(s):   w: an array of integers that represent the weights of each order to ship   Input Format The first line contains an integer , the number of orders to ship.  The next line contains  space-separated integers, ,  representing the orders in a weight array. Constraints     Output Format Return the integer value of the number of containers Priyanka must contract to ship all of the toys.  Sample Input 8 1 2 3 21 7 12 14 21  Sample Output 4  Explanation The first container holds items weighing ,  and . (weights in range )  The second container holds the items weighing  units. ()  The third container holds the item weighing  units.  ()  The fourth container holds the items weighing  and  units. ()    containers are required.
__label__Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?  Example: Input: [4,3,2,7,8,2,3,1]  Output: [2,3]
__label__Array __label__Two-Pointers __label__Binary-Search Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2  Example 2: Input: [3,1,3,4,2] Output: 3 Note:  You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.
__label__Game-Theory Alice and Bob invented the following silly game: The game starts with an integer, , that's used to build a  of  distinct integers in the inclusive range from  to  (i.e., ). Alice always plays first, and the two players move in alternating turns. During each move, the current player chooses a prime number, , from . The player then removes  and all of its multiples from . The first player to be unable to make a move loses the game. Alice and Bob play  games. Given the value of  for each game, print the name of the game's winner on a new line. If Alice wins, print Alice; otherwise, print Bob. Alice Bob Note: Each player always plays optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists. Input Format The first line contains an integer, , denoting the number of games Alice and Bob play.  Each line  of the  subsequent lines contains a single integer, , describing a game. Constraints    Subtasks  for  of the maximum score Output Format For each game, print the name of the winner on a new line. If Alice wins, print Alice; otherwise, print Bob. Alice Bob Sample Input 0 Sample Output 0 Explanation 0 Alice and Bob play the following  games: We are given , so . Because Alice has no valid moves (there are no prime numbers in the set), she loses the game. Thus, we print Bob on a new line. Bob We are given , so . Alice chooses the prime number  and deletes it from the set, which becomes . Because Bob has no valid moves (there are no prime numbers in the set), he loses the game. Thus, we print Alice on a new line. Alice We are given , so . Alice chooses the prime number  and deletes the numbers  and  from the set, which becomes . Now there are two primes left,  and . Bob can remove either prime from the set, and then Alice can remove the remaining prime. Because Bob is left without a final move, Alice will always win. Thus, we print Alice on a new line. Alice
__label__Graph-Algorithms Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from  to , and edges will have varying distances or lengths. For example, consider the following graph of 5 nodes:   Starting at node , the shortest path to  is direct and distance .  Going from  to , there are two paths:  at a distance of  or  at a distance of .  Choose the shortest path, .  From  to , choose the shortest path through  and extend it:  for a distance of   There is no route to node , so the distance is . The distances to all nodes in increasing node order, omitting the starting node, are 5 11 13 -1. 5 11 13 -1 Function Description  Complete the shortestReach function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.   shortestReach has the following parameter(s):   n: the number of nodes in the graph   edges: a 2D array of integers where each  consists of three integers that represent the start and end nodes of an edge, followed by its length   s: the start node number   Input Format The first line contains , the number of test cases.  Each test case is as follows:  - The first line contains two space-separated integers  and , the number of nodes and edges in the graph.  - Each of the next  lines contains three space-separated integers , , and , the beginning and ending nodes of an edge, and the length of the edge.  - The last line of each test case has an integer , denoting the starting position.   Constraints           If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges. Output Format For each of the  test cases, print a single line consisting  space separated integers denoting the shortest distance to the  nodes from starting position  in  increasing order of their labels, excluding .  For unreachable nodes, print . Sample Input 1 4 4 1 2 24 1 4 20 3 1 3 4 3 12 1  Sample Output 24 3 15  Explanation The graph given in the test case is shown as :   * The lines are weighted edges where weight denotes the length of the edge. The shortest paths followed for the three nodes 2, 3 and 4 are as follows : 1/S->2 - Shortest Path Value :  1/S->3 - Shortest Path Value :  1/S->3->4 - Shortest Path Value :
__label__Tree __label__Depth-first-Search Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2]     1   /  3   \    2  Output: [3,1,null,null,2]     3   /  1   \    2  Example 2: Input: [3,1,4,null,null,2]    3  / \ 1   4    /   2  Output: [2,1,4,null,null,3]    2  / \ 1   4    /   3  Follow up:  A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
__label__Binary-Search Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.      Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4   Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30   Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23    Note:  1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9
__label__Search __label__Dynamic-Programming You have a rectangular board consisting of  rows, numbered from  to , and  columns, numbered from  to . The top left is  and the bottom right is . Initially - at time  - there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:   *: Exactly one of your cells has letter '*'. *: Exactly one of your cells has letter '*'. U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . U: If at time  the coin is on cell  and cell  has letter 'U', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . L: If at time  the coin is on cell  and cell  has letter 'L', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . D: If at time  the coin is on cell  and cell  has letter 'D', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . R: If at time  the coin is on cell  and cell  has letter 'R', the coin will be on cell  at time , if . Otherwise, there is no coin on your board at time . When the coin reaches a cell that has letter '*', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time  the coin will reach the cell having letter '*'. In each operation you can select a cell with some letter other than '*' and change the letter to 'U', 'L', 'R' or 'D'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations.  For example, given a grid of  rows and  columns: the goal is to get from  to  in as few steps as possible.  As the grid stands, it cannot be done because of the U in the cell at .  If  is changed to D, the path  is available.  It could also be changed to R which would make the path  available.  Either choice takes  change operation, which is the value sought if .  A lower value of  would result in a return value of  because the shortest path is  steps, starting from .   U D R Function Description  Complete the coinOnTheTable function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or  if it is not possible.   coinOnTheTable has the following parameters:   m: an integer, the number of columns on the board   k: an integer, the maximum time to reach the goal   board: an array of strings where each string represents a row of the board   Input Format The first line of input contains three integers, , , and , the number of rows, the number of columns and the maximum time respectively.   The next  lines contain  letters each, describing your board.    Constraints     Output Format Print an integer which represents the minimum number of operations required to achieve your goal. If you cannot achieve your goal, print . Sample Input 2 2 3   RD   *L  Sample output : 0  Sample input : 2 2 1   RD   *L  Sample output : 1  Explanation : In the first example, a valid path exists without making any changes.  In the second example, the letter of cell (1,1) must be changed to 'D' to make a valid path.  In each example, a path length  is available.
__label__Mathematics __label__Binary-Search Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:  Input: 16 Output: true   Example 2: Input: 14 Output: false
__label__Graph-Algorithms __label__Tree It has been a prosperous year for King Charles and he is rapidly expanding his empire. In fact, he recently invaded his neighboring country and set up a new kingdom! This kingdom has many cities connected by one-way roads. To ensure higher connectivity, two cities are sometimes directly linked by more than one road. In the new kingdom, King Charles has made one of the cities his financial capital and another city his warfare capital. He wants a better connectivity between these two capitals. The connectivity of a pair of cities,  and , is defined as the number of different paths from city  to city . A path may use a road more than once if possible. Two paths are considered different if they do not use the same sequence of roads the same number of times. There are  cities numbered  to  in the new kingdom and  one-way roads. City  is the financial capital and city  is the warfare capital.  Determine the number of different paths between cities  and . Since the number may be large, print the result modulo  or .    Note: Two roads may connect the same cities, but they are still considered distinct for path connections.  For example, there are  cities connected by  roads as shown in the following graph:   There are two direct paths and one cyclic path.  Direct paths are  and  and 4 \rightarrow 53 \leftrightarrow 44 \rightarrow 3$ did not exist, there would be only the two direct paths. Function Description Complete the countPaths function in the editor below.  It should print your result, modulo  if there are limited paths or INFINITE PATHS if they are unlimited. There is no expected return value.    INFINITE PATHS countPaths has the following parameters:  - n: the integer number of cities  - edges: a 2D integer array where  is the source city and  is the destination city for the directed road   Input Format The first line contains two integers  and .  Each of the following  lines contains two space-separated integers that represent source and destination cities for a directed connection. Constraints       Output Format Print the number of different paths from city  to city  modulo . If there are infinitely many different paths, print INFINITE PATHS. INFINITE PATHS Sample Input Sample Input 0  5 5   1 2   2 4   2 3   3 4   4 5  Sample Output 0  2  Explanation 0  There are two possible paths from city  to city :      Sample Input 1  5 5   1 2   4 2   2 3   3 4   4 5  Sample Output 1  INFINITE PATHS   Explanation 1   The cycle in the graph can be traversed an infinite number of times on the way to city .
__label__Greedy-Algorithms We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"], and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length.    Example 1: Input: ["cba","daf","ghi"] Output: 1 Explanation:  After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order. If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.   Example 2: Input: ["a","b"] Output: 0 Explanation: D = {}   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation: D = {0, 1, 2}    Note:  1 <= A.length <= 100 1 <= A[i].length <= 1000
__label__Tree Taylor loves trees, and this new challenge has him stumped! Consider a tree, , consisting of  nodes. Each node is numbered from  to , and each node  has an integer, , attached to it.  A query on tree  takes the form w x y z. To process a query, you must print the count of ordered pairs of integers  such that the following four conditions are all satisfied:  w x y z   the path from node  to node .  path from node  to node .   Given  and  queries, process each query in order, printing the pair count for each query on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes) and  (the number of queries).  The second line contains  space-separated integers describing the respective values of each node (i.e., ).  Each of the  subsequent lines contains two space-separated integers,  and , defining a bidirectional edge between nodes  and .  Each of the  subsequent lines contains a w x y z query, defined above. w x y z Constraints         Scoring for this problem is Binary, that means you have to pass all the test cases to get a positive score. Output Format For each query, print the count of ordered pairs of integers satisfying the four given conditions on a new line. Sample Input 10 5 10 2 3 5 10 5 3 6 2 1 1 2 1 3 3 4 3 5 3 6 4 7 5 8 7 9 2 10 8 5 2 10 3 8 4 9 1 9 5 9 4 6 4 6 5 8 5 8  Sample Output 0 1 3 2 0  Explanation We perform  queries on the following tree:  Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . One such pair, , exists, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Three such pairs, , , and  exist, so we print . Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . Two such pairs,  and , exist, so we print .   Find the number of valid ordered pairs where  is in the path from node  to node  and  is in the path from node  to node . No such pair exists, so we print .
__label__Strings Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like "USA". All letters in this word are not capitals, like "leetcode". Only the first letter in this word is capital, like "Google".  Otherwise, we define that this word doesn't use capitals in a right way.    Example 1: Input: "USA" Output: True    Example 2: Input: "FlaG" Output: False    Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.
__label__Strings You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A.      Example 1: Input: ["a","b","c","a","c","c"] Output: 3 Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]   Example 2: Input: ["aa","bb","ab","ba"] Output: 4 Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]   Example 3: Input: ["abc","acb","bac","bca","cab","cba"] Output: 3 Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]   Example 4: Input: ["abcd","cdab","adcb","cbad"] Output: 1 Explanation: 1 group ["abcd","cdab","adcb","cbad"]    Note:  1 <= A.length <= 1000 1 <= A[i].length <= 20 All A[i] have the same length. All A[i] consist of only lowercase letters.
__label__Dynamic-Programming The evil forest is guarded by vicious mandragoras. Garnet and her pet must make a journey through.  She starts with  health point () and  experience points.     As she encouters each mandragora, her choices are: Garnet's pet eats mandragora . This increments  by  and defeats mandragora .   Garnet's pet battles mandragora . This increases  by  experience points and defeats mandragora .  Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.   For example, as always, she starts out with  health point and  experience points.  Mandragoras have the following health values: .  For each of the beings, she has two choices, at or attle.  We have the following permutations of choices and outcomes: Action  s   p _______ _   __ e, e, e 4   0 e, e, b 3   15 e, b, b 2   14 b, b, b 1   10 b, b, e 2   10 b, e, e 3   9 b, e, b 2   16 e, b, e 3   6  Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have  health points, then battles the beast with  heatlth points to gain  experience points.  We see that the best option is to eat the beast with  points and battle the others to achieve  experience points. Function Description  Complete the mandragora function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn. mandragora has the following parameter(s):   H: an array of integers that represents the health values of mandragoras   Input Format The first line contains an integer, , denoting the number of test cases. Each test case is described over two lines: The first line contains a single integer , the number of mandragoras in the forest.  The second line contains  space-separated integers describing the respective health points for the mandragoras .     Constraints     , where   The sum of all s in a single test case is   Output Format For each test case, print a single line with an integer denoting the maximum number of experience points that Garnet can earn. Sample Input 1 3 3 2 2  Sample Output 10   Explanation There are  mandragoras having the following health points: . Initially,  and . The following is an optimal sequence of actions for achieving the maximum number of experience points possible:   Eat the second mandragora ().  is increased from  to , and  is still .  Battle the first mandragora ().  remains the same, but  increases by  experience points.  Battle the third mandragora ().  remains the same, but  increases by  experience points.  Garnet earns  experience points.
__label__Array Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end. A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.    Note:  The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].
__label__Tree __label__Depth-first-Search You need to find the largest value in each row of a binary tree. Example: Input:             1          / \         3   2        / \   \         5   3   9   Output: [1, 3, 9]
__label__Mathematics __label__Dynamic-Programming Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1:  Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1.  Example 2: Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58.
__label__Greedy-Algorithms We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"]. Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]). Return the minimum possible value of D.length.          Example 1: Input: ["ca","bb","ac"] Output: 1 Explanation:  After deleting the first column, A = ["a", "b", "c"]. Now A is in lexicographic order (ie. A[0] <= A[1] <= A[2]). We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.   Example 2: Input: ["xc","yb","za"] Output: 0 Explanation:  A is already in lexicographic order, so we don't need to delete anything. Note that the rows of A are not necessarily in lexicographic order: ie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)   Example 3: Input: ["zyx","wvu","tsr"] Output: 3 Explanation:  We have to delete every column.      Note:  1 <= A.length <= 100 1 <= A[i].length <= 100
__label__Depth-first-Search There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.   Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.  Example 1: Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Example 2: Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.   Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.
__label__Mathematics __label__Bit Given an integer , find each  such that:   where  denotes the bitwise XOR operator. Print the number of 's satisfying the criteria. For example, if , there are four values:      .   Function Description Complete the sumXor function in the editor below.  It should return the number of values determined, as an integer.   sumXor has the following parameter(s):  - n: an integer   Input Format A single integer, . Constraints  Subtasks  for  of the maximum score. Output Format Print the total number of integers  satisfying the criteria. Sample Input 0 5  Sample Output 0 2  Explanation 0 For , the  values  and  satisfy the conditions:   Sample Input 1 10  Sample Output 1 4  Explanation 1 For , the  values , , , and  satisfy the conditions:
__label__Graph-Algorithms A tree of  nodes is an un-directed connected graph having  edges. Let us denote  as the root node. If  is a node such that it is at a distance of  from , and  is a node such that it is at at distance of  from   and  is connected to , then we call  as the parent of .  Similarly, if  is at a distance of  from  and  is at a distance of  from  and there is a path of length  from  to , then we call  as the th parent of .  Susan likes to play with graphs and Tree data structure is one of her favorites. She has designed a problem and wants to know if anyone can solve it. Sometimes she adds or removes a leaf node. Your task is to figure out the th parent of a node at any instant. Input Format The first line contain an integer  denoting the number of test cases.  test cases follow. First line of each test case contains an integer , the number of nodes in the tree.  lines follows each containing two integers  and  separated by a single space denoting  as the parent of . If  is , then X is the root node of the tree.  ( is for namesake and is not in the tree).  The next line contains an integer , the number of queries.   lines follow each containing a query.       :  is added as a new leaf node whose parent is  .  is not in the tree while  is in.        : This tells that leaf node  is removed from the tree.  is a leaf in the tree.       : In this query output the th parent of  .  is a node in the tree.  Note  Each node index is any number between 1 and 105 i.e., a tree with a single node can have its root indexed as 105 Constraints             Output Format For each query of type , output the th parent of . If th parent doesn't exist, output  and if the node doesn't exist, output . Sample Input 2 7 2 0 5 2 3 5 7 5 9 8 8 2 6 8 10 0 5 15 2 15 2 1 3 0 15 20 0 20 13 2 13 4 2 13 3 2 6 10 2 11 1 2 9 1 1 10000 0 3 0 10000 4 1 4 2 4 1  Sample Output 2 2 5 0 0 8 0  Explanation There are 2 test cases. The first test case has 7 nodes with 2 as its root. There are 10 queries 0 5 15 -> 15 is added as a leaf node to 5.  2 15 2 -> 2nd parent of 15 is 15->5->2 is 2.  1 3 -> leaf node 3 is removed from the tree.  0 15 20 -> 20 is added as a leaf node to 15.  0 20 13 -> 13 is added as a leaf node to 20. 2 13 4 -> 4th parent of 13 is 2.  2 13 3 -> 3rd parent of 13 is 5. 2 6 10 -> there is no 10th parent of 6 and hence 0.  2 11 1 -> 11 is not a node in the tree, hence 0. 2 9 1 -> 9's parent is 8.   the second testcase has a tree with only 1 node (10000).  0 10000 4 -> 4 is added as a leaf node to 10000. 1 4 -> 4 is removed.  2 4 1 -> as 4 is already removed, answer is 0.
__label__Strings Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid. Example 1: Input: "()" Output: true  Example 2: Input: "()[]{}" Output: true  Example 3: Input: "(]" Output: false  Example 4: Input: "([)]" Output: false  Example 5: Input: "{[]}" Output: true
__label__Tree Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.   Example 1:  Input: [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22    Note:  The number of nodes in the tree is between 1 and 1000. node.val is 0 or 1. The answer will not exceed 2^31 - 1.
__label__Strings You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern.  You may return the answer in any order.    Example 1: Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.   Note:  1 <= words.length <= 50 1 <= pattern.length = words[i].length <= 20
__label__Strings __label__Dynamic-Programming __label__Greedy-Algorithms Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "*" Output: true Explanation: '*' matches any sequence.  Example 3: Input: s = "cb" p = "?a" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.  Example 4: Input: s = "adceb" p = "*a*b" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".  Example 5: Input: s = "acdcb" p = "a*c?b" Output: false
__label__Tree Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.  The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input:  A binary tree as following:        4      /   \     2     6    / \   /    3   1 5     v = 1  d = 2  Output:         4       / \      1   1     /     \    2       6   / \     /   3   1   5       Example 2: Input:  A binary tree as following:       4      /        2        / \      3   1      v = 1  d = 3  Output:        4      /        2    / \       1   1  /     \   3       1   Note:  The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node.
__label__Mathematics __label__Dynamic-Programming Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.   Example 1: Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.  Example 2: Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.    Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
__label__Tree Print a binary tree in an m*n 2D string array following these rules:   The row number m should be equal to the height of the given binary tree. The column number n should always be an odd number. The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them.  Each unused space should contain an empty string "". Print the subtrees following the same rules.  Example 1: Input:      1     /    2 Output: [["", "1", ""],  ["2", "", ""]]   Example 2: Input:      1     / \    2   3     \      4 Output: [["", "", "", "1", "", "", ""],  ["", "2", "", "", "", "3", ""],  ["", "", "4", "", "", "", ""]]   Example 3: Input:       1      / \     2   5    /    3   /  4  Output:  [["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]  ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]  ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]  ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]   Note: The height of binary tree is in the range of [1, 10].
__label__Dynamic-Programming You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.   As an example, bricks are numbered .  You can remove either ,  or .  For your friend, your moves would leave the options of  to  elements from  leaving  for you (total score = ),  or .  In this case, it will never be optimal for your friend to take fewer than the maximum available number of elements.  Your maximum possible score is , achievable two ways:  first move and  the second, or  in your first move.   Function Description  Complete the bricksGame function in the editor below.  It should return an integer that represents your maximum possible score.   bricksGame has the following parameter(s):   arr:  an array of integers   Input Format The first line will contain an integer , the number of test cases.   Each of the next  pairs of lines are in the following format:  The first line contains an integer , the number of bricks in .  The next line contains  space-separated integers $arr[i].   Constraints       Output Format For each test case, print a single line containing your maximum score. Sample Input 2 5 999 1 1 1 0 5 0 1 1 1 999  Sample Output 1001 999  Explanation In first test case, you will pick 999,1,1. If you play in any other way, you will not get a score of 1001.  In second case, best option will be to pick up the first brick (with 0 score) at first. Then your friend  will choose the next three blocks, and you will get the last brick.
__label__Array __label__Tree __label__Depth-first-Search Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:     3    / \   9  20     /  \    15   7
__label__Tree __label__Data-Structures For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements: The  value of every node in a node's left subtree is less than the data value of that node. The  value of every node in a node's right subtree is greater than the data value of that node. Given the root node of a binary tree, can you determine if it's also a binary search tree?  Complete the function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge. Input Format You are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument. Constraints  Output Format You are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line. Sample Input  Sample Output No
__label__Strings Two strings are anagrams of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.   For example , the list of all anagrammatic pairs is  at positions  respectively. Function Description Complete the function sherlockAndAnagrams in the editor below.  It must return an integer that represents the number of anagrammatic pairs of substrings in . sherlockAndAnagrams has the following parameter(s): s: a string .  Input Format The first line contains an integer , the number of queries.  Each of the next  lines contains a string  to analyze.  Constraints     String  contains only lowercase letters  ascii[a-z].  Output Format For each query, return the number of unordered anagrammatic pairs.   Sample Input 0 Sample Output 0 Explanation 0 The list of all anagrammatic pairs is  and  at positions  and  respectively.   No anagrammatic pairs exist in the second query as no character repeats. Sample Input 1 Sample Output 1 Explanation 1 For the first query, we have anagram pairs  and  at positions  and  respectively. For the second query:  There are 6 anagrams of the form  at positions  and .  There are 3 anagrams of the form  at positions  and .  There is 1 anagram of the form  at position . Sample Input 2 Sample Output 2 Explanation 2 There are two anagrammatic pairs of length :  and .  There are three anagrammatic pairs of length :  at positions  respectively.
__label__Hash-Table Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.  Example 1: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] Output: ["Shogun"] Explanation: The only restaurant they both like is "Shogun".   Example 2: Input: ["Shogun", "Tapioca Express", "Burger King", "KFC"] ["KFC", "Shogun", "Burger King"] Output: ["Shogun"] Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).   Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Hash-Table Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.  Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.   Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.   Note: The length of the given binary array will not exceed 50,000.
__label__Strings Greg wants to build a string,  of length . Starting with an empty string, he can perform  operations: Add a character to the end of  for  dollars. Copy any substring of , and then add it to the end of  for  dollars. Calculate minimum amount of money Greg needs to build . Input Format The first line contains number of testcases .         The  subsequent lines each describe a test case over  lines:  The first contains  space-separated integers, ,  , and , respectively.  The second contains  (the string Greg wishes to build). Constraints     is composed of lowercase letters only. Output Format On a single line for each test case, print the minimum cost (as an integer) to build . Sample Input 2 9 4 5 aabaacaba 9 8 9 bacbacacb  Sample Output 26 42  Explanation Test Case 0:   "";  ""  Append "";  ""; cost is   Append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Summing each cost, we get , so our output for Test Case 1 is . Test Case 1:   "";  ""  Append "";  ""; cost is   Append "";  ""; cost is   Append "";  ""; cost is   Copy and append "";  ""; cost is   Copy and append "";  ""; cost is  Summing each cost, we get , so our output for Test Case 2 is .
__label__Graph-Algorithms __label__Graph-Algorithms John lives in HackerLand, a country with  cities and  bidirectional roads. Each of the roads has a distinct length, and each length is a power of two (i.e.,  raised to some exponent). It's possible for John to reach any city from any other city. Given a map of HackerLand, can you help John determine the sum of the minimum distances between each pair of cities? Print your answer in binary representation.  Input Format The first line contains two space-seperated integers denoting  (the number of cities) and  (the number of roads), respectively.  Each line  of the  subsequent lines contains the respective values of , , and  as three space-separated integers. These values define a bidirectional road between cities  and  having length . Constraints   ,   If , then . Output Format Find the sum of minimum distances of each pair of cities and print the answer in binary representation.  Sample Input 5 6 1 3 5 4 5 0 2 1 3 3 2 1 4 3 4 4 2 2  Sample Output 1000100  Explanation In the sample, the country looks like this:  Let  be the minimum distance between city  and city .
__label__Graph-Algorithms __label__Tree Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day. Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office. Input Format There are N cities numbered 0 to N-1 and M bidirectional roads.   The first line of the input contains two integers N and M.   M lines follow, each containing three space-separated integers u , v and w, where u and v are cities connected by a bi-directional road and w is the length of this road. There is at most one road between any two cities and no road connects a city to itself.   The next line contains two integers S and D. S is the city where Ms. Kox lives and D is the city where her office is located.   The next line contains an integer Q, the number of queries.   Q lines follow, each containing two integers u and v, where the road between u and v has been blocked that day. Constraints          Output Format Output Q lines, with each line containing the minimum distance Ms.Kox has to travel on that day. If there is no path, print "Infinity". Sample Input 6 9   0 1 1   1 2 1   2 3 1   3 4 1   4 5 1   2 4 5   3 5 8   1 3 3   0 2 4   0 5   9   0 1   1 2   2 3   3 4   4 5   2 4   3 5   1 3   0 2  Sample Output 7   6   6   8   11   5   5   5   5
__label__Array Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1
__label__Binary-Search __label__Dynamic-Programming You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example:  Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
__label__Dynamic-Programming There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture. Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Note:  The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, dst, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles.
__label__Greedy-Algorithms __label__Bit You are given  non-negative integers, . We define the score for some permutation () of length  to be the maximum of  for .  Find the permutation with the minimum possible score and print its score. Note:  is the exclusive-OR (XOR) operator. Input Format The first line contains single integer, , denoting the number of integers.  The second line contains  space-separated integers, , describing the respective integers. Constraints   Output Format Print a single integer denoting the minimum possible score. Sample Input 0 4 1 2 3 4  Sample Output 0 5  Sample Input 1 3 1 2 3  Sample Output 1 2  Explanation Sample Case 0:  The permutation with the minimum score is :        Because the permutation's score is the maximum of these values, we print  on a new line. Sample Case 1:  The permutation with the minimum score is :     Because the permutation's score is the maximum of these values, we print  on a new line.
__label__Dynamic-Programming Little Walter likes playing with his toy scales. He has  types of weights. The  weight type has weight . There are infinitely many weights of each type. Recently, Walter defined a function, , denoting the number of different ways to combine several weights so their total weight is equal to . Ways are considered to be different if there is a type which has a different number of weights used in these two ways. For example, if there are  types of weights with corresonding weights , , and , then there are  ways to get a total weight of : Use  weights of type . Use  weights of type . Use  weight of type  and  weight of type . Use  weight of type . Given , , , and , can you find the value of ? Input Format The first line contains a single integer, , denoting the number of types of weights.  The second line contains  space-separated integers describing the values of , respectively  The third line contains two space-separated integers denoting the respective values of  and . Constraints      Note: The time limit for C/C++ is  second, and for Java it's  seconds.  Output Format Print a single integer denoting the answer to the question. As this value can be very large, your answer must be modulo . Sample Input 3 1 2 3 1 6  Sample Output 22  Explanation
__label__Greedy-Algorithms Lena is preparing for an important coding competition that is preceded by a number of sequential preliminary contests. Initially, her luck balance is 0. She believes in "saving luck", and wants to check her theory. Each contest is described by two integers,  and :  is the amount of luck associated with a contest. If Lena wins the contest, her luck balance will decrease by ; if she loses it, her luck balance will increase by .  denotes the contest's importance rating. It's equal to  if the contest is important, and it's equal to  if it's unimportant. If Lena loses no more than  important contests, what is the maximum amount of luck she can have after competing in all the preliminary contests? This value may be negative. For example,  and: If Lena loses all of the contests, her will be .  Since she is allowed to lose  important contests, and there are only  important contests.  She can lose all three contests to maximize her luck at .  If , she has to win at least  of the  important contests.  She would choose to win the lowest value important contest worth .  Her final luck will be .   Function Description  Complete the luckBalance function in the editor below.  It should return an integer that represents the maximum luck balance achievable.   luckBalance has the following parameter(s):   k: the number of important contests Lena can lose   contests: a 2D array of integers where each  contains two integers that represent the luck balance and importance of the  contest.   Input Format The first line contains two space-separated integers  and , the number of preliminary contests and the maximum number of important contests Lena can lose.  Each of the next  lines contains two space-separated integers,  and , the contest's luck balance and its importance rating. Constraints     Output Format Print a single integer denoting the maximum amount of luck Lena can have after all the contests. Sample Input 6 3 5 1 2 1 1 1 8 1 10 0 5 0  Sample Output 29  Explanation There are  contests. Of these contests,  are important and she cannot lose more than  of them. Lena maximizes her luck if she wins the  important contest (where ) and loses all of the other five contests for a total luck balance of .
__label__Data-Structures This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson. If you're new to linked lists, this is a great exercise for learning about them. Given a pointer to the head node of a linked list, print its elements in order, one element per line. If the head pointer is null (indicating the list is empty), don’t print anything. Input Format The first line of input contains , the number of elements in the linked list.  The next  lines contain one element each, which are the elements of the linked list. Note: Do not read any input from stdin/console. Complete the printLinkedList function in the editor below. Constraints   , where  is the  element of the linked list. Output Format Print the integer data for each element of the linked list to stdout/console (e.g.: using printf, cout, etc.). There should be one element per line. Sample Input 2 16 13  Sample Output 16 13  Explanation There are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each in a new line.
__label__Mathematics Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.
__label__Greedy-Algorithms Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  Note: You may assume the greed factor is always positive.  You cannot assign more than one cookie to one child.  Example 1: Input: [1,2,3], [1,1]  Output: 1  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.   Example 2: Input: [1,2], [1,2,3]  Output: 2  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.
__label__Hash-Table Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions:  add(value): Insert a value into the HashSet.  contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.   Example: MyHashSet hashSet = new MyHashSet(); hashSet.add(1);          hashSet.add(2);          hashSet.contains(1);    // returns true hashSet.contains(3);    // returns false (not found) hashSet.add(2);           hashSet.contains(2);    // returns true hashSet.remove(2);           hashSet.contains(2);    // returns false (already removed)   Note:  All values will be in the range of [0, 1000000]. The number of operations will be in the range of [1, 10000]. Please do not use the built-in HashSet library.
__label__Greedy-Algorithms In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: 	A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: 	If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.    Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire. Example 1: Input: "RD" Output: "Radiant" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights any more since his right has been banned.  And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.    Example 2: Input: "RDD" Output: "Dire" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1.  And the second senator can't exercise any rights anymore since his right has been banned.  And the third senator comes from Dire and he can ban the first senator's right in the round 1.  And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.    Note:  The length of the given string will in the range [1, 10,000].
__label__Search Given an array of integers, you must answer a number of queries. Each query consists of a single integer, , and is performed as follows: Add  to each element of the array, permanently modifying it for any future queries. Find the absolute value of each element in the array and print the sum of the absolute values on a new line. Tip: The Input/Output for this challenge is very large, so you'll have to be creative in your approach to pass all test cases. Function Description  Complete the playingWithNumbers function in the editor below.  It should return an array of integers that represent the responses to each query.   playingWithNumbers has the following parameter(s):   arr: an array of integers   queries: an array of integers   Input Format The first line contains an integer  the number of elements in .  The second line contains  space-separated integers .  The third line contains an integer , the number of queries.  The fourth line contains  space-separated integers  where .     Constraints     , where . , where  Output Format For each query, print the sum of the absolute values of all the array's elements on a new line. Sample Input 3 -1 2 -3 3 1 -2 3   Sample Output 5 7 6  Explanation Query 0:   Array:   The sum of the absolute values of the updated array's elements is .     Query 1:   Array:   The sum of the absolute values of the updated array's elements is .    Query 2:   Array:   The sum of the absolute values of the updated array's elements is .
__label__Data-Structures Kundu is true tree lover. Tree is a connected graph having N vertices and N-1  edges. Today when he got a tree, he colored each edge with one of either red(r) or black(b) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex a to b, vertex b to c and vertex c to a . Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet.  r b If the answer is greater than 109 + 7, print the answer modulo (%) 109 + 7. Input Format  The first line contains an integer N, i.e., the number of vertices in tree.  The next N-1 lines represent edges:  2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(r) or black(b).   r b Output Format  Print a single number i.e. the number of triplets.   Constraints  1 ≤ N ≤ 105  A node is numbered between 1 to N.   Sample Input  5 1 2 b 2 3 r 3 4 r 4 5 b  Sample Output  4  Explanation Given tree is something like this.  (2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color. (2,3,5), (1,3,4) and (1,3,5) are other such triplets.  Note that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.
__label__Two-Pointers __label__Dynamic-Programming There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.  After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string "S" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state.  Example 1: Input: ".L.R...LR..L.." Output: "LL.RR.LLRRLL.."  Example 2: Input: "RR.L" Output: "RR.L" Explanation: The first domino expends no additional force on the second domino.  Note:  0 <= N <= 10^5 String dominoes contains only 'L', 'R' and '.'
__label__Two-Pointers Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:  B.length >= 3 There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]  (Note that B could be any subarray of A, including the entire array A.) Given an array A of integers, return the length of the longest mountain.  Return 0 if there is no mountain. Example 1: Input: [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5.  Example 2: Input: [2,2,2] Output: 0 Explanation: There is no mountain.  Note:  0 <= A.length <= 10000 0 <= A[i] <= 10000  Follow up:  Can you solve it using only one pass? Can you solve it in O(1) space?
__label__Array Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.   Example 1: Input: [1,0,2,3,0,4,5,0] Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]  Example 2: Input: [1,2,3] Output: null Explanation: After calling your function, the input array is modified to: [1,2,3]    Note:  1 <= arr.length <= 10000 0 <= arr[i] <= 9
__label__Mathematics Given a positive integer N, find and return the longest distance between two consecutive 1's in the binary representation of N. If there aren't two consecutive 1's, return 0.            Example 1: Input: 22 Output: 2 Explanation:  22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1's. The first consecutive pair of 1's have distance 2. The second consecutive pair of 1's have distance 1. The answer is the largest of these two distances, which is 2.   Example 2: Input: 5 Output: 2 Explanation:  5 in binary is 0b101.   Example 3: Input: 6 Output: 1 Explanation:  6 in binary is 0b110.   Example 4: Input: 8 Output: 0 Explanation:  8 in binary is 0b1000. There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.       Note:  1 <= N <= 10^9
__label__Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]    Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.  Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.    Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the BST.
__label__Strings Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].   Example 1: Given s = "324",  You should return a NestedInteger object which contains a single integer 324.   Example 2: Given s = "[123,[456,[789]]]",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.
__label__Bit Given two integers,  and , find the maximal value of  xor , written , where  and  satisfy the following condition:   For example, if  and , then        Our maximum value is .   Function Description Complete the maximizingXor function in the editor below.  It must return an integer representing the maximum value calculated.   maximizingXor has the following parameter(s): l: an integer, the lower bound, inclusive   r: an integer, the upper bound, inclusive   Input Format The first line contains the integer .  The second line contains the integer .     Constraints 3  Output Format Return the maximal value of the xor operations for all permutations of the integers from  to , inclusive. Sample Input 0 Sample Output 0 Explanation 0 The input tells us that  and . All the pairs which comply to above condition are the following:                                            Here two pairs (10, 13) and (11, 12) have maximum xor value 7, and this is the answer.  Sample Input 1 Sample Output 1
__label__Array __label__Binary-Search There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.5
__label__Strings __label__Greedy-Algorithms In this challenge, you will be given a string.  You must remove characters until the string is made up of any two alternating characters.  When you choose a character to remove, all instances of that character must be removed.  Your goal is to create the longest string possible that contains just two alternating letters. As an example, consider the string abaacdabd.  If you delete the character a, you will be left with the string bcdbd.  Now, removing the character c leaves you with a valid string bdbd having a length of 4. Removing either b or d at any point would not result in a valid string. abaacdabd a bcdbd c bdbd b d Given a string , convert it to the longest possible string  made up only of alternating characters.  Print the length of string  on a new line.  If no string  can be formed, print  instead. Function Description Complete the alternate function in the editor below.  It should return an integer that denotes the longest string that can be formed, or  if it cannot be done.   alternate has the following parameter(s):   s: a string   Input Format The first line contains a single integer denoting the length of .  The second line contains string . Constraints    Output Format Print a single integer denoting the maximum length of  for the given ; if it is not possible to form string , print  instead. Sample Input 10 beabeefeab  Sample Output 5  Explanation The characters present in  are a, b, e, and f. This means that  must consist of two of those characters and we must delete two others.  Our choices for characters to leave are [a,b], [a,e], [a, f], [b, e], [b, f] and [e, f]. a b e f If we delete e and f, the resulting string is babab. This is a valid  as there are only two distinct characters (a and b), and they are alternating within the string. e f babab a b If we delete a and f, the resulting string is bebeeeb. This is not a valid string  because there are consecutive e's present.  Removing them would leave consecutive b's, so this fails to produce a valid string . a f bebeeeb e b's Other cases are solved similarly. babab is the longest string we can create. babab
__label__Tree __label__Depth-first-Search Given a binary tree, flatten it to a linked list in-place. For example, given the following tree:     1    / \   2   5  / \   \ 3   4   6  The flattened tree should look like: 1  \   2    \     3      \       4        \         5          \           6
__label__Graph-Algorithms HackerLand is a country with  beautiful cities and  undirected roads. Like every other beautiful country, HackerLand has traffic jams. Each road has a crowd value. The crowd value of a path is defined as the maximum crowd value for all roads in the path. For example, if the crowd values for all roads are , then the crowd value for the path will be . Each city  has a type value, , denoting the type of buildings in the city. David just started his vacation in HackerLand. He wants to travel from city  to city . He also wants to see at least  different types of buildings along the path from  to . When choosing a path from city  to city  that has at least  different types of buildings along the path, David always selects the one with the minimum crowd value. You will be given  queries. Each query takes the form of  space-separated integers, , , and , denoting the respective values for starting city, destination city, and minimum number of unique buildings that David wants to see along the way. For each query, you must print the minimum crowd value for a path between  and  that has at least  different buildings along the route. If there is no such path, print -1. -1 Note: A path may contain cycles (i.e., the same roads or cities may be traveled more than once). Input Format The first line contains  space-separated integers denoting the respective values for  (the number of cities),  (the number of roads), and  (the number of queries).  The second line contains  space-separated integers describing the respective building type for each city in array  (where the -th value is  and ).     Each of the  subsequent lines defines a road in the form of  space-separated integers, , , and , defining an undirected road with crowd value  that connects cities  and .   Each of the  subsequent lines defines a query in the form of  space-separated integers, , , and  (where ), respectively.  Constraints    Each road connect  distinct cities, meaning no road starts and ends in the same city. Output Format For each query, print its answer on a new line. Sample Input 7 6 1 1 1 4 5 1 3 2 1 2 3 2 6 2 2 3 4 3 4 3 2 4 9 5 7 9 1 2 4  Sample Output 4  Explanation The diagram below depicts the country given as Sample Input. Different values of  are shown in different colors.  The path for the last query (1 2 4) will be . David sees his first type of building in cities  and , his second type of building in city , his third type of building in city , and his fourth type of building in city . The crowd values for each road traveled on this path are ; the maximum of these values is . Thus, we print  on a new line. 1 2 4
__label__Hash-Table Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Example 2: Input: nums = [1], k = 1 Output: [1]  Note:   You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You’re given the pointer to the head node of a linked list, an integer to add to the list and the position at which the integer must be inserted. Create a new node with the given integer, insert this node at the desired position and return the head node.   A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.   As an example, if your list starts as  and you want to insert a node at position  with , your new list should be  Function Description Complete the function insertNodeAtPosition in the editor below.  It must return a reference to the head node of your finished list. insertNodeAtPosition has the following parameters: head: a SinglyLinkedListNode pointer to the head of the list data: an integer value to insert as data in your new node position: an integer position to insert the new node, zero based indexing Input Format The first line contains an integer , the number of elements in the linked list.  Each of the next  lines contains an integer SinglyLinkedListNode[i].data.  The next line contains an integer  denoting the data of the node that is to be inserted.  The last line contains an integer . Constraints   , where  is the  element of the linked list.   .   Output Format Return a reference to the list head.  Locked code prints the list for you. Sample Input 3 16 13 7 1 2  Sample Output 16 13 1 7  Explanation The initial linked list is 16 13 7. We have to insert  at the position  which currently has  in it. The updated linked list will be 16 13 1 7 16 13 7 16 13 1 7
__label__Array Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]
__label__Graph-Algorithms In the magical kingdom of Kasukabe, people strive to possess skillsets. Higher the number of skillset present among the people, the more content people will be.   There are  types of skill set present and initially there exists  people possessing  skill set, where .  There are  wizards in the kingdom and they have the ability to transform the skill set of a person into another skill set. Each of the these wizards has two lists of skill sets associated with them,  and . He can only transform the skill set of person whose initial skill set belongs to the list  to one of the final skill set which belongs to the list . That is, if  and  then following transformation can be done by that trainer.   Once a transformation is done, both skill is removed from the respective lists. In the above example, if he perform   transformation on a person, list  will be updated to  and list  will be . This updated list will be used for further transformations. Few points to note are: One person can possess only one skill set. A wizard can perform zero or more transformation as long as they satisfies the above criteria.  A person can go through multiple transformation of skill set. Same class transformation is also possible. That is a person' skill set can be transformed into his current skill set. Eg.  in the above example. Your goal is to design a series of transformation which results into maximum number of skill set with non-zero number of people knowing it. Input Format The first line contains two numbers, , where  represent the number of skill set and  represent the number of wizards.  Next line contains  space separated integers, ,  where  represents the number of people with  skill. Then follows  lines, where each pair of line represent the configuration of each wizard.  First line of the pair will start with the length of list  and followed by list  in the same line. Similarly second line of the pair starts with the length of list  and then the list .  Constraints                  Output Format The output must consist of one number, the maximum number of distinct skill set that can the people of country learn, after making optimal transformation steps. Sample Input 3 3 3 0 0 1 1 2 2 3 1 2 1 3 1 1 1 2   Sample Output 2    Explanation There are  types of skill sets present along with  wizards. Initially, all three people know the  skill set but no one knows the  and  skill sets.   The  wizard's initial lists are:  and . Suppose, he performs  transformation one any one of person with the  skill set, then it's list  will be updated to an empty list  and list  will be .  Now, we have two people knowing the  skill set and one person knowing the  skill set.   The  wizard's initial lists are:  and . He will use the transformation  one of the person with the  skill set, then it's lists will also be updated to an empty lists A:  and : .    Now, we have 1 person with  skillset and and 2 people knowing the  skillset.   The  wizard's initial lists are:  and . He will transform one of the person with  skillset to  one using the transformation . It's lists will also be updated to an empty lists A:  and : .  At this point, no further transformations are possible and we have achieved our maximum possible answer. Thus, each of the skill set, is known by  person.. This means there are three skill sets available in the kingdom.
__label__Data-Structures Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed. There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by . If you join  adjacent buildings, they will form a solid rectangle of area .   For example, the heights array .  A rectangle of height  and length  can be constructed within the boundaries.  The area formed is .   Function Description Complete the function largestRectangle int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.   largestRectangle largestRectangle has the following parameter(s): h: an array of integers representing building heights Input Format The first line contains , the number of buildings.  The second line contains  space-separated integers, each representing the height of a building.    Constraints    Output Format Print a long integer representing the maximum area of rectangle formed. Sample Input 5 1 2 3 4 5  Sample Output 9  Explanation An illustration of the test case follows.
__label__Mathematics Alef the Frog is in an  two-dimensional maze represented as a table.  The maze has the following characteristics:  Each cell can be free or can contain an obstacle, an exit, or a mine. Any two cells in the table considered adjacent if they share a side.   The maze is surrounded by a solid wall made of obstacles.  Some pairs of free cells are connected by a bidirectional tunnel.   When Alef is in any cell, he can randomly and with equal probability choose to move into one of the adjacent cells that don't contain an obstacle in it. If this cell contains a mine, the mine explodes and Alef dies. If this cell contains an exit, then Alef escapes the maze.   When Alef lands on a cell with an entrance to a tunnel, he is immediately transported through the tunnel and is thrown into the cell at the other end of the tunnel. Thereafter, he won't fall again, and will now randomly move to one of the adjacent cells again. (He could possibly fall in the same tunnel later.)    It's possible for Alef to get stuck in the maze in the case when the cell in which he was thrown into from a tunnel is surrounded by obstacles on all sides.   Your task is to write a program which calculates and prints a probability that Alef escapes the maze. Input Format The first line contains three space-separated integers ,  and  denoting the dimensions of the maze and the number of bidirectional tunnels.   The next  lines describe the maze. The 'th line contains a string of length  denoting the 'th row of the maze. The meaning of each character is as follows: # denotes an obstacle. # A denotes a free cell where Alef is initially in.   A * denotes a cell with a mine.  * % denotes a cell with an exit.   % O denotes a free cell (which may contain an entrance to a tunnel).   O The next  lines describe the tunnels. The 'th line contains four space-separated integers , , , . Here,  and  denote the coordinates of both entrances of the tunnel.  denotes the row and column number, respectively.   Constraints         and  are distinct.   A appears exactly once.   A Each free cell contains at most one entrance to a tunnel.   If a cell contains an entrance to a tunnel, then it doesn't contain an obstacle, mine or exit, and Alef doesn't initially stand in it. Tunnels don't connect adjacent cells. Output Format Print one real number denoting the probability that Alef escapes the maze. Your answer will be considered to be correct if its (absolute) difference from the true answer is not greater than .   Sample Input 0 Sample Output 0 Explanation 0 The following depicts this sample case:  In this case, Alef will randomly choose one of four adjacent cells. If he goes up or down, he will explode and die. If he goes right, he will escape. If he goes left, he will go through a tunnel and get stuck in cell . So the probability of Alef escaping is .
__label__Depth-first-Search Let's play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:  If a mine ('M') is revealed, then the game is over - change it to 'X'. If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively. If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.    Example 1: Input:   [['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'M', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E'],  ['E', 'E', 'E', 'E', 'E']]  Click : [3,0]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:   Example 2: Input:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'M', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Click : [1,2]  Output:   [['B', '1', 'E', '1', 'B'],  ['B', '1', 'X', '1', 'B'],  ['B', '1', '1', '1', 'B'],  ['B', 'B', 'B', 'B', 'B']]  Explanation:     Note:  The range of the input matrix's height and width is [1,50]. The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square. The input board won't be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.
__label__Game-Theory __label__Game-Theory Poker Nim is another -player game that's a simple variation on a Nim game. The rules of the games are as follows: The game starts with  piles of chips indexed from  to . Each pile  (where ) has  chips. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. The players move in alternating turns. During each move, the current player must perform either of the following actions: Remove one or more chips from a single pile.  Add one or more chips to a single pile.      At least  chip must be added or removed during each turn. To ensure that the game ends in finite time, a player cannot add chips to any pile  more than  times. The player who removes the last chip wins the game. Given the values of , , and the numbers of chips in each of the  piles, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: Two space-separated integers,  (the number of piles) and  (the maximum number of times an individual player can add chips to some pile ), respectively.  space-separated integers, , where each  describes the number of chips at pile . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either  or ). Sample Input 2 2 5 1 2 3 5 2 1 3  Sample Output First Second
__label__Array __label__Hash-Table Design a data structure that supports all following operations in average O(1) time.   insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.   Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();
__label__Graph-Algorithms Bitville is a seaside city that has a number of shopping centers connected by bidirectional roads, each of which has a travel time associated with it.  Each of the shopping centers may have a fishmonger who sells one or more kinds of fish.  Two cats, Big Cat and Little Cat, are at shopping center  (each of the centers is numbered consecutively from  to ).  They have a list of fish they want to purchase, and to save time, they will divide the list between them.  Determine the total travel time for the cats to purchase all of the types of fish, finally meeting at shopping center .  Their paths may intersect, they may backtrack through shopping center , and one may arrive at a different time than the other.  The minimum time to determine is when both have arrived at the destination.   For example, there are  shopping centers selling  types of fish.  The following is a graph that shows a possible layout of the shopping centers connected by  paths.  Each of the centers is labeled .  Here  and  represent Big Cat and Little Cat, respectively.  In this example, both cats take the same path, i.e.  and arrive at time  having purchased all three types of fish they want.  Neither cat visits shopping centers  or .     Function Description  Complete the shop function in the editor below.  It should return an integer that represents the minimum time required for their shopping.   shop has the following parameters:  - n: an integer, the number of shopping centers  - k: an integer, the number of types of fish  - centers: an array of strings of space-separated integers where the first integer of each element is the number of types of fish sold at a center and the remainder are the types sold  - roads: a 2-dimensional array of integers where the first two values are the shopping centers connected by the bi-directional road, and the third is the travel time for that road   Input Format The first line contains  space-separated integers:  (the number of shopping centers),  (the number of roads), and  (the number of types of fish sold in Bitville), respectively.         Each line  of the  subsequent lines () describes a shopping center as a line of space-separated integers. Each line takes the following form: The first integer, , denotes the number of types of fish that are sold by the fishmonger at the  shopping center. Each of the  subsequent integers on the line describes a type of fish sold by that fishmonger, denoted by , where  going forward. Each line  of the  subsequent lines () contains  space-separated integers that describe a road. The first two integers,  and , describe the two shopping centers it connects. The third integer, , denotes the amount of time it takes to travel the road. Constraints      All  are different for every fixed .   Each road connectes  distinct shopping centers (i.e., no road connects a shopping center to itself). Each pair of shopping centers is directly connected by no more than  road. It is possible to get to any shopping center from any other shopping center. Each type of fish is always sold by at least one fishmonger. Output Format Print the minimum amount of time it will take for the cats to collectively purchase all  fish and meet up at shopping center . Sample Input 5 5 5 1 1 1 2 1 3 1 4 1 5 1 2 10 1 3 10 2 4 10 3 5 10 4 5 10  Sample Output 30  Explanation    represents a location Big Cat visits,  represents a location where Little Cat visits.   Big Cat can travel  and buy fish at all of the shopping centers on his way. Little Cat can then travel , and buy fish from the fishmonger at the  shopping center only.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You’re given the pointer to the head node of a linked list and the position of a node to delete. Delete the node at the given position and return the head node. A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The list may become empty after you delete the node. Input Format You have to complete the deleteNode(SinglyLinkedListNode* llist, int position) method which takes two arguments - the head of the linked list and the position of the node to delete. You should NOT read any input from stdin/console. position will always be at least 0 and less than the number of the elements in the list. deleteNode(SinglyLinkedListNode* llist, int position) position The first line of input contains an integer , denoting the number of elements in the linked list.  The next  lines contain an integer each in a new line, denoting the elements of the linked list in the order.  The last line contains an integer  denoting the position of the node that has to be deleted form the linked list.   Constraints   , where  is the  element of the linked list. Output Format Delete the node at the given position and return the head of the updated linked list. Do NOT print anything to stdout/console. return The code in the editor will print the updated linked list in a single line separated by spaces. Sample Input 8 20 6 2 19 7 4 15 9 3  Sample Output 20 6 2 7 4 15 9  Explanation The given linked list is 20->6->2->19->7->4->15->9. We have to delete the node at position 3, which is 19. After deleting that node, the updated linked list is: 20->6->2->7->4->15->9 20->6->2->19->7->4->15->9 20->6->2->7->4->15->9
__label__Hash-Table Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0. Return the maximum number of rows that have all values equal after some number of flips.      Example 1: Input: [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal.   Example 2: Input: [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values.   Example 3: Input: [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values.    Note:  1 <= matrix.length <= 300 1 <= matrix[i].length <= 300 All matrix[i].length's are equal matrix[i][j] is 0 or 1
__label__Tree __label__Data-Structures Complete the inOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your inOrder function. Constraints 1 Nodes in the tree   500 Output Format Print the tree's inorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 3 4 5 6
__label__Strings Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.   Example 1: Input: "/home/" Output: "/home" Explanation: Note that there is no trailing slash after the last directory name.  Example 2: Input: "/../" Output: "/" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.  Example 3: Input: "/home//foo/" Output: "/home/foo" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.  Example 4: Input: "/a/./b/../../c/" Output: "/c"  Example 5: Input: "/a/../../b/../c//.//" Output: "/c"  Example 6: Input: "/a//b////c/d//././/.." Output: "/a/b/c"
__label__Tree __label__Depth-first-Search Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7 return its depth = 3.
__label__Strings DNA is a nucleic acid present in the bodies of living things. Each piece of DNA contains a number of genes, some of which are beneficial and increase the DNA's total health. Each gene has a health value, and the total health of a DNA is the sum of the health values of all the beneficial genes that occur as a substring in the DNA. We represent genes and DNA as non-empty strings of lowercase English alphabetic letters, and the same gene may appear multiple times as a susbtring of a DNA. Given the following: An array of beneficial gene strings, . Note that these gene sequences are not guaranteed to be distinct. An array of gene health values, , where each  is the health value for gene . A set of  DNA strands where the definition of each strand has three components, , , and , where string  is a DNA for which genes  are healthy. Find and print the respective total healths of the unhealthiest (minimum total health) and  healthiest (maximum total health) strands of DNA as two space-separated values on a single line. Input Format The first line contains an integer, , denoting the total number of genes.  The second line contains  space-separated strings describing the respective values of  (i.e., the elements of ).  The third line contains  space-separated integers describing the respective values of  (i.e., the elements of ).  The fourth line contains an integer, , denoting the number of strands of DNA to process.  Each of the  subsequent lines describes a DNA strand in the form start end d, denoting that the healthy genes for DNA strand  are  and their respective correlated health values are . start end d Constraints        the sum of the lengths of all genes and DNA strands   It is guaranteed that each  consists of lowercase English alphabetic letters only (i.e., a to z). a z Output Format Print two space-separated integers describing the respective total health of the unhealthiest and the healthiest strands of DNA. Sample Input 0 Sample Output 0 Explanation 0 In the diagrams below, the ranges of beneficial genes for a specific DNA on the left are highlighed in green and individual instances of beneficial genes on the right are bolded. The total healths of the  strands are:    The total health of caaab is . caaab   The total health of xyz is , because it contains no beneficial genes. xyz   The total health of bcdybc is . bcdybc The unhealthiest DNA strand is xyz with a total health of , and the healthiest DNA strand is caaab with a total health of . Thus, we print 0 19 as our answer. xyz caaab 0 19
__label__Data-Structures __label__Advanced-Data-Structures In Burger Town new burger restaurants will be opened! Concretely,  restaurants will open in  days, while restaurant  will be opened on day  and will be located at . The town should be imagined as an one dimensional line in which every object's location can be described by the  coordinate. Tim has just recently arrived the town after a very bad result in a programming contest. Thus he wants to cheer himself up by starting a trip to try out some new burgers.  Every burger restaurant  is associated with two integers  and . If Tim eats a burger from , then his happiness will increase by , which can also be negative, depending on the deliciousness of the burger. On the other hand, if Tim looks through the window of an opened restaurant , from which he will not eat a burger, then his happiness decreases by , since Tim gets sad by only seeing the burgers.  Tim's journey can start from any day  at the burger restaurant  and eats a burger from there. On each subsequent day , Tim has the following options: Stay at the previous restaurant .  Or go to the new restaurant  to eat a burger from there. If he decides for the latter option, then on the path from  to  he will look through all the windows that are on his path and maybe lose some happiness. Concretely, if , then he will look through the window of every opened restaurant , having . Similar for the case . Since Tim is a very good friend of yours you should help him finding a trip that will maximize his happiness. If he should stay at home since no trip would cheer him up, then print 0.  0 Note: Tim's happiness is 0 at the beginning of the trip and is allowed to be negative throughout the time.  Input Format  will be given on the first line, then  lines will follow, describing the restaurants numbered from 1 to  accordingly. Restaurant  will be described by ,  and  separated by a single space. Output Format Output the maximium happiness on one line. Constraints         and no two restaurants will have the same  coordinates.  and no two restaurants will have the same  coordinates. Sample Input  3  2 -5 1  1 5 1  3 5 1  Sample Output 8  Sample Input  4  4 10 0  1 -5 0  3 0 10  2 10 0  Sample Output  15  Sample Input  3  1 -1 0  2 -2 0  3 -3 0  Sample Output  0  First testcase: His trip starts on day 2 at restaurant 2 located at . He gains  happiness points there by eating a burger. On the next day he goes from restaurant 2 to 3, but will look through the window of restaurant 2 and 1. Therefore he loses  and  points on the way to restaurant 3. There he eats a burger and gains another  points. In total his happiness is equal to  8 and this is optimal. 8 Second testcase: His trip starts on day 1 at restaurant 1. Then his actions on day 2, 3 and 4 will be go to restaurant 2, stay at restaurant 2 and go to restaurant 4 respectively. The happiness of this optimal trip is equal to  15. 15 Third testcase: It's not worth to start the trip from any of the restaurant since he will only have negative happiness. That's why he should stay at home and 0 should be printed.  0
__label__Dynamic-Programming Return the largest possible k such that there exists a_1, a_2, ..., a_k such that:  Each a_i is a non-empty string; Their concatenation a_1 + a_2 + ... + a_k is equal to text; For all 1 <= i <= k,  a_i = a_{k+1 - i}.    Example 1: Input: text = "ghiabcdefhelloadamhelloabcdefghi" Output: 7 Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".  Example 2: Input: text = "merchant" Output: 1 Explanation: We can split the string on "(merchant)".  Example 3: Input: text = "antaprezatepzapreanta" Output: 11 Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".  Example 4: Input: text = "aaa" Output: 3 Explanation: We can split the string on "(a)(a)(a)".    Constraints:  text consists only of lowercase English characters. 1 <= text.length <= 1000
__label__Strings __label__Dynamic-Programming Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial). Note:  s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example 1: Input: s = "aa" p = "a" Output: false Explanation: "a" does not match the entire string "aa".  Example 2: Input: s = "aa" p = "a*" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".  Example 3: Input: s = "ab" p = ".*" Output: true Explanation: ".*" means "zero or more (*) of any character (.)".  Example 4: Input: s = "aab" p = "c*a*b" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".  Example 5: Input: s = "mississippi" p = "mis*is*p*." Output: false
__label__Bit Bob has received a binary string of length N transmitted by Alice. He knows that due to errors in transmission, up to K bits might have been corrupted (and hence flipped). However, he also knows that the string Alice had intended to transmit was not periodic. A string is not periodic if it cannot be represented as a smaller string concatenated some number of times. For example, "0001", "0110" are not periodic while "00000", "010101" are periodic strings. Now he wonders how many possible strings could Alice have transmitted. Input Format The first line contains the number of test cases T. T test cases follow. Each case contains two integers N and K on the first line, and a binary string of length N on the next line. Constraints       Output Format Output T lines, one for each test case. Since the answers can be really big, output the numbers modulo 1000000007. Sample Input 0 Sample Output 0 Explanation 0 Explanation: For the second example, Alice could have transmitted "001", or "011" or "101".  For the third example, Alice could have transmitted 001, 010, 100, 011, 101, 110
__label__Dynamic-Programming In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways:  a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars.  The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days.   Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation:  For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel.   Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation:  For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel.     Note:  1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000
__label__Two-Pointers Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.     Example 1: Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation:  [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.  Example 2: Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 Output: 10 Explanation:  [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.    Note:  1 <= A.length <= 20000 0 <= K <= A.length A[i] is 0 or 1
__label__Tree __label__Data-Structures Complete the preOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your preOrder function. Constraints  Nodes in the tree   Output Format Print the tree's preorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 5 3 4 6
__label__Greedy-Algorithms Victoria is splurging on expensive accessories at her favorite stores. Each store stocks  types of accessories, where the  accessory costs  dollars (). Assume that an item's type identifier is the same as its cost, and the store has an unlimited supply of each accessory. Victoria wants to purchase a total of  accessories according to the following rule: Any -element subset of the purchased items must contain at least  different types of accessories.  For example, if , , and , then she must choose  accessories such that any subset of  of the  accessories will contain at least  distinct types of items.  Given , , , and  values for  shopping trips, find and print the maximum amount of money that Victoria can spend during each trip; if it's not possible for Victoria to make a purchase during a certain trip, print SAD instead. You must print your answer for each trip on a new line. SAD Input Format The first line contains an integer, , denoting the number of shopping trips.  Each of the  subsequent lines describes a single shopping trip as four space-separated integers corresponding to , , , and , respectively. Constraints       The sum of the 's for all  shopping trips .   Output Format For each shopping trip, print a single line containing either the maximum amount of money Victoria can spend; if there is no collection of items satisfying her shopping rule for the trip's , , , and  values, print SAD instead. SAD Sample Input 2 6 5 3 2 2 1 2 2  Sample Output 24 SAD  Explanation Shopping Trip 1:  We know that: Victoria wants to buy  accessories.  The store stocks the following  types of accessories: .  For any grouping of  of her  accessories, there must be at least  distinct types of accessories.   Victoria can satisfy her shopping rule and spend the maximum amount of money by purchasing the following set of accessories: . The total cost is , so we print  on a new line. Shopping Trip 2:  We know that: Victoria wants to buy  accessories. The store stocks  type of accessory: .  For any grouping of  of her  accessories, there must be at least  distinct types of accessories.  Because the store only carries  type of accessory, Victoria cannot make a purchase satisfying the constraint that there be at least  distinct types of accessories. Because Victoria will not purchase anything, we print that she is SAD on a new line.  SAD
__label__Strings X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation:  There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.  Note:  N  will be in range [1, 10000].
__label__Strings Given a string s, return the last substring of s in lexicographical order.   Example 1: Input: "abab" Output: "bab" Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".  Example 2: Input: "leetcode" Output: "tcode"    Note:  1 <= s.length <= 4 * 10^5 s contains only lowercase English letters.
__label__Mathematics You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed:  Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.  Example 1: (From the famous "Die Hard" example) Input: x = 3, y = 5, z = 4 Output: True  Example 2: Input: x = 2, y = 6, z = 5 Output: False
__label__Graph-Algorithms In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the red knight.   The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below.   The board is a grid of size . Each cell is identified with a pair of coordinates , where  is the row number and  is the column number, both zero-indexed. Thus,  is the upper-left corner and  is the bottom-right corner.  Complete the function printShortestPath, which takes as input the grid size , and the coordinates of the starting and ending position  and  respectively, as input. The function does not return anything.      printShortestPath Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word "Impossible".  Note: There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority: UL, UR, R, LR, LL, L. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input  for an illustration. Input Format The first line of input contains a single integer . The second line contains four space-separated integers .  denotes the coordinates of the starting position and  denotes the coordinates of the final position. Constraints     the starting and the ending positions are different Output Format If the destination can be reached, print two lines. In the first line, print a single integer denoting the minimum number of moves that the red knight has to make in order to reach the destination. In the second line, print the space-separated sequence of moves.  If the destination cannot be reached, print a single line containing only the word Impossible. Impossible Sample Input 0 Sample Output 0 Explanation 0  Sample Input 1 Sample Output 1 Explanation 1  Sample Input 2 Sample Output 2 Explanation 2
__label__Hash-Table Implement a magic directory with buildDict, and search methods.   For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.   For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.  Example 1: Input: buildDict(["hello", "leetcode"]), Output: Null Input: search("hello"), Output: False Input: search("hhllo"), Output: True Input: search("hell"), Output: False Input: search("leetcoded"), Output: False   Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.
__label__Tree __label__Depth-first-Search Given a binary tree, find the leftmost value in the last row of the tree.   Example 1: Input:      2    / \   1   3  Output: 1     Example 2:  Input:          1        / \       2   3      /   / \     4   5   6        /       7  Output: 7   Note: You may assume the tree (i.e., the given root node) is not NULL.
__label__Dynamic-Programming You have d dice, and each die has f faces numbered 1, 2, ..., f. Return the number of possible ways (out of fd total ways) modulo 10^9 + 7 to roll the dice so the sum of the face up numbers equals target.   Example 1: Input: d = 1, f = 6, target = 3 Output: 1 Explanation:  You throw one die with 6 faces.  There is only one way to get a sum of 3.  Example 2: Input: d = 2, f = 6, target = 7 Output: 6 Explanation:  You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.  Example 3: Input: d = 2, f = 5, target = 10 Output: 1 Explanation:  You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.  Example 4: Input: d = 1, f = 2, target = 3 Output: 0 Explanation:  You throw one die with 2 faces.  There is no way to get a sum of 3.  Example 5: Input: d = 30, f = 30, target = 500 Output: 222616187 Explanation:  The answer must be returned modulo 10^9 + 7.    Constraints:  1 <= d, f <= 30 1 <= target <= 1000
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You're given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete as few nodes as possible so that the list does not contain any value more than once. The given head pointer may be null indicating that the list is empty. Input Format You have to complete the SinglyLinkedListNode* removeDuplicates(SinglyLinkedListNode* head) method which takes one argument - the head of the sorted linked list. You should NOT read any input from stdin/console. SinglyLinkedListNode* removeDuplicates(SinglyLinkedListNode* head) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases. The format for each test case is as follows:   The first line contains an integer , denoting the number of elements in the linked list.  The next  lines contain an integer each, denoting the elements of the linked list. Constraints     Output Format Delete as few nodes as possible to ensure that no two nodes have the same data. Adjust the next pointers to ensure that the remaining nodes form a single sorted linked list. Then return the head of the sorted updated linked list. Do NOT print anything to stdout/console. next return The output is handled by the code in the editor and the format is as follows: For each test case, print in a new line, the data of the linked list after removing the duplicates separated by space. Sample Input 1 5 1 2 2 3 4  Sample Output 1 2 3 4   Explanation The initial linked list is: 1 -> 2 -> 2 -> 3 -> 4 -> NULL The final linked list is: 1 -> 2 -> 3 -> 4 -> NULL
__label__Depth-first-Search Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.   Example:  Input: {"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}  Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3.    Note:  The number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph.
__label__Greedy-Algorithms Quibdó in Colombia is one among the cities that receive maximum rainfall in the world. All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you.  Every cloud covers all towns located at a certain distance from it. A town is said to be in darkness if there exists at least one cloud such that the town is within the cloud's range. Otherwise, it is said to be sunny.  The city council has determined that they have enough money to remove exactly one cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud? Note: If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer. Complete the function maximumPeople which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud. maximumPeople Input Format The first line of input contains a single integer , the number of towns. The next line contains  space-separated integers . The  integer in this line denotes the population of the  town.   The next line contains  space-separated integers  denoting the location of the  town on the one-dimensional line. The next line consists of a single integer  denoting the number of clouds covering the city.   The next line contains  space-separated integers  the  of which denotes the location of the  cloud on the coordinate axis. The next line consists of  space-separated integers  denoting the range of the  cloud.  Note: The range of each cloud is computed according to its location, i.e., the  cloud is located at position  and it covers every town within a distance of  from it. In other words, the  cloud covers every town with location in the range . Constraints    Output Format Print a single integer denoting the maximum number of people that will be in a sunny town by removing exactly one cloud. Sample Input 0 Sample Output 0 Explanation 0 In the sample case, there is only one cloud which covers the first town. Our only choice is to remove this sole cloud which will make all towns sunny, and thus, all  people will live in a sunny town.   As you can see, the only cloud present, is at location  on the number line and has a range , so it covers towns located at ,  and  on the number line. Hence, the first town is covered by this cloud and removing this cloud makes all towns sunny.
__label__Dynamic-Programming Let's talk about binary numbers. We have an -digit binary number, , and we denote the digit at index  (zero-indexed from right to left) to be . We can find the decimal value of  using the following formula:   For example, if binary number , we compute its decimal value like so:   Meanwhile, in our well-known decimal number system where each digit ranges from  to , the value of some decimal number, , can be expanded in the same way:   Now that we've discussed both systems, let's combine decimal and binary numbers in a new system we call decibinary! In this number system, each digit ranges from  to  (like the decimal number system), but the place value of each digit corresponds to the one in the binary number system. For example, the decibinary number  represents the decimal number  because:   Pretty cool system, right? Unfortunately, there's a problem: two different decibinary numbers can evaluate to the same decimal value! For example, the decibinary number  also evaluates to the decimal value :   This is a major problem because our new number system has no real applications beyond this challenge!  Consider an infinite list of non-negative decibinary numbers that is sorted according to the following rules: The decibinary numbers are sorted in increasing order of the decimal value that they evaluate to.  Any two decibinary numbers that evaluate to the same decimal value are ordered by increasing decimal value, meaning the equivalent decibinary values are strictly interpreted and compared as decimal values and the smaller decimal value is ordered first. For example,  and  both evaluate to . We would order  before  because . Here is a list of first few decibinary numbers properly ordered:  You will be given  queries in the form of an integer, . For each , find and print the the  decibinary number in the list on a new line.   Function Description Complete the decibinaryNumbers function in the editor below.  For each query, it should return the decibinary number at that one-based index.   decibinaryNumbers has the following parameter(s): x: the index of the decibinary number to return    Input Format The first line contains an integer, , the number of queries.  Each of the next  lines contains an integer, , describing a query. Constraints   Subtasks  for  of the maximum score  for  of the maximum score  for  of the maximum score Output Format For each query, print a single integer denoting the the  decibinary number in the list. Note that this must be the actual decibinary number and not its decimal value.  Use 1-based indexing. Sample Input 0 Sample Output 0 Explanation 0 For each , we print the  decibinary number on a new line. See the figure in the problem statement.  Sample Input 1 Sample Output 1 Sample Input 2 Sample Output 2
__label__Data-Structures You have an empty sequence, and you will be given  queries. Each query is one of these three types: 1 x  -Push the element x into the stack. 2    -Delete the element present at the top of the stack. 3    -Print the maximum element in the stack.  Input Format The first line of input contains an integer, . The next  lines each contain an above mentioned query. (It is guaranteed that each query is valid.) Constraints       Output Format For each type  query, print the maximum element in the stack on a new line. Sample Input 10 1 97 2 1 20 2 1 26 1 20 2 3 1 91 3  Sample Output 26 91
__label__Mathematics __label__Strings Given two strings representing two complex numbers.  You need to return a string representing their multiplication. Note i2 = -1 according to the definition.  Example 1: Input: "1+1i", "1+1i" Output: "0+2i" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.   Example 2: Input: "1+-1i", "1+-1i" Output: "0+-2i" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.   Note:  The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.
__label__Dynamic-Programming __label__Depth-first-Search In LeetCode Store, there are some kinds of items to sell. Each item has a price.   However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.   You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.   Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.  You could use any of special offers as many times as you want. Example 1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation:  There are two kinds of items, A and B. Their prices are $2 and $5 respectively.  In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B.  You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.   Example 2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation:  The price of A is $2, and $3 for B, $4 for C.  You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.  You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.  You cannot add more items, though only $9 for 2A ,2B and 1C.   Note:  There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price.
__label__Strings Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.   Example 1: Input: "()" Output: True   Example 2: Input: "(*)" Output: True   Example 3: Input: "(*))" Output: True   Note:  The string size will be in the range [1, 100].
__label__Array __label__Mathematics There are n flights, and they are labeled from 1 to n. We have a list of flight bookings.  The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label.   Example 1: Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25]    Constraints:  1 <= bookings.length <= 20000 1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000 1 <= bookings[i][2] <= 10000
__label__Strings A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:  If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word. 	For example, the word 'apple' becomes 'applema'. 	  If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma". 	For example, the word "goat" becomes "oatgma". 	  Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. 	For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.  Return the final sentence representing the conversion from S to Goat Latin.    Example 1: Input: "I speak Goat Latin" Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"  Example 2: Input: "The quick brown fox jumped over the lazy dog" Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"    Notes:  S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 <= S.length <= 150.
__label__Bit Consider a zero-indexed matrix with  rows and  columns, where each row is filled gradually. Given the first row of the matrix, you can generate the elements in the subsequent rows using the following formula:   Each row is generated one by one, from the second row through the last row. Given the first row of the matrix, find and print the elements of the last row as a single line of space-separated integers. Note: The  operator denotes bitwise XOR. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of columns in the matrix) and  (the number of rows in the matrix).  The second line contains  space-separated integers denoting the respective values of the elements in the matrix's first row. Constraints    Output Format Print  space-separated integers denoting the respective values of the elements in the last row of the matrix. Sample Input 0 Sample Output 0 Explanation 0 We use the formula given above to calculate the  values in the last row of the matrix:         We then print each value (in order) as a single line of space-separated integers.
__label__Dynamic-Programming There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:  Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B  When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml's of soup B are used first.   Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.   Example: Input: N = 50 Output: 0.625 Explanation:  If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.   Notes:   0 <= N <= 10^9.  Answers within 10^-6 of the true value will be accepted as correct.
__label__Bit Consider two non-negative long integers,  and , where . The bitwise AND of all long integers in the inclusive range between  and  can be expressed as , where  is the bitwise AND operator.  Given  pairs of long integers,  and , compute and print the bitwise AND of all natural numbers in the inclusive range between  and . For example, if  and , the calculation is .   Function Description  Complete the andProduct in the editor below.  It should return the computed value as an integer.   andProduct has the following parameter(s):   a: an integer   b: an integer   Input Format The first line contains a single integer , the number of intervals to test.  Each of the next  lines contains two space-separated integers  and . Constraints    Output Format For each pair of long integers, print the bitwise AND of all numbers in the inclusive range between  and  on a new line. Sample Input 0 Sample Output 0 Explanation 0 There are three pairs to compute results for:  and   , so we print  on a new line.  and     and    Sample Input 1 Sample Output 1
__label__Dynamic-Programming Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.  Example 2: Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
__label__Strings Sami's spaceship crashed on Mars! She sends a series of SOS messages to Earth for help.  SOS  Letters in some of the SOS messages are altered by cosmic radiation during transmission. Given the signal received by Earth as a string, , determine how many letters of Sami's SOS have been changed by radiation. SOS SOS For example, Earth receives SOSTOT.  Sami's original message was SOSSOS.  Two of the message characters were changed in transit.   SOSTOT SOSSOS Function Description Complete the marsExploration function in the editor below.  It should return an integer representing the number of letters changed during transmission.   marsExploration has the following parameter(s): s: the string as received on Earth   Input Format There is one line of input: a single string, .  Note: As the original message is just SOS repeated  times, 's length will be a multiple of . SOS Constraints    will contain only uppercase English letters, ascii[A-Z]. Output Format Print the number of letters in Sami's message that were altered by cosmic radiation. Sample Input 0 Sample Output 0 Explanation 0  = SOSSPSSQSSOR, and signal length . Sami sent  SOS messages (i.e.: ). SOS We print the number of changed letters. Sample Input 1 Sample Output 1 Explanation 1  = SOSSOT, and signal length . Sami sent  SOS messages (i.e.: ). SOS We print the number of changed letters, which is . Sample Input 2 Sample Output 2 Explanation 2 Since no character is altered, we print 0.
__label__Two-Pointers __label__Strings Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters.    Example 1: Input: ["h","e","l","l","o"] Output: ["o","l","l","e","h"]   Example 2: Input: ["H","a","n","n","a","h"] Output: ["h","a","n","n","a","H"]
__label__Graph-Algorithms __label__Graph-Algorithms Daniel loves graphs. He thinks a graph is special if it has the following properties: It is undirected. The length of each edge is . It includes exactly  different lovely triplets.  A triplet is a set of  different nodes. A triplet is lovely if the minimum distance between each pair of nodes in the triplet is exactly . Two triplets are different if  or more of their component nodes are different.  Given  and , help Daniel draw a special graph. Input Format A single line containing  space-separated integers,  (the number of different lovely triplets you must have in your graph) and  (the required distance between each pair of nodes in a lovely triplet), respectively. Constraints   Output Format For the first line, print  space-separated integers,  (the number of nodes in the graph) and  (the number of edges in the graph), respectively.  On each line  of the  subsequent lines, print two space-separated integers,  and , describing an edge between nodes  and . Your output must satisfy the following conditions:   If there is more than one correct answer, print any one of them. Sample Input 3 2  Sample Output 7 7 1 2 2 3 3 4 4 5 5 6 6 1 1 7  Explanation There are exactly  lovely triplets in this graph: , , and .  Observe that each node in a lovely triplet is  edges away from the other nodes composing the lovely triplet.
__label__Array __label__Mathematics In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:  Each group has exactly X cards. All the cards in each group have the same integer.    Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]   Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition.   Example 3: Input: [1] Output: false Explanation: No possible partition.   Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1]   Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]       Note:  1 <= deck.length <= 10000 0 <= deck[i] < 10000
__label__Strings Given a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.   Example 1: Input: S = "0110", N = 3 Output: true  Example 2: Input: S = "0110", N = 4 Output: false    Note:  1 <= S.length <= 1000 1 <= N <= 10^9
__label__Dynamic-Programming Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.  For example, if the string is , the substrings are  and .  Their sum is . Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo .   Function Description Complete the substrings function in the editor below.  It should return the sum of the integer values of all substrings in a string representation of a number, modulo .   substrings has the following parameter(s):   n: the string representation of an integer   Input Format A single line containing an integer as a string without leading zeros.   Constraints  Output Format A single line which is sum of the substrings,  Sample Input 0 Sample Output 0 Explanation 0 The substring of number 16 are 16, 1 and 6 which sums to 23. 16 16, 1 6 23 Sample Input 1 Sample Output 1 Explanation 1 The sub-strings of 123 are 1, 2, 3, 12, 23, 123 which sums to 164.  123 1, 2, 3, 12, 23, 123 164
__label__Mathematics Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1. Example 1: Input:"-1/2+1/2" Output: "0/1"   Example 2: Input:"-1/2+1/2+1/3" Output: "1/3"   Example 3: Input:"1/3-1/2" Output: "-1/6"   Example 4: Input:"5/3+1/3" Output: "2/1"   Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.
__label__Mathematics __label__Binary-Search Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2  Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since               the decimal part is truncated, 2 is returned.
__label__Array __label__Dynamic-Programming A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?  An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input: [   [0,0,0],   [0,1,0],   [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right
__label__Array Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.   Example 1: Input: day = 31, month = 8, year = 2019 Output: "Saturday"  Example 2: Input: day = 18, month = 7, year = 1999 Output: "Sunday"  Example 3: Input: day = 15, month = 8, year = 1993 Output: "Sunday"    Constraints:  The given dates are valid dates between the years 1971 and 2100.
__label__Dynamic-Programming Shaka and his brother have created a boring game which is played like this:   They take a word composed of lowercase English letters and try to get the maximum possible score by building exactly 2 palindromic subsequences. The score obtained is the product of the length of these 2 subsequences. Let's say  and  are two subsequences from the initial string. If  &  are the smallest and the largest positions (from the initial word) respectively in  ; and  &  are the smallest and the largest positions (from the initial word) respectively in , then the following statements hold true:  ,  , &  .  i.e., the positions of the subsequences should not cross over each other.  Hence the score obtained is the product of lengths of subsequences  & . Such subsequences can be numerous for a larger initial word, and hence it becomes harder to find out the maximum possible score. Can you help Shaka and his brother find this out? Input Format Input contains a word  composed of lowercase English letters in a single line.   Constraints   each character will be a lower case english alphabet.   Output Format Output the maximum score the boys can get from . Sample Input eeegeeksforskeeggeeks  Sample Output 50  Explanation A possible optimal solution is eee-g-ee-ksfor-skeeggeeks being eeeee the one subsequence and skeeggeeks the other one. We can also select eegee in place of eeeee, as both have the same length.
__label__Strings The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P   A   H   N A P L S I I G Y   I   R  And then read line by line: "PAHNAPLSIIGYIR" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = "PAYPALISHIRING", numRows = 3 Output: "PAHNAPLSIIGYIR"  Example 2: Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I
__label__Strings Julius Caesar protected his confidential information by encrypting it using a cipher. Caesar's cipher shifts each letter by a number of letters.  If the shift takes you past the end of the alphabet, just rotate back to the front of the alphabet.  In the case of a rotation by 3, w, x, y and z would map to z, a, b and c. For example, the given cleartext  and the alphabet is rotated by .  The encrypted string is .   Note: The cipher only encrypts letters; symbols, such as -, remain unencrypted.   - Function Description  Complete the caesarCipher function in the editor below.  It should return the encrypted string.   caesarCipher has the following parameter(s): s: a string in cleartext   k: an integer, the alphabet rotation factor   Input Format The first line contains the integer, , the length of the unencrypted string.  The second line contains the unencrypted string, .  The third line contains , the number of letters to rotate the alphabet by. Constraints      is a valid ASCII string without any spaces.    Output Format For each test case, print the encoded string.   Sample Input 11 middle-Outz 2  Sample Output okffng-Qwvb  Explanation Original alphabet:      abcdefghijklmnopqrstuvwxyz Alphabet rotated +2:    cdefghijklmnopqrstuvwxyzab  m -> o i -> k d -> f d -> f l -> n e -> g -    - O -> Q u -> w t -> v z -> b
__label__Greedy-Algorithms Sean invented a game involving a  matrix where each cell of the matrix contains an integer. He can reverse any of its rows or columns any number of times.  The goal of the game is to maximize the sum of the elements in the  submatrix located in the upper-left quadrant of the matrix. Given the initial configurations for  matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.   For example, given the matrix: It is  so we want to maximize the top left  matrix.  Reverse row : And now reverse column : The maximal sum is . Function Description  Complete the flippingMatrix function in the editor below.  It should return an integer that represents the maximum sum possible for the top  matrix.   flippingMatrix has the following parameters:  - matrix: a  array of integers   Input Format The first line contains an integer , the number of queries.    The next  sets of lines are in the following format: The first line of each query contains an integer, .  Each of the next  lines contains  space-separated integers  in row  of the matrix.   Constraints     , where . Output Format You must print  lines of output. For each query, print the maximum possible sum of the elements in the matrix's upper-left quadrant. Sample Input 1 2 112 42 83 119 56 125 56 49 15 78 101 43 62 98 114 108  Sample Output 414  Explanation We start out with the following  matrix:   We can perform the following operations to maximize the sum of the  submatrix in the upper-left corner: Reverse column  (), resulting in the matrix:   Reverse row  (), resulting in the matrix:   When we sum the values in the  submatrix in the upper-left quadrant, we get .
__label__Mathematics Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0.      Example 1: Input: [2,1,2] Output: 5   Example 2: Input: [1,2,1] Output: 0   Example 3: Input: [3,2,3,4] Output: 10   Example 4: Input: [3,6,2,3] Output: 8    Note:  3 <= A.length <= 10000 1 <= A[i] <= 10^6
__label__Greedy-Algorithms Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way.   Example 1: Input: A = [4,2,3], K = 1 Output: 5 Explanation: Choose indices (1,) and A becomes [4,-2,3].   Example 2: Input: A = [3,-1,0,2], K = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].   Example 3: Input: A = [2,-3,-1,5,-4], K = 2 Output: 13 Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].      Note:  1 <= A.length <= 10000 1 <= K <= 10000 -100 <= A[i] <= 100
__label__Mathematics __label__Strings Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: "III" Output: 3 Example 2: Input: "IV" Output: 4 Example 3: Input: "IX" Output: 9 Example 4: Input: "LVIII" Output: 58 Explanation: L = 50, V= 5, III = 3.  Example 5: Input: "MCMXCIV" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__Mathematics __label__Dynamic-Programming Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:  Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)   Example 2: Input: [1,2,4,8] Output: [1,2,4,8]
__label__Mathematics __label__Bit An array, , is defined as follows:    for , where  is the symbol for XOR You will be given a left and right index .  You must determine the XOR sum of the segment of  as .  For example, .  The segment from  to  sums to .  Print the answer to each question. Function Description  Complete the xorSequence function in the editor below.  It should return the integer value calculated.   xorSequence has the following parameter(s):   l: the lower index of the range to sum   r: the higher index of the range to sum   Input Format The first line contains an integer , the number of questions.  Each of the next  lines contains two space-separated integers,  and , the inclusive left and right indexes of the segment to query. Constraints     Output Format On a new line for each test case, print the XOR-Sum of 's elements in the inclusive range between indices  and . Sample Input 0 Sample Output 0 Explanation 0 The beginning of our array looks like this:   Test Case 0:   Test Case 1:   Test Case 2:   Sample Input 1 Sample Output 1 Explanation 1 .  Perform the xor sum on each interval:
__label__Hash-Table __label__Mathematics Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.
__label__Search __label__Dynamic-Programming There are  variables and  requirements. Requirements are represented as , meaning that the  variable must be less than or equal to the  variable.  Your task is to assign non-negative numbers smaller than  to each variable and then calculate the number of different assignments satisfying all requirements. Two assignments are different if and only if at least one variable is assigned to a different number in both assignments. Print your answer modulo . Input Format The first line contains  space-separated integers,  and , respectively. Each of the  subsequent lines contains  space-seperated integers describing the respective  and  values for an  requirement. Constraints    Output Format Print your answer modulo . Sample Input 0 Sample Output 0 Explanation 0 There are  variables and  requirements. Let the variables be in the array . Requirements are -  One of the assignments is -  Similarly there are  assignments possible. Result = .
__label__Dynamic-Programming Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A common subsequence of two strings is a subsequence that is common to both strings.   If there is no common subsequence, return 0.   Example 1: Input: text1 = "abcde", text2 = "ace"  Output: 3   Explanation: The longest common subsequence is "ace" and its length is 3.  Example 2: Input: text1 = "abc", text2 = "abc" Output: 3 Explanation: The longest common subsequence is "abc" and its length is 3.  Example 3: Input: text1 = "abc", text2 = "def" Output: 0 Explanation: There is no such common subsequence, so the result is 0.    Constraints:  1 <= text1.length <= 1000 1 <= text2.length <= 1000 The input strings consist of lowercase English characters only.
__label__Binary-Search We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!  Example :  Input: n = 10, pick = 6 Output: 6
__label__Dynamic-Programming Consider an array, , of  integers. We define the following terms: Subsequence  A subsequence of  is an array that's derived by removing zero or more elements from  without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence. Subsequence  A subsequence of  is an array that's derived by removing zero or more elements from  without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence. Strictly Increasing Subsequence  A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element.  Strictly Increasing Subsequence  A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element.  Subarray  A subarray of  is an array consisting of a contiguous block of 's elements in the inclusive range from index  to index . Any subarray of  can be denoted by . Subarray  A subarray of  is an array consisting of a contiguous block of 's elements in the inclusive range from index  to index . Any subarray of  can be denoted by . The diagram below shows all possible subsequences and subarrays of :   We define the following functions:   = the maximum sum of some strictly increasing subsequence in subarray   We define the goodness, , of array  to be:   In other words,  is the maximum possible value of  for all possible subarrays of array .  Let  be the length of the smallest subarray such that . Given , find the value of  as well as the number of subarrays such that  and , then print these respective answers as space-separated integers on a single line. Input Format The first line contains an integer, , denoting number of elements in array .  The second line contains  space-separated integers describing the respective values of . Constraints   Subtasks  For the  of the maximum score:     For the  of the maximum score:     Output Format Print two space-seperated integers describing the respective values of  and the number of subarrays satisfying  and . Sample Input 0 Sample Output 0 Explanation 0 The figure below shows how to calculate :   is the length of the smallest subarray satisfying . From the table, we can see that . There is only one subarray of length  such that .
__label__Array Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]  Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]
__label__Bit Given a long integer , count the number of values of  satisfying the following conditions:     where  and  are long integers and  is the bitwise XOR operator.   You are given  queries, and each query is in the form of a long integer denoting . For each query, print the total number of values of  satisfying the conditions above on a new line. For example, you are given the value .  Condition  requires that .  The following tests are run:           We find that there are  values meeting the first condition:  and .   Function Description  Complete the theGreatXor function in the editor below.  It should return an integer that represents the number of values satisfying the constraints.   theGreatXor has the following parameter(s): x: an integer   Input Format The first line contains an integer , the number of queries.  Each of the next  lines contains a long integer describing the value of  for a query.   Constraints   Subtasks For  of the maximum score:   Output Format For each query, print the number of values of  satisfying the given conditions on a new line. Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: For  the only value of  satisfying  is . This also satisfies our other condition, as  and . Because we have one valid  and there are no more values to check, we print  on a new line. For , the following values of  satisfy our conditions:          There are five valid values of . For , the following values of  satisfy our conditions:          There are five valid values of . Sample Input 1 Sample Output 1 Explanation 1 In the first case:      In the second case, the first 10 values are:
__label__Greedy-Algorithms Watson gives Sherlock an array of integers.  Given the endpoints of an integer range, for all  in that inclusive range, determine the minimum( abs(arr[i]-M) for all ) ).  Once that has been determined for all integers in the range, return the  which generated the maximum of those values.  If there are multiple 's that result in that value, return the lowest one.   For example, your array  and your range is from  to  inclusive. We look at the Min column and see the maximum of those three values is .  Two 's result in that answer so we choose the lower value, . Min Function Description  Complete the sherlockAndMinimax function in the editor below.  It should return an integer as described.   sherlockAndMinimax has the following parameters:  - arr: an array of integers  - p: an integer that represents the lowest value of the range for   - q: an integer that represents the highest value of the range for   Input Format The first line contains an integer , the number of elements in .  The next line contains  space-separated integers .  The third line contains two space-separated integers  and , the inclusive endpoints for the range of .        Constraints       Output Format Print the value of  on a line. Sample Input 3 5 8 14 4 9  Sample Output 4  Explanation  For , or , the result is . Since we have to output the smallest of the multiple solutions, we print .
__label__Tree Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.    Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32   Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23    Note:  The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31.
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note:  This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why?
__label__Mathematics __label__Game-Theory Alice and Bob play the following game: They choose a permutation of the numbers  to .   Alice plays first and they alternate.   In a turn, they can remove any one remaining number from the permutation.   The game ends when the remaining numbers form an increasing sequence of  or more numbers. The person who played the last turn (after which the sequence becomes increasing) wins the game.   Assuming both play optimally, who wins the game?   For example, if  the starting permutation might be .  First, Alice chooses  or  (use  for the example) leaving .  Since this is a decreasing sequence, Bob can remove any number for optimum play (he will lose regardless).  Alice then removes any number leaving an array of only one element.  Since Alice removed the last element to create an increasing sequence, Alice wins.  Function Description  Complete the permutationGame function in the editor below.  It should return a string that represents the winner of the game, either Bob or Alice.   Bob Alice permutationGame has the following parameter:  - arr: an array of integers that represents the starting permutation   Input Format The first line contains the number of test cases .   Each of the next  pairs of lines is in the following format:  - The first line contains an integer , the size of the array   - The second line contains  space-separated integers,  where   Constraints    The permutation will not be an increasing sequence initially. Output Format Output  lines, one for each test case, containing Alice if Alice wins the game and Bob otherwise.   Alice Bob Sample Input 2 3 1 3 2 5 5 3 2 1 4  Sample Output Alice Bob  Explanation For the first test, Alice can remove the  or the  to make the sequence increasing and wins the game.     For the second test, if  is removed then the only way to have an increasing sequence is to only have  number left.  This would take a total of  moves, thus allowing Bob to win. On the first move if Alice removes the , it will take  more moves to create an increasing sequence thus Bob wins. If Alice does not remove the , then Bob can remove it on his next turn to create the same game state to win (decreasing sequence,  numbers left).
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. The lists are equal only if they have the same number of nodes and corresponding nodes contain the same data. Either head pointer given may be null meaning that the corresponding list is empty. Input Format You have to complete the int CompareLists(Node* headA, Node* headB) method which takes two arguments - the heads of the two linked lists to compare. You should NOT read any input from stdin/console. int CompareLists(Node* headA, Node* headB) The input is handled by the code in the editor and the format is as follows:  The first line contains , the number of test cases. The format for each test case is as follows:   The first line contains an integer , denoting the number of elements in the first linked list.  The next  lines contain an integer each, denoting the elements of the first linked list.  The next line contains an integer , denoting the number of elements in the second linked list.  The next  lines contain an integer each, denoting the elements of the second linked list.   Constraints     , where  is the  element in the list.   Output Format Compare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout/console. return return The output is handled by the code in the editor and it is as follows:   For each test case, in a new line, print  if the two lists are equal, else print .   Sample Input 2 2 1 2 1 1 2 1 2 2 1 2  Sample Output 0 1  Explanation In the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL In the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL
__label__Strings We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1". The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: "(123)" Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]  Example 2: Input: "(00011)" Output:  ["(0.001, 1)", "(0, 0.011)"] Explanation:  0.0, 00, 0001 or 00.01 are not allowed.  Example 3: Input: "(0123)" Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]  Example 4: Input: "(100)" Output: [(10, 0)] Explanation:  1.0 is not allowed.    Note:   4 <= S.length <= 12. S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits.
__label__Greedy-Algorithms The city of Gridland is represented as an  matrix where the rows are numbered from  to  and the columns are numbered from  to . Gridland has a network of train tracks that always run in straight horizontal lines along a row. In other words, the start and end points of a train track are  and , where  represents the row number,  represents the starting column, and  represents the ending column of the train track.  The mayor of Gridland is surveying the city to determine the number of locations where lampposts can be placed. A lamppost can be placed in any cell that is not occupied by a train track. Given a map of Gridland and its  train tracks, find and print the number of cells where the mayor can place lampposts. Note: A train track may overlap other train tracks within the same row.  For example, if Gridland's data is the following:   In this case, there are five open cells (red) where lampposts can be placed. Function Description Complete the gridlandMetro function in the editor below.  It should return an integer that denotes the number of cells where lampposts can be installed.   gridlandMetro has the following parameter(s):   n: an integer, the number of rows in Gridland m: an integer, the number of columns in Gridland k: an integer, the number of tracks track: a 2 dimensional array of integers where each element contains  integers that represent   Input Format The first line contains three space-separated integers  and , the number of rows, columns and tracks to be mapped.    Each of the next  lines contains three space-separated integers,  and , the row number and the track column start and end.   Constraints     Output Format Print a single integer denoting the number of cells where the mayor can install lampposts. Sample Input 4 4 3 2 2 3 3 1 4 4 4 4  Sample Output 9  Explanation   In the diagram above, the yellow cells denote the first train track, green denotes the second, and blue denotes the third. Lampposts can be placed in any of the nine red cells.
__label__Binary-Search __label__Tree Given a complete binary tree, count the number of nodes. Note:  Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input:      1    / \   2   3  / \  / 4  5 6  Output: 6
__label__Data-Structures We're going to make our own Contacts application! The application must perform two types of operations: add name, where  is a string denoting a contact name. This must store  as a new contact in the application.   add name find partial, where  is a string denoting a partial name to search the application for. It must count the number of contacts starting with  and print the count on a new line. find partial Given  sequential add and find operations, perform each operation in order. Input Format The first line contains a single integer, , denoting the number of operations to perform.  Each line  of the  subsequent lines contains an operation in one of the two forms defined above.   Constraints       It is guaranteed that  and  contain lowercase English letters only. The input doesn't have any duplicate  for the  operation. Output Format For each find partial operation, print the number of contact names starting with  on a new line. find partial Sample Input 4 add hack add hackerrank find hac find hak  Sample Output 2 0  Explanation We perform the following sequence of operations: Add a contact named hack. hack Add a contact named hackerrank. hackerrank Find and print the number of contact names beginning with hac. There are currently two contact names in the application and both of them start with hac, so we print  on a new line. hac hac Find and print the number of contact names beginning with hak. There are currently two contact names in the application but neither of them start with hak, so we print  on a new line. hak hak
__label__Array Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.  Elements that don't appear in arr2 should be placed at the end of arr1 in ascending order.   Example 1: Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19]    Constraints:  arr1.length, arr2.length <= 1000 0 <= arr1[i], arr2[i] <= 1000 Each arr2[i] is distinct. Each arr2[i] is in arr1.
__label__Dynamic-Programming You are using at most A number of 1s and at most B number of 2s. How many different evaluation results are possible when they are formed in an expression containing only addition + sign and multiplication * sign are allowed? + * Note that, multiplication takes precedence over addition. For example, if A=2 and B=2, then we have the following expressions: 1, 1*1 = 1 1 1*1 2, 1*2, 1*1*2, 1+1 = 2 2 1*2 1*1*2 1+1 1+2, 1+1*2 = 3 1+2 1+1*2 2+2, 2*2, 1+1+2, 1*2*2, 1*1*2*2, 1*2+1*2, 1*1*2+2, 1*2+2 = 4 2+2 2*2 1+1+2 1*2*2 1*1*2*2 1*2+1*2 1*1*2+2 1*2+2 1+2+2, 1+1*2+2 = 5 1+2+2 1+1*2+2 1+1+2+2,  1+1+2*2 = 6 1+1+2+2 1+1+2*2 So there are 6 unique results that can be formed if A = 2 and B = 2.  Input Format The first line contains the number of test cases T, T testcases follow each in a newline.  Each testcase contains 2 integers A and B separated by a single space.   Constraints 1 <= T <= 105  0<=A<=1000000000  0<=B<=1000   Output Format Print the number of different evaluations modulo (%) (109+7.) Sample Input 4 0 0 2 2 0 2 2 0  Sample Output 0 6 2 2  Explanation When A = 0, B = 0, there are no expressions, hence 0.  When A = 2, B = 2, as explained in the problem statement above, expressions leads to 6 possible solutions.  When A = 0, B = 2, we have 2, 2+2 or 2*2, hence 2.  2 2+2 2*2 When A = 2, B = 0, we have 1 or 1*1, 1+1 hence 2.  1 1*1 1+1
__label__Dynamic-Programming Bill Gates is on one of his philanthropic journeys to a village in Utopia. He has brought a box of packets of candies and would like to distribute one packet to each of the children.  Each of the packets contains a number of candies.  He wants to minimize the cumulative difference in the number of candies in the packets he hands out.  This is called the unfairness sum.  Determine the minimum unfairness sum achievable.  For example, he brings  packets where the number of candies is .  There are  children.  The minimum difference between all packets can be had with  from indices  and .  We must get the difference in the following pairs: .  We calculate the unfairness sum as: Function Description Complete the angryChildren function in the editor below.  It should return an integer that represents the minimum unfairness sum achievable. angryChildren has the following parameter(s): k: an integer that represents the number of children   packets:  an array of integers that represent the number of candies in each packet   Input Format The first line contains an integer .  The second line contains an integer .  Each of the next  lines contains an integer . Constraints       Output Format A single integer representing the minimum achievable unfairness sum. Sample Input 0  7 3 10 100 300 200 1000 20 30  Sample Output 0  40  Explanation 0 Bill Gates will choose packets having 10, 20 and 30 candies.  The unfairness sum is .   Sample Input 1  10 4 1 2 3 4 10 20 30 40 100 200  Sample Output 1  10  Explanation 1  Bill Gates will choose 4 packets having 1,2,3 and 4 candies. The unfairness sum i .
__label__Mathematics __label__Binary-Search For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1. Now given a string representing n, you should return the smallest good base of n in string format. Example 1: Input: "13" Output: "3" Explanation: 13 base 3 is 111.    Example 2: Input: "4681" Output: "8" Explanation: 4681 base 8 is 11111.    Example 3: Input: "1000000000000000000" Output: "999999999999999999" Explanation: 1000000000000000000 base 999999999999999999 is 11.    Note:  The range of n is [3, 10^18]. The string representing n is always valid and will not have leading zeros.
__label__Strings __label__Dynamic-Programming Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.  Example 1: Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.   Example 2: Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.   Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}.
__label__Hash-Table Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1  Example 2: Input: [4,1,2,1,2] Output: 4
__label__Strings Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.  Example: Input: "23" Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].  Note: Although the above answer is in lexicographical order, your answer could be in any order you want.
__label__Dynamic-Programming You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).              Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).              Total amount you can rob = 2 + 9 + 1 = 12.
__label__Dynamic-Programming __label__Depth-first-Search In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:  You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.  Example:     Input: ring = "godding", key = "gd" Output: 4 Explanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo". Also, we need 1 more step for spelling. So the final output is 4.  Note:  Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. It's guaranteed that string key could always be spelled by rotating the string ring.
__label__Dynamic-Programming We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = ["babca","bbazb"] and deletion indices {0, 1, 4}, then the final array after deletions is ["bc","az"]. Suppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in lexicographic order. For clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on. Return the minimum possible value of D.length.    Example 1: Input: ["babca","bbazb"] Output: 3 Explanation: After deleting columns 0, 1, and 4, the final array is A = ["bc", "az"]. Both these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]). Note that A[0] > A[1] - the array A isn't necessarily in lexicographic order.   Example 2: Input: ["edcba"] Output: 4 Explanation: If we delete less than 4 columns, the only row won't be lexicographically sorted.   Example 3: Input: ["ghi","def","abc"] Output: 0 Explanation: All rows are already lexicographically sorted.       Note:  1 <= A.length <= 100 1 <= A[i].length <= 100
__label__Dynamic-Programming We define a modified Fibonacci sequence using the following definition: Given terms  and  where , term  is computed using the following relation:     For example, if  and ,   ,   ,   ,   and so on.   Given three integers, , , and , compute and print the  term of a modified Fibonacci sequence. Function Description  Complete the fibonacciModified function in the editor below.  It must return the  number in the sequence.   fibonacciModified has the following parameter(s):   t1: an integer   t2: an integer   n: an integer   Note: The value of  may far exceed the range of a -bit integer. Many submission languages have libraries that can handle such large results but, for those that don't (e.g., C++), you will need to compensate for the size of the result. Input Format A single line of three space-separated integers describing the respective values of , , and . Constraints     may far exceed the range of a -bit integer.  Output Format Print a single integer denoting the value of term  in the modified Fibonacci sequence where the first two terms are  and .  Sample Input 0 1 5  Sample Output 5  Explanation The first two terms of the sequence are  and , which gives us a modified Fibonacci sequence of . Because , we return the  term.
__label__Hash-Table Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = "abba", str = "dog cat cat dog" Output: true Example 2: Input:pattern = "abba", str = "dog cat cat fish" Output: false Example 3: Input: pattern = "aaaa", str = "dog cat cat dog" Output: false Example 4: Input: pattern = "abba", str = "dog dog dog dog" Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.
__label__Array Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
__label__Hash-Table Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = "anagram", t = "nagaram" Output: true  Example 2: Input: s = "rat", t = "car" Output: false  Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
__label__Strings Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc", "eae" Output: 3   Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].
__label__Tree Given a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.   Example 1:  Input: [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.   Example 2:  Input: [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn't as far left as possible.     Note:  The tree will have between 1 and 100 nodes.
__label__Depth-first-Search Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X  After running your function, the board should be: X X X X X X X X X X X X X O X X  Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
__label__Dynamic-Programming Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: Input: "a" Output: 1  Explanation: Only the substring "a" of string "a" is in the string s.   Example 2: Input: "cac" Output: 2 Explanation: There are two substrings "a", "c" of string "cac" in the string s.   Example 3: Input: "zab" Output: 6 Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
__label__Tree __label__Depth-first-Search The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1]       3     / \    2   3     \   \       3   1  Output: 7  Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1]       3     / \    4   5   / \   \   1   3   1  Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
__label__Array __label__Binary-Search A conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.   Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation:  A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10  Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.   Example 2: Input: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation:  A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4  Example 3: Input: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation:  1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1    Note:  1 <= D <= weights.length <= 50000 1 <= weights[i] <= 500
__label__Search __label__Dynamic-Programming __label__Tree ADZEN is a popular advertising firm in your city that owns all  billboard locations on Main street. The city council passed a new zoning ordinance mandating that no more than  consecutive billboards may be up at any given time. For example, if there are  billboards on Main street and , ADZEN must remove either the middle billboard, the first two billboards, the last two billboards or the first and last billboard. Being a for-profit company, ADZEN wants to lose as little advertising revenue as possible when removing the billboards. They want to comply with the new ordinance in such a way that the remaining billboards maximize their total revenues (i.e., the sum of  revenues generated by the billboards left standing on Main street). Given , , and the revenue of each of the  billboards, find and print the maximum profit that ADZEN can earn while complying with the zoning ordinance. Assume that Main street is a straight, contiguous block of  billboards that can be removed but cannot be reordered in any way.   For example, if there are  billboards, and  is the maximum number of consecutive billboards that can be active, with , then the maximum revenue that can be generated is : .   Function Description  Complete the billboards function in the editor below.  It should return an integer that represents the maximum revenue that can be generated under the rules.   billboards has the following parameter(s):   k: an integer that represents the longest contiguous group of billboards allowed   revenue: an integer array where each element represents the revenue potential for a billboard at that index   Input Format The first line contains two space-separated integers,  (the number of billboards) and  (the maximum number of billboards that can stand together on any part of the road).  Each line  of the  subsequent lines contains an integer denoting the revenue value of billboard  (where ). Constraints    Output Format Print a single integer denoting the maximum profit ADZEN can earn from Main street after complying with the city's ordinance. Sample Input 0  6 2    1   2   3   1   6   10   Sample Output 0  21  Explanation 0  There are  billboards, and we must remove some of them so that no more than  billboards are immediately next to one another. We remove the first and fourth billboards, which gives us the configuration _ 2 3 _ 6 10 and a profit of . As no other configuration has a profit greater than , we print  as our answer. _ 2 3 _ 6 10 Sample Input 1  5 4 1 2 3 4 5  Sample Output 1  14  Explanation 1  There are  billboards, and we must remove some of them so that no more than  billboards are immediately next to one another. We remove the first billboard, which gives us the configuration _ 2 3 4 5 and a profit of . As no other configuration has a profit greater than , we print  as our answer. _ 2 3 4 5
__label__Hash-Table Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:  Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.  Empty cells are indicated by the character '.'.  A sudoku puzzle...  ...and its solution numbers marked in red. Note:  The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9.
__label__Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return true if and only if the given array A is monotonic.      Example 1: Input: [1,2,2,3] Output: true   Example 2: Input: [6,5,4,4] Output: true   Example 3: Input: [1,3,2] Output: false   Example 4: Input: [1,2,4,5] Output: true   Example 5: Input: [1,1,1] Output: true    Note:  1 <= A.length <= 50000 -100000 <= A[i] <= 100000
__label__Dynamic-Programming We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.  Example 1: Input:["with", "example", "science"], "thehat"  Output:3  Explanation:We can use 2 "with" stickers, and 1 "example" sticker. After cutting and rearrange the letters of those stickers, we can form the target "thehat". Also, this is the minimum number of stickers necessary to form the target string.  Example 2: Input:["notice", "possible"], "basicbasic"  Output:-1  Explanation:We can't form the target "basicbasic" from cutting letters from the given stickers.  Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.
__label__Binary-Search __label__Depth-first-Search On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.  You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.  Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation:  0  1  2  3  4 24 23 22 21  5 12 13 14 15 16 11 17 18 19 20 10  9  8  7  6  The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected.  Note:  2 <= N <= 50. grid[i][j] is a permutation of [0, ..., N*N - 1].
__label__Depth-first-Search In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space.  These characters divide the square into contiguous regions. (Note that backslash characters are escaped, so a \ is represented as "\\".) Return the number of regions.                Example 1: Input: [   " /",   "/ " ] Output: 2 Explanation: The 2x2 grid is as follows:    Example 2: Input: [   " /",   "  " ] Output: 1 Explanation: The 2x2 grid is as follows:    Example 3: Input: [   "\\/",   "/\\" ] Output: 4 Explanation: (Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.) The 2x2 grid is as follows:    Example 4: Input: [   "/\\",   "\\/" ] Output: 5 Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.) The 2x2 grid is as follows:    Example 5: Input: [   "//",   "/ " ] Output: 3 Explanation: The 2x2 grid is as follows:     Note:  1 <= grid.length == grid[0].length <= 30 grid[i][j] is either '/', '\', or ' '.
__label__Graph-Algorithms Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board.  Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible.  But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board . Note  Immovable blocks cannot be moved while cheating.  A block can be moved only in the directions UP, DOWN, LEFT or RIGHT.  Input Format The first line contains four integers N, M, K, Q separated by a single space.  N lines follow.  Each line contains M integers 0 or 1 separated by a single space. If the jth integer is 1, then the block in ith row and jth column is movable. If the jth integer is 0 then the block in ith row and jth column is fixed. Then Q lines follows, each line contains six integers EXi, EYi, SXi, SYi, TXi, TYi separated by a single space. The ith query is the Cao Cao block is in row SXi column SYi, the exit is in TXi, TYi, and the empty position is in row EXi column EYi. It is guaranteed that the blocks in these positions are movable. Find the minimum seconds Acme needs to finish the game. If it is impossible to finish the game, you should answer -1. Constraints N,M ≤ 200  1 ≤ Q ≤ 250  10 ≤ K≤ 15  1 ≤ EXi,  SXi,  TXi≤ N  1 ≤ EYi, SYi,TYi ≤ M Output Format You should output Q lines, i-th line contains an integer which is the answer to i-th query. Sample Input 5 5 12 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1 5 4 3 4 1  Sample Output 20  Explanation Move the block in (1, 4) to (1, 5);  Move the block in (1, 3) to (1, 4);  Move the block in (1, 2) to (1, 3);  Move the block in (2, 2) to (1, 2);  Move the block in (3, 2) to (2, 2);  Move the block in (4, 2) to (3, 2);  Move the block in (4, 3) to (4, 2);  Move the block in (4, 1) to (4, 3) by cheating;  Move the block in (4, 2) to (4, 1).   So, 1 + 1 + 1 + 1 + 1 + 1 + 1 + 12 + 1 = 20.
__label__Depth-first-Search In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.  Example 2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4.   Notes:  1 <= grid.length = grid[0].length <= 50. 0 <= grid[i][j] <= 1.
__label__Array Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.) Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)    Example 1: Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3   Example 2: Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10   Example 3: Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4   Example 4: Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3  Example 5: Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1    Note:   -30000 <= A[i] <= 30000 1 <= A.length <= 30000
__label__Game-Theory Consider the following game: There are two players, First and Second, sitting in front of a pile of  stones. First always plays first. There is a set, , of  distinct integers defined as . The players move in alternating turns. During each turn, a player chooses some  and splits one of the piles into exactly  smaller piles of equal size. If no  exists that will split one of the available piles into exactly  equal smaller piles, the player loses. Both players always play optimally. Given , , and the contents of , find and print the winner of the game. If First wins, print First; otherwise, print Second. First Second Input Format The first line contains two space-separated integers describing the respective values of  (the size of the initial pile) and  (the size of the set).  The second line contains  distinct space-separated integers describing the respective values of . Constraints    Output Format Print First if the First player wins the game; otherwise, print Second. First Second Sample Input 0 Sample Output 0 Explanation 0 The initial pile has  stones, and . During First's initial turn, they have two options: Split the initial pile into  equal piles, which forces them to lose after the following sequence of turns:   Split the initial pile into  equal piles, which forces them to lose after the following sequence of turns:   Because First never has any possible move that puts them on the path to winning, we print Second as our answer. Second
__label__Tree Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them.   Example 1: Input:               5              / \             4   5            / \   \           1   1   5  Output: 2   Example 2: Input:               1              / \             4   5            / \   \           4   4   5  Output: 2   Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.
__label__Two-Pointers Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.   Example 1: Input: s1 = "ab" s2 = "eidbaooo" Output: True Explanation: s2 contains one permutation of s1 ("ba").  Example 2: Input:s1= "ab" s2 = "eidboaoo" Output: False    Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].
__label__Search Consider a matrix where each cell contains either a  or a .  Any cell containing a  is called a filled cell. Two cells are said to be connected if they are adjacent to each other horizontally, vertically, or diagonally.  In the following grid, all cells marked X are connected to the cell marked Y. X Y XXX XYX   XXX      If one or more filled cells are also connected, they form a region. Note that each cell in a region is connected to zero or more cells in the region but is not necessarily directly connected to all the other cells in the region. Given an  matrix, find and print the number of cells in the largest region in the matrix. Note that there may be more than one region in the matrix. For example, there are two regions in the following  matrix.  The larger region at the top left contains  cells.  The smaller one at the bottom right contains .   110 100 001  Function Description  Complete the connectedCell function in the editor below.  It should return an integer that denotes the area of the largest region.   connectedCell has the following parameter(s):  - matrix: a 2D array of integers where  represents the  row of the matrix   Input Format The first line contains an integer , the number of rows in the matrix.  The second line contains an integer , the number of columns in the matrix.  Each of the next  lines contains  space-separated integers . Constraints  Output Format Print the number of cells in the largest region in the given matrix. Sample Input 4 4 1 1 0 0 0 1 1 0 0 0 1 0 1 0 0 0  Sample Output 5  Explanation The diagram below depicts two regions of the matrix; for each region, the component cells forming the region are marked with an X: X X X 0 0     1 1 0 0 0 X X 0     0 1 1 0 0 0 X 0     0 0 1 0 1 0 0 0     X 0 0 0  The first region has five cells and the second region has one cell. We print the size of the largest region.
__label__Tree __label__Data-Structures You are given a pointer to the root of a binary tree. You need to print the level order traversal of this tree. In level order traversal, we visit the nodes level by level from left to right.  You only have to complete the function.  For example:      1       \        2         \          5         /  \        3    6         \          4    For the above tree, the level order traversal is 1 -> 2 -> 5 -> 3 -> 6 -> 4. Input Format You are given a function, void levelOrder(Node * root) {  }  Constraints 1 Nodes in the tree   500 Output Format Print the values in a single line separated by a space. Sample Input      1       \        2         \          5         /  \        3    6         \          4    Sample Output 1 2 5 3 6 4 Explanation We need to print the nodes level by level. We process each level from left to right.  Level Order Traversal: 1 -> 2 -> 5 -> 3 -> 6 -> 4.
__label__Search __label__Greedy-Algorithms A group of friends want to buy a bouquet of flowers.  The florist wants to maximize his number of new customers and the money he makes.  To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus .  The first flower will be original price, , the next will be  and so on.   Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers. For example, if there are  friends that want to buy  flowers that cost  each will buy one of the flowers priced  at the original price.  Having each purchased  flower, the first flower in the list, , will now cost .  The total cost will be .   Function Description Complete the getMinimumCost function in the editor below.  It should return the minimum cost to purchase all of the flowers.   getMinimumCost has the following parameter(s): c: an array of integers representing the original price of each flower k: an integer, the number of friends Input Format The first line contains two space-separated integers  and , the number of flowers and the number of friends.  The second line contains  space-separated positive integers , the original price of each flower. Constraints        Output Format Print the minimum cost to buy all  flowers. Sample Input 0 Sample Output 0 Explanation 0 There are  flowers with costs  and  people in the group. If each person buys one flower, the total cost of prices paid is  dollars. Thus, we print  as our answer.   Sample Input 1 Sample Output 1 Explanation 1 There are  flowers with costs  and  people in the group. We can minimize the total purchase cost like so: The first person purchases  flowers in order of decreasing price; this means they buy the more expensive flower () first at price  dollars and the less expensive flower () second at price  dollars.  The second person buys the most expensive flower at price  dollars.  We then print the sum of these purchases, which is , as our answer. Sample Input 2 Sample Output 2 Explanation 2 The friends buy flowers for ,  and ,  and  for a cost of .
__label__Array Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1. Return the least number of moves to make every value in A unique.   Example 1: Input: [1,2,2] Output: 1 Explanation:  After 1 move, the array could be [1, 2, 3].   Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values.     Note:  0 <= A.length <= 40000 0 <= A[i] < 40000
__label__Mathematics __label__Game-Theory HackerChess is a variant of chess played at HackerRank. It is a game played between two players who make moves in turns until one of them cannot make any move. The player who cannot make a move loses the game and the other player is declared the winner. The game is played on a board with  rows and  columns. The only pieces used in the game are rooks. A rook in HackerChess moves only vertically, which means that in never leaves a column to which it belongs. Moreover, in a single move, a rook moves through any number of unoccupied cells. Notice that there are no captures in HackerChess, two rooks cannot occupy the same cell, and a rook cannot jump over another rook. Each player has exactly one rook in each of the  columns of the board. Given the initial position of the rooks and knowing that the second player makes the first move, decide who will win the game if both players play optimally. Input Format In the first line, there is a single integer  denoting the number of games to be played. After that, descriptions of  games follow: In the first line, there is a single integer  denoting the size of the board. Next,  lines follow. In the -th of them there is a single integer  denoting the row of the rook belonging to the first player placed in the -th column. After that, another  lines follow. In the -th of them there is a single integer  denoting the row of the rook belonging to the second player placed in the -th column. Constraints      Output Format Print exactly  lines. In the -th of them, print player-1 if the first player will win the -th game. Otherwise, print player-2 in this line. player-1 player-2 Sample Input 0 Sample Output 0 Explanation 0 There is only one game player in the sample input. The game is played on the board with  rows and  columns. Let's denote the first player's rooks as red rooks and the second player's rooks as green ones. Then the initial position of the game looks like this:  The second player moves first and he can move his rook in the first column to the second row. After this move, the position looks as follows:  Next, it is the first player's turn. He cannot make any move with his rook in the first column, so he has to make a move in the second or the third column. Without the loss of generality, let's assume that he makes a move in the second column. He can only make one such move, i.e. move the rook from the second to the third row. This results in the following position:  After that, the best move for the second player is to move his rook in the second column from the first to the second row. After this move, the position looks like this:  Next, it is again the first player's move. The only move he can make is to move his rook in the third column from the second to the third row. It results in the following position:  Then, the best move for the second player is to move his rook in the third column from the first to the second row. After that, the position looks as follows:  Next, it is the first player's move, but since he is unable to make any valid move, he loses and the second player is declared a winner. It shows that regardless of the first player's moves, the second player has a strategy leading to his victory. Sample Input 1 Sample Output 1 Explanation 1 Second player cannot make a move so  is the winner.
__label__Dynamic-Programming Sophia has discovered several alien languages. Suprisingly, all of these languages have an alphabet, and each of them may contain thousands of characters! Also, all the words in a language have the same number of characters in it. However, the aliens like their words to be aesthetically pleasing, which for them means that for the  letter of an -letter alphabet (letters are indexed ): if , then the  letter may be the last letter of a word, or it may be immediately followed by any letter, including itself. if , then the  letter may be the last letter of a word, or it may be immediately followed by any letter, including itself. if , then the  letter can not be the last letter of a word and also can only be immediately followed by  letter if and only if .   if , then the  letter can not be the last letter of a word and also can only be immediately followed by  letter if and only if .   Sophia wants to know how many different words exist in this language. Since the result may be large, she wants to know this number, modulo . Input Format The first line contains , the number of test cases. The first line is followed by  lines, each line denoting a test case. Each test case will have two space-separated integers ,  which denote the number of letters in the language and the length of words in this language respectively. Constraints       Output Format For each test case, output the number of possible words modulo . Sample Input 3 1 3 2 3 3 2  Sample Output 1 3 6  Explanation For the first test case, there's one letter ('a') and all the words consist of  letters. There's only one possibility which is "aaa".   For the second test case, there are two letters ('a' and 'b') and all the words are of  letters. The possible strings are "abb", "bab", & "bbb". The words can end only with 'b' because  and for 'a', it's . "aab" is not allowed because 'a' can not be followed immediately by 'a'. For a word of length 4 and alphabet of size 2, "abab" would be allowed. For the third test case, there are three letters ('a', 'b' and 'c') and all of the words are  letters. The words can only end with 'b' or 'c'. The possible words are "ab", "ac", "bb", "cc", "bc", "cb".
__label__Two-Pointers Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.  Example 1: Input: S = "ab#c", T = "ad#c" Output: true Explanation: Both S and T become "ac".   Example 2: Input: S = "ab##", T = "c#d#" Output: true Explanation: Both S and T become "".   Example 3: Input: S = "a##c", T = "#a#c" Output: true Explanation: Both S and T become "c".   Example 4: Input: S = "a#c", T = "b" Output: false Explanation: S becomes "c" while T becomes "b".  Note:  1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters.  Follow up:  Can you solve it in O(N) time and O(1) space?
__label__Dynamic-Programming Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3   Note:  You may assume that the array does not change. There are many calls to sumRange function.
__label__Strings Oh!! Mankind is in trouble again. This time, it's a deadly disease spreading at a rate never seen before. The need of the hour is to set up efficient virus detectors. You are the lead at Central Hospital and you need to find a fast and reliable way to detect the footprints of the virus DNA in that of the patient. The DNA of the patient as well as of the virus consists of lowercase letters. Since the collected data is raw, there may be some errors. You will need to find all substrings in the patient DNA that either exactly match the virus DNA or have at most one mismatch, i.e., a difference in at most one location.  For example, "aa" and "aa" are matching, "ab" and "aa" are matching, while "abb" and "bab" are not. aa aa ab aa abb bab Function Description Complete the virusIndices function in the editor below.  It should print a list of space-separated integers that represent the starting indices of matching substrings in increasing order, or No match!. No match! virusIndices has the following parameter(s):   p: a string that represents patient DNA   v: a string that represents virus DNA   Input Format The first line contains an integer , the number of test cases.   .  Each of the next  lines contains two space-separated strings  (the patient DNA) and  (the virus DNA).   Constraints    All characters in  and . Output Format For each test case, output a single line containing a space-delimited list of starting indices (-indexed) of substrings of  which are matching with  according to the condition mentioned above. The indices have to be in increasing order. If there is no matching substring, output No Match!.   No Match! Sample Input 0 Sample Output 0 Explanation 0 For the first case, the substrings of  starting at indices  and  are "bb" and "ba" and they are matching with the string  which is "ba".  For the second case, there are no matching substrings so the output is No Match!.  For the third case, the substrings of  starting at indices  and  are "ban" and "nan" and they are matching with the string  which is "nan".   bb ba ba No Match! ban nan nan Sample Input 1 Sample Output 1 Explanation 1 For the first case, the substrings of  starting at indices  and  are "ga" and "gc" and they are matching with the string  which is "gc".  For the second case, the substrings of  starting at indices  and  are "cga" and "cga" and they are matching with the string  which is "cgg".  For the third case, the substrings of  starting at indices ,  and  are "aa", "ar" and "ar" and they are matching with the string  which is "ab".  ga gc gc cga cga cgg aa ar ar ab
__label__Dynamic-Programming Given a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7.   Example 1: Input: "abc" Output: 7 Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".   Example 2: Input: "aba" Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".   Example 3: Input: "aaa" Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".        Note:  S contains only lowercase letters. 1 <= S.length <= 2000
__label__Mathematics You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.
__label__Hash-Table Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example: Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
__label__Greedy-Algorithms There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note:  If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer.  Example 1: Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.  Example 2: Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start.
__label__Dynamic-Programming In a tournament,  players play against each other exactly once. Each game results in exactly one player winning. There are no ties. You have been given a scorecard containing the scores of each player at the end of the tournament. The score of a player is the total number of games the player won in the tournament. However, the scores of some players might have been erased from the scorecard. How many possible scorecards are consistent with the input scorecard? Input Format The first line contains a single integer  denoting the number of test cases.  test cases follow.   The first line of each test case contains a single integer . The second line contains  space-separated integers .  denotes the score of the th player. If the score of the th player has been erased, it is represented by . Constraints    Output Format For each test case, output a single line containing the answer for that test case modulo .  Sample Input 0 Sample Output 0 Explanation 0 For the first case, there are 2 scorecards possible: (0,1,2) or (1,0,2).  For the second case, the valid scorecards are (1,1,1), (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0).  For the third case, the only valid scorecard is (0,1,2,3).  For the fourth case, there is no valid scorecard. It is not possible for both players to have score of 1.  For the fifth case, 6-variations of {(3,1,0)[2]}, and 3 variations each of {(2,2,0)[2]} and {(2,1,1)[2]}.
__label__Strings A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string.  Given two strings of equal length, what's the longest string  that can be constructed such that it is a child of both?   For example, ABCD and ABDC have two children with maximum length 3, ABC and ABD.  They can be formed by eliminating either the D or C from both strings.  Note that we will not consider ABCD as a common child because we can't rearrange characters and ABCD  ABDC.   ABCD ABDC ABC ABD D C ABCD ABCD ABDC Function Description Complete the commonChild function in the editor below.  It should return the longest string which is a common child of the input strings. commonChild has the following parameter(s): s1, s2:  two equal length strings   Input Format There is one line with two space-separated strings,  and .  Constraints   All characters are upper case in the range ascii[A-Z]. Output Format Print the length of the longest string , such that  is a child of both  and .  Sample Input HARRY SALLY  Sample Output  2  Explanation The longest string that can be formed by deleting zero or more characters from  and  is , whose length is 2. Sample Input 1 AA BB  Sample Output 1 0  Explanation 1  and  have no characters in common and hence the output is 0. Sample Input 2 SHINCHAN NOHARAAA  Sample Output 2 3  Explanation 2 The longest string that can be formed between  and  while maintaining the order is . Sample Input 3 ABCDEF FBDAMN  Sample Output 3 2  Explanation 3   is the longest child of the given strings.
__label__Dynamic-Programming __label__Mathematics Mr K has a rectangular plot of land which may have marshes where fenceposts cannot be set. He wants you to find the perimeter of the largest rectangular fence that can be built on this land. For example, in the following  grid,  marks a marsh and  marks good land. .... ..x. ..x. x...  If we number the rows and columns starting with , we see that there are two main areas that can be fenced:  and .  The longest perimeter is .   Function Description Complete the kMarsh function in the editor below.  It should print either an integer or impossible. impossible kMarsh has the following parameter(s):   grid: an array of strings that represent the grid   Input Format The first line contains two space-separated integers  and , the grid rows and columns.  Each of the next  lines contains  characters each describing the state of the land. 'x' (ascii value: 120) if it is a marsh and '.' ( ascii value:46) otherwise.   Constraints   Output Format Output contains a single integer - the largest perimeter. If the rectangular fence cannot be built, print impossible. Sample Input 0 4 5 ..... .x.x. ..... .....  Sample Output 0 14  Explanation 0  The fence can be put up around the entire field. The perimeter is . Sample Input 1 2 2 .x x.  Sample Output 1 impossible  Explanation 1 We need a minimum of 4 points to place the 4 corners of the fence. Hence, impossible.  Sample Input 2 2 5 ..... xxxx.  Sample Output 2 impossible
__label__Binary-Search Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1.      Example 1: Input: A = [1], K = 1 Output: 1   Example 2: Input: A = [1,2], K = 4 Output: -1   Example 3: Input: A = [2,-1,2], K = 3 Output: 3    Note:  1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9
__label__Strings Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero. Example 1: Input: "3+2*2" Output: 7  Example 2: Input: " 3/2 " Output: 1 Example 3: Input: " 3+5 / 2 " Output: 5  Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.
__label__Array __label__Hash-Table Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,  Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].
__label__Array A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n. The bus goes along both directions i.e. clockwise and counterclockwise. Return the shortest distance between the given start and destination stops.   Example 1:  Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.   Example 2:  Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.    Example 3:  Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.    Constraints:  1 <= n <= 10^4 distance.length == n 0 <= start, destination < n 0 <= distance[i] <= 10^4
__label__Hash-Table __label__Two-Pointers __label__Binary-Search Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note:  Each element in the result must be unique. The result can be in any order.
__label__Search __label__Dynamic-Programming __label__Strings Consider a string, , of  lowercase English letters where each character,  (, denotes the letter at index  in . We define an  palindromic tuple of  to be a sequence of indices in  satisfying the following criteria: , meaning the characters located at indices  and  are the same. , meaning the characters located at indices  and  are the same. , meaning that , , , and  are ascending in value and are valid indices within string . Given , find and print the number of  tuples satisfying the above conditions. As this value can be quite large, print it modulo . Input Format A single string denoting .  Constraints  It is guaranteed that  only contains lowercase English letters. Output Format Print the the number of  tuples satisfying the conditions in the Problem Statement above. As this number can be very large, your answer must be modulo . Sample Input 0 kkkkkkz  Sample Output 0 15  Explanation 0 The letter z will not be part of a valid tuple because you need at least two of the same character to satisfy the conditions defined above. Because all tuples consisting of four k's are valid, we just need to find the number of ways that we can choose four of the six k's. This means our answer is . z k k Sample Input 1 ghhggh  Sample Output 1 4  Explanation 1 The valid tuples are:     Thus, our answer is . Sample Input 0 Sample Output 0 Sample Input 1 Sample Output 1 Sample Input 2 Sample Output 2 Explanation 2 Tuples possible are
__label__Strings You have an array of logs.  Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier.  Then, either:  Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order. Return the final order of the logs.   Example 1: Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"] Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]    Constraints:  0 <= logs.length <= 100 3 <= logs[i].length <= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier.
__label__Two-Pointers Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.    Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.     Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.     Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.      Follow up: Can you solve it using O(1) (i.e. constant) memory?
__label__Strings Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: "Let's take LeetCode contest" Output: "s'teL ekat edoCteeL tsetnoc"   Note: In the string, each word is separated by single space and there will not be any extra space in the string.
__label__Strings Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.   IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;   Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.   IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).   However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.   Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.  Note: You may assume there is no extra space or special characters in the input string.  Example 1: Input: "172.16.254.1"  Output: "IPv4"  Explanation: This is a valid IPv4 address, return "IPv4".   Example 2: Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"  Output: "IPv6"  Explanation: This is a valid IPv6 address, return "IPv6".   Example 3: Input: "256.256.256.256"  Output: "Neither"  Explanation: This is neither a IPv4 address nor a IPv6 address.
__label__Tree Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input:  	Tree 1                     Tree 2                             1                         2                                       / \                       / \                                     3   2                     1   3                                /                           \   \                             5                             4   7                   Output:  Merged tree: 	     3 	    / \ 	   4   5 	  / \   \  	 5   4   7    Note: The merging process must start from the root nodes of both trees.
__label__Array __label__Mathematics Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2  Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8  Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
__label__Binary-Search Let's call an array A a mountain if the following properties hold:  A.length >= 3 There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]  Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1   Example 2: Input: [0,2,1,0] Output: 1  Note:  3 <= A.length <= 10000 0 <= A[i] <= 10^6 A is a mountain, as defined above.
__label__Array Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition.   Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.    Note:  2 <= A.length <= 20000 A.length % 2 == 0 0 <= A[i] <= 1000
__label__Tree Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [3,2,1]  Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Dynamic-Programming In a N x N grid representing a field of cherries, each cell is one of three possible integers.    0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.    Your task is to collect maximum number of cherries possible by following the rules below:    Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.      Example 1: Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.    Note:  grid is an N by N 2D array, with 1 <= N <= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.
__label__Mathematics Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000
__label__Data-Structures A bracket is considered to be any one of the following characters: (, ), {, }, [, or ].  ( ) { } [ ] Two brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and (). ( [ { ) ] } [] {} () A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ]. {[(])} { } ( ] By this logic, we say a sequence of brackets is balanced if the following conditions are met: It contains no unmatched brackets. The subset of brackets enclosed within the confines of a matched pair of brackets  is also a matched pair of brackets. Given  strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return YES.  Otherwise, return NO.   YES NO Function Description  Complete the function isBalanced in the editor below.  It must return a string: YES if the sequence is balanced or NO if it is not.   YES NO isBalanced has the following parameter(s): s: a string of brackets Input Format The first line contains a single integer , the number of strings.  Each of the next  lines contains a single string , a sequence of brackets. Constraints   , where  is the length of the sequence.   All chracters in the sequences ∈ { {, }, (, ), [, ] }. Output Format For each string, return YES or NO. YES NO Sample Input 3 {[()]} {[(])} {{[[(())]]}}  Sample Output YES NO YES  Explanation The string {[()]} meets both criteria for being a balanced string, so we print YES on a new line.     {[()]} YES The string {[(])} is not balanced because the brackets enclosed by the matched pair { and } are not balanced: [(]).       {[(])} { } [(]) The string {{[[(())]]}} meets both criteria for being a balanced string, so we print YES on a new line.   {{[[(())]]}} YES
__label__Graph-Algorithms The mayor of Farzville is studying the city's road system to find ways of improving its traffic conditions. Farzville's road system consists of  junctions connected by  bidirectional toll roads, where the  toll road connects junctions  and . In addition, some junctions may not be reachable from others and there may be multiple roads connecting the same pair of junctions.    Each toll road has a toll rate that's paid each time it's used. This rate varies depending on the direction of travel:   If traveling from  to , then the toll rate is .  If traveling from  to , then the toll rate is . It is guaranteed that .    For each digit , the mayor wants to find the number of ordered pairs of  junctions such that  and a path exists from  to  where the total cost of the tolls (i.e., the sum of all toll rates on the path) ends in digit . Given a map of Farzville, can you help the mayor answer this question? For each digit  from  to , print the the number of valid ordered pairs on a new line. Note: Each toll road can be traversed an unlimited number of times in either direction.  Input Format The first line contains two space-separated integers describing the respective values of  (the number of junctions) and  (the number of roads).  Each line  of the  subsequent lines describes a toll road in the form of three space-separated integers, , , and .   Constraints           Output Format Print ten lines of output. Each line  (where ) must contain a single integer denoting the answer for . For example, the first line must contain the answer for , the second line must contain the answer for , and so on. Sample Input 0 Sample Output 0 Explanation 0 The table below depicts the distinct pairs of junctions for each :     Note the following: There may be multiple paths between each pair of junctions.  Junctions and roads may be traversed multiple times. For example, the path  is also valid, and it has total cost of .  An ordered pair can be counted for more than one . For example, the pair  is counted for  and . Each ordered pair must only be counted once for each . For example, the paths  and  both have total costs that end in , but the pair  is only counted once.
__label__Tree __label__Depth-first-Search Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree:       We should return its max depth, which is 3.   Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.
__label__Dynamic-Programming In this problem, we'll use the term "longest common substring" loosely.  It refers to substrings differing at some number or fewer characters when compared index by index.  For example, 'abc' and 'adc' differ in one position, 'aab' and 'aba' differ in two.   Given two strings and an integer , determine the length of the longest common substrings of the two strings that differ in no more than  positions.   For example, .  Strings  and .  Check to see if the whole string (the longest substrings) matches.  Given that neither the first nor last characters match and , we need to try shorter substrings.  The next longest substrings are  and .  Two pairs of these substrings only differ in  position:  and .  They are of length .   Function Description Complete the substringDiff function in the editor below.  It should return an integer that represents the length of the longest common substring as defined.   substringDiff has the following parameter(s):   k: an integer that represents the maximum number of differing characters in a matching pair   s1: the first string   s2: the second string   Input Format The first line of input contains a single integer, , the number of test cases follow.  Each of the next  lines contains three space-separated values:  an integer  and two strings,  and . Constraints        All characters in  and . Output Format For each test case, output a single integer which is the length of the maximum length common substrings differing at  or fewer positions. Sample Input Sample Output Explanation First test case: If we take "briz" from the first string, and "orin" from the second string, then the number of mismatches between these two substrings is equal to 2 and their lengths are . First test case: If we take "briz" from the first string, and "orin" from the second string, then the number of mismatches between these two substrings is equal to 2 and their lengths are . Second test case: Since , we should find the longest common substring, standard definition, for the given input strings. We choose "aba" as the result. Second test case: Since , we should find the longest common substring, standard definition, for the given input strings. We choose "aba" as the result. Third test case: We can choose "hellowor" from first string and "yellomar" from the second string.   Third test case: We can choose "hellowor" from first string and "yellomar" from the second string.
__label__Array Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.  Example 1: Input: [1,4,3,2]  Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).   Note:  n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].
__label__Search You will be given an array of integers and a target value.  Determine the number of pairs of array elements that have a difference equal to a target value.   For example, given an array of [1, 2, 3, 4] and a target value of 1, we have three values meeting the condition: , , and . Function Description Complete the pairs function below.  It must return an integer representing the number of element pairs having the required difference. pairs has the following parameter(s): k: an integer, the target difference arr: an array of integers Input Format The first line contains two space-separated integers  and , the size of  and the target value.  The second line contains  space-separated integers of the array . Constraints       each integer  will be unique Output Format An integer representing the number of pairs of integers whose difference is .   Sample Input 5 2   1 5 3 4 2    Sample Output 3  Explanation There are 3 pairs of integers in the set with a difference of 2: [5,3], [4,2] and [3,1] .
__label__Mathematics __label__Strings Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: "III" Example 2: Input: 4 Output: "IV" Example 3: Input: 9 Output: "IX" Example 4: Input: 58 Output: "LVIII" Explanation: L = 50, V = 5, III = 3.  Example 5: Input: 1994 Output: "MCMXCIV" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
__label__Greedy-Algorithms N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1:Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.  Example 2:Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.   Note:   len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1.
__label__Dynamic-Programming __label__Graph-Algorithms There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things: The minimum number of turns (T) needed to remove all the points. The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn. Input Format The first line contains the number of test cases T. T test cases follow. Each test case contains N on the first line, followed by N lines giving the coordinates of the points. Constraints 1 <= T <= 50  1 <= N <= 16  0 <= xi,yi <= 100  No two points will have the same coordinates. Output Format Output T lines, one for each test case, containing the least number of turns needed to remove all points and the number of ways to do so. As the answers can be large, output them modulo 1000000007. Sample Input 2   3   0 0   0 1   1 0   4   3 4   3 5   3 6   5 5  Sample Output 2 6   2 8  Explanation For the 1st input, Let the points be labelled p1,p2,p3. These are the ways to remove them (first turn's points, followed by second turn's points): a. 1) p1,p2 2) p3  b. 1) p1,p3 2) p2  c. 1) p2,p3 2) p1  d. 1) p3 2) p1,p2  e. 1) p2 2) p1,p3  f. 1) p1 2) p3,p2
__label__Game-Theory __label__Game-Theory Two HackerRank staffers found a secret room with a mysterious  square board and decided to play a game with it. The game has the following rules: At the beginning of the game, the players write a single digit (given as input) ranging from  to  in each  cell composing the  square board.  The players move in alternating turns. In each move, the current player performs the following actions: Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions ).  Cuts the chosen board into  smaller boards by breaking it along any horizontal or vertical line at the edge of a cell. Note: Although the game starts with one  board, that board is split in two during each move. At the beginning of the  move, a player can choose any one of the  pieces of the original board (as long as it can have a legal move performed on it). The players move in alternating turns. In each move, the current player performs the following actions: Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions ).  Cuts the chosen board into  smaller boards by breaking it along any horizontal or vertical line at the edge of a cell. Note: Although the game starts with one  board, that board is split in two during each move. At the beginning of the  move, a player can choose any one of the  pieces of the original board (as long as it can have a legal move performed on it). The game ends when there are no more cuttable boards (i.e., there are  boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses. The game ends when there are no more cuttable boards (i.e., there are  boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses. Given the value of  and the respective numbers written in each  cell of the board, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Time Limit Python: 18 seconds Pypy2: 5 seconds For other languages, the time limit is standard. Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is defined as follows over the subsequent lines: An integer, , denoting the length of each of the board's sides. Each line  of the  subsequent lines contains  space-separated integers describing , where each  describes the number written in cell  of the board. Constraints    Output Format For each test case, print the name of the player with the winning strategy on a new line (i.e., either  or ). Sample Input 2 3 2 7 5 2 7 5 7 7 7 2 4 3 1 2  Sample Output Second First  Explanation We'll refer to the two players as  and . Test Case 0:  All cells contain prime numbers, so there are no valid moves available to . As  wins by default, we print  on a new line. Test Case 1:  In this test case, the two players perform the following sequence of moves:  makes a horizontal cut, splitting the board into two  boards. This is demonstrated in the following diagram:   makes a horizontal cut, splitting the board into two  boards. This is demonstrated in the following diagram:   now chooses one of the two  rectangles and cuts it vertically, splitting it into two  squares.       now chooses one of the two  rectangles and cuts it vertically, splitting it into two  squares.       chooses remaining  rectangle and cuts it vertically, splitting it into two  squares.  After the above  moves take place, the board is split into four  squares and no more moves are available for  to make. Thus,  wins and we print  on a new line.
__label__Array Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [   ['A','B','C','E'],   ['S','F','C','S'],   ['A','D','E','E'] ]  Given word = "ABCCED", return true. Given word = "SEE", return true. Given word = "ABCB", return false.
__label__Tree __label__Depth-first-Search Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.   Note:  Both of the given trees will have between 1 and 100 nodes.
__label__Dynamic-Programming __label__Mathematics Tara has an array, , consisting of  integers where each integer occurs at most  times in the array.  Let's define  to be a permutation of  where  is the  element of permutation . Tara thinks a permutation is beautiful if there is no index  such that  where . You are given  queries where each query consists of some array . For each , help Tara count the number of possible beautiful permutations of the  integers in  and print the count, modulo , on a new line. Note: Two permutations,  and , are considered to be different if and only if there exists an index  such that  and . Input Format The first line contains a single integer, , denoting the number of queries. The  subsequent lines describe each query in the following form: The first line contains an integer, , denoting the number of elements in array .  The second line contains  space-separated integers describing the respective values of  in array . Constraints  Each integer in  can occur at most  times. For  of the maximum score:     The sum of  over all queries does not exceed .   For  of the maximum score:      Output Format For each query, print the the number of possible beautiful permutations, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 We perform the following  queries: Array  and there is only one good permutation:    Thus, we print the result of  on a new line. Array  and there is only one good permutation:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    Thus, we print the result of  on a new line. Array  and there are two good permutations:    For demonstration purposes, the following two permutations are invalid (i.e., not good):    Because we only want the number of good permutations, we print the result of  on a new line. Array  and there are two good permutations:    For demonstration purposes, the following two permutations are invalid (i.e., not good):    Because we only want the number of good permutations, we print the result of  on a new line.
__label__Dynamic-Programming __label__Graph-Algorithms Nikita is making a graph as a birthday gift for her boyfriend, a fellow programmer! She drew an undirected connected graph with  nodes numbered from  to  in her notebook. Each node is shaded in either white or black. We define  to be the number of white nodes, and  to be the number of black nodes. The graph is drawn in such a way that: No  adjacent nodes have same coloring. The value of , which we'll call , is minimal. Nikita's mischievous little brother erased some of the edges and all of the coloring from her graph! As a result, the graph is now decomposed into one or more components. Because you're her best friend, you've decided to help her reconstruct the graph by adding  edges such that the aforementioned graph properties hold true. Given the decomposed graph, construct and shade a valid connected graph such that the difference  between its shaded nodes is minimal. Input Format The first line contains  space-separated integers,  (the number of nodes in the original graph) and  (the number of edges in the decomposed graph), respectively.  The  subsequent lines each contain  space-separated integers,  and , describing a bidirectional edge between nodes  and  in the decomposed graph. Constraints   It is guaranteed that every edge will be between  distinct nodes, and there will never be more than  edge between any  nodes. Your answer must meet the following criteria: The graph is connected and no  adjacent nodes have the same coloring. The value of  is minimal.  The graph is connected and no  adjacent nodes have the same coloring. The value of  is minimal.  Output Format You must have  lines of output.  The first line contains  space-separated integers:  (the minimum possible value of ) and  (the number of edges you've added to the graph), respectively.  Each of the  subsequent lines contains  space-separated integers,  and , describing a newly-added bidirectional edge in your final graph (i.e.: new edge ).  You may print any  of the possible reconstructions of Nikita's graph such that the value of  in the reconstructed shaded graph is minimal. Sample Input 0  8 8  1 2  2 3  3 4  4 1  1 5  2 6  3 7  4 8  Sample output 0 0 0  Sample Input 1  8 6  1 2  3 4  3 5  3 6  3 7  3 8  Sample Output 1 4 1 1 5  Sample Input 2  5 4  1 2  2 3  3 4  4 1  Sample Output 2   1 2   2 5   4 5  Explanation In the figure below, the solid lines show the decomposed graph after Nikita's brother erased the edges, and the dotted lines show one possible correct answer:  In Sample , no additional edges are added and . Because  and , we get . Thus, we print  on a new line (there is only  line of output, as ). In Sample , the only edge added is , so . Here,  and , so . Thus, we print  on the first line. Next, we must print  lines describing each edge added; because , we print a single line describing the  space-separated nodes connected by our new edge: . In Sample , we can either add  edge  or , or both of them. In both cases we get  and , so . Thus  and  or  both are correct.
__label__Game-Theory Kitty and Katty have  plastic blocks. They label the blocks with sequential numbers from  to  and begin playing a game in turns, with Kitty always taking the first turn. The game's rules are as follows: For each turn, the player removes  blocks,  and , from the set. They calculate , write the result on a new block, and insert the new block into the set.  The game ends when only  block is left. The winner is determined by the value written on the final block, : If , then Kitty wins. If , then Katty wins. If , then the player who moved last wins. If , then Kitty wins. If , then Katty wins. If , then the player who moved last wins. Recall that  is the Modulo Operation. Given the value of , can you find and print the name of the winner? Assume that both play optimally. Note: The selection order for  and  matters, as sometimes . The diagram below shows an initial set of blocks where . If  and , then the newly inserted block is labeled ; alternatively, if  and , the newly inserted block is labeled .  Input Format The first line contains a single positive integer,  (the number of test cases or games).  The  subsequent lines each contain an integer,  (the number of blocks for that test case). Constraints    Output Format For each test case, print the name of the winner (i.e.: either Kitty or Katty) on a new line. Sample Input 2 2 3  Sample Output Kitty Katty  Explanation Test Case 0:   so there are two blocks labeled  and . Kitty chooses  and , then inserts a new block with  the label  (the result of ). The game ends, as there is now only  block in the set. The label on the last block, , is , so we calculate . Because  , Kitty wins and we print Kitty on a new line. Kitty Test Case 1:  , so there are three blocks labeled , , and . No matter how Kitty makes the first move, Katty will win. If Kitty chooses  and  on the first move and inserts a block labeled  (the result of ), the set of blocks becomes . Katty then must choose  and  and insert a new block labeled  (the result of ). The game ends, as there is now only  block in the set. The label on the last block, , is , so we calculate . Because  and Katty made the last move, Katty wins and we print Katty on a new line. Katty
__label__Hash-Table __label__Binary-Search Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
__label__Search You are given a number of sticks of varying lengths.  You will iteratively cut the sticks into smaller sticks, discarding the shortest pieces until there are none left.  At each iteration you will determine the length of the shortest stick remaining, cut that length from each of the longer sticks and then discard all the pieces of that shortest length.  When all the remaining sticks are the same length, they cannot be shortened so discard them. Given the lengths of  sticks, print the number of sticks that are left before each iteration until there are none left. For example, there are  sticks of lengths .  The shortest stick length is , so we cut that length from the longer two and discard the pieces of length .  Now our lengths are .  Again, the shortest stick is of length , so we cut that amount from the longer stick and discard those pieces.  There is only one stick left, , so we discard that stick.  Our lengths are .   Function Description  Complete the cutTheSticks function in the editor below.  It should return an array of integers representing the number of sticks before each cut operation is performed.   cutTheSticks has the following parameter(s):   arr: an array of integers representing the length of each stick   Input Format  The first line contains a single integer , the size of .  The next line contains  space-separated integers, each an  where each value represents the length of the  stick. Output Format  For each operation, print the number of sticks that are present before the operation on separate lines.   Constraints    Sample Input 0 6 5 4 4 2 2 8  Sample Output 0 6 4 2 1  Explanation 0 Sample Input 1 8 1 2 3 4 3 3 2 1  Sample Output 1 8 6 4 1  Explanation 1
__label__Mathematics Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:     1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...  Example 1: Input: 1 Output: "A"  Example 2: Input: 28 Output: "AB"  Example 3: Input: 701 Output: "ZY"
__label__Mathematics Find the smallest prime palindrome greater than or equal to N. Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.  For example, 2,3,5,7,11 and 13 are primes. Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.  For example, 12321 is a palindrome.    Example 1: Input: 6 Output: 7   Example 2: Input: 8 Output: 11   Example 3: Input: 13 Output: 101      Note:  1 <= N <= 10^8 The answer is guaranteed to exist and be less than 2 * 10^8.
__label__Hash-Table With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:  word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. 	For example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage"; while invalid words are "beefed" (doesn't include "a") and "based" (includes "s" which isn't in the puzzle).  Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i].   Example : Input:  words = ["aaaa","asas","able","ability","actt","actor","access"],  puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for "aboveyz" : "aaaa"  1 valid word for "abrodyz" : "aaaa" 3 valid words for "abslute" : "aaaa", "asas", "able" 2 valid words for "absoryz" : "aaaa", "asas" 4 valid words for "actresz" : "aaaa", "asas", "actt", "access" There're no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.    Constraints:  1 <= words.length <= 10^5 4 <= words[i].length <= 50 1 <= puzzles.length <= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] are English lowercase letters. Each puzzles[i] doesn't contain repeated characters.
__label__Mathematics Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
__label__Dynamic-Programming There are N users registered on a website CuteKittens.com. Each of them has a unique password represented by pass[1], pass[2], ..., pass[N]. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin does not want the site to be available to the general public, so only those people who have passwords can access it. Yu, being an awesome hacker finds a loophole in the password verification system. A string which is a concatenation of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear  or more times in that string. Given access to each of the  passwords, and also have a string loginAttempt$ string can be created by concatenating password strings, it is accepted. For example, if there are 3 users with , then some of the valid combinations are abra , kaabra , kadabraka , kadabraabra  and so on.  Supplying abra ka dabra, concatenated, passes authentication. abra kaabra kadabraka kadabraabra abra ka dabra Function Description Complete the passwordCracker function in the editor below.  It should return the passwords as a single string in the order required for the password to be accepted, each separated by a space. If it is not possible to form the string, return the string WRONG PASSWORD.   WRONG PASSWORD passwordCracker has the following parameters:  - passwords: a list of password strings  - loginAttempt: the string to attempt to create   Input Format The first line contains an integer t, the total number of test cases.   Each of the next  sets of three lines is as follows:  - The first line of each test case contains n, the number of users with passwords.  - The second line contains n space-separated strings, passwords[i], that represent  the passwords of each user.  - The third line contains a string, loginAttempt, which Yu must test for acceptance.   Constraints       , where     loginAttempt and passwords[i] contain only lowercase latin characters ('a'-'z'). Output Format For each valid string, Yu has to print the actual order of passwords, separated by space, whose concatenation results into loginAttempt. If there are multiple solutions, print any of them.  If loginAttempt can't be accepted by the password verification system, then print WRONG PASSWORD. WRONG PASSWORD Sample Input 0 Sample Output 0 Explanation 0 Sample Case #00: "wedowhatwemustbecausewecan" is the concatenation of passwords {"we", "do", "what", "we", "must", "because", "we", "can"}. That is  "wedowhatwemustbecausewecan" "we" "do" "what" "we" "must" "because" "we" "can" loginAttempt = pass[5] + pass[3] + pass[6] + pass[5] +  pass[4] + pass[1] + pass[5] + pass[2]  Note that any password can repeat any number of times.   Sample Case #01: We can't create string "helloworld" using the strings {"hello", "planet"}.   "helloworld" "hello" "planet" Sample Case #02: There are two ways to create loginAttempt ("abcd"). Both pass[2] = "abcd" and pass[1] + pass[3] = "ab cd" are valid answers. "abcd" pass[2] = "abcd" pass[1] + pass[3] = "ab cd" Sample Input 1 Sample Output 1
__label__Dynamic-Programming __label__Strings We define a function, , on a string, , as follows:   where:  denotes the number of characters in string .  denotes the number of distinct characters in string . Consuela loves creating string challenges and she needs your help testing her newest one! Given a string, , consisting of  lowercase letters, compute the summation of function  (provided above) over all possible distinct substrings of . As the result is quite large, print it modulo . Input Format The first line contains a single integer, , denoting the number of test cases.  Each of the  subsequent lines contains a string, . Constraints     The sum of  over all test cases does not exceed . Scoring  for  of test data.  for  of test data.    for  of test data. Output Format For each test case, print the answer modulo . Sample Input 3 aa aba abc  Sample Output 3 19 38  Explanation Test 0:  and  are the only distinct substrings.     Test 1: , , , , and  are the only distinct substrings.
__label__Two-Pointers Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7.   Example 1: Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation:  Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.   Example 2: Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation:  A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways.     Note:  3 <= A.length <= 3000 0 <= A[i] <= 100 0 <= target <= 300
__label__Dynamic-Programming Given an array A of integers, return the length of the longest arithmetic subsequence in A. Recall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).   Example 1: Input: [3,6,9,12] Output: 4 Explanation:  The whole array is an arithmetic sequence with steps of length = 3.   Example 2: Input: [9,4,7,2,10] Output: 3 Explanation:  The longest arithmetic subsequence is [4,7,10].   Example 3: Input: [20,1,15,3,10,5,8] Output: 4 Explanation:  The longest arithmetic subsequence is [20,15,10,5].     Note:  2 <= A.length <= 2000 0 <= A[i] <= 10000
__label__Strings Steve has a string of lowercase characters in range ascii[‘a’..’z’].  He wants to reduce the string to its shortest length by doing a series of operations.  In each operation he selects a pair of adjacent lowercase letters that match, and he deletes them.  For instance, the string aab could be shortened to b in one operation.   ascii[‘a’..’z’] aab b Steve’s task is to delete as many characters as possible using this method and print the resulting string.  If the final string is empty, print Empty String Empty String Function Description Complete the superReducedString function in the editor below.  It should return the super reduced string or Empty String if the final string is empty.   Empty String superReducedString has the following parameter(s):   s: a string to reduce   Input Format A single string, . Constraints  Output Format If the final string is empty, print Empty String; otherwise, print the final non-reducible string. Empty String Sample Input 0 Sample Output 0 Explanation 0 Steve performs the following sequence of operations to get the final string: aaabccddd → abccddd → abddd → abd  Sample Input 1 Sample Output 1 Explanation 1 aa → Empty String  Sample Input 2 Sample Output 2 Explanation 2 baab → bb → Empty String
__label__Greedy-Algorithms Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending.  Determine if the columns are also in ascending alphabetical order, top to bottom.  Return YES if they are or NO if they are not. YES NO For example, given: a b c a d e e f g  The rows are already in alphabetical order.  The columns a a e, b d f and c e g are also in alphabetical order, so the answer would be YES.  Only elements within the same row can be rearranged.  They cannot be moved to a different row. a a e b d f c e g YES Function Description  Complete the gridChallenge function in the editor below.  It should return a string, either YES or NO.   YES NO gridChallenge has the following parameter(s):   grid: an array of strings   Input Format The first line contains , the number of testcases.    Each of the next  sets of lines are described as follows:  - The first line contains , the number of rows and columns in the grid.  - The next  lines contains a string of length  Constraints     Each string consists of lowercase letters in the range ascii[a-z]  Output Format For each test case, on a separate line print YES if it is possible to rearrange the grid alphabetically ascending in both its rows and columns, or NO otherwise. YES NO Sample Input 1 5 ebacd fghij olmkn trpqs xywuv  Sample Output YES  Explanation The x grid in the  test case can be reordered to  abcde fghij klmno pqrst uvwxy  This fulfills the condition since the rows 1, 2, ..., 5 and the columns 1, 2, ..., 5 are all lexicographically sorted.
__label__Bit Understanding 's complement representation is fundamental to learning about Computer Science. It allows us to write negative numbers in binary.  The leftmost digit is used as a sign bit.  If it is , we have a negative number and it is represented as the two's complement of its absolute value.  Let's say you wrote down the 's complement representation for each -bit integer in the inclusive range from  to .  How many 's would you write down in all?   For example, using an -bit byte rather than  bit integer, the two's complement of a number can be found by reversing all its bits and adding .  The two's complement representations for a few numbers are shown below:           |Number|                Representation in Number   Binary     Inverse     Two's Complement -3      00000011    11111100    11111101 -2      00000010    11111101    11111110 -1      00000001    11111110    11111111  0      00000000                00000000  1      00000001                00000001  2      00000010                00000010  3      00000011                00000011  To write down that range of numbers' two's complements in  bits, we wrote 's.  Remember to use  bits rather than  in your solution.  The logic is the same, so the  bit representation was chosen to reduce apparent complexity in the example.   Function Description  Complete the twosCompliment function in the editor below.  It should return an integer.   twosCompliment has the following parameter(s):  - a: an integer, the range minimum  - b: an integer, the range maximum   Input Format The first line contains an integer , the number of test cases.    Each of the next  lines contains two space-separated integers,  and .   Constraints   Output Format For each test case, print the number of 's in the -bit 's complement representation for integers in the inclusive range from  to  on a new line. Sample Input 0 Sample Output 0 Explanation 0 Test case 0  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  31+32+0 = 63  Test case 1  -3 has 31 ones  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  31+31+32+0+1+1+2+1 = 99  Test case 2  -1 has 32 ones  0 has 0 ones  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  32+0+1+1+2+1 = 37   Sample Input 1 Sample Output 1 Explanation 1 Test case 0  -5 has 31 ones  -4 has 30 ones  -3 has 31 ones  -2 has 31 ones  -1 has 32 ones  0 has 0 ones  31+30+31+31+32+0 = 155  Test case 1  1 has 1 ones  2 has 1 ones  3 has 2 ones  4 has 1 ones  5 has 2 ones  6 has 2 ones  7 has 3 ones  1+1+2+1+2+2+3 = 12  Test case 2  -6 has 30 ones  -5 has 31 ones  -4 has 30 ones  -3 has 31 ones  30+31+30+31 = 122  Test case 3  3 has 2 ones  4 has 1 ones  5 has 2 ones  6 has 2 ones  2+1+2+2 = 7
__label__Strings __label__Data-Structures Consider an array of numeric strings where each string is a positive number with anywhere from  to  digits. Sort the array's elements in non-decreasing, or ascending order of their integer values and print each element of the sorted array on a new line. Function Description  Complete the bigSorting function in the editor below.  It should return the sorted string array.   bigSorting has the following parameter(s):   unsorted: an unsorted array of integers as strings   Input Format The first line contains an integer, , denoting the number of strings in .  Each of the  subsequent lines contains an integer string . Constraints  Each string is guaranteed to represent a positive integer without leading zeros. The total number of digits across all strings in  is between  and  (inclusive). Output Format Print each element of the sorted array on a new line. Sample Input 0 Sample Output 0 Explanation 0 The initial array of strings is . When we order each string by the real-world integer value it represents, we get:   We then print each value on a new line, from smallest to largest. Sample Input 1 Sample Output 1
__label__Array __label__Two-Pointers Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.  The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6
__label__Graph-Algorithms There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the ith problem has estimated difficulty level i. You have also assigned a rating vi to each problem. Problems with similar vi values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their vi rating by at least K. What is the least number of days in which you can solve all problems? Input Format The first line contains the number of test cases T. T test cases follow. Each case contains an integer N and K on the first line, followed by integers v1,...,vn on the second line. Constraints 1 <= T <= 100  1 <= N <= 300  1 <= vi <= 1000  1 <= K <= 1000 Output Format Output T lines, one for each test case, containing the minimum number of days in which all problems can be solved. Sample Input 2   3 2   5 4 7   5 1   5 3 4 5 6  Sample Output 2   1  Explanation For the first example, you can solve the problems with rating 5 and 7 on the first day and the problem with rating 4 on the next day. Note that the problems with rating 5 and 4 cannot be completed consecutively because the ratings should differ by at least K (which is 2). Also, the problems cannot be completed in order 5,7,4 in one day because the problems solved on a day should be in increasing difficulty level. For the second example, all problems can be solved on the same day.
__label__Array In a list of songs, the i-th song has a duration of time[i] seconds.  Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i < j with (time[i] + time[j]) % 60 == 0.   Example 1: Input: [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60   Example 2: Input: [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60.     Note:  1 <= time.length <= 60000 1 <= time[i] <= 500
__label__Strings Compare two version numbers version1 and version2. If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.   Example 1: Input: version1 = "0.1", version2 = "1.1" Output: -1 Example 2: Input: version1 = "1.0.1", version2 = "1" Output: 1 Example 3: Input: version1 = "7.5.2.4", version2 = "7.5.3" Output: -1 Example 4: Input: version1 = "1.01", version2 = "1.001" Output: 0 Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1” Example 5: Input: version1 = "1.0", version2 = "1.0.0" Output: 0 Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"   Note:  Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes.  Version strings do not start or end with dots, and they will not be two consecutive dots.
__label__Dynamic-Programming __label__Mathematics A company needs random numbers for its operation.  random numbers have been generated using  numbers as seeds and the following recurrence formula:   The numbers used as seeds are .  is the  term of the recurrence. Due to a failure on the servers, the company lost its seed numbers. Now they just have the recurrence formula and the previously generated  random numbers. The company wants to recover the numbers used as seeds, so they have hired you for doing this task. Input Format The first line contains two space-separated integers,  and , respectively.  The second line contains the space-separated integers describing  (all these numbers are non-negative integers ).  The third line contains the space-separated coefficients of the recurrence formula, . All of these coefficients are positive integers . Constraints    Output Format The output must be one line containing the space-separated seeds of the random numbers - . Sample Input 2 6 13 8 1 1  Sample Output 1 1   Explanation This is the classic Fibonacci recurrence. We have the  and  terms, and, of course, the seeds are the numbers  and .
__label__Strings This challenge uses the famous KMP algorithm. It isn't really important to understand how KMP works, but you should understand what it calculates. A KMP algorithm takes a string, , of length  as input. Let's assume that the characters in  are indexed from  to ; for every prefix of , the algorithm calculates the length of its longest valid border in linear complexity. In other words, for every  (where ) it calculates the largest  (where ) such that for every  (where ) there is . Here is an implementation example of KMP: Given a sequence , construct a string, , that meets the following conditions: The frequency of letter '' in  is exactly , the frequency of letter '' in  is exactly , and so on. Let's assume characters of  are numbered from  to , where . We apply the KMP algorithm to  and get a table, , of size . You must ensure that the sum of  for all  is minimal. If there are multiple strings which fulfill the above conditions, print the lexicographically smallest one. Input Format A single line containing  space-separated integers describing sequence .  Constraints The sum of all  will be a positive integer . Output Format Print a single string denoting . Sample Input 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  Sample Output aabb  Explanation The output string must have two '' and two ''. There are several such strings but we must ensure that sum of  for all  is minimal. See the figure below:  The minimum sum is . Among all the strings that satisfy both the condition, "aabb" is the lexicographically smallest.
__label__Binary-Search __label__Dynamic-Programming table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.   Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.    -2 (K) -3 3   -5 -10 1   10 30 -5 (P)      Note:  The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty. Input Format You have to complete the SinglyLinkedListNode insertAtTail(SinglyLinkedListNode head, int data) method. It takes two arguments: the head of the linked list and the integer to insert at tail. You should not read any input from the stdin/console. SinglyLinkedListNode insertAtTail(SinglyLinkedListNode head, int data) The input is handled by code editor and is as follows:  The first line contains an integer , denoting the elements of the linked list.  The next  lines contain an integer each, denoting the element that needs to be inserted at tail.   Constraints     Output Format Insert the new node at the tail and just return the head of the updated linked list. Do not print anything to stdout/console. return The output is handled by code in the editor and is as follows:  Print the elements of the linked list from head to tail, each in a new line. Sample Input 5 141 302 164 530 474  Sample Output 141 302 164 530 474  Explanation First the linked list is NULL. After inserting 141, the list is 141 -> NULL.  After inserting 302, the list is 141 -> 302 -> NULL.  After inserting 164, the list is 141 -> 302 -> 164 -> NULL.  After inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.
__label__Array In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition. You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately. Example 1: Input: [1,4], 2 Output: 4 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately.  This poisoned status will last 2 seconds until the end of time point 2.  And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds.  So you finally need to output 4.    Example 2: Input: [1,2], 2 Output: 3 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned.  This poisoned status will last 2 seconds until the end of time point 2.  However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.  Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3.  So you finally need to output 3.    Note:  You may assume the length of given time series array won't exceed 10000. You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.
__label__Tree Invert a binary tree. Example: Input:      4    /   \   2     7  / \   / \ 1   3 6   9 Output:      4    /   \   7     2  / \   / \ 9   6 3   1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.
__label__Greedy-Algorithms There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.  Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.              The third child gets 1 candy because it satisfies the above two conditions.
__label__Tree __label__Depth-first-Search Given a rooted binary tree, return the lowest common ancestor of its deepest leaves. Recall that:  The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1. The lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.    Example 1: Input: root = [1,2,3] Output: [1,2,3] Explanation:  The deepest leaves are the nodes with values 2 and 3. The lowest common ancestor of these leaves is the node with value 1. The answer returned is a TreeNode object (not an array) with serialization "[1,2,3]".  Example 2: Input: root = [1,2,3,4] Output: [4]  Example 3: Input: root = [1,2,3,4,5] Output: [2,4,5]    Constraints:  The given tree will have between 1 and 1000 nodes. Each node of the tree will have a distinct value between 1 and 1000.
__label__Mathematics __label__Game-Theory __label__Game-Theory After their success in coming up with Fun Game, Kyle and Mike invented another game having the following rules: The game starts with an -element sequence, , and is played by two players,  and .  The players move in alternating turns, with  always moving first. During each move, the current player chooses one of the asterisks () in the above sequence and changes it to either a + (plus) or a - (minus) sign.   + - The game ends when there are no more asterisks () in the expression. If the evaluated value of the sequence is divisible by , then  wins; otherwise,  wins. Given the value of , can you determine the outcome of the game? Print  if  will win, or  if  will win. Assume both players always move optimally. Input Format The first line of input contains a single integer , denoting the number of test cases. Each line  of the  subsequent lines contains an integer, , denoting the maximum exponent in the game's initial sequence. Constraints   Output Format For each test case, print either of the following predicted outcomes of the game on a new line: Print  if  will win. Print  if  will win. Sample Input 1 2    Sample Output First  Explanation In this case, it doesn't matter in which order the asterisks are chosen and altered. There are  different courses of action and, in each one, the final value is not divisible by  (so  always loses and we print  on a new line).  Possible options:
__label__Dynamic-Programming In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.  What if we change the game so that players cannot re-use integers?  For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.  You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.  Example Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.
__label__Hash-Table Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:   postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee.   Example: Twitter twitter = new Twitter();  // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5);  // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1);  // User 1 follows user 2. twitter.follow(1, 2);  // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1);  // User 1 unfollows user 2. twitter.unfollow(1, 2);  // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);
__label__Depth-first-Search You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.   Example: Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL    Explanation for the above example: Given the following multilevel doubly linked list:    We should return the following flattened doubly linked list:
__label__Array __label__Hash-Table Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.   Example: // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();
__label__Search Anna loves graph theory! She has a tree where each vertex is numbered from  to , and each contains a data value.   The sum of a tree is the sum of all its nodes' data values.  If she cuts an edge in her tree, she forms two smaller trees.  The difference between two trees is the absolute value between their sums.   Given a tree, determine which edge to cut so that the resulting trees have a minimal difference between them, then return that difference.   For example, your tree's nodes have weights of .  In this case, node numbers match their weights for convenience.  In the diagram below, you have the following edges: .    The values are calculated as follows:   Edge    Tree 1  Tree 2  Absolute Cut     Sum      Sum     Difference 1        8         13         5 2        9         12         3 3        6         15         9 4        4         17        13 5        5         16        11  The minimum absolute difference is . Note: The tree is always rooted at vertex .   Function Description  Complete the cutTheTree function in the editor below.  Return an integer that represents the minimal absolute difference achievable between the resultant two trees.   cutTheTree has the following parameter(s):   data: an array of integers that represent node values   edges: an 2 dimensional array of integer pairs where each pair represents an edge in the graph   Input Format The first line contains an integer , the number of vertices in the tree.  The second line contains  space-separated integers, where each integer  denotes the value of .  Each of the  subsequent lines contains two space-separated integers  and  describing edge  in tree .        Constraints   , where . Output Format A single line containing the minimum difference possible for tree . Sample Input 6 100 200 100 500 100 600 1 2 2 3 2 5 4 5 5 6  Sample Output 400  Explanation We can visualize the initial, uncut tree as:    There are  edges we can cut: Edge  results in   Edge  results in  Edge  results in   Edge  results in  Edge  results in  The minimum difference is .
__label__Dynamic-Programming Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order.   Example 1: Input: N = 3, K = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes.   Example 2: Input: N = 2, K = 1 Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]    Note:  1 <= N <= 9 0 <= K <= 9
__label__Hash-Table __label__Two-Pointers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A.   Example 1: Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].  Example 2: Input: A = [1,2,1,3,4], K = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].    Note:  1 <= A.length <= 20000 1 <= A[i] <= A.length 1 <= K <= A.length
__label__Dynamic-Programming Given an array nums of integers, you can perform operations on the array. In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1. You start with 0 points. Return the maximum number of points you can earn by applying such operations. Example 1: Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.    Example 2: Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.    Note:  The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000].
__label__Two-Pointers Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5
__label__Dynamic-Programming Alice plays the following game, loosely based on the card game "21". Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points? Example 1: Input: N = 10, K = 1, W = 10 Output: 1.00000 Explanation:  Alice gets a single card, then stops.  Example 2: Input: N = 6, K = 1, W = 10 Output: 0.60000 Explanation:  Alice gets a single card, then stops. In 6 out of W = 10 possibilities, she is at or below N = 6 points.  Example 3: Input: N = 21, K = 17, W = 10 Output: 0.73278 Note:  0 <= K <= N <= 10000 1 <= W <= 10000 Answers will be accepted as correct if they are within 10^-5 of the correct answer. The judging time limit has been reduced for this question.
__label__Bit Suppose that  is a list of  numbers  and  is a permutation of these numbers, we say B is K-Manipulative if and only if:  is not less than , where  represents the XOR operator. You are given . Find the largest  such that there exists a K-manipulative permutation . Input: The first line is an integer . The second line contains  space separated integers - .   Output:  The largest possible , or  if there is no solution. Constraints:      Sample Input 0 Sample Output 0 Explanation 0 Here the list  is . One possible permutation . Here   .  So there exists a permutation  of  such that  is not less than . However there does not exist any permutation  of  such that  is not less than . So the maximum possible value of  is . Sample Input 1 Sample Output 1 Explanation 1 Here the list  is . One possible permutation . Here   .  So there exists a permutation  of  such that  is not less than . However there does not exist any permutation  of  such that  is not less than . So the maximum possible value of  is .
__label__Strings __label__Dynamic-Programming Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: "(()" Output: 2 Explanation: The longest valid parentheses substring is "()"  Example 2: Input: ")()())" Output: 4 Explanation: The longest valid parentheses substring is "()()"
__label__Data-Structures There is a collection of input strings and a collection of query strings.  For each query string, determine how many times it occurs in the list of input strings.   For example, given input  and , we find  instances of ',  of '' and  of ''.  For each query, we add an element to our return array, .   Function Description Complete the function matchingStrings in the editor below.  The function must return an array of integers representing the frequency of occurrence of each query string in strings. matchingStrings has the following parameters: strings - an array of strings to search   queries - an array of query strings   Input Format The first line contains and integer , the size of .  Each of the next  lines contains a string .  The next line contains , the size of .  Each of the next  lines contains a string .   Constraints      .  Output Format Return an integer array of the results of all queries in order.
__label__Two-Pointers __label__Strings Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: "hello" Output: "holle"   Example 2: Input: "leetcode" Output: "leotcede"  Note: The vowels does not include the letter "y".
__label__Hash-Table __label__Binary-Search Create a timebased key-value store class TimeMap, that supports two operations. 1. set(string key, string value, int timestamp)  Stores the key and value, along with the given timestamp.  2. get(string key, int timestamp)  Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string ("").     Example 1: Input: inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]] Output: [null,null,"bar","bar",null,"bar2","bar2"] Explanation:    TimeMap kv;    kv.set("foo", "bar", 1); // store the key "foo" and value "bar" along with timestamp = 1    kv.get("foo", 1);  // output "bar"    kv.get("foo", 3); // output "bar" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie "bar"    kv.set("foo", "bar2", 4);    kv.get("foo", 4); // output "bar2"    kv.get("foo", 5); //output "bar2"       Example 2: Input: inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]] Output: [null,null,null,"","high","high","low","low"]      Note:  All key/value strings are lowercase. All key/value strings have length in the range [1, 100] The timestamps for all TimeMap.set operations are strictly increasing. 1 <= timestamp <= 10^7 TimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case.
__label__Dynamic-Programming __label__Graph-Algorithms You are situated in an  dimensional grid at position . The dimensions of the grid are . In one step, you can walk one step ahead or behind in any one of the  dimensions. This implies that there are always  possible moves if movements are unconstrained by grid boundaries. How many ways can you take  steps without leaving the grid at any point? You leave the grid if at any point , either  or . For example, you start off in a 3 dimensional grid at position .  The dimensions of the grid are , so each of your axes will be numbered from  to .  If you want to move  step, you can move to the following coordinates: .       If we started at  in the same grid, our new paths would lead to .  Other moves are constrained by . Function Description Complete the gridWalking function in the editor below.  It should return an integer that represents the number of possible moves, modulo . gridWalking has the following parameter(s): m: an integer that represents the number of steps   x: an integer array where each  represents a coordinate in the  dimension where  D: an integer array where each  represents the upper limit of the axis in the  dimension   Input Format The first line contains an integer , the number of test cases. Each of the next  sets of lines is as follows: The first line contains two space-separated integers,  and .   The next line contains  space-separated integers .   The third line of each test contains  space-separated integers .   Constraints          Output Format Output one line for each test case. Since the answer can be really huge, output it modulo .   Sample Input 1 2 3 1 1 2 3  Sample Output 12  Explanation We are starting from (1, 1) in a  2-D grid, and need to count the number of possible paths with length equal to .  Here are the  paths:
__label__Mathematics __label__Tree In an infinite binary tree where every node has two children, the nodes are labelled in row order. In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.  Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.   Example 1: Input: label = 14 Output: [1,3,4,14]  Example 2: Input: label = 26 Output: [1,2,6,10,26]    Constraints:  1 <= label <= 10^6
__label__Data-Structures The LRT Company has  employees. Each employee has a unique ID number from  to , where the director's ID is number . Every employee in the company has exactly one immediate supervisor — except the director, who has no supervisor. The company's employee hierarchy forms a tree of employee IDs that's rooted at employee number  (the director). The director decides to have a retreat lasting  days. Each day, the employees will be assigned to different groups for team building exercises. Groups are constructed in the following way: An employee can invite their immediate supervisor (the director has no supervisor and, thus, doesn't invite anyone). If employee  is invited by employee , then  and  are considered to be in the same group. Once an employee is invited to be in a group, they are in that group. This means that if two employees have the same immediate supervisor, only one of them can invite that supervisor to be in their group.   Every employee must be in a group, even if they are the only employee in it. The venue where LRT is hosting the retreat has different pricing for each of the  days of the retreat. For each day , there is a cost of  dollars per group and a per-group size limit of  (i.e., the maximum number of people that can be in any group on that day). Help the director find optimal groupings for each day so the cost of the -day retreat is minimal, then print the total cost of the retreat. As this answer can be quite large, your answer must be modulo . Input Format The first line contains two space-separated integers denoting the respective values of  (the number of employees) and  (the retreat's duration in days).  The next line contains  space-separated integers where each integer  denotes  (), which is the ID number of employee 's direct supervisor.  Each line  of the  subsequent lines contain two space-separated integers describing the respective values of  (the cost per group in dollars) and  (the maximum number of people per group) for the  day of the retreat. Constraints    Subtask   for  of the maximum possible score. Output Format Print a single integer denoting the minimum total cost for the -day retreat. As this number can be quite large, print your answer modulo . Sample Input 7 3 1 1 3 4 2 4 5 3 6 2 1 1  Sample Output 46  Explanation In the Sample Case above, the company has  employees and the retreat goes on for  days. The hierarchy looks like this:   On the first day, the cost per group is  dollars and each group has a maximum size of . The employees split into the following three groups: Employee  invites their manager, employee . Employee  then invites their manager, employee  (the director). Employee  invites their manager, employee . Employee  then invites their manager, employee . Employee 's manager is already in another group, so they are in a group by themself. These groupings are demonstrated in the following image where each group has a different pattern:  In other words, the final groups are , , and . This means the total cost for the first day is  dollars. On the second day, they split into  groups with a maximum size of  at a total cost of  dollars. On the third day, they split into  groups of size  at a total cost of  dollars. When we sum the costs for all three days, we get  as our answer.
__label__Search __label__Bit You will be given an array of integers.  All of the integers except one occur twice.  That one is unique in the array. Given an array of integers, find and print the unique element.   For example, , the unique element is .   Function Description  Complete the lonelyinteger function in the editor below.  It should return the integer which occurs only once in the input array.   lonelyinteger has the following parameter(s):   a: an array of integers   Input Format The first line contains a single integer, , denoting the number of integers in the array.  The second line contains  space-separated integers describing the values in . Constraints   It is guaranteed that  is an odd number and that there is one unique element.   , where . Output Format Print the unique integer in the array. Sample Input 0 Sample Output 0 Explanation 0 There is only one element in the array, thus it is unique. Sample Input 1 Sample Output 1 Explanation 1 We have two 's, and  is unique.  Sample Input 2 Sample Output 2 Explanation 2 We have two 's, two 's, and one .   is unique.
__label__Tree We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1]   Explanation:  Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer.    Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1]     Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1]     Note:   The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1.
__label__Two-Pointers Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space?
__label__Binary-Search Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i. For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.    Example 1: Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.    Example 2: Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied "right" interval for [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point; For [1,2], the interval [2,3] has minimum-"right" start point.    Example 3: Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied "right" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-"right" start point.  NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Mathematics __label__Strings Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: "1000/(100/10/2)" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".   Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2   Note:  The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case.
__label__Mathematics There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour? Answer this question, and write an algorithm for the general case.   General case:  If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous bucket within p minutes? There is exactly one bucket with poison.   Note:  A pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time. After a pig has instantly finished drinking buckets, there has to be a cool down time of m minutes. During this time, only observation is allowed and no feedings at all. Any given bucket can be sampled an infinite number of times (by an unlimited number of pigs).
__label__Greedy-Algorithms Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building  and at a height of .  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.   Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:   If the bot's  is less than the height of the building, his   If the bot's  is greater than the height of the building, his   For example, building heights are given as .  If the bot starts with , we get the following table: botEnergy   height  delta 4               2       +2 6               3       +3 9               4       +5 14              3       +11 25              2       +23 48  That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting  in this case is .   Function Description  Complete the chiefHopper function in the editor below.  It should return an integer that represents the minimum starting  that will allow completion of the course.   chiefHopper has the following parameter(s):   arr: an array of integers that represent building heights   Input Format The first line contains an integer , the number of buildings.  The next line contains  space separated integers  representing the heights of the buildings.   Constraints     Output Format Print a single integer representing minimum units of energy required to complete the game. Sample Input 0 Sample Output 0 Explanation 0 If initial energy is 4, after step 1 energy is 5, after step 2 it's 6, after step 3 it's 9 and after step 4 it's 16, finally at step 5 it's 28.  If initial energy were 3 or less, the bot could not complete the course.  Sample Input 1 Sample Output 1 Explanation 1 In the second test case if bot has energy 4, it's energy is changed by (4 - 4 = 0) at every step and remains 4.   Sample Input 2 Sample Output 2 Explanation 2 botEnergy   height  delta 3           1       +2 5           6       -1 4           4       0 4  We can try lower values to assure that they won't work.
__label__Data-Structures Jesse loves cookies. He wants the sweetness of all his cookies to be greater than value . To do this, Jesse repeatedly mixes two cookies with the least sweetness. He creates a special combined cookie with: sweetness  Least sweet cookie   2nd least sweet cookie). He repeats this procedure until all the cookies in his collection have a sweetness  .  You are given Jesse's cookies. Print the number of operations required to give the cookies a sweetness  . Print   if this isn't possible.  Input Format The first line consists of integers , the number of cookies and , the minimum required sweetness, separated by a space.  The next line contains  integers describing the array  where  is the sweetness of the  cookie in Jesse's collection. Constraints       Output Format Output the number of operations that are needed to increase the cookie's sweetness .  Output  if this isn't possible.  Sample Input 6 7 1 2 3 9 10 12  Sample Output 2  Explanation Combine the first two cookies to create a cookie with sweetness  =   After this operation, the cookies are .  Then, combine the cookies with sweetness  and sweetness , to create a cookie with resulting sweetness  =   Now, the cookies are .  All the cookies have a sweetness .   Thus,  operations are required to increase the sweetness.
__label__Dynamic-Programming Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] Output: [   "cats and dog",   "cat sand dog" ]  Example 2: Input: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] Output: [   "pine apple pen apple",   "pineapple pen apple",   "pine applepen apple" ] Explanation: Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] Output: []
__label__Graph-Algorithms Johnny, like every mathematician, has his favorite sequence of distinct natural numbers.  Let’s call this sequence . Johnny was very bored, so he wrote down  copies of the sequence  in his big notebook. One day, when Johnny was out, his little sister Mary erased some numbers(possibly zero) from every copy of  and then threw the notebook out onto the street. You just found it. Can you reconstruct the sequence?   In the input there are  sequences of natural numbers representing the  copies of the sequence  after Mary’s prank. In each of them all numbers are distinct. Your task is to construct the shortest sequence  that might have been the original . If there are many such sequences, return the lexicographically smallest one. It is guaranteed that such a sequence exists. Note  Sequence  is lexicographically less than sequence  if and only if there exists  such that for all . Input Format In the first line, there is one number  denoting the number of copies of .  This is followed by   and in next line a sequence of length  representing one of sequences after Mary's prank. All numbers are separated by a single space.   Constraints      All values in one sequence are distinct numbers in range . Output Format In one line, write the space-separated sequence  - the shortest sequence that might have been the original . If there are many such sequences, return the lexicographically smallest one. Sample Input 2 2 1 3 3 2 3 4  Sample Output  1 2 3 4  Explanation You have 2 copies of the sequence with some missing numbers:  and . There are two candidates for the original sequence , where the first one is lexicographically least.
__label__Strings Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   Valid Code Examples: Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> "<DIV>" end_tag -> "</DIV>" tag_content could also be separated into : text1|cdata|text2. text1 -> ">>  ![cdata[]] " cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>" text2 -> "]]>>]"  The reason why start_tag is NOT "<DIV>>>" is because of the rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.   Invalid Code Examples: Input: "<A>  <B> </A>   </B>" Output: False Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.  Input: "<DIV>  div tag is not closed  <DIV>" Output: False  Input: "<DIV>  unmatched <  </DIV>" Output: False  Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>" Output: False  Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>" Output: False  Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>" Output: False   Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.
__label__Array A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing.    Example 1: Input: "00110" Output: 1 Explanation: We flip the last digit to get 00111.   Example 2: Input: "010110" Output: 2 Explanation: We flip to get 011111, or alternatively 000111.   Example 3: Input: "00011000" Output: 2 Explanation: We flip to get 00000000.    Note:  1 <= S.length <= 20000 S only consists of '0' and '1' characters.
__label__Binary-Search (This problem is an interactive problem.) You may recall that an array A is a mountain array if and only if:  A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: 	 A[0] < A[1] < ... A[i-1] < A[i] A[i] > A[i+1] > ... > A[A.length - 1]    Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target.  If such an index doesn't exist, return -1. You can't access the mountain array directly.  You may only access the array using a MountainArray interface:  MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array.  Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer.  Also, any solutions that attempt to circumvent the judge will result in disqualification.     Example 1: Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1.    Constraints:  3 <= mountain_arr.length() <= 10000 0 <= target <= 10^9 0 <= mountain_arr.get(index) <= 10^9
__label__Data-Structures __label__Advanced-Data-Structures A Sumo wrestling championship is scheduled to be held this winter in the HackerCity where N wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K,  (i.e) wrestler A and wrestler B can fight if and only if |height(A)-height(B)|<=K.    Given an array H[], where H[i] represents the height of the ith fighter, for a given l, r where 0 <= l <= r < N, can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game? 0 <= l <= r < N Input Format  The first line contains an integer N and K  separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K.  The second line contains N integers separated by a single space, representing their heights H[0] H[1] ... H[N - 1].  The third line contains Q, the number of queries. This is followed by Q lines each having two integers l and r separated by a space.   Output Format  For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that K.   Constraints  1 <= N <= 100000  0 <= K <= 109  0 <= H[i] <= 109  1 <= Q <= 100000  0 <= l <= r < N   Sample Input Sample Output  Explanation  Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1.  Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| <=2. Hence output is 3.  Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.   Timelimits Timelimits are given here
__label__Strings For strings S and T, we say "T divides S" if and only if S = T + ... + T  (T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2.   Example 1: Input: str1 = "ABCABC", str2 = "ABC" Output: "ABC"  Example 2: Input: str1 = "ABABAB", str2 = "ABAB" Output: "AB"  Example 3: Input: str1 = "LEET", str2 = "CODE" Output: ""    Note:  1 <= str1.length <= 1000 1 <= str2.length <= 1000 str1[i] and str2[i] are English uppercase letters.
__label__Binary-Search Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles. Note:  An integer point is a point that has integer coordinates.  A point on the perimeter of a rectangle is included in the space covered by the rectangles.  ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner. length and width of each rectangle does not exceed 2000. 1 <= rects.length <= 100 pick return a point as an array of integer coordinates [p_x, p_y] pick is called at most 10000 times.   Example 1: Input:  ["Solution","pick","pick","pick"] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]   Example 2: Input:  ["Solution","pick","pick","pick","pick","pick"] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]   Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Dynamic-Programming Given an integer array arr and an integer k, modify the array by repeating it k times. For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0. As the answer can be very large, return the answer modulo 10^9 + 7.   Example 1: Input: arr = [1,2], k = 3 Output: 9  Example 2: Input: arr = [1,-2,1], k = 5 Output: 2  Example 3: Input: arr = [-1,-2], k = 7 Output: 0    Constraints:  1 <= arr.length <= 10^5 1 <= k <= 10^5 -10^4 <= arr[i] <= 10^4
__label__Strings Roy wanted to increase his typing speed for programming contests.  His friend suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly.  This sentence is known as a pangram because it contains every letter of the alphabet. After typing the sentence several times, Roy became bored with it so he started to look for other pangrams. Given a sentence, determine whether it is a pangram.  Ignore case. Function Description Complete the function pangrams in the editor below.  It should return the string pangram if the input string is a pangram.  Otherwise, it should return not pangram.   pangram not pangram pangrams has the following parameter(s): s: a string to test Input Format Input consists of a string .  Constraints   Each character of ,  Output Format Output a line containing pangram if  is a pangram, otherwise output not pangram.   Sample Input 0  pangram not pangram We promptly judged antique ivory buckles for the next prize We promptly judged antique ivory buckles for the next prize Sample Output 0 pangram pangram Sample Explanation 0 All of the letters of the alphabet are present in the string.   Sample Input 1  We promptly judged antique ivory buckles for the prize We promptly judged antique ivory buckles for the prize Sample Output 1 not pangram not pangram Sample Explanation 0 The string lacks an x.   x
__label__Tree __label__Depth-first-Search Given a binary tree struct Node {   int val;   Node *left;   Node *right;   Node *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.   Example:  Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":null,"next":null,"right":{"$id":"6","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}  Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":null,"right":null,"val":7},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"6","left":null,"next":null,"right":{"$ref":"5"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"6"},"val":1}  Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.    Note:  You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.
__label__Dynamic-Programming __label__Greedy-Algorithms A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence.  Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time?
__label__Hash-Table __label__Strings Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format: "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: "directory_path/file_name.txt" Example 1: Input: ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"] Output:   [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]    Note:  No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.    Follow-up beyond contest:  Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive?
__label__Greedy-Algorithms For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants.  Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is  where , there exists another team member whose skill level is . Note that a contestant can write buggy code and thus can have a negative skill level. The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible. For example, there are  contestants with skill levels .  There are many ways teams could be formed, e.g. [-1], [0],...,[3].  At the other end of the spectrum, we could form  and .  We're looking for the largest smaller team size though.  Two sets that meet the criteria are  and .  The largest smaller team size possible is . Note: There is an edge case where  contestants have registered.  As no teams are to be created, the largest team created will have  members. Input Format The first line contains an integer , the number of test cases.   Each of the next  lines contains a string of space-separated integers,  followed by  integers , a list of the contestants' skill levels. Constraints       Output Format For each test case, print the size of largest possible smallest team on a separate line. Sample Input 4   7 4 5 2 3 -4 -3 -5   1 -4   4 3 2 3 1   7 1 -2 -3 -4 2 0 -1    Sample Output 3 1 1 7  Explanation For the first case, Roy can form two teams: one with contestants with skill levels {-4,-3,-5} and the other one with {4,5,2,3}. The first group containing 3 members is the smallest.   {-4,-3,-5} {4,5,2,3} 3 In the second case, the only team is {-4}  {-4} In the third case, the teams are {3} , {1,2,3}, the size of the smaller group being 1. {3} {1,2,3} 1 In the last case, you can build one group containing all of the contestants. The size of the group equals the total number of contestants. Time limits  Time limits for this challenge are given here Note  If n = 0, print 0.
__label__Array Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.) Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5. Example 1: Input: [0,1,1] Output: [true,false,false] Explanation:  The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.  Example 2: Input: [1,1,1] Output: [false,false,false]  Example 3: Input: [0,1,1,1,1,1] Output: [true,false,false,false,true,false]  Example 4: Input: [1,1,1,0,1] Output: [false,false,false,false,false]    Note:  1 <= A.length <= 30000 A[i] is 0 or 1
__label__Graph-Algorithms Consider an undirected graph where each edge is the same weight.  Each of the nodes is labeled consecutively. You will be given a number of queries.  For each query, you will be given a list of edges describing an undirected graph.  After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the breadth-first search algorithm (BFS).  Distances are to be reported in node number order, ascending.  If a node is unreachable, print  for that node.  Each of the edges weighs 6 units of distance. For example, given a graph with  nodes and  edges, , a visual representation is:     The start node for the example is node .  Outputs are calculated for distances to nodes  through : .  Each edge is  units, and the unreachable node  has the required return distance of .   Function Description  Complete the bfs function in the editor below.  It must return an array of integers representing distances from the start node to each other node in node ascending order.  If a node is unreachable, its distance is .   bfs has the following parameter(s):   n: the integer number of nodes   m: the integer number of edges   edges: a 2D array of start and end nodes for edges s: the node to start traversals from Input Format The first line contains an integer , the number of queries.  Each of the following  sets of lines has the following format: The first line contains two space-separated integers  and , the number of nodes and edges in the graph.   Each line  of the  subsequent lines contains two space-separated integers,  and , describing an edge connecting node  to node .   The last line contains a single integer, , denoting the index of the starting node. Constraints         Output Format For each of the  queries, print a single line of  space-separated integers denoting the shortest distances to each of the  other nodes from starting position . These distances should be listed sequentially by node number (i.e., ), but should not include node . If some node is unreachable from , print  as the distance to that node. Sample Input 2 4 2 1 2 1 3 1 3 1 2 3 2  Sample Output 6 6 -1 -1 6  Explanation We perform the following two queries: The given graph can be represented as:    where our start node, , is node . The shortest distances from  to the other nodes are one edge to node , one edge to node , and an infinite distance to node  (which it's not connected to). We then print node 's distance to nodes , , and  (respectively) as a single line of space-separated integers: 6, 6, -1.   The given graph can be represented as:    where our start node, , is node . The shortest distances from  to the other nodes are one edge to node , one edge to node , and an infinite distance to node  (which it's not connected to). We then print node 's distance to nodes , , and  (respectively) as a single line of space-separated integers: 6, 6, -1.   6, 6, -1 The given graph can be represented as:    where our start node, , is node . There is only one edge here, so node  is unreachable from node  and node  has one edge connecting it to node . We then print node 's distance to nodes  and  (respectively) as a single line of space-separated integers: -1 6.  The given graph can be represented as:    where our start node, , is node . There is only one edge here, so node  is unreachable from node  and node  has one edge connecting it to node . We then print node 's distance to nodes  and  (respectively) as a single line of space-separated integers: -1 6.  -1 6 Note: Recall that the actual length of each edge is , and we print  as the distance to any node that's unreachable from .
__label__Dynamic-Programming You are given a hexagonal grid consisting of two rows, each row consisting of  cells. The cells of the first row are labelled  and the cells of the second row are labelled .   For example, for :  (Note that the  is connected with .) Your task is to tile this grid with  tiles that look like the following:  As you can see above, there are three possible orientations in which a tile can be placed. Your goal is to tile the whole grid such that every cell is covered by a tile, and no two tiles occupy the same cell. To add to the woes, certain cells of the hexagonal grid are blackened. No tile must occupy a blackened cell. Is it possible to tile the grid? Here's an example. Suppose we want to tile this grid:  Then we can do the tiling as follows:  Input Format The first line contains a single integer , the number of test cases.   The first line of each test case contains a single integer  denoting the length of the grid.  The second line contains a binary string of length . The  character describes whether cell  is blackened.  The third line contains a binary string of length . The  character describes whether cell  is blackened.  A 0 corresponds to an empty cell and a 1 corresponds to blackened cell.   0 1 Constraints     Output Format For each test case, print YES if there exists at least one way to tile the grid, and NO otherwise. YES NO Sample Input 0 Sample Output 0 Explanation 0 The first test case in the sample input describes the example given in the problem statement above.  For the second test case, there are two ways to fill it: either place two diagonal tiles side-by-side or place two horizontal tiles.
__label__Array __label__Binary-Search A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,               or index number 5 where the peak element is 6.  Note: Your solution should be in logarithmic complexity.
__label__Mathematics __label__Dynamic-Programming You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.   For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .   Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. Example1 Input: [1,0,5]  Output: 3  Explanation:  1st move:    1     0 <-- 5    =>    1     1     4 2nd move:    1 <-- 1 <-- 4    =>    2     1     3     3rd move:    2     1 <-- 3    =>    2     2     2     Example2 Input: [0,3,0]  Output: 2  Explanation:  1st move:    0 <-- 3     0    =>    1     2     0     2nd move:    1     2 --> 0    =>    1     1     1       Example3 Input: [0,2,0]  Output: -1  Explanation:  It's impossible to make all the three washing machines have the same number of dresses.    Note:  The range of n is [1, 10000]. The range of dresses number in a super washing machine is [0, 1e5].
__label__Advanced-Data-Structures Let's define a function, , on a string, , of length  as follows:   where  denotes the ASCII value of the  character in string , , and .  Nikita has a string, , consisting of  lowercase letters that she wants to perform  queries on. Each query consists of an integer, , and you have to find the value of  where  is the  alphabetically smallest palindromic substring of . If  doesn't exist, print  instead. Input Format The first line contains  space-separated integers describing the respective values of  (the length of string ) and  (the number of queries).  The second line contains a single string denoting .  Each of the  subsequent lines contains a single integer denoting the value of  for a query.  Constraints     It is guaranteed that string  consists of lowercase English alphabetic letters only (i.e.,  to ).  .  Scoring  for  of the test cases.  for  of the test cases. Output Format For each query, print the value of function  where  is the  alphabetically smallest palindromic substring of ; if  doesn't exist, print  instead. Sample Input 5 7 abcba 1 2 3 4 6 7 8         Sample Output 97 97 696207567 98 29493435 99 -1  Explanation There are  palindromic substrings of . Let's list them in lexicographical order and find value of : ,   ,   ,   ,   ,   ,   ,    doesn't exist, so we print  for .
__label__Dynamic-Programming In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.  Examples of Axis-Aligned Plus Signs of Order k:Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000  Example 1:Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.  Example 2:Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.  Example 3:Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.  Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)
__label__Dynamic-Programming Borussia Dortmund are a famous football ( soccer ) club from Germany. Apart from their fast-paced style of playing, the thing that makes them unique is the hard to pronounce names of their players ( błaszczykowski , papastathopoulos , großkreutz etc. ). The team's coach is your friend. He is in a dilemma as he can't decide how to make it easier to call the players by name, during practice sessions. So, you advise him to assign easy names to his players. A name is easy to him if  1. It consists of only one word.  2. It consists of only lowercase english letters.  3. Its length is exactly .  4. It contains exactly  different letters from the  letters of English alphabet.  5. At least one of its proper prefixes matches with its proper suffix of same length. Given,  and  you have to tell him the number of easy names he can choose from modulo . Note : A prefix  of a name  is proper if, . Similarly, a suffix  of a name  is proper if, . Input Format  The first line of the input will contain  ( the number of testcases ). Each of the next  lines will contain  space separated integers  and . Output Format  For each testcase, output the number of ways the coach can assign names to his players modulo . Constraints       Sample Input #1 3 1 1 2 1 4 2  Sample Output #1 0   26  2600    Sample Input #2 5   2 2 5 1 3 2 6 2 1 3  Sample Output #2 0 26 650 13650 0
__label__Hash-Table __label__Strings Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples: s = "leetcode" return 0.  s = "loveleetcode", return 2.    Note: You may assume the string contain only lowercase letters.
__label__Greedy-Algorithms There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day. Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken. Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.    Note:  The integer 1 <= d, t, n <= 10,000. You can't take two courses simultaneously.
__label__Tree __label__Depth-first-Search Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as:  a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example 1: Given the following tree [3,9,20,null,null,15,7]:     3    / \   9  20     /  \    15   7 Return true.  Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:        1       / \      2   2     / \    3   3   / \  4   4  Return false.
__label__Hash-Table __label__Greedy-Algorithms We have a set of items: the i-th item has value values[i] and label labels[i]. Then, we choose a subset S of these items, such that:  |S| <= num_wanted For every label L, the number of items in S with label L is <= use_limit.  Return the largest possible sum of the subset S.    Example 1: Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1 Output: 9 Explanation: The subset chosen is the first, third, and fifth item.   Example 2: Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2 Output: 12 Explanation: The subset chosen is the first, second, and third item.   Example 3: Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1 Output: 16 Explanation: The subset chosen is the first and fourth item.   Example 4: Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2 Output: 24 Explanation: The subset chosen is the first, second, and fourth item.    Note:  1 <= values.length == labels.length <= 20000 0 <= values[i], labels[i] <= 20000 1 <= num_wanted, use_limit <= values.length
__label__Data-Structures Transforming data into some other data is typical of a programming job. This problem is about a particular kind of transformation which we'll call the max transform. Let  be a zero-indexed array of integers. For , let  denote the subarray of  from index  to index , inclusive. Let's define the max transform of  as the array obtained by the following procedure: Let  be a list, initially empty. For  from  to : For  from  to : Let .   Append  to the end of .   For  from  to : Let .   Append  to the end of .   Let .   Append  to the end of .   Return .   The returned array is defined as the max transform of . We denote it by .  Complete the function solve that takes an integer array  as input. solve Given an array , find the sum of the elements of , i.e., the max transform of the max transform of . Since the answer may be very large, only find it modulo .   Input Format The first line of input contains a single integer  denoting the length of .   The second line contains  space-separated integers  denoting the elements of .   Constraints     Subtasks  For  of the total score,   Output Format Print a single line containing a single integer denoting the answer.   Sample Input 0 Sample Output 0 Explanation 0 In the sample case, we have:   Therefore, the sum of the elements of  is .
__label__Bit You will be given a list of 32 bit unsigned integers. Flip all the bits ( and ) and print the result as an unsigned integer.   For example, your decimal input .  We're working with 32 bits, so:       Function Description Complete the flippingBits function in the editor below.  It should return the unsigned decimal integer result.   flippingBits has the following parameter(s): n: an integer Input Format The first line of the input contains , the number of queries.  Each of the next  lines contain an integer, , to process.   Constraints    Output Format Output one line per element from the list with the decimal value of the resulting unsigned integer. Sample Input 0 Sample Output 0 Explanation 0             Sample Input 1 Sample Output 1 Explanation 1         Sample Input 2 Sample Output 2 Explanation 2
__label__Array __label__Two-Pointers Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. 	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?
__label__Data-Structures __label__Advanced-Data-Structures Chinese Version Russian Version You are given a 3-D Matrix in which each block contains 0 initially. The first block is defined by the coordinate (1,1,1) and the last block is defined by the coordinate (N,N,N). There are two types of queries. UPDATE x y z W  updates the value of block (x,y,z) to W. QUERY x1 y1 z1 x2 y2 z2  calculates the sum of the value of blocks whose x coordinate is between x1 and x2 (inclusive), y coordinate between y1 and y2 (inclusive) and z coordinate between z1 and z2 (inclusive).  Input Format  The first line contains an integer T, the number of test-cases. T testcases follow.  For each test case, the first line will contain two integers N and M separated by a single space.  N defines the N * N * N matrix.  M defines the number of operations.  The next M lines will contain either    1. UPDATE x y z W  2. QUERY  x1 y1 z1 x2 y2 z2   Output Format  Print the result for each QUERY. Constrains  1 <= T <= 50  1 <= N <= 100  1 <= M <= 1000  1 <= x1 <= x2 <= N  1 <= y1 <= y2 <= N  1 <= z1 <= z2 <= N  1 <= x,y,z <= N  -109 <= W <= 109  Sample Input 2 4 5 UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3 2 4 UPDATE 2 2 2 1 QUERY 1 1 1 1 1 1 QUERY 1 1 1 2 2 2 QUERY 2 2 2 2 2 2  Sample Output 4 4 27 0 1 1  Explanation  First test case, we are given a cube of 4 * 4 * 4 and 5 queries.  Initially all the cells (1,1,1) to (4,4,4) are 0.  UPDATE 2 2 2 4 makes the cell (2,2,2) = 4  QUERY 1 1 1 3 3 3. As (2,2,2) is updated to 4 and the rest are all 0. The answer to this query is 4.  UPDATE 1 1 1 23. updates the cell (1,1,1) to 23.  QUERY 2 2 2 4 4 4. Only the cell (1,1,1) and (2,2,2) are non-zero and (1,1,1) is not between (2,2,2) and (4,4,4). So, the answer is 4.  QUERY 1 1 1 3 3 3. 2 cells are non-zero and their sum is 23+4 = 27.  UPDATE 2 2 2 4 QUERY 1 1 1 3 3 3 UPDATE 1 1 1 23 QUERY 2 2 2 4 4 4 QUERY 1 1 1 3 3 3
__label__Hash-Table Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: "tree"  Output: "eert"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.   Example 2: Input: "cccaaa"  Output: "cccaaa"  Explanation: Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer. Note that "cacaca" is incorrect, as the same characters must be together.   Example 3: Input: "Aabb"  Output: "bbAa"  Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note that 'A' and 'a' are treated as two different characters.
__label__Two-Pointers Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1: Input: s = "abpcplea", d = ["ale","apple","monkey","plea"]  Output:  "apple"    Example 2: Input: s = "abpcplea", d = ["a","b","c"]  Output:  "a"   Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.
__label__Strings __label__Greedy-Algorithms You want to form a target string of lowercase letters. At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns. For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array. For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc". Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.   Example 1: Input: stamp = "abc", target = "ababc" Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.)   Example 2: Input: stamp = "abca", target = "aabcaca" Output: [3,0,1]     Note:    1 <= stamp.length <= target.length <= 1000 stamp and target only contain lowercase letters.
__label__Array __label__Strings Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:  Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.  Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]  Output: [   ["hit","hot","dot","dog","cog"],   ["hit","hot","lot","log","cog"] ]  Example 2: Input: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"]  Output: []  Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
__label__Depth-first-Search Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.          Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3]   Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false   Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false    Note:  1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j].
__label__Strings Amanda has a string of lowercase letters that she wants to copy to a new string.  She can perform the following operations with the given costs. She can perform them any number of times to construct a new string : Append a character to the end of string  at a cost of  dollar.  Choose any substring of  and append it to the end of  at no charge. Given  strings , find and print the minimum cost of copying each  to  on a new line. For example, given a string , it can be copied for  dollars.  Start by copying ,  and  individually at a cost of  dollar per character.  String  at this time.  Copy  to the end of  at no cost to complete the copy.   Function Description  Complete the stringConstruction function in the editor below.  It should return the minimum cost of copying a string.   stringConstruction has the following parameter(s):   s: a string   Input Format The first line contains a single integer , the number of strings.  Each of the next  lines contains a single string, . Constraints     Subtasks  for  of the maximum score. Output Format For each string  print the minimum cost of constructing a new string  on a new line. Sample Input 2 abcd abab  Sample Output 4 2  Explanation Query 0: We start with  and . Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Because the total cost of all operations is  dollars, we print  on a new line. Query 1: We start with  and . Append character '' to  at a cost of  dollar, .  Append character '' to  at a cost of  dollar, .  Append substring  to  at no cost, .  Because the total cost of all operations is  dollars, we print  on a new line. Note A substring of a string  is another string  that occurs "in"  (Wikipedia). For example, the substrings of the string "" are "", "" ,"", "", "", and "".
__label__Dynamic-Programming Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction "A", your car does the following: position += speed, speed *= 2. When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.) For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input:  target = 3 Output: 2 Explanation:  The shortest instruction sequence is "AA". Your position goes from 0->1->3.  Example 2: Input:  target = 6 Output: 5 Explanation:  The shortest instruction sequence is "AAARA". Your position goes from 0->1->3->7->7->6.    Note:   1 <= target <= 10000.
__label__Mathematics You are standing at position 0 on an infinite number line.  There is a goal at position target.  On each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.  Return the minimum number of steps required to reach the destination.  Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3.   Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step  from 1 to -1. On the third move we step from -1 to 2.   Note: target will be a non-zero integer in the range [-10^9, 10^9].
__label__Depth-first-Search Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:  The order of returned grid coordinates does not matter. Both m and n are less than 150.    Example: Given the following 5x5 matrix:    Pacific ~   ~   ~   ~   ~         ~  1   2   2   3  (5) *        ~  3   2   3  (4) (4) *        ~  2   4  (5)  3   1  *        ~ (6) (7)  1   4   5  *        ~ (5)  1   1   2   4  *           *   *   *   *   * Atlantic  Return:  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
__label__Dynamic-Programming You are given an integer array A.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps. You may from index i jump forward to index j (with i < j) in the following way:  During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j. During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j. (It may be the case that for some index i, there are no legal jumps.)  A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.) Return the number of good starting indexes.   Example 1: Input: [10,13,12,14,15] Output: 2 Explanation:  From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more. From starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more. From starting index i = 3, we can jump to i = 4, so we've reached the end. From starting index i = 4, we've reached the end already. In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.   Example 2: Input: [2,3,1,1,4] Output: 3 Explanation:  From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:  During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].  During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.  During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].  We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.  In a similar manner, we can deduce that: From starting index i = 1, we jump to i = 4, so we reach the end. From starting index i = 2, we jump to i = 3, and then we can't jump anymore. From starting index i = 3, we jump to i = 4, so we reach the end. From starting index i = 4, we are already at the end. In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.   Example 3: Input: [5,1,3,4,2] Output: 3 Explanation:  We can reach the end from starting indexes 1, 2, and 4.      Note:  1 <= A.length <= 20000 0 <= A[i] < 100000
__label__Strings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.   Example 2: Input: "10101" Output: 4 Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.   Note: s.length will be between 1 and 50,000. s will only consist of "0" or "1" characters.
__label__Tree Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example,  Given the tree:         4        / \       2   7      / \     1   3 And the value to insert: 5  You can return this binary search tree:          4        /   \       2     7      / \   /     1   3 5  This tree is also valid:          5        /   \       2     7      / \        1   3          \           4
__label__Dynamic-Programming __label__Graph-Algorithms You have N soldiers numbered from 1 to N. Each of your soldiers is either a liar or a truthful person. You have M sets of information about them. Each set of information tells you the number of liars among a certain range of your soldiers. Let L be the total number of your liar soldiers. Since you can't find the exact value of L, you want to find the minimum and maximum value of L. Input Format  The first line of the input contains two integers N and M.   Each of next M lines contains three integers:  A B C where the set of soldiers numbered as {A, A+1, A+2, ..., B}, exactly C of them are liars. (1 <= Ai <= Bi <= n) and (0 <= Ci <= Bi-Ai). Note: N and M are not more than 101, and it is guaranteed the given informations is satisfiable. Output Format  Print two integers Lmin and Lmax to the output. Sample Input #1  3 2 1 2 1 2 3 1  Sample Output #1 1 2  Sample Input #2  20 11 3 8 4 1 9 6 1 13 9 5 11 5 4 19 12 8 13 5 4 8 4 7 9 2 10 13 3 7 16 7 14 19 4  Sample Output #2 13 14  Explanation  In the first input, the initial line is "3 2", i.e. that there are 3 soldiers and we have 2 sets of information. The next line says there is one liar in the set of soldiers {1, 2}. The final line says there is one liar in the set {2,3}. There are two possibilities for this scenario: Soldiers number 1 and 3 are liars or soldier number 2 is liar.  So the minimum number of liars is 1 and maximum number of liars is 2. Hence the answer, 1 2.
__label__Dynamic-Programming Alice is a kindergarten teacher. She wants to give some candies to the children in her class.  All the children sit in a line and each of them has a rating score according to his or her performance in the class.  Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy. For example, assume her students' ratings are [4, 6, 4, 5, 6, 2].  She gives the students candy in the following minimal amounts: [1, 2, 1, 2, 3, 1].  She must buy a minimum of 10 candies.   Function Description Complete the candies function in the editor below.  It must return the minimum number of candies Alice must buy.   candies has the following parameter(s):   n: an integer, the number of children in the class   arr: an array of integers representing the ratings of each student   Input Format The first line contains an integer, , the size of .  Each of the next  lines contains an integer  indicating the rating of the student at position . Constraints     Output Format Output a single line containing the minimum number of candies Alice must buy. Sample Input 0 Sample Output 0 Explanation 0 Here 1, 2, 2 is the rating. Note that when two children have equal rating, they are allowed to have different number of candies. Hence optimal distribution will be 1, 2, 1. Sample Input 1 Sample Output 1 Explanation 1 Optimal distribution will be  Sample Input 2 Sample Output 2 Explanation 2 Optimal distribution will be .
__label__Array __label__Binary-Search Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
__label__Dynamic-Programming You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Treeland is a country with  cities and  roads. There is exactly one path between any two cities.   The ruler of Treeland wants to implement a self-driving bus system and asks tree-loving Alex to plan the bus routes. Alex decides that each route must contain a subset of connected cities; a subset of cities is connected if the following two conditions are true: There is a path between every pair of cities which belongs to the subset. Every city in the path must belong to the subset.  In the figure above,  is a connected subset, but  is not  (for the second condition to be true,  would need to be part of the subset). Each self-driving bus will operate within a connected segment of Treeland. A connected segment  where  is defined by the connected subset of cities .  In the figure above,  is a connected segment that represents the subset . Note that a single city can be a segment too. Help Alex to find number of connected segments in Treeland. Input Format The first line contains a single positive integer, .  The  subsequent lines each contain two positive space-separated integers,  and , describe an edge connecting two nodes in tree . Constraints   Subtasks  For  score:  For  score:  Output Format Print a single integer: the number of segments , which are connected in tree . Sample Input 3 1 3 3 2  Sample Output 5  Explanation The connected segments for our test case are: , , , , and . These segments can be represented by the respective subsets: , , , , and .  Note:  is not a connected segment. It represents the subset  and the path between  and  goes through  which is not a member of the subset.
__label__Mathematics We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.) Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return True if and only if Alice wins the game, assuming both players play optimally. Example: Input: nums = [1, 1, 2] Output: false Explanation:  Alice has two choices: erase 1 or erase 2.  If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.  If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.   Notes:   1 <= N <= 1000.  0 <= nums[i] <= 2^16.
__label__Tree Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1:          1        / \       2   3      /   / \     4   2   4        /       4  The following are two duplicate subtrees:       2      /     4  and     4  Therefore, you need to return above trees' root in the form of a list.
__label__Depth-first-Search There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]]  Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished                 course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.               So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note:  The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.
__label__Binary-Search Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note:  Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same.    Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.    Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
__label__Dynamic-Programming Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.    Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? Credits: Special thanks to @pbrother for adding this problem and creating all test cases.
__label__Greedy-Algorithms Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.   To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.  Example 1: Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].  Output: 4  Explanation: Since your initial capital is 0, you can only start the project indexed 0.              After finishing it you will obtain profit 1 and your capital becomes 1.              With capital 1, you can either start the project indexed 1 or the project indexed 2.              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.   Note:  You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer.
__label__Graph-Algorithms You are given a table, , with  rows and  columns. The top-left corner of the table has coordinates , and the bottom-right corner has coordinates . The  cell contains integer . A path in the table is a sequence of cells  such that for each , cell  and cell  share a side.  The weight of the path  is defined by  where  is the weight of the cell . You must answer  queries. In each query, you are given the coordinates of two cells,  and . You must find and print the minimum possible weight of a path connecting them. Note: A cell can share sides with at most  other cells. A cell with coordinates  shares sides with , ,  and . Input Format The first line contains  space-separated integers,  (the number of rows in ) and  (the number of columns in ), respectively.  Each of  subsequent lines contains  space-separated integers. The  integer in the  line denotes the value of .  The next line contains a single integer, , denoting the number of queries.  Each of the  subsequent lines describes a query in the form of  space-separated integers: , , , and , respectively.  Constraints     For each query:   Output Format On a new line for each query, print a single integer denoting the minimum possible weight of a path between  and . Sample Input 3 5 0 0 0 0 0 1 9 9 9 1 0 0 0 0 0 3 0 0 2 4 0 3 2 3 1 1 1 3  Sample Output 1 1 18  Explanation The input table looks like this:  The first two queries are explained below: In the first query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is . In the first query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is . In the second query, we have to find the minimum possible weight of a path connecting  and . Here is one possible path:  The total weight of the path is .
__label__Array A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.   Example 1: Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}    Note:  N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1].
__label__Graph-Algorithms __label__Tree The kingdom of Zion has cities connected by bidirectional roads.  There is a unique path between any pair of cities. Morpheus has found out that the machines are planning to destroy the whole kingdom.  If two machines can join forces, they will attack.  Neo has to destroy roads connecting cities with machines in order to stop them from joining forces.  There must not be any path connecting two machines. Each of the roads takes an amount of time to destroy, and only one can be worked on at a time.  Given a list of edges and times, determine the minimum time to stop the attack. For example, there are  cities called .  Three of them have machines and are colored red.  The time to destroy is shown next to each road.  If we cut the two green roads, there are no paths between any two machines.  The time required is .     Function Description Complete the function minTime in the editor below.  It must return an integer representing the minimum time to cut off access between the machines. minTime has the following parameter(s): roads: a two-dimensional array of integers, each  where cities are connected by a road that takes  to destroy   machines: an array of integers representing cities with machines   Input Format The first line of the input contains two space-separated integers,  and , the number of cities and the number of machines.   Each of the following  lines contains three space-separated integers, , and .  There is a bidirectional road connecting  and , and to destroy this road it takes  units. Each of the last  lines contains an integer, , the label of a city with a machine.    Constraints       Output Format Return an integer representing the minimum time required to disrupt the connections among all machines. Sample Input 5 3 2 1 8 1 0 5 2 4 5 1 3 4 2 4 0  Sample Output 10  Explanation  The machines are located at the cities ,  and . Neo can destroy the green roads resulting in a time of .  Destroying the road between cities  and  instead of between  and  would work, but it's not minimal.
__label__Game-Theory Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects.  Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows:  Initially there are  piles of stones; pile  has  stone, pile  has  stones, and so on. Thus, the  pile has  stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy at least half of the stones in it. The winner is the saint who destroys the last available stone .  For example, from a pile of  stones, a saint must destroy at least  stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills. Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?   Input Format First line of the input consists of an integer ,  testcases follow, each in a new line. Each line will contain a single integer , which describes the number of initial piles as explained above. Constraints    Output Format For each line in the input, output the minimum number of stones Ryuho needs to destroy in his first turn, assuming he starts playing and that both he and Koga play always as well as possible. If this is not possible, just print . Sample Input 0 Sample Output 0 Explanation 0 For the first testcase, we can see that the saint can destroy the first stone and win the game.  Sample Input 1 Sample Output 1 Explanation 1 There are three piles with stones  and . Initially Ryuho will remove  stone from the first pile. Now other saint has  options -  First, to remove all stones from second pile. In that case Ryuho will remove all stones from third pile and win the game. Second, to remove all stones from third pile. In that case Ryuho will remove all stones from second pile and win the game. Third, to remove  stone from second pile. In that case Ryuho will remove  stones from third pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. Fourth, to remove  stones from the third pile. In that case Ryuho will remove  stone from second pile and they will be left with  stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone. So in all four cases Ryuho will win the game.
__label__Graph-Algorithms After completing her final semester, Savita is back home. She is excited to meet all her friends. Her  friends live in different houses spread across the city.     There are  roads connecting the houses. The road network formed is connected and does not contain self loops and multiple roads between same pair of houses. Savita and Friends decide to meet.   Savita wants to choose a point(not necessarily an integer)  on the road numbered , such that, the maximum of  for all  is minimised,  where  is the shortest distance between the 'th friend and .     If 'th road connects friend  and friend  you should print distance of chosen point from . Also, print the  for all . If there is more than one solution, print the one in which the point  is closest to .      Note:  Use scanf/printf instead of cin/cout. Large input files. Order of  and  as given in the input must be maintained. If P is at a distance of 8 from  and 2 from , you should print 8 and not 2.   Input Format First line contain , the number of testcases.  T testcases follow.  First Line of each testcase contains 3 space separated integers  .  Next  lines contain description of the th road : three space separated integers , where  is the length of road connecting  and .       Constraints             Output Format For each testcase, print two space separated values in one line. The first value is the distance of  from the point  and the second value is the maximum of all the possible shortest paths between  and all of Savita's and her friends' houses. Round both answers to  decimal digits and print exactly  digits after the decimal point.    Sample Input 2 2 1 1 1 2 10 4 4 1 1 2 10 2 3 10 3 4 1 4 1 5  Sample Output 5.00000 5.00000 2.00000 8.00000  Explanation First testcase:  As  = 1, they will meet at the point  on the road that connects friend  with friend . If we choose mid point then distance for both of them will be . In any other position the maximum of distance will be more than . Second testcase:  As  = 1, they will meet at a point  on the road connecting friend  and friend . If we choose point at a distance of  from friend : Friend  will have to travel distance .  Friend  will have to travel distance .  Friend  will have to travel distance .  Friend  will have to travel distance .  So, the maximum will be .  In any other position of point choosen, the maximum distance will be more than .    Timelimits Timelimits for this problem is 2 times the environment limit.
__label__Strings Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.   For example, given n = 3, a solution set is:  [   "((()))",   "(()())",   "(())()",   "()(())",   "()()()" ]
__label__Graph-Algorithms Update: A slight modification in the problem statement (see below)   Evil Nation A is angry and plans to launch N guided-missiles at the peaceful Nation B in an attempt to wipe out all of Nation B's people. Nation A's missile i will arrive in nation B at time ti. Missile i communicates with its headquarters by unique radio signals with a frequency equal to fi. Can you help the peaceful Nation B survive by building a defensive system that will stop the missiles dead in the sky? Defensive system:  The only way to defend Nation B from the attacking missile is by counter attacking them with a hackerX missile. You have a lot of hackerX missiles and each one of them has its own radio frequency. An individual hackerX missile can destroy Evil Nation A’s attacking missile if the radio frequency of both of the missiles match. Each hackerX missile can be used an indefinite number of times. Its invincible and doesn't get destroyed in the collision. The good news is you can adjust the frequency of the hackerX missile to match the evil missiles' frequency. When changing the hackerX missile's initial frequency fA to the new defending frequency fB, you will need \|fB - fA\| units of time to do.  Each hackerX missile can only destroy one of Nation A's missile at a time. So if two evil missiles with same frequency arrive at the same time, you need at least two hackerX missiles with the same frequency as the evil missiles to avoid damage.  If two evil missles with same frequency arrive at the same time, we can destroy them both with one hackerX missile. You can set the frequency of a hackerX missile to any value when its fired.   What is the minimum number of hackerX missiles you must launch to keep Nation B safe? Input Format:  The first line contains a single integer N denoting the number of missiles.  This is followed by N lines each containing two integers ti and fi denoting the time & frequency of the ith missile. Output Format:  A single integer denoting the minimum number of hackerX missiles you need to defend the nation. Constraints:  1 <=  N  <= 100000  0 <= ti <= 100000  0 <= fi <= 100000  t1 <= t2 <= ... <= tN  Sample Input #00  4 1 1 2 2 3 1 5 1  Sample Output #00  1  Explanation #00 A HackerX missile is launched at t = 1 with a frequency f = 1, and destroys the first missile. It re-tunes its frequency to f = 2 in 1 unit of time, and destroys the missile that is going to hit Nation B at t = 2. It re-tunes its frequency back to 1 in 1 unit of time and destroys the missile that is going to hit the nation at t = 3. It is relaunched at t = 5 with f = 1 and destroys the missile that is going to hit nation B at t = 5. Hence, you need only 1 HackerX to protect nation B.  Sample Input #01  4 1 1 2 3 3 1 5 1  Sample Output #01  2  Explanation #01 Destroy 1 missile at t = 1, f = 1. now at t = 2, there is a missile with frequency 3. The launched missile takes 2 units of time to destroy this, hence we need a new hackerX missile to destroy this one. The first hackerX missile can destroy the 3rd missile which has the same frequency as itself. The same hackerX missile destroys the missile that is hitting its city at t = 5. Thus, we need atleast 2 hackerX missiles.
__label__Tree __label__Data-Structures You are given a pointer to the root of a binary tree. Print the top view of the binary tree.  Top view means when you look the tree from the top the nodes, what you will see will be called the top view of the tree. See the example below.  You only have to complete the function.  For example :    1     \      2       \        5       /  \      3    6       \        4  Top View : 1 -> 2 -> 5 -> 6 Input Format You are given a function, void topView(node * root) {  }  Constraints 1 Nodes in the tree   500 Output Format Print the values on a single line separated by space. Sample Input    1     \      2       \        5       /  \      3    6       \        4  Sample Output 1 2 5 6 Explanation    1     \      2       \        5       /  \      3    6       \        4  From the top only nodes 1,2,5,6 will be visible.
__label__Data-Structures __label__Graph-Algorithms __label__Graph-Algorithms We define the diameter of a strongly-connected oriented graph, , as the minimum integer  such that for each  there is a path from  to  of length  (recall that a path's length is its number of edges).   Given two integers,  and , build a strongly-connected oriented graph with  vertices where each vertex has outdegree  and the graph's diameter is as small as possible (see the Scoring section below for more detail). Then print the graph according to the Output Format specified below.   Here's a sample strongly-connected oriented graph with  nodes, whose outdegree is  and diameter is .    Note: Cycles and multiple edges between vertices are allowed. Input Format Two space-separated integers describing the respective values of  (the number of vertices) and  (the outdegree of each vertex). Constraints   Scoring  We denote the diameter of your graph as  and the diameter of the graph in the author's solution as . Your score for each test case (as a real number from  to ) is:  if   if   if  Output Format First, print an integer denoting the diameter of your graph on a new line.  Next, print  lines where each line  () contains  space-separated integers in the inclusive range from  to  describing the endpoints for each of vertex 's outbound edges. Sample Input 0 Sample Output 0 Explanation 0 The diagram below depicts a strongly-connected oriented graph with  nodes where each node has an outdegree of :  The diameter of this graph is , which is minimal as the outdegree of each node must be . We cannot construct a graph with a smaller diameter of  because it requires an outbound edge from each vertex to each other vertex in the graph (so the outdegree of that graph would be ).
__label__Depth-first-Search On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone. Now, a move consists of removing a stone that shares a column or row with another stone on the grid. What is the largest possible number of moves we can make?    Example 1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5   Example 2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3   Example 3: Input: stones = [[0,0]] Output: 0    Note:  1 <= stones.length <= 1000 0 <= stones[i][j] < 10000
__label__Strings Consider the following game for two players: There are two strings A and B. Initially, some strings A' and B' are written on the sheet of paper. A' is always a substring of A and B' is always a substring of B. A move consists of appending a letter to exactly one of these strings: either to A' or to B'. After the move the constraint of A' being a substring of A and B' is a substring of B should still be satisfied. Players take their moves alternately. We call a pair (A', B') a position. Two players are playing this game optimally. That means that if a player has a move that leads to his/her victory, he/she will definitely use this move. If a player is unable to make a move, he loses.  Alice and Bob are playing this game. Alice makes the first move. As always, she wants to win and this time she does a clever trick. She wants the starting position to be the Kth lexicographically winning position for the first player (i.e. her). Consider two positions (A'1, B'1) and (A'2, B'2). We consider the first position lexicographically smaller than the second if A1 is lexicographically smaller than A2, or if A1 is equal to A2 and B1 is lexicographically smaller than B2. Please help her to find such a position, knowing the strings A, B and the integer K. Note: An empty string has higher precedence than character "a" "a" Input Format The first line of input consists of three integers, separated by a single space: N, M and K denoting the length of A, the length of B and K respectively. The second line consists of N small latin letters, corresponding to the string A. The third line consists of M small latin letters, corresponding to the string B. Constraints 1 <= N, M <= 3 * 105  1 <= K <= 1018 Output Format Output A' on the first line of input and B' on the second line of input. Please, pay attention that some of these strings can be empty. If there's no such pair, output "no solution" without quotes. Sample Input 0 Sample Output 0 Explanation 0 The given strings are  and . So there are  =  ways to fill a starting position (each character has two options, either to be present or not present).     ["", ""] : If this is the start position, Alice will append  to . So, the next two moves will consist of appending  and  to  and  respectively. So, Bob will suffer lack of moves and hence Alice wins.     ["", "c"] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.     ["a", ""] : If Alice appends  to  then Bob will append  to  and if Alice appends  to  then Bob will append  to . So Alices looses.    ["a", "c"] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.    ["ab", ""] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.     ["ab", "c"] : If this is the start position, Alice will suffer lack of moves and hence he looses.     ["b", ""] : If this is the start position, Alice will append  to . Now, Bob will suffer lack of moves and hence Alice wins.    ["b", "c"] : If this is the start position, Alice will suffer lack of moves and hence he looses.   So, the list of start positions in lexicographical order where Alice wins are: ["", ""], ["", "c"], ["a", "c"], ["ab", ""], ["b", ""]. The  one in this list is ["a", "c"].
__label__Data-Structures There are a number of plants in a garden. Each of these plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.   You are given the initial values of the pesticide in each of the plants. Print the number of days after which no plant dies, i.e. the time after which there are no plants with more pesticide content than the plant to their left.   For example, pesticide levels .  Using a -indexed array, day  plants  and  die leaving .  On day , plant  of the current array dies leaving .  As there is no plant with a higher concentration of pesticide than the one to its left, plants stop dying after day .   Function Description  Complete the function poisonousPlants in the editor below.  It must return an integer representing the number of days until plants no longer die from pesticide. poisonousPlants has the following parameter(s): p: an array of integers representing pesticide levels in each plant Input Format The first line contains an integer , the size of the array .  The next line contains  space-separated integers .   Constraints    Output Format Output an integer equal to the number of days after which no plants die. Sample Input 7 6 5 8 4 7 10 9  Sample Output 2  Explanation Initially all plants are alive.   Plants = {(6,1), (5,2), (8,3), (4,4), (7,5), (10,6), (9,7)}    Plants[k] = (i,j) => jth plant has pesticide amount = i.   After the 1st day, 4 plants remain as plants 3, 5, and 6 die.   Plants = {(6,1), (5,2), (4,4), (9,7)}   After the 2nd day, 3 plants survive as plant 7 dies. Plants = {(6,1), (5,2), (4,4)}   After the 2nd day the plants stop dying.
__label__Mathematics You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.   Example 1: ┌───┐ │   │ └───┼──>     │  Input: [2,1,1,2] Output: true  Example 2: ┌──────┐ │      │ │ │ └────────────>  Input: [1,2,3,4] Output: false   Example 3: ┌───┐ │   │ └───┼>  Input: [1,1,1,1] Output: true
__label__Array Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3  Example 2: Input: [3,4,-1,1] Output: 2  Example 3: Input: [7,8,9,11,12] Output: 1  Note: Your algorithm should run in O(n) time and uses constant extra space.
__label__Strings A weighted string is a string of lowercase English letters where each letter has a weight.  Character weights are  to  from  to  as shown below:  We define the following terms:   The weight of a string is the sum of the weights of all the string's characters.  For example:   The weight of a string is the sum of the weights of all the string's characters.  For example:   A uniform string consists of a single character repeated zero or more times. For example, ccc and a are uniform strings, but bcb and cd are not. ccc a bcb cd Given a string, , let  be the set of weights for all possible uniform contiguous  substrings of string . You have to answer  queries, where each query  consists of a single integer, . For each query, print Yes on a new line if ; otherwise, print No instead. Yes No Note: The  symbol denotes that  is an element of set . Function Description  Complete the weightedUniformStrings function in the editor below. It should return an array of strings, either Yes or No, one for each query.   Yes No weightedUniformStrings has the following parameter(s):   s: a string   queries: an array of integers   Input Format The first line contains a string , the original string.  The second line contains an integer , the number of queries.  Each of the next  lines contains an integer , the weight of a uniform subtring of  that may or may not exist. Constraints    will only contain lowercase English letters, ascii[a-z]. Output Format Print  lines. For each query, print Yes on a new line if .  Otherwise, print No. Yes No Sample Input 0 Sample Output 0 Explanation 0 The weights of every possible uniform substring in the string abccddde are shown below: abccddde  We print Yes on the first four lines because the first four queries match weights of uniform substrings of . We print No for the last two queries because there are no uniform substrings in  that have those weights.  Yes No Note that while de is a substring of  that would have a weight of , it is not a uniform substring.  de Note that we are only dealing with contiguous substrings. So ccc is not a substring of the string ccxxc. ccc ccxxc Sample Input 1 Sample Output 1
__label__Dynamic-Programming In this challenge, you will be given an array  and must determine an array .  There is a special rule:  For all , .  That is,  can be any number you choose such that .  Your task is to select a series of  given  such that the sum of the absolute difference of consecutive pairs of  is maximized.  This will be the array's cost, and will be represented by the variable  below.  The equation can be written:   For example, if the array , we know that , , and .  Arrays meeting those guidelines are: Our calculations for the arrays are as follows: The maximum value obtained is . Function Description Complete the cost function in the editor below.  It should return the maximum value that can be obtained.   cost has the following parameter(s):   B: an array of integers   Input Format The first line contains the integer , the number of test cases.  Each of the next  pairs of lines is a test case where:  - The first line contains an integer , the length of   - The next line contains  space-separated integers   Constraints     Output Format For each test case, print the maximum sum on a separate line.    Sample Input 1 5 10 1 10 1 10  Sample Output 36  Explanation The maximum sum occurs when A[1]=A[3]=A[5]=10 and A[2]=A[4]=1.  That is .
__label__Strings __label__Greedy-Algorithms Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result.  If not possible, return the empty string. Example 1: Input: S = "aab" Output: "aba"  Example 2: Input: S = "aaab" Output: ""  Note:  S will consist of lowercase letters and have length in range [1, 500].
__label__Strings __label__Mathematics __label__Data-Structures A border of a string is a proper prefix of it that is also a suffix. For example: a and abra are borders of abracadabra, a abra abracadabra kan and kankan are borders of kankankan.  kan kankan kankankan de is a border of decode.  de decode Note that decode is not a border of decode because it's not proper. decode decode A palindromic border is a border that is palindromic. For example, a and ana are palindromic borders of anabanana,  a ana anabanana l, lol and lolol are palindromic borders of lololol. l lol lolol lololol Let's define  as the number of palindromic borders of string . For example, if  lololol, then .  lololol Now, a string of length  has exactly  non-empty substrings (we count substrings as distinct if they are of different lengths or are in different positions, even if they are the same string). Given a string , consisting only of the first 8 lowercase letters of the English alphabet, your task is to find the sum of  for all the non-empty substrings  of . In other words, you need to find:   Since the answer can be very large, output the answer modulo . Input Format  The first line contains a string consisting of  characters. Output Format  Print a single integer: the remainder of the division of the resulting number by . Constraints    All characters in the string can be any of the first 8 lowercase letters of the English alphabet (abcdefgh).   abcdefgh Sample Input 1  ababa  Sample Output 1  5  Sample Input 2  aaaa  Sample Output 2  10  Sample Input 3  abcacb  Sample Output 3  3  Explanation   ababa has 15 substrings but only 4 substrings have palindromic borders.   ababa  aba    ababa    bab    aba   aba ababa bab aba
__label__Two-Pointers Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list.   Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node.   Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node.   Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list.     Follow-up: Can you solve it without using extra space?
__label__Dynamic-Programming There are  gold mines along a river, and each mine  produces  tons of gold. In order to collect the mined gold, we want to redistribute and consolidate it amongst exactly  mines where it can be picked up by trucks. We do this according to the following rules: You can move gold between any pair of mines (i.e.,  and , where ). All the gold at some pickup mine  must either stay at mine  or be completely moved to some other mine, . Move  tons of gold between the mine at location  and the mine at location  at a cost of . Given , , and the amount of gold produced at each mine, find and print the minimum cost of consolidating the gold into  pickup locations according to the above conditions. Input Format The first line contains two space-separated integers describing the respective values of  (the number of mines) and  (the number of pickup locations).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  (the mine's distance from the mouth of the river) and  (the amount of gold produced in tons) for mine .  Note: It is guaranteed that the mines are will be given in order of ascending location. Constraints   Output Format Print a single line with the minimum cost of consolidating the mined gold amongst  different pickup sites according to the rules stated above. Sample Input 0 3 1 20 1 30 1 40 1  Sample Output 0 20  Explanation 0  We need to consolidate the gold from  mines into a single pickup location (because ). The mines are all equidistant and they all produce the same amount of gold, so we just move the gold from the mines at locations  and  to the mine at  for a minimal cost of . Sample Input 1 3 1 11 3 12 2 13 1  Sample Input 1 4  Explanation 1  We need to consolidate the gold from  mines into a single pickup location (because ). We can achieve a minimum cost of  by moving the gold from mines  and  to the mine at . Sample Input 2 6 2 10 15 12 17 16 18 18 13 30 10 32 1  Sample Output 2 182  Explanation 2  We need to consolidate the gold from  mines into  pickup locations. We can minimize the cost of doing this by doing the following: Move the gold from the mines at locations , , and  to the mine at .    Move the gold from the mine at location  to the mine at .
__label__Array __label__Mathematics Given an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between the maximum and minimum element of S. Return the sum of the widths of all subsequences of A.  As the answer may be very large, return the answer modulo 10^9 + 7.    Example 1: Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6.    Note:  1 <= A.length <= 20000 1 <= A[i] <= 20000
__label__Game-Theory Dexter and Debra are playing a game. They have N containers each having one or more chocolates. Containers are numbered from 1 to N, where ith container has A[i] number of chocolates. The game goes like this. First player will choose a container and take one or more chocolates from it. Then, second player will choose a non-empty container and take one or more chocolates from it. And then they alternate turns. This process will continue, until one of the players is not able to take any chocolates (because no chocolates are left). One who is not able to take any chocolates loses the game. Note that player can choose only non-empty container. The game between Dexter and Debra has just started, and Dexter has got the first Chance. He wants to know the number of ways to make a first move such that under optimal play, the first player always wins. Input Format The first line contains an integer N, i.e., number of containers.  The second line contains N integers, i.e., number of chocolates in each of the containers separated by a single space.   Constraints 1 ≤ N ≤ 106  1 ≤ A[i] ≤ 109  Output Format Print the number of ways to make the first move such that under optimal play, the first player always wins. If the first player cannot win under optimal play, print 0.   Sample Input 2 2 3  Sample Output 1  Explanation Only 1 set of moves helps player 1 win.  Player:      1      2      1      2      1 Chocolates: 2 3 -> 2 2 -> 1 2 -> 1 1 -> 0 1
__label__Search __label__Bit The Tower of Hanoi is a famous game consisting of  rods and a number of discs of incrementally different diameters. The puzzle starts with the discs neatly stacked on one rod, ordered by ascending size with the smallest disc at the top. The game's objective is to move the entire stack to another rod, obeying the following rules: Only one disc can be moved at a time. Each move consists of taking the topmost disc from a stack and moving it to the top of another stack. No disc may be placed on top of a smaller disc. Gena has a modified version of the Tower of Hanoi. His Hanoi has  rods and  discs ordered by ascending size. He made a few moves (following the rules above), but stopped and lost his place. He wants to restore the tower to its original state by making valid moves. Given the state of Gena's Hanoi, help him calculate the minimum number of moves needed to restore the tower to its original state. Note: Gena's rods are numbered from  to . All discs are initially located on rod . Input Format The first line contains a single integer, , denoting the number of discs.  The second line contains  space-separated integers, where the  integer is the index of the rod where the disk with diameter  is located. Constraints  Output Format Print the minimum number of moves Gena must make to restore the tower to its initial, ordered state on the first rod. Sample Input 3 1 4 1  Sample Output 3  Explanation  moves are enough to build the tower. Here is one possible solution:
__label__Greedy-Algorithms Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)  Example 1: Input: N = 10 Output: 9   Example 2: Input: N = 1234 Output: 1234   Example 3: Input: N = 332 Output: 299   Note: N is an integer in the range [0, 10^9].
__label__Dynamic-Programming We have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j]. Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)    Example 1: Input: [0] Output: 1 Explanation:  There is only one possible result: 0.   Example 2: Input: [1,1,2] Output: 3 Explanation:  The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.   Example 3: Input: [1,2,4] Output: 6 Explanation:  The possible results are 1, 2, 3, 4, 6, and 7.       Note:  1 <= A.length <= 50000 0 <= A[i] <= 10^9
__label__Bit Johnny is playing with a large binary number, . The number is so large that it needs to be compressed into an array of integers, , where the values in even indices () represent some number of consecutive  bits and the values in odd indices () represent some number of consecutive  bits in alternating substrings of .        For example, suppose we have array .  represents ,  represents ,  represents ,  represents , and  represents . The number of consecutive binary characters in the  substring of  corresponds to integer , as shown in this diagram:  When we assemble the sequential alternating sequences of 's and 's, we get . We define setCount() to be the number of 's in a binary number, . Johnny wants to find a binary number, , that is the smallest binary number  where setCount() = setCount(). He then wants to compress  into an array of integers,  (in the same way that integer array  contains the compressed form of binary string ). Johnny isn't sure how to solve the problem. Given array , find integer array  and print its length on a new line. Then print the elements of array  as a single line of space-separated integers. Input Format The first line contains a single positive integer, , denoting the number of test cases. Each of the  subsequent lines describes a test case over  lines: The first line contains a single positive integer, , denoting the length of array .  The second line contains  positive space-separated integers describing the respective elements in integer array  (i.e., ). Constraints   Subtasks For a  score, . For a  score, . Output Format For each test case, print the following  lines:   Print the length of integer array  (the array representing the compressed form of binary integer ) on a new line.  Print each element of  as a single line of space-separated integers. It is guaranteed that a solution exists. Sample Input 0 Sample Output 0 Explanation 0 , which expands to . We then find setCount() . The smallest binary number  which also has eleven 's is . This can be reduced to the integer array . This is demonstrated by the following figure:  Having found , we print its length () as our first line of output, followed by the space-separated elements in  as our second line of output.
__label__Array Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note:  All numbers will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]
__label__Hash-Table Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example "Aa" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010.  Example:  Input: "abccccdd"  Output: 7  Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
__label__Dynamic-Programming __label__Mathematics Given an array of  integers (), find all possible increasing subsequences of maximum length, . Then print the lexicographically  longest increasing subsequence as a single line of space-separated integers; if there are less than  subsequences of length , print . Two subsequences  and  are considered to be different if there exists at least one  such that . Input Format The first line contains  space-separated integers,  and , respectively.  The second line consists of  space-separated integers denoting  respectively. Constraints      Scoring  for  of the test data.    for  of the test data. Output Format Print a single line of  space-separated integers denoting the lexicographically  longest increasing subsequence; if there are less than  subsequences of length , print . Note:  is the length of longest increasing subsequence in the array. Sample Input 0 5 3 1 3 1 2 5  Sample Output 0 1 3 5  Sample Input 1 5 2 1 3 2 4 5  Sample Output 1 1 3 4 5      Explanation Sample Case 0:  The longest possible increasing subsequences in lexicographical order are:      Notice that the first and second subsequences appear the same; they are actually both different because the  in the first subsequence comes from array element , and the  in the second subsequence comes from array element . Because , we print the  one () as a single line of space-separated integers. Sample Case 1:  The longest possible increasing subsequences in lexicographical order are:      Because , we print the  one () as a single line of space-separated integers.
__label__Dynamic-Programming Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note:  Each of the array element will not exceed 100. The array size will not exceed 200.    Example 1: Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].    Example 2: Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.
__label__Search Ron and Hermione are deep in the Forbidden Forest collecting potion ingredients, and they've managed to lose their way. The path out of the forest is blocked, so they must make their way to a portkey that will transport them back to Hogwarts.   Consider the forest as an  grid. Each cell is either empty (represented by .) or blocked by a tree (represented by ). Ron and Hermione can move (together inside a single cell) LEFT, RIGHT, UP, and DOWN through empty cells, but they cannot travel through a tree cell. Their starting cell is marked with the character , and the cell with the portkey is marked with a . The upper-left corner is indexed as .  .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX.  In example above, Ron and Hermione are located at index  and the portkey is at . Each cell is indexed according to Matrix Conventions.     Hermione decides it's time to find the portkey and leave. They start along the path and each time they have to choose a direction, she waves her wand and it points to the correct direction. Ron is betting that she will have to wave her wand exactly  times. Can you determine if Ron's guesses are correct? The map from above has been redrawn with the path indicated as a series where  is the starting point (no decision in this case),  indicates a decision point and  is just a step on the path: .X.X.10000X .X*0X0XXX0X .XX0X0XM01. ...100XXXX.  There are three instances marked with  where Hermione must use her wand. Note: It is guaranteed that there is only one path from the starting location to the portkey.   Function Description  Complete the countLuck function in the editor below.  It should return a string, either  if Ron is correct or  if he is not.   countLuck has the following parameters:   matrix: a list of strings, each one represents a row of the matrix   k: an integer that represents Ron's guess   Input Format The first line contains an integer , the number of test cases. Each test case is described as follows:  The first line contains  space-separated integers  and , the number of forest matrix rows and columns.  Each of the next  lines contains a string of length  describing a row of the forest matrix.  The last line contains an integer , Ron's guess as to how many times Hermione will wave her wand. Constraints       There will be exactly one  and one  in the forest.   Exactly one path exists between  and . Output Format On a new line for each test case, print  if Ron impresses Hermione by guessing correctly.  Otherwise, print . Sample Input 3 2 3 *.M .X. 1 4 11 .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX. 3 4 11 .X.X......X .X*.X.XXX.X .XX.X.XM... ......XXXX. 4  Sample Output Impressed Impressed Oops!  Explanation For each test case,  denotes the number of times Hermione waves her wand.     Case 0: Hermione waves her wand at , giving us . Because , we print  on a new line.  Case 1: Hermione waves her wand at , , and , giving us . Because , we print  on a new line.  Case 2: Hermione waves her wand at , , and , giving us . Because  and ,  and we print  on a new line.
__label__Depth-first-Search Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =  [   [9,9,4],   [6,6,8],   [2,1,1] ]  Output: 4  Explanation: The longest increasing path is [1, 2, 6, 9].  Example 2: Input: nums =  [   [3,4,5],   [3,2,6],   [2,2,1] ]  Output: 4  Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
__label__Mathematics Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2.      Example 1: Input: 1 Output: true   Example 2: Input: 10 Output: false   Example 3: Input: 16 Output: true   Example 4: Input: 24 Output: false   Example 5: Input: 46 Output: true    Note:  1 <= N <= 10^9
__label__Hash-Table __label__Two-Pointers In an array A of 0s and 1s, how many non-empty subarrays have sum S?   Example 1: Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation:  The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]    Note:  A.length <= 30000 0 <= S <= A.length A[i] is either 0 or 1.
__label__Search __label__Dynamic-Programming Given a set of  intervals, find the size of its largest possible subset of intervals such that no three intervals in the subset share a common point. Input Format The first line contains an integer, , denoting the number of interval sets you must find answers for. The  subsequent lines describe each of the  interval sets as follows: The first line contains an integer, , denoting the number of intervals in the list.  Each line  of the  subsequent lines contains two space-separated integers describing the respective starting () and ending () boundaries of an interval. Constraints     Output Format For each of the  interval sets, print an integer denoting the size of the largest possible subset of intervals in the given set such that no three points in the subset overlap. Sample Input 4 3 1 2 2 3 2 4 3 1 5 1 5 1 5 4 1 10 1 3 4 6 7 10 4 1 10 1 3 3 6 7 10  Sample Output 2 2 4 3  Explanation For set , all three intervals fall on point  so we can only choose any  of the intervals. Thus, we print  on a new line. For set , all three intervals span the range from  to  so we can only choose any  of them. Thus, we print  on a new line. For set , we can choose all  intervals without having more than two of them overlap at any given point. Thus, we print  on a new line. For set , the intervals , , and  all overlap at point , so we must only choose  of these intervals to combine with the last interval, , for a total of  qualifying intervals. Thus, we print  on a new line.
__label__Array Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note:  All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.  Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]  Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [   [1,2,2],   [5] ]
__label__Strings There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is "facing" is irrelevant. "R" will always make the robot move to the right once, "L" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: "UD" Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.    Example 2: Input: "LL" Output: false Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.
__label__Array The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0,   F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N > 1.  Given N, calculate F(N).   Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.  Example 2: Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.  Example 3: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.    Note: 0 ≤ N ≤ 30.
__label__Hash-Table __label__Mathematics Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
__label__Mathematics Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.  Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int.
__label__Dynamic-Programming Penny has an array of  integers, . She wants to find the number of unique multisets she can form using elements from the array such that the bitwise XOR of all the elements of the multiset is a prime number. Recall that a multiset is a set which can contain duplicate elements. Given  queries where each query consists of an array of integers, can you help Penny find and print the number of valid multisets for each array? As these values can be quite large, modulo each answer by  before printing it on a new line. Input Format The first line contains a single integer, , denoting the number of queries. The  subsequent lines describe each query in the following format: The first line contains a single integer, , denoting the number of integers in the array. The second line contains  space-separated integers describing the respective values of . Constraints     Output Format On a new line for each query, print a single integer denoting the number of unique multisets Penny can construct using numbers from the array such that the bitwise XOR of all the multiset's elements is prime. As this value is quite large, your answer must be modulo . Sample Input 1    3    3511 3671 4153    Sample Output 4  Explanation The valid multisets are:  is prime.  is prime.  is prime. , which is prime. Because there are four valid multisets, we print the value of  on a new line.
__label__Game-Theory __label__Game-Theory Two players called  and  are playing a game with a starting number of stones. Player  always plays first, and the two players move in alternating turns. The game's rules are as follows: In a single move, a player can remove either , , or  stones from the game board.  If a player is unable to make a move, that player loses the game. Given the starting number of stones, find and print the name of the winner.   is named First and  is named Second.  Each player plays optimally, meaning they will not make a move that causes them to lose the game if a winning move exists. First Second For example, if ,  can make the following moves:    removes  stones leaving .  will then remove  stones and win.  removes  stones leaving .  cannot move and loses.  would make the second play and win the game. Function Description Complete the gameOfStones function in the editor below.  It should return a string, either First or Second.   First Second gameOfStones has the following parameter(s): n: an integer that represents the starting number of stones Input Format The first line contains an integer , the number of test cases.  Each of the next  lines contains an integer , the number of stones in a test case. Constraints  Output Format On a new line for each test case, print First if the first player is the winner.  Otherwise print Second. First Second Sample Input 8 1 2 3 4 5 6 7 10  Sample Output Second First First First First First Second First  Explanation In the sample, we have  testcases.   If ,  can't make any moves and loses the game. If ,  removes  stones and wins the game. If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  removes all  stones from the game board, winning the game.   If ,  removes  stones in their first move, leaving  stone on the board and winning the game.   If ,  can make any of the following three moves: Remove  stones, leaving  stones on the board.  then removes  stones, winning the game.   Remove  stones, leaving  stones on the board.  then removes  stones, leaving  stone left on the board and winning the game.   Remove  stones, leaving  stones on the board.  then removes the  remaining stones and wins the game.   All possible moves result in  winning. If ,  can remove either  or  stones to win the game.
__label__Tree __label__Data-Structures The height of a binary tree is the number of edges between the tree's root and its furthest leaf.  For example, the following binary tree is of height :   Function Description Complete the getHeight or height function in the editor.  It must return the height of a binary tree as an integer. getHeight or height has the following parameter(s): root: a reference to the root of a binary tree.     Note -The Height of binary tree with single node is taken as zero.   Input Format The first line contains an integer , the number of nodes in the tree.  Next line contains  space separated integer where th integer denotes node[i].data. Note:  Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function.  In a binary search tree, all nodes on the left branch of a node are less than the node value.  All values on the right branch are greater than the node value. Constraints    Output Format Your function should return a single integer denoting the height of the binary tree. Sample Input  Sample Output 3  Explanation The longest root-to-leaf path is shown below:  There are  nodes in this path that are connected by  edges, meaning our binary tree's .
__label__Hash-Table __label__Tree Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3]    1     \      2     /    3  Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?
__label__Hash-Table __label__Mathematics The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.    Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.  Example 1: Input: nums = [1,2,2,4] Output: [2,3]   Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.
__label__Greedy-Algorithms There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
__label__Greedy-Algorithms At a lemonade stand, each lemonade costs $5.  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don't have any change in hand at first. Return true if and only if you can provide every customer with correct change.    Example 1: Input: [5,5,5,10,20] Output: true Explanation:  From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true.   Example 2: Input: [5,5,10] Output: true   Example 3: Input: [10,10] Output: false   Example 4: Input: [5,5,10,10,20] Output: false Explanation:  From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can't give change of $15 back because we only have two $10 bills. Since not every customer received correct change, the answer is false.    Note:  0 <= bills.length <= 10000 bills[i] will be either 5, 10, or 20.
__label__Strings Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: "aacecaaa" Output: "aaacecaaa"  Example 2: Input: "abcd" Output: "dcbabcd"
__label__Bit Louise and Richard have developed a numbers game.  They pick a number and check to see if it is a power of .  If it is, they divide it by .  If not, they reduce it by the next lower number which is a power of .  Whoever reduces the number to  wins the game.  Louise always starts. Given an initial value, determine who wins the game. As an example, let the initial value .  It's Louise's turn so she first determines that  is not a power of .  The next lower power of  is , so she subtracts that from  and passes  to Richard.   is a power of , so Richard divides it by  and passes  to Louise.  Likewise,  is a power so she divides it by  and reaches .  She wins the game. Update If they initially set counter to , Richard wins.  Louise cannot make a move so she loses. Function Description  Complete the counterGame function in the editor below.  It should return the winner's name, either Richard or Louise.   Richard Louise counterGame has the following parameter(s):   n: an integer to initialize the game counter   Input Format The first line contains an integer , the number of testcases.  Each of the next  lines contains an integer , the initial value for the game.   Constraints   Output Format For each test case, print the winner's name on a new line in the form Louise or Richard. Louise Richard Sample Input 0 Sample Output 0 Explanation 0  is not a power of  so Louise reduces it by the largest power of  less than :.    is a power of  so Richard divides by  to get  and wins the game.
__label__Array Given an array A, we can perform a pancake flip: We choose some positive integer k <= A.length, then reverse the order of the first k elements of A.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A. Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.   Example 1: Input: [3,2,4,1] Output: [4,2,4,3] Explanation:  We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: A = [3, 2, 4, 1] After 1st flip (k=4): A = [1, 4, 2, 3] After 2nd flip (k=2): A = [4, 1, 2, 3] After 3rd flip (k=4): A = [3, 2, 1, 4] After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted.    Example 2: Input: [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted.     Note:  1 <= A.length <= 100 A[i] is a permutation of [1, 2, ..., A.length]
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2]  Output: 1  Example 2: Input: [4,5,6,7,0,1,2] Output: 0
__label__Graph-Algorithms Given a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes.  There may be many queries, so efficiency counts.   For example, your graph consists of  nodes as in the following:   A few queries are from node  to node , node  to node , and node  to node .   There are two paths from  to :  at a distance of    at a distance of   In this case we choose path .   There are two paths from  to :  at a distance of    at a distance of   In this case we choose path .   There is no path from  to , so we return .   There is no path from  to , so we return .   There is one path from  to :    at a distance of .   There is one path from  to :    at a distance of .   Input Format The first line has two integers  and , the number of nodes and the number of edges in the graph.  Each of the next  lines contains three space-separated integers   and , the two nodes between which the directed edge  exists, and , the length of the edge.  The next line contains a single integer , the number of queries.  Each of the next  lines contains two space-separated integers  and , denoting the start and end nodes for traversal.   Constraints           The distance from a node to itself is always  and it is always reachable from itself. If there are edges between the same pair of nodes with different weights, the last one (most recent) is to be considered as the only edge between them. Output Format Print  lines, each containing a single integer specifying the shortest distance for the query.   If the destination node is not reachable, return .   Sample Input 4 5 1 2 5 1 4 24 2 4 6 3 4 4 3 2 7 3 1 2 3 1 1 4  Sample Output 5 -1 11  Explanation The graph given in the test case is shown as :  The shortest paths for the 3 queries are : : The direct Path is shortest with weight 5 : The direct Path is shortest with weight 5 : There is no way of reaching node 1 from node 3 : There is no way of reaching node 1 from node 3  The indirect path is shortest with weight (5+6) = 11 units. The direct path is longer with 24 units length.  The indirect path is shortest with weight (5+6) = 11 units. The direct path is longer with 24 units length.
__label__Data-Structures A left rotation operation on an array of size  shifts each of the array's elements  unit to the left. For example, if  left rotations are performed on array , then the array would become . Given an array of  integers and a number, , perform  left rotations on the array. Then print the updated array as a single line of space-separated integers. Input Format The first line contains two space-separated integers denoting the respective values of  (the number of integers) and  (the number of left rotations you must perform).  The second line contains  space-separated integers describing the respective elements of the array's initial state. Constraints      Output Format Print a single line of  space-separated integers denoting the final state of the array after performing  left rotations. Sample Input 5 4 1 2 3 4 5  Sample Output 5 1 2 3 4  Explanation When we perform  left rotations, the array undergoes the following sequence of changes:    Thus, we print the array's final state as a single line of space-separated values, which is 5 1 2 3 4. 5 1 2 3 4
__label__Array Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.) Formally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:  0 <= i < i + L - 1 < j < j + M - 1 < A.length, or 0 <= j < j + M - 1 < i < i + L - 1 < A.length.       Example 1: Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2 Output: 20 Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.   Example 2: Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2 Output: 29 Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.   Example 3: Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3 Output: 31 Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.    Note:  L >= 1 M >= 1 L + M <= A.length <= 1000 0 <= A[i] <= 1000
__label__Strings Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.  Example 1: Input: "sea", "eat" Output: 2 Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".   Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.
__label__Dynamic-Programming There is a huge blanket on your bed but unfortunately it has N stains. You cover them using  a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly K stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth. Let X denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove K stains so that the remaining N-K stains can be covered with silk of area strictly less than X (We are looking for any configuration that will reduce the cost). Assume that each stain is a point and that the rectangle is aligned parallel to the axes.   Input Format The first line contains two integers N (1<=N<=1000) and K (0<=K<=N).  Next follow N lines, one for each stain. Each line contains two integers in the form 'X Y', (0<=X,Y<100000), the coordinates of each stain into the blanket. Each pair of coordinates is unique. Output Format Output a single integer. The remainder of the division by 1000000007 of the answer. Sample Input 5 2 0 1 3 3 2 0 0 3 2 3  Sample Output 8  Explanation We can clean two spots. So removing any of the following set of stains will lead us to a conbination that will need less amount of silk.(The numbers refer to the indices of the stains in the input and they begin from 1). 1, 4 2, 1 2, 3 2, 4 2, 5 3, 1 3, 4 3, 5  So there are 8 ways.
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Simon received the board game Ticket to Ride as a birthday present. After playing it with his friends, he decides to come up with a strategy for the game. There are  cities on the map and  road plans. Each road plan consists of the following:  Two cities which can be directly connected by a road. The length of the proposed road.  The entire road plan is designed in such a way that if one builds all the roads, it will be possible to travel between any pair of cities.  A ticket enables you to travel between two different cities. There are  tickets, and each ticket has a cost associated with it. A ticket is considered to be useful if there is a path between those cities. Simon wants to choose two cities,  and , and build a minimal number of roads so that they form a simple path between them. Let  be the sum of costs of all useful tickets and  be the sum of lengths of all the roads Simon builds. The profit for pair  is defined as . Note that  and  are not necessarily unique and may be the same cities. Given  road plans and  ticket prices, help Simon by printing the value of his maximum possible profit on a new line. Input Format The first line contains single positive integer, , denoting the number of cities.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a road plan, where , , and . Here,  and  are two cities that the road plan proposes to connect and  is the length of the proposed road.  The next line contains a single positive integer, , denoting the number of tickets.  Each of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for a ticket from city  to city  (where  is the cost of the ticket). Constraints    Output Format Print a single integer denoting the the maximum profit Simon can make. Time Limits   seconds for Java and C#. Please refer to our Environment page to see time limits for other languages. Sample Input 7 1 2 1 1 3 1 1 4 4 4 5 1 4 6 1 4 7 1 5 5 7 3 3 6 2 3 4 10 2 7 15 1 6 7  Sample Output 13  Explanation  Simon can maximize his profit by choosing the pair .  The roads on the path between them are , , and . The total road length is .  The useful tickets are , , and . The total ticket cost is .  The profit is .
__label__Mathematics __label__Depth-first-Search There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1. While entering a password, the last n digits entered will automatically be matched against the correct password. For example, assuming the correct password is "345", if you type "012345", the box will open because the correct password matches the suffix of the entered password. Return any password of minimum length that is guaranteed to open the box at some point of entering it.   Example 1: Input: n = 1, k = 2 Output: "01" Note: "10" will be accepted too.  Example 2: Input: n = 2, k = 2 Output: "00110" Note: "01100", "10011", "11001" will be accepted too.    Note:  n will be in the range [1, 4]. k will be in the range [1, 10]. k^n will be at most 4096.
__label__Dynamic-Programming It is the Indian version of the famous heist “The Italian Job”. N robbers have already broken into the National Museum and are just about to get inside the main vault which is full of jewels. They were lucky that just as they broke into the museum, the guard was leaving the museum for exactly G minutes. But there are other problems too. The main vault has heat sensors that if at any moment of time there are more than two people present in the vault, the alarm goes off.   To collect the jewels, the ith robber needs to be inside the vault for exactly A[i] minutes, 0 <= i < N, in one continuous stretch. As guard will return after G minutes, they have to finish their tasks within G minutes. The robbers want to know if there exists any arrangement such that demands of each robber is satisfied and also they are not caught? Gotchas  If a robber goes inside the vault at a time "X" and at the same time another robber comes out, it's equivalent to saying they were never in the vault at the same time.  Similarly, when the guard gets inside vault at time G and a robber comes out exactly at time G, the guard will not be able see the robber. Input Format The first line contains an integer T denoting the number of testcases. T testcases follow. Each testcase consists of two lines. First line contains two space separated integers denoting N and G denoting the number of thieves and duration for which guard leaves the museum.  The next line contains N space separated numbers where the ith integer, A[i]  represents the time the ith robber needs to be in the vault. Constraints 1 <= T <= 20  1 <= N <= 100  0 <= G <= 1000000 (106)  0 <= A[i] <= 100   Output Format For each testcase print YES if there exists such an arrangement or NO otherwise in a newline.   YES NO Sample Input 2 3 4 2 4 2 3 2 2 4 2  Sample Output YES NO  Explanation Test case #00: In first testcase, one possible arrangement is:  at t=0, robber1 goes inside and comes out at t=2  at t=0, robber2 goes inside and comes out at t=4  at t=2, robber3 goes inside and comes out at t=4   Test case #01: No possible arrangement is possible in second testcase.
__label__Mathematics Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4. Note:  1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
__label__Mathematics __label__Binary-Search Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note:  Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
__label__Mathematics Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example 1:  Input: a = 2, b = [3] Output: 8   Example 2: Input: a = 2, b = [1,0] Output: 1024
__label__Hash-Table On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp. Initially, some number of lamps are on.  lamps[i] tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess). For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0. After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).) Return an array of answers.  Each value answer[i] should be equal to the answer of the i-th query queries[i].   Example 1: Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]] Output: [1,0] Explanation:  Before performing the first query we have both lamps [0,0] and [4,4] on. The grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner: 1 1 1 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1 Then the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this: 1 0 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 1 1 Before performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.    Note:  1 <= N <= 10^9 0 <= lamps.length <= 20000 0 <= queries.length <= 20000 lamps[i].length == queries[i].length == 2
__label__Array Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition.    Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.    Note:  1 <= A.length <= 5000 0 <= A[i] <= 5000
__label__Data-Structures __label__Advanced-Data-Structures Consider a sequence, , and a polynomial of degree  defined as . You must perform  queries on the sequence, where each query is one of the following two types: 1 i x: Replace  with . 1 i x 2 l r: Consider the polynomial  and determine whether  is divisible by  over the field , where . In other words, check if there exists a polynomial  with integer coefficients such that each coefficient of  is divisible by . If a valid  exists, print Yes on a new line; otherwise, print No. 2 l r Yes No Given the values of , , , and  queries, perform each query in order. Input Format The first line contains four space-separated integers describing the respective values of  (the length of the sequence),  (a coefficient in ),  (a coefficient in ), and  (the number of queries).  The second line contains  space-separated integers describing .  Each of the  subsequent lines contains three space-separated integers describing a query of either type 1 or type 2. 1 2 Constraints  For query type 1:  and . 1 For query type 2: . 2   Output Format For each query of type 2, print Yes on a new line if  is a divisor of ; otherwise, print No instead. 2 Yes No Sample Input 0 Sample Output 0 Explanation 0 Given  and the initial sequence , we perform the following  queries:  is not a divisor of , so we print No on a new line. No Set  to , so . After the second query, . Because , we print Yes on a new line. Yes
__label__Array __label__Greedy-Algorithms In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the i-th domino, so that A[i] and B[i] swap values. Return the minimum number of rotations so that all the values in A are the same, or all the values in B are the same. If it cannot be done, return -1.   Example 1:  Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2] Output: 2 Explanation:  The first figure represents the dominoes as given by A and B: before we do any rotations. If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.  Example 2: Input: A = [3,5,1,2,3], B = [3,6,3,3,4] Output: -1 Explanation:  In this case, it is not possible to rotate the dominoes to make one row of values equal.    Note:  1 <= A[i], B[i] <= 6 2 <= A.length == B.length <= 20000
__label__Dynamic-Programming An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.     Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3]    Note:  1 <= graph.length <= 12 0 <= graph[i].length < graph.length
__label__Dynamic-Programming __label__Depth-first-Search You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.  Find out how many ways to assign symbols to make sum of integers equal to target S.    Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.   Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.
__label__Dynamic-Programming You are working at the cash counter at a fun-fair, and you have different types of coins available to you in infinite quantities. The value of each coin is already given. Can you determine the number of ways of making change for a particular number of units using the given types of coins?  For example, if you have  types of coins, and the value of each type is given as  respectively, you can make change for  units in three ways:  , , and . Function Description  Complete the getWays function in the editor below.  It must return an integer denoting the number of ways to make change.   getWays has the following parameter(s): n: an integer, the amount to make change for   c: an array of integers representing available denominations   Input Format The first line contains two space-separated integers describing the respective values of  and , where:   is the number of units   is the number of coin types  The second line contains  space-separated integers describing the respective values of each coin type :  (the list of distinct coins available in infinite amounts). Constraints    Each  is guaranteed to be distinct. Hints Solve overlapping subproblems using Dynamic Programming (DP):      You can solve this problem recursively but will not pass all the test cases without optimizing to eliminate the overlapping subproblems. Think of a way to store and reference previously computed solutions to avoid solving the same subproblem multiple times. * Consider the degenerate cases:      - How many ways can you make change for  cents?      - How many ways can you make change for  cents if you have no coins? * If you're having trouble defining your solutions store, then think about it in terms of the base case . - The answer may be larger than a -bit integer. Output Format Print a long integer denoting the number of ways we can get a sum of  from the given infinite supply of  types of coins. Sample Input 0 Sample Output 0 Explanation 0 There are four ways to make change for  using coins with values given by :      Thus, we print  as our answer. Sample Input 1 Sample Output 1 Explanation 1 There are five ways to make change for  units using coins with values given by :        Thus, we print  as our answer.
__label__Array __label__Two-Pointers Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.  It doesn't matter what values are set beyond the returned length.  Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Mathematics __label__Game-Theory Laurel and Hardy have  piles of chocolates with each pile containing some number of chocolates. The piles are arranged from left to right in a non decreasing order based on the number of chocolates in each pile. They play the following game.  For every continuous subsequence of chocolate piles (at least 2 piles form a subsequence), Laurel and Hardy will play game on this subsequence of chocolate piles, Laurel plays first, and they play in turn. In one move, the player can choose one of the piles and remove at least one chocolate from it, but the non-decreasing order of the chocolate piles must be maintained. The last person to make a valid move wins.  How many continuous subsequences of chocolate piles will Laurel win if both of them play optimally? The number of chocolates of each pile will be recovered after the game ends for each subsequences.  Input Format The first line contains an integer  denoting the number of piles.  The second line contains the number of chocolates in each pile, arranged from left to right and separated by a single space between them.  Constraints  ≤  ≤    ≤     ≤  Output Format A single integer denoting the number of continuous subsequences of chocolate piles in which Laurel will win. Sample Input 5 1 1 2 2 3  Sample Output 5  Explanation Of the 10 continuous-sub-sequence of chocolate piles,  Laurel loses in [1,1], [1,1,2], [1,1,2,2], [1,2,2,3], [2,2] and  wins in [1,1,2,2,3], [1,2], [1,2,2], [2,2,3] and [2,3] and hence 5.
__label__Dynamic-Programming Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: "aab" Output: 1 Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
__label__Depth-first-Search An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, "flood fill" the image.  To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1: Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.   Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].
__label__Tree __label__Depth-first-Search In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \ v   v 2-->3   Example 2: Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5 <- 1 -> 2      ^    |      |    v      4 <- 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.
__label__Mathematics __label__Dynamic-Programming We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.) Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.   Example 1: Input: D = ["1","3","5","7"], N = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.   Example 2: Input: D = ["1","4","9"], N = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.    Note:  D is a subset of digits '1'-'9' in sorted order. 1 <= N <= 10^9
__label__Mathematics Madam Hannah Otto, the CEO of Reviver Corp., is fond of palindromes, or words that read the same forwards or backwards. She thinks palindromic brand names are appealing to millennials.   As part of the marketing campaign for the company's new juicer called the Rotator™, Hannah decided to push the marketing team's palindrome-searching skills to a new level with a new challenge.   In this challenge, Hannah provides a string  consisting of lowercase English letters. Every day, for  days, she would select two integers  and , take the substring  (the substring of  from index  to index ), and ask the following question: Consider all the palindromes that can be constructed from some of the letters from . You can reorder the letters as you need. Some of these palindromes have the maximum length among all these palindromes. How many maximum-length palindromes are there?   For example, if ,  and , then we have,  Your job as the head of the marketing team is to answer all the queries. Since the answers can be very large, you are only required to find the answer modulo .   Complete the functions initialize and answerQuery and return the number of maximum-length palindromes modulo .  initialize answerQuery Input Format The first line contains the string . The second line contains a single integer . The  of the next  lines contains two space-separated integers ,  denoting the  and  values Anna selected on the  day.   Constraints Here,  denotes the length of .      Subtasks For 30% of the total score:    For 60% of the total score:   Output Format For each query, print a single line containing a single integer denoting the answer. Sample Input 0 Sample Output 0 Explanation 0 On the first day,  and . The maximum-length palindromes are "ewe" and "eke". On the second day,  and . The maximum-length palindrome is "ee".  Sample Input 1 Sample Output 1 Explanation 1 Here, the maximum-length palindromes are "abba" and "baab".
__label__Array You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix =  [   [1,2,3],   [4,5,6],   [7,8,9] ],  rotate the input matrix in-place such that it becomes: [   [7,4,1],   [8,5,2],   [9,6,3] ]  Example 2: Given input matrix = [   [ 5, 1, 9,11],   [ 2, 4, 8,10],   [13, 3, 6, 7],   [15,14,12,16] ],   rotate the input matrix in-place such that it becomes: [   [15,13, 2, 5],   [14, 3, 4, 1],   [12, 6, 8, 9],   [16, 7,10,11] ]
__label__Array Implement a SnapshotArray that supports the following interface:  SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0. void set(index, val) sets the element at the given index to be equal to val. int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1. int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id    Example 1: Input: ["SnapshotArray","set","snap","set","get"] [[3],[0,5],[],[0,6],[0,0]] Output: [null,null,0,null,5] Explanation:  SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3 snapshotArr.set(0,5);  // Set array[0] = 5 snapshotArr.snap();  // Take a snapshot, return snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5   Constraints:  1 <= length <= 50000 At most 50000 calls will be made to set, snap, and get. 0 <= index < length 0 <= snap_id < (the total number of times we call snap()) 0 <= val <= 10^9
__label__Greedy-Algorithms You are given an unordered array of unique integers incrementing from .  You can swap any two elements a limited number of times.  Determine the largest lexicographical value array that can be created by executing no more than the limited number of swaps.   For example, if  and the maximum swaps , the following arrays can be formed by swapping the  with the other elements:   The highest value of the four (including the original) is .  If , we can swap to the highest possible value: . Function Description  Complete the largestPermutation function in the editor below.  It must return an array that represents the highest value permutation that can be formed.   largestPermutation has the following parameter(s):   k: an integer that represents the limit of swaps   arr: an array of integers   Input Format The first line contains two space-separated integers  and , the length of  and the maximum swaps that can be performed. The second line contains  unique space-separated integers  where . Constraints     Output Format Print the lexicographically largest permutation you can make with at most  swaps.  Sample Input 0  5 1 4 2 3 5 1  Sample Output 0  5 2 3 4 1  Explanation 0  You can swap any two numbers in  and see the largest permutation is  Sample Input 1 3 1 2 1 3  Sample Output 1  3 1 2  Explanation 1  With 1 swap we can get ,  and .  Of these,  is the largest permutation.   Sample Input 2 2 1 2 1  Sample Output 2  2 1  Explanation 2  We can see that  is already the largest permutation.  We don't make any swaps.
__label__Mathematics Given a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and N only contains the digit 1. Return the length of N.  If there is no such N, return -1.   Example 1: Input: 1 Output: 1 Explanation: The smallest answer is N = 1, which has length 1. Example 2: Input: 2 Output: -1 Explanation: There is no such positive integer N divisible by 2. Example 3: Input: 3 Output: 3 Explanation: The smallest answer is N = 111, which has length 3.   Note:  1 <= K <= 10^5
__label__Game-Theory Alice and Bob are playing a game with a rooted tree. The tree has  vertices and the first node, , is always the root. Here are the basic rules: They move in alternating turns, and both players always move optimally. During each move, a player removes an edge from the tree, disconnecting one of its leaves or branches. The leaf or branch that was disconnected from the rooted tree is removed from the game.  The first player to be unable to make a move loses the game. Alice always makes the first move.  For example, the diagram below shows a tree of size , where the root is node :  Now, if a player removes the edge between  and , then nodes  and  become disconnected from the root and are removed from the game:  Given the structure of the tree, determine and print the winner of the game. If Alice wins, print ; otherwise print . Input Format The first line contains a single integer, , denoting the number of test cases.  For each test case, the first line contains an integer, , denoting the number of nodes in the tree.  Each of the  subsequent lines contains  space-separated integers,  and , defining an edge connecting nodes  and . Constraints    Output Format For each test case, print the name of the winner (i.e.,  or ) on a new line. Sample Input 1 5 1 2 3 1 3 4 4 5  Sample Output Alice  Explanation Test Case 0: Alice removes the edge connecting node  to node , effectively trimming nodes  and  from the tree. Now the only remaining edges are  and . Because Bob can't remove both of them, Alice will make the last possible move. Because the last player to move wins, we print  on a new line.
__label__Graph-Algorithms __label__Bit __label__Graph-Algorithms Consider an undirected graph containing  nodes and  edges. Each edge  has an integer cost, , associated with it. The penalty of a path is the bitwise OR of every edge cost in the path between a pair of nodes,  and . In other words, if a path contains edges , then the penalty for this path is  OR  OR ... OR . Given a graph and two nodes,  and , find the path between  and  having the minimal possible penalty and print its penalty; if no such path exists, print  to indicate that there is no path from  to . Note: Loops and multiple edges are allowed. The bitwise OR operation is known as or in Pascal and as | in C++ and Java. Input Format The first line contains two space-separated integers,  (the number of nodes) and  (the number of edges), respectively. Each line  of the  subsequent lines contains three space-separated integers , , and , respectively, describing edge  connecting the nodes  and  and its associated penalty (). The last line contains two space-separated integers,  (the starting node) and  (the ending node), respectively. Constraints       Output Format Print the minimal penalty for the optimal path from node  to node ; if no path exists from node  to node , print . Sample Input 3 4 1 2 1 1 2 1000 2 3 3 1 3 100 1 3  Sample Output 3  Explanation The optimal path is .   and .  The penalty for this path is:  OR , so we print .
__label__Greedy-Algorithms Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.     Example 1: Input: [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.  Example 2: Input: [[1,2],[1,2],[1,2]] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.  Example 3: Input: [[1,2],[2,3]] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping.    Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
__label__Game-Theory Nim is the most famous two-player algorithm game. The basic rules for this game are as follows: The game starts with a number of piles of stones.  The number of stones in each pile may not be equal. The players alternately pick up  or more stones from  pile The player to remove the last stone wins. For example, there are  piles of stones having  stones in them.  Play may proceed as follows: Player  Takes           Leaving                         pile=[3,2,4] 1       2 from pile[1]  pile=[3,4] 2       2 from pile[1]  pile=[3,2] 1       1 from pile[0]  pile=[2,2] 2       1 from pile[0]  pile=[1,2] 1       1 from pile[1]  pile=[1,1] 2       1 from pile[0]  pile=[0,1] 1       1 from pile[1]  WIN  Given the value of  and the number of stones in each pile, determine the game's winner if both players play optimally. Function Desctription  Complete the nimGame function in the editor below.  It should return a string, either First or Second.   First Second nimGame has the following parameter(s):   pile: an integer array that represents the number of stones in each pile   Input Format The first line contains an integer, , denoting the number of games they play. Each of the next  pairs of lines is as follows:   The first line contains an integer , the number of piles. The next line contains  space-separated integers , the number of stones in each pile. Constraints    Player 1 always goes first. Output Format For each game, print the name of the winner on a new line (i.e., either First or Second). First Second Sample Input 2 2 1 1 3 2 1 4  Sample Output Second First  Explanation In the first case, there are  piles of  stones.  Player  has to remove one pile on the first move.  Player  removes the second for a win. In the second case, there are  piles of  stones.  If player  removes any one pile, player  can remove all but one of another pile and force a win.  If player  removes less than a pile, in any case, player  can force a win as well, given optimal play.
__label__Array __label__Two-Pointers Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:  You must do this in-place without making a copy of the array. Minimize the total number of operations.
__label__Graph-Algorithms You are given an array with  -bit integers: . BIT(x, i) = (x >> i) & 1. (where  is the  lower bit of  in binary form.) If we regard every bit as a vertex of a graph G, there exists one undirected edge between vertex  and vertex  if there exists at least one k such that BIT(d[k], i) == 1 && BIT(d[k], j) == 1. For every subset of the input array, how many  connected-components are there in that graph? The number of connected-components in a graph are the sets of nodes, which are accessible to each other, but not to/from the nodes in any other set.   For example if a graph has six nodes, labelled . And contains the edges . There are three connected-components: ,  and . Because  can be accessed from each other through one or more edges,  can access each other and  is isolated from everone else.   You only need to output the sum of the number of connected-component() in every graph. Input Format n d[0] d[1] ... d[n - 1]  Constraints    Output Format Print the value of .
__label__Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.  Example: Input: The root of a Binary Search Tree like this:               5             /   \            2     13  Output: The root of a Greater Tree like this:              18             /   \           20     13
__label__Dynamic-Programming Alex and Lee continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.  Alex and Lee take turns, with Alex starting first.  Initially, M = 1. On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). The game continues until all the stones have been taken. Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get.   Example 1: Input: piles = [2,7,9,4,4] Output: 10 Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger.     Constraints:  1 <= piles.length <= 100 1 <= piles[i] <= 10 ^ 4
__label__Mathematics Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.               Since 2 has only one digit, return it.  Follow up: Could you do it without any loop/recursion in O(1) runtime?
__label__Array On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move.   Example 1:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  In this example the rook is able to capture all the pawns.  Example 2:  Input: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 0 Explanation:  Bishops are blocking the rook to capture any pawn.  Example 3:  Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]] Output: 3 Explanation:  The rook can capture the pawns at positions b5, d6 and f5.    Note:  board.length == board[i].length == 8 board[i][j] is either 'R', '.', 'B', or 'p' There is exactly one cell with board[i][j] == 'R'
__label__Strings International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = ["gin", "zen", "gig", "msg"] Output: 2 Explanation:  The transformation of each word is: "gin" -> "--...-." "zen" -> "--...-." "gig" -> "--...--." "msg" -> "--...--."  There are 2 different transformations, "--...-." and "--...--.".  Note:  The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters.
__label__Array __label__Binary-Search Implementing the class MajorityChecker, which has the following API:  MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr; int query(int left, int right, int threshold) has arguments such that: 	 0 <= left <= right < arr.length representing a subarray of arr; 2 * threshold > right - left + 1, ie. the threshold is always a strict majority of the length of the subarray    Each query(...) returns the element in arr[left], arr[left+1], ..., arr[right] that occurs at least threshold times, or -1 if no such element exists.   Example: MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // returns 1 majorityChecker.query(0,3,3); // returns -1 majorityChecker.query(2,3,2); // returns 2    Constraints:  1 <= arr.length <= 20000 1 <= arr[i] <= 20000 For each query, 0 <= left <= right < len(arr) For each query, 2 * threshold > right - left + 1 The number of queries is at most 10000
__label__Graph-Algorithms HackerRank is starting a bus service in MountainView, California. The bus starts at time T = 0 at station1 and goes through station2, station3, station4 in that order and reaches the headquarters located at stationn. At every station, the bus waits for various commuters to arrive before it departs to the next station. Ignoring the acceleration, the bus moves at 1 meter / second. i.e., if stationi and stationj are 1000 meters apart, the bus takes 1000 seconds to travel from stationi to stationj.  The bus is equipped with K units of Nitro (N2O). If going from stationi to stationj takes x seconds, then using t units of nitro can decrease the time taken to max(x-t, 0) seconds where max(a,b) denotes the greater of the two values between a & b. The Nitro can be used all at once or in multiples of 1 unit.  If the bus driver travels optimally, what is the minimum sum of travelling time for all commuters? The travelling time equals to the time he/she arrived at the destination minus the time he/she arrived the start station.  Please remember that the driver must take all passengers to their destination.   Input Format The first line contains 3 space separated integers n, m and K which indicate the number of stations, total number of people who board the bus at various stations and the total units of Nitro (N2O) present in the bus.   The second line contains n-1 space separated integers where the ith integer indicates the distance between station(i-1) to stationi.   m lines follow each containing 3 space separated integers. The ith line contains ti, si and ei in that order indicating the arrival time of the commuter at si at time ti with his destination being ei.  n m K   d1 d2 ... dn-1   // di: the distance between station_i to station_(i+1). t1 s1 e1         // commuter 1 arrives at his boarding point at s1 and his destination is e1 t2 s2 e2 ... tm sm em  Constraints 0 < n <= 100000  0 < m <= 100000  0 <= K <= 10000000  0 < di <= 100  0 <= ti <= 10000000  1 <= si < ei <= n   Output Format The minimal total travel time.  Sample Input 3 3 2 1 4 1 1 3 2 1 2 5 2 3  Sample Output 9  Explanation The bus waits for the 1st and the 2nd commuter to arrive at station1 and travels to station2 carrying 2 passengers. The travel time from station1 to station2 is 1 second. It then waits for the 3rd commuter to board the bus at time = 5, 2nd commuter deboards the bus. The 3rd commuter boards the bus at t = 5. The bus now uses 2 units of nitro, this reduces the commute time to travel to station3 from 4 to 2.  Hence, the total time spent by each of the passengers on the bus is  1 (time spent waiting for commuter 2) + 1 (travel time from station1 to station2) + 2 (time spent waiting for commuter 3) + 2 (travel time from station2 to station3) = 6 1 (travel time from station1 to station2) 2 (travel time from station2 to station3) 6+1+2 = 9 2 (travel time from station2 to station3) 6+1+2 = 9 hence the answer.  Timelimits Timelimits for this challenge can be seen here
__label__Dynamic-Programming __label__Strings __label__Mathematics Given a string consisting of the letters ,  and , we can perform the following operation:  Take any two adjacent distinct characters and replace them with the third character.  Find the shortest string obtainable through applying this operation repeatedly.   For example, given the string  we can reduce it to a  character string by replacing  with  and  with : .   Function Description  Complete the stringReduction function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.   stringReduction has the following parameter:  - s: a string   Input Format The first line contains the number of test cases .   Each of the next  lines contains a string  to process. Constraints   Output Format For each test case, print the length of the resultant minimal string on a new line.   Sample Input 3   cab   bcab   ccccc  Sample Output 2   1   5  Explanation For the first case, there are two solutions:   or .  For the second case, one optimal solution is: .  For the third case, no operations can be performed so the answer is .
__label__Dynamic-Programming In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.    Example 1: Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”    Example 2: Input: Array = {"10", "0", "1"}, m = 1, n = 1 Output: 2  Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head node of a linked list and a specific position. Counting backwards from the tail node of the linked list, get the value of the node at the given position. A position of 0 corresponds to the tail, 1 corresponds to the node before the tail and so on. Input Format You have to complete the int getNode(SinglyLinkedListNode* head, int positionFromTail) method which takes two arguments - the head of the linked list and the position of the node from the tail. positionFromTail will be at least 0 and less than the number of nodes in the list. You should NOT read any input from stdin/console.  int getNode(SinglyLinkedListNode* head, int positionFromTail) The first line will contain an integer , the number of test cases.  Each test case has the following format:  The first line contains an integer , the number of elements in the linked list.  The next  lines contains, an element each denoting the element of the linked list.  The last line contains an integer  denoting the position from the tail, whose value needs to be found out and returned.    Constraints     , where  is the  element of the linked list.    Output Format Find the node at the given position counting backwards from the tail. Then return the data contained in this node. Do NOT print anything to stdout/console. return data The code in the editor handles output.  For each test case, print the value of the node, each in a new line.   Sample Input 2 1 1 0 3 3 2 1 2  Sample Output 1 3  Explanation In first case, there is one element in linked list with value 1. Hence, last element is 1. In second case, there are 3 elements with values 3, 2 and 1 (3 -> 2 -> 1). Hence, element with position of 2 from tail is 3.
__label__Strings Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: "Hello, my name is John" Output: 5
__label__Dynamic-Programming __label__Graph-Algorithms You are playing a game of Nim with a friend. The rules are are follows: 1) Initially, there are N piles of stones. Two players play alternately. 2) In each turn, a player can choose one non empty pile and remove any number of stones from it. At least one stone must be removed. 3) The player who picks the last stone from the last non empty pile wins the game. It is currently your friend's turn. You suddenly realize that if your friend was to play optimally in that position, you would lose the game. So while he is not looking, you decide to cheat and add some (possibly 0) stones to each pile. You want the resultant position to be such that your friend has no guaranteed winning strategy, even if plays optimally. You cannot create a new pile of stones. You can only add stones, and not remove stones from a pile. What is the least number of stones you need to add? Input Format The first line contains the number of cases T. T cases follow. Each case contains the number N on the first line followed by N numbers on the second line. The ith number denotes si, the number of stones in the ith pile currently. Constraints 1 <= T <= 20 2 <= N <= 15 1 <= si < 1000000000 (10^9) Output Format Output T lines, containing the answer for each case. If the current position is already losing for your friend, output 0. Sample Input 3 2 1 3 3 1 1 1 4 10 4 5 1 Sample Output 2 3 6 Explanation For the first case, add 2 stones to the first pile. Then, both piles will have 3 stones each. It is easy to verify that your friend cannot win the game unless you make a mistake. For the second case, add 1 stone to the first pile, and 2 stones to the second pile.
__label__Tree __label__Depth-first-Search Given a binary tree with N nodes, each node has a different value from {1, ..., N}. A node in this binary tree can be flipped by swapping the left child and the right child of that node. Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree. (Recall that a preorder traversal of a node means we report the current node's value, then preorder-traverse the left child, then preorder-traverse the right child.) Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given. If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order. If we cannot do so, then return the list [-1].    Example 1:  Input: root = [1,2], voyage = [2,1] Output: [-1]   Example 2:  Input: root = [1,2,3], voyage = [1,3,2] Output: [1]   Example 3:  Input: root = [1,2,3], voyage = [1,2,3] Output: []    Note:  1 <= N <= 100
__label__Hash-Table __label__Dynamic-Programming Given a list of words, each word consists of English lowercase letters. Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, "abc" is a predecessor of "abac". A word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on. Return the longest possible length of a word chain with words chosen from the given list of words.   Example 1: Input: ["a","b","ba","bca","bda","bdca"] Output: 4 Explanation: one of the longest word chain is "a","ba","bda","bdca".    Note:  1 <= words.length <= 1000 1 <= words[i].length <= 16 words[i] only consists of English lowercase letters.
__label__Array Students are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)   Example 1: Input: [1,1,4,2,1,3] Output: 3 Explanation:  Students with heights 4, 3 and the last 1 are not standing in the right positions.    Note:  1 <= heights.length <= 100 1 <= heights[i] <= 100
__label__Dynamic-Programming __label__Data-Structures You have two arrays of integers,  and , where both have  number of elements. Consider the following function: score = 0  int Go(step, energy) {     if (step == N) {         score += V[step];         return (score);     }     else {         int way = random(1, 2);         if (way == 1) {             score += V[step];         }         else {             energy = P[step];         }         if (energy > 0) {             Go(step + 1, energy - 1);         }         else {             KillTheWorld();         }     } }  What is the maximum possible value of score that we can get in the end, if we call ?.  Note that the function should never invoke KillTheWorld function. And  generates a random integer from set  [1, 2].  It is guaranteed there will be a solution that wont kill the world. Input Format The first line contains an integer N. Each of the following N lines contains a pair of integers. The i-th line contains a pair of numbers, , separated by space.   Constraints       Output Format Derive the maximum score given by return (score);. return (score); Sample Input 4 4 2 0 2 4 0 3 4  Sample Output 7  Explanation In the best case, the first and second function call in Go variable  will take value 2, while in the other calls it will be equal to 1 then the final score will be equal to the value of 7.
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.  You’re given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer, insert this node at the head of the linked list and return the new head node. The head pointer given may be null meaning that the initial list is empty. Input Format You have to complete the SinglyLinkedListNode Insert(SinglyLinkedListNode head, int data) method which takes two arguments - the head of the linked list and the integer to insert. You should NOT read any input from stdin/console.   SinglyLinkedListNode Insert(SinglyLinkedListNode head, int data) The input is handled by code in the editor and is as follows:   The first line contains an integer , denoting the number of elements to be inserted at the head of the list.  The next  lines contain an integer each, denoting the element to be inserted.   Constraints     Output Format Insert the new node at the head and return the head of the updated linked list. Do NOT print anything to stdout/console. return The output is handled by the code in the editor and it is as follows: Print the elements of linked list from head to tail, each in a new line. Sample Input 5 383 484 392 975 321  Sample Output 321 975 392 484 383  Explanation Intially the list in NULL. After inserting 383, the list is 383 -> NULL.  After inserting 484, the list is 484 -> 383 -> NULL.  After inserting 392, the list is 392 -> 484 -> 383 -> NULL.  After inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.  After inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.
__label__Game-Theory Nim is a famous game in which two players take turns removing items from  distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player removes the last item from the last non-empty pile. John and Kate modified Nim by adding the following rule, which they call a Zero-Move: For each non-empty pile, either player can remove  items from that pile and have it count as their move; however, this move can only be performed once per pile by either player. For example, let's say pile  initially has  items in it. If John decides to use a Zero-Move on pile , then neither John nor Kate can perform another Zero-Move on pile ; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet. John and Kate play  games of Zero-Move Nim. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print W on a new line if John can win; otherwise, print L instead. W L Input Format The first line contains an integer, , denoting the number of games. The  subsequent lines describe each game over two lines: The first line contains an integer, , denoting the number of heaps. The second line contains  space-separated integers describing .  Constraints       Subtasks  For  of the test cases,   For  of the test cases,  Output Format For each game, print W on a new line if John will win; otherwise, print L instead. W L Sample Input 0 Sample Output 0 Explanation 0 John and Kate play the following  games: We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. We have two piles,  and . John removes  item from , so . Now that there is only  item in each pile, gameplay can proceed in either of the following ways: Kate removes the last object from one pile, then John removes the last object from the other pile. Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.           Because John always wins in either scenario, we print W on a new line. W John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios: If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move). If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile. If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.       Because John always loses this game, we print L on a new line. L
__label__Hash-Table You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A". Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3  Example 2: Input: J = "z", S = "ZZ" Output: 0  Note:  S and J will consist of letters and have length at most 50. The characters in J are distinct.
__label__Strings Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: Input: 12 Output: 21    Example 2: Input: 21 Output: -1
__label__Mathematics You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]). Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape. Return True if and only if it is possible to escape. Example 1: Input:  ghosts = [[1, 0], [0, 3]] target = [0, 1] Output: true Explanation:  You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.  Example 2: Input:  ghosts = [[1, 0]] target = [2, 0] Output: false Explanation:  You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.  Example 3: Input:  ghosts = [[2, 0]] target = [1, 0] Output: false Explanation:  The ghost can reach the target at the same time as you.  Note:  All points have coordinates with absolute value <= 10000. The number of ghosts will not exceed 100.
__label__Depth-first-Search On a 2-dimensional grid, there are 4 types of squares:  1 represents the starting square.  There is exactly one starting square. 2 represents the ending square.  There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over.  Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.    Example 1: Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths:  1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)  Example 2: Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths:  1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)  Example 3: Input: [[0,1],[2,0]] Output: 0 Explanation:  There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid.       Note:  1 <= grid.length * grid[0].length <= 20
__label__Dynamic-Programming We call a sequence of N natural numbers (a1, a2, ..., aN) a P-sequence, if the product of any two adjacent numbers in it is not greater than P. In other words, if a sequence (a1, a2, ..., aN) is a P-sequence, then ai * ai+1 ≤ P ∀ 1 ≤ i < N N P You are given N and P. Your task is to find the number of such P-sequences of N integers modulo 109+7. N P N Input Format The first line of input consists of N  The second line of the input consists of P.  N P Constraints 2 ≤ N ≤ 103  1 ≤ P ≤ 109  1 ≤ ai  Output Format Output the number of P-sequences of N integers modulo 109+7. N Sample Input 0 Sample Output 0 Explanation 0 3 such sequences are {1,1},{1,2} and {2,1}
__label__Greedy-Algorithms Mark and Jane are very happy after having their first child. Their son loves toys, so Mark wants to buy some. There are a number of different toys lying in front of him, tagged with their prices.  Mark has only a certain amount to spend, and he wants to maximize the number of toys he buys with this money. Given a list of prices and an amount to spend, what is the maximum number of toys Mark can buy?  For example, if  and Mark has  to spend, he can buy items  for , or  for  units of currency.  He would choose the first group of  items. Function Description Complete the function maximumToys in the editor below.  It should return an integer representing the maximum number of toys Mark can purchase.   maximumToys has the following parameter(s):   prices:  an array of integers representing toy prices   k:  an integer, Mark's budget Input Format The first line contains two integers,  and , the number of priced toys and the amount Mark has to spend.  The next line contains  space-separated integers   Constraints       A toy can't be bought multiple times. Output Format An integer that denotes the maximum number of toys Mark can buy for his son. Sample Input 7 50 1 12 5 111 200 1000 10  Sample Output 4  Explanation He can buy only  toys at most. These toys have the following prices: .
__label__Hash-Table __label__Two-Pointers __label__Binary-Search Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note:  Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  Follow up:  What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
__label__Mathematics There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)    Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.   Note:  1 <= p <= 1000 0 <= q <= p
__label__Mathematics Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
__label__Dynamic-Programming You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height. You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.   Example 1: Input: [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.   Example 2: Input: [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.    Example 3: Input: [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0.     Note:  0 <= rods.length <= 20 1 <= rods[i] <= 1000 The sum of rods is at most 5000.
__label__Data-Structures Tieu owns a pizza restaurant and he manages it in his own way.  While in a normal restaurant, a customer is served by following the first-come, first-served rule, Tieu simply minimizes the average waiting time of his customers. So he gets to decide who is served first, regardless of how sooner or later a person comes.  Different kinds of pizzas take different amounts of time to cook. Also, once he starts cooking a pizza, he cannot cook another pizza until the first pizza is completely cooked. Let's say we have three customers who come at time t=0, t=1, & t=2 respectively, and the time needed to cook their pizzas is 3, 9, & 6 respectively. If Tieu applies first-come, first-served rule, then the waiting time of three customers is 3, 11, & 16  respectively. The average waiting time in this case is (3 + 11 + 16) / 3 = 10. This is not an optimized solution. After serving the first customer at time t=3, Tieu can choose to serve the third customer. In that case, the waiting time will be 3, 7, & 17 respectively. Hence the average waiting time is (3 + 7 + 17) / 3 = 9. Help Tieu achieve the minimum average waiting time. For the sake of simplicity, just find the integer part of the minimum average waiting time. Input Format The first line contains an integer N, which is the number of customers.  In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.   The  customer is not the customer arriving at the  arrival time.  The  customer is not the customer arriving at the  arrival time.  Output Format Display the integer part of the minimum average waiting time. Constraints 1 ≤ N ≤ 105 0 ≤ Ti ≤ 109 1 ≤ Li ≤ 109 Note The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served. Cook does not know about the future orders. Cook does not know about the future orders. Sample Input #00 3 0 3 1 9 2 6  Sample Output #00 9  Sample Input #01 3 0 3 1 9 2 5  Sample Output #01 8  Explanation #01 Let's call the person ordering at time = 0 as A, time = 1 as B and time = 2 as C. By delivering pizza for A, C and B we get the minimum average wait time to be  (3 + 6 + 16)/3 = 25/3 = 8.33   the integer part is 8 and hence the answer.  8
__label__Mathematics Given a column title as appear in an Excel sheet, return its corresponding column number. For example:     A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...  Example 1: Input: "A" Output: 1  Example 2: Input: "AB" Output: 28  Example 3: Input: "ZY" Output: 701
__label__Mathematics Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number. In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:  <IntegerPart> (e.g. 0, 12, 123) <IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001) <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))  The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example: 1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66) Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.   Example 1: Input: S = "0.(52)", T = "0.5(25)" Output: true Explanation: Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.   Example 2: Input: S = "0.1666(6)", T = "0.166(66)" Output: true   Example 3: Input: S = "0.9(9)", T = "1." Output: true Explanation:  "0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.] "1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".     Note:  Each part consists only of digits. The <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.) 1 <= <IntegerPart>.length <= 4  0 <= <NonRepeatingPart>.length <= 4  1 <= <RepeatingPart>.length <= 4
__label__Graph-Algorithms The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two "somewhat near" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as "somewhat near" each other. Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this? Input Format The first line contains the number of test cases T. T test cases follow. The first line contains N, the number of cities in Byteland. The following N - 1 lines contain the description of the roads. The ith line contains two integers ai and bi, meaning that there was originally a road connecting cities with numbers ai and bi. Constraints 1 <= T <= 20  1 <= N <= 10000  0 <= ai,bi < N   Output Format Output T lines, one corresponding to each test case containing the required answer for that test case. Since the answers can be huge, output them modulo 1000000007. Sample Input 2  3  0 1  1 2  5  0 1  1 2  2 3  2 4 Sample Output 2  4 Explanation For the first case, a new road was build between cities 0 and 2. Now, the salesman has two tour possibilities: 0-1-2-0 or 0-2-1-0.
__label__Graph-Algorithms __label__Mathematics __label__Greedy-Algorithms You're researching friendships between groups of  new college students where each student is distinctly numbered from  to . At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: Bidirectional. If student  is friends with student , then student  is also friends with student . Transitive. If student  is friends with student  and student  is friends with student , then student  is friends with student . In other words, two students are considered to be friends even if they are only indirectly linked through a network of mutual (i.e., directly connected) friends.  The purpose of your research is to find the maximum total value of a group's friendships, denoted by . Each time a direct friendship forms between two students, you sum the number of friends that each of the  students has and add the sum to .  You are given  queries, where each query is in the form of an unordered list of  distinct direct friendships between  students. For each query, find the maximum value of  among all possible orderings of formed friendships and print it on a new line. Input Format The first line contains an integer, , denoting the number of queries. The subsequent lines describe each query in the following format: The first line contains two space-separated integers describing the respective values of  (the number of students) and  (the number of distinct direct friendships). Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  (where ) describing a friendship between student  and student . Constraints       Output Format For each query, print the maximum value of  on a new line. Sample Input 0 Sample Output 0 Explanation 0  The value of  is maximal if the students form the  direct friendships in the following order: Students  and  become friends:   We then sum the number of friends that each student has to get . Students  and  become friends:   We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . Students  and  become friends:    We then sum the number of friends that each student has to get . When we add the sums from each step, we get . We then print  on a new line.
__label__Array __label__Greedy-Algorithms Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks.   Example: Input: tasks = ["A","A","A","B","B","B"], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.    Note:  The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100].
__label__Game-Theory __label__Game-Theory Two people are playing Nimble! The rules of the game are: The game is played on a line of  squares, indexed from  to . Each square  (where ) contains  coins. For example:   The players move in alternating turns. During each move, the current player must  remove exactly  coin from square  and move it to square  if and only if . The game ends when all coins are in square  and nobody can make a move. The first player to have no available move loses the game. Given the value of  and the number of coins in each square, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of squares.  space-separated integers, , where each  describes the number of coins at square . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either  or ). Sample Input 2 5 0 2 3 0 6 4 0 0 0 0  Sample Output First Second  Explanation Explanation for  testcase:  The first player will shift one coin from  to . Hence, the second player is left with the squares . Now whatever be his/her move is, the first player can always nullify the change by shifting a coin to the same square where he/she shifted it. Hence the last move is always played by the first player, so he wins.  Exlanation for  testcase:  There are no coins in any of the squares so the first player cannot make any move, hence second player wins.
__label__Data-Structures __label__Advanced-Data-Structures White Falcon was amazed by what she can do with heavy-light decomposition on trees. As a resut, she wants to improve her expertise on heavy-light decomposition. Her teacher gave her an another assignment which requires path updates. As always, White Falcon needs your help with the assignment. You are given a tree with  nodes and each node's value  is initially . Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   The problem asks you to operate the following two types of queries on the tree: "1 u v x" Add  to ,  to ,  to , ...,   to .  "2 u v" print the sum of the nodes' values on the path between  and  at modulo . Input Format First line cosists of two integers  and  seperated by a space. Following  lines contains two integers which denote the undirectional edges of the tree. Following  lines contains one of the query types described above. Note: Nodes are numbered by using 0-based indexing.  Constraints   Output Format For every query of second type print a single integer. Sample Input 3 2 0 1 1 2 1 0 2 1 2 1 2  Sample Output 5  Explanation After the first type of query, . Hence the answer of the second query is .
__label__Tree __label__Depth-first-Search An undirected, connected tree with N nodes labelled 0...N-1 and N-1 edges are given. The ith edge connects nodes edges[i][0] and edges[i][1] together. Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes. Example 1: Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation:  Here is a diagram of the given tree:   0  / \ 1   2    /|\   3 4 5 We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.  Note: 1 <= N <= 10000
__label__Array __label__Mathematics Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6    Example 2: Input: [1,2,3,4] Output: 24    Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.
__label__Graph-Algorithms __label__Mathematics __label__Data-Structures One day Bob drew a tree, , with  nodes and  edges on a piece of paper. He soon discovered that parent of a node depends on the root of the tree. The following images shows an example of that:  Learning the fact, Bob invented an exciting new game and decided to play it with Alice. The rules of the game is described below: Bob picks a random node to be the tree's root and keeps the identity of the chosen node a secret from Alice. Each node has an equal probability of being picked as the root. Alice then makes a list of  guesses, where each guess is in the form u v and means Alice guesses that  is true. It's guaranteed that an undirected edge connecting  and  exists in the tree.  u v For each correct guess, Alice earns one point. Alice wins the game if she earns at least  points (i.e., at least  of her guesses were true). Alice and Bob play  games. Given the tree, Alice's guesses, and the value of  for each game, find the probability that Alice will win the game and print it on a new line as a reduced fraction in the format p/q. p/q Input Format The first line contains an integer, , denoting the number of different games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of nodes in the tree. The  subsequent lines contain two space-separated integers,  and , defining an undirected edge between nodes  and .  The next line contains two space-separated integers describing the respective values of  (the number of guesses) and  (the minimum score needed to win). Each of the  subsequent lines contains two space-separated integers,  and , indicating Alice guesses . Constraints     The sum of  over all test cases won't exceed . No two guesses will be identical.  Scoring For  of the maximum score, . For  of the maximum score, . Output Format Print the probability as a reduced fraction in the format p/q. p/q Note: Print 0/1 if the probability is  and print 1/1 if the probability is . 0/1 1/1 Sample Input 0 Sample Output 0 Explanation 0 Alice and Bob play the following  games: Alice makes two guesses,  and , meaning she guessed that  and . To win the game, at least  of her guesses must be true. In the diagrams below, you can see that at least  guesses are true if the root of the tree is either node  or :  There are  nodes in total and the probability of picking node  or  as the root is , which reduces to . Alice makes two guesses,  and , meaning she guessed that  and . To win the game, at least  of her guesses must be true. In the diagrams below, you can see that at least  guesses are true if the root of the tree is either node  or :  There are  nodes in total and the probability of picking node  or  as the root is , which reduces to . In this game, Alice only wins if node  is the root of the tree. There are  nodes in total, and the probability of picking node  as the root is .
__label__Mathematics Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true  Explanation: 20 = 1  Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false
__label__Hash-Table __label__Binary-Search Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.) Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is "".)   Example 1: Input: "banana" Output: "ana"  Example 2: Input: "abcd" Output: ""    Note:  2 <= S.length <= 10^5 S consists of lowercase English letters.
__label__Two-Pointers Given a string s that consists of only uppercase English letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character. Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations. Note: Both the string's length and k will not exceed 104. Example 1: Input: s = "ABAB", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.    Example 2: Input: s = "AABABBA", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA". The substring "BBBB" has the longest repeating letters, which is 4.
__label__Binary-Search __label__Greedy-Algorithms A string is a valid parentheses string (denoted VPS) if and only if it consists of "(" and ")" characters only, and:  It is the empty string, or It can be written as AB (A concatenated with B), where A and B are VPS's, or It can be written as (A), where A is a VPS.  We can similarly define the nesting depth depth(S) of any VPS S as follows:  depth("") = 0 depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's depth("(" + A + ")") = 1 + depth(A), where A is a VPS.  For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.   Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length). Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.   Example 1: Input: seq = "(()())" Output: [0,1,1,1,1,0]  Example 2: Input: seq = "()(())()" Output: [0,0,0,1,1,0,1,1]    Constraints:  1 <= seq.size <= 10000
__label__Dynamic-Programming The King of Byteland wants to grow his territory by conquering  other countries. To prepare his  heirs for the future, he decides they must work together to capture each country.  The King has an army, , of  battalions; the  battalion has  soldiers. For each battle, the heirs get a detachment of soldiers to share but will fight amongst themselves and lose the battle if they don't each command the same number of soldiers (i.e.: the detachment must be divisible by ). If given a detachment of size , the heirs will fight alone without any help. The battalions chosen for battle must be selected in the following way: A subsequence of  battalions must be selected (from the  battalions in army ).  The  battle will have a squad of soldiers from the  selected battalion such that its size is divisible by .  The soldiers within a battalion have unique strengths. For a battalion of size , the detachment of soldiers  is different from the detachment of soldiers  The King tasks you with finding the number of ways of selecting  detachments of battalions to capture  countries using the criterion above. As this number may be quite large, print the answer modulo . Input Format The first line contains two space-separated integers,  (the number of battalions in the King's army) and  (the number of countries to conquer), respectively. The second line contains  space-separated integers describing the King's army, , where the  integer denotes the number of soldiers in the  battalion ().  Constraints     holds for test cases worth at least  of the problem's score. Output Format Print the number of ways of selecting the  detachments of battalions modulo . Sample Input 3 2 3 4 5  Sample Output 20  Explanation First, we must find the ways of selecting  of the army's  battalions; then we must find all the ways of selecting detachments for each choice of battalion.  Battalions :   has  soldiers, so the only option is an empty detachment ().   has  soldiers, giving us  detachment options ( and ).  So for this subset of battalions, we get  possible detachments. Battalions :   has  soldiers, so the only option is an empty detachment ().   has  soldiers, giving us  detachment options (, , , , , ). So for this subset of battalions, we get  possible detachments. Battalions :   has  soldiers, giving us  detachment options ( and ).   has  soldiers, giving us  detachment options (, , , , , ).  So for this subset of battalions, we get  possible detachments. In total, we have  ways to choose detachments, so we print , which is .
__label__Binary-Search Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.  Letters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.  Examples: Input: letters = ["c", "f", "j"] target = "a" Output: "c"  Input: letters = ["c", "f", "j"] target = "c" Output: "f"  Input: letters = ["c", "f", "j"] target = "d" Output: "f"  Input: letters = ["c", "f", "j"] target = "g" Output: "j"  Input: letters = ["c", "f", "j"] target = "j" Output: "c"  Input: letters = ["c", "f", "j"] target = "k" Output: "c"   Note:  letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter.
__label__Array __label__Hash-Table Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order.    Example 1: Input: ["bella","label","roller"] Output: ["e","l","l"]   Example 2: Input: ["cool","lock","cook"] Output: ["c","o"]    Note:  1 <= A.length <= 100 1 <= A[i].length <= 100 A[i][j] is a lowercase letter
__label__Graph-Algorithms Given an undirected weighted connected graph, find the Really Special SubTree in it. The Really Special SubTree is defined as a subgraph consisting of all the nodes in the graph and:  There is only one exclusive path from a node to every other node.  The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.   No cycles are formed To create the Really Special SubTree, always pick the edge with smallest weight. Determine if including it will create a cycle.  If so, ignore the edge.  If there are edges of equal weight available: Choose the edge that minimizes the sum  where  and  are vertices and  is the edge weight. If there is still a collision, choose any of them. Print the overall weight of the tree formed using the rules. For example, given the following edges: First choose  at weight .  Next choose  at weight .  All nodes are connected without cycles for a total weight of .   Function Description  Complete the  function in the editor below.  It should return an integer that represents the total weight of the subtree formed.   kruskals has the following parameters:   g_nodes: an integer that represents the number of nodes in the tree   g_from: an array of integers that represent beginning edge node numbers   g_to: an array of integers that represent ending edge node numbers   g_weight: an array of integers that represent the weights of each edge   Input Format The first line has two space-separated integers  and , the number of nodes and edges in the graph.   The next  lines each consist of three space-separated integers ,  and , where  and  denote the two nodes between which the undirected edge exists and  denotes the weight of that edge.   Constraints         **Note: ** If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges. Output Format Print a single integer denoting the total weight of the Really Special SubTree.
__label__Dynamic-Programming A message containing letters from A-Z is being encoded to numbers using the following mapping way:  'A' -> 1 'B' -> 2 ... 'Z' -> 26   Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.   Given the encoded message containing digits and the character '*', return the total number of ways to decode it.   Also, since the answer may be very large, you should return the output mod 109 + 7.  Example 1: Input: "*" Output: 9 Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".   Example 2: Input: "1*" Output: 9 + 9 = 18   Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.
__label__Mathematics __label__Dynamic-Programming Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.   Example 1: Input: [5,3,4,5] Output: true Explanation:  Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true.    Note:  2 <= piles.length <= 500 piles.length is even. 1 <= piles[i] <= 500 sum(piles) is odd.
__label__Strings __label__Dynamic-Programming Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: "babad" Output: "bab" Note: "aba" is also a valid answer.  Example 2: Input: "cbbd" Output: "bb"
__label__Mathematics In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input:  [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.  Note:  The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000].
__label__Tree Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree:      We should return its level order traversal: [      [1],      [3,2,4],      [5,6] ]    Note:  The depth of the tree is at most 1000. The total number of nodes is at most 5000.
__label__Search Quality Blimps Inc. is looking to expand their sales to other cities (), so they hired you as a salesman to fly to other cities to sell blimps. Blimps can be expensive to travel with, so you will need to determine how many blimps to take along with you on each trip and when to return to headquarters to get more. Quality Blimps has an unlimited supply of blimps.  You will be able to sell only one blimp in each city you visit, but you do not need to visit every city, since some have expensive travel costs. Each city has an initial price that blimps sell for, but this goes down by a certain percentage as more blimps are sold (and the novelty wears off). Find a good route that will maximize profits.  Details Blimp Decline  - The blimps will decline () in price every time you visit  of the cities (the number of cities will always be a multiple of ). For example, if  is  and there are  cities, then for every city you visit (except headquarters), the price of blimps will be multiplied by . So after  visits, every city's blimp price will be about  of the initial value (). Note that if the price declines after you visit some city, then it will only happen after you made the sale on that city, so your sale on that city will not be affected. In particular, each blimp you sell in the first  of the cities will always be sold at their corresponding city's initial price. Input Format The first line of input for each test case will contain three parameters: number of cities ()  blimp cost per mile ()  blimp factor of decline ()  This will be followed by  lines, which will each contain three integers , the city location (x and y coordinates the grid, in miles) and the initial blimp sales price, respectively.   Constraints         The city locations will be distinct Output Format On each line, output the x and y coordinates of the next city you are visiting. When leaving the headquarters, also output the number of blimps you are taking with you for that part of the trip. You do not need to return to headquarters when you finish your sales.  You can only visit each city at most once. Sample Input 10 3 0.95 1 1 30 2 2 35 0 8 50 7 2 20 7 3 25 10 7 90 9 8 35 5 15 10 8 18 15 1 9 60  Sample Output 1 1 2 2 2 0 0 10 7 2 9 8 0 0 0 8 2 1 9  Explanation The salesman first travels a distance of √2 dollars to (1,1) carrying 2 blimps. This will cost him √2 dollars for his own travel and 6√2 dollars for the 2 blimps. He will then earn 30 dollars selling 1 blimp. He then continues to (2,2) with only 1 blimp, which will cost him 1√2 dollars for his travel and 3√2 dollars for his blimp. He will then earn 33.25 dollars selling the blimp, since the prices have declined by 5%. After his return to HQ (a distance of 2√2) he will have earned an approximate profit of 44.87 dollars. Scoring The goal of this challenge is to achieve the maximum profit on each test case. Your profits for each test case will be: Total Blimp Sales - Total Travel Costs You will receive a score for each test case based on the ratio of your profit to the estimated maximum profit. Your total score for this challenge will be a weighted sum of your scores for each test case. If your profit is negative, you'll receive a zero score.
__label__Binary-Search You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true  Then 4 is the first bad version.
__label__Array Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input: [[1,1,1],  [1,0,1],  [1,1,1]] Output: [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0   Note:  The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150].
__label__Dynamic-Programming __label__Tree Given an array arr of positive integers, consider all binary trees such that:  Each node has either 0 or 2 children; The values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.) The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.  Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.   Example 1: Input: arr = [6,2,4] Output: 32 Explanation: There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.      24            24    /  \          /  \   12   4        6    8  /  \               / \ 6    2             2   4    Constraints:  2 <= arr.length <= 40 1 <= arr[i] <= 15 It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).
__label__Array __label__Greedy-Algorithms Given an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.   Example 1: Input: [3,2,1] Output: [3,1,2] Explanation: Swapping 2 and 1.  Example 2: Input: [1,1,5] Output: [1,1,5] Explanation: This is already the smallest permutation.  Example 3: Input: [1,9,4,6,7] Output: [1,7,4,6,9] Explanation: Swapping 9 and 7.  Example 4: Input: [3,1,1,3] Output: [1,3,1,3] Explanation: Swapping 1 and 3.    Note:  1 <= A.length <= 10000 1 <= A[i] <= 10000
__label__Dynamic-Programming Given an array, we define its value to be the value obtained by following these instructions: Write down all pairs of numbers from this array.   Compute the product of each pair.   Find the sum of all the products. For example, for a given array, for a given array [, , , ],  Note that  is listed twice, one for each occurrence of .   Given an array of integers, find the largest value of any of its nonempty subarrays. Note: A subarray is a contiguous subsequence of the array. Complete the function largestValue which takes an array and returns an integer denoting the largest value of any of the array's nonempty subarrays.   largestValue Input Format The first line contains a single integer , denoting the number of integers in array .  The second line contains  space-separated integers  denoting the elements of array .   Constraints     Subtasks   for 20% of the points.    for 70% of the points. Output Format Print a single line containing a single integer denoting the largest value of any of the array's nonempty subarrays. Sample Input 0 Sample Output 0 Explanation 0 In this case, we have . The largest-valued subarray turns out to be  with value .   Sample Input 1 Sample Output 1
__label__Dynamic-Programming __label__Greedy-Algorithms Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3] Example 2: Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4] Example 3: Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9]
__label__Tree A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued.   Example 1:  Input: [1,1,1,1,1,null,1] Output: true   Example 2:  Input: [2,2,2,5,2] Output: false     Note:  The number of nodes in the given tree will be in the range [1, 100]. Each node's value will be an integer in the range [0, 99].
__label__Data-Structures __label__Data-Structures Given  strings. Each string contains only lowercase letters from (both inclusive). The set of  strings is said to be GOOD SET if no string is prefix of another string else, it is BAD SET. (If two strings are identical, they are considered prefixes of each other.) For example, aab, abcde, aabcd is BAD SET because aab is prefix of aabcd.   Print GOOD SET if it satisfies the problem requirement.  Else, print BAD SET and the first string for which the condition fails.   Input Format  First line contains , the number of strings in the set.  Then next  lines follow, where  line contains  string.   Constraints     Length of the string   Output Format  Output GOOD SET if the set is valid.  Else, output BAD SET followed by the first string for which the condition fails.   GOOD SET BAD SET Sample Input00  7 aab defgab abcde aabcde cedaaa bbbbbbbbbb jabjjjad  Sample Output00  BAD SET aabcde  Sample Input01 4 aab aac aacghgh aabghgh  Sample Output01  BAD SET aacghgh  Explanation  aab is prefix of aabcde. So set is BAD SET and it fails at string aabcde.
__label__Depth-first-Search Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, but "star" is not similar to "tars", "rats", or "arts". Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that "tars" and "arts" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there? Example 1: Input: ["tars","rats","arts","star"] Output: 2 Note:  A.length <= 2000 A[i].length <= 1000 A.length * A[i].length <= 20000 All words in A consist of lowercase letters only. All words in A have the same length and are anagrams of each other. The judging time limit has been increased for this question.
__label__Dynamic-Programming Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.   Example 1: Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.    Note:  1 <= k <= len(nums) <= 16. 0 < nums[i] < 10000.
__label__Greedy-Algorithms Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.  Note:  The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.   Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.   Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.   Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0.
__label__Search Two spies in a grid will have their covers blown if: They are both in the same row.   They are both in the same column.   They can see each other diagonally (i.e., lie in a line inclined ° or ° to the base of the grid). The level of danger is now increased! In addition to the conditions above, no  spies may lie in any straight line. This line need not be aligned ° or ° to the base of grid. Write a program in the language of your choice to place  spies (one spy per row) on an  grid without blowing anyone's cover. Your program must then print the following  lines describing a valid configuration: The value of . A space-separated list of -indexed column numbers, where each value  is the column number of the spy in row  (where ). Solve this problem for  as large as possible, up to (and including) . Note: Run and Custom Input are not available for this challenge; you must click Submit Code for your submission to be scored. Your score for this challenge will always be the maximum value scored by any of your submissions. Examples  In the examples below,  denotes a spy and * denotes an empty cell. Sample Configuration 0  A valid configuration for :   Sample Output 0  This C++ code: Produces this output: 11 2 4 7 1 8 11 5 3 9 6 10   This configuration will earn a score of . Sample Configuration 1  A valid configuration for : Sample Output 1  This Python code: Produces this output: 13 1 3 12 10 7 2 11 5 8 13 9 4 6  This configuration will earn a score of . Sample Configuration 2  An invalid configuration for : Sample Output 2  The following output: 7 1 3 5 7 2 4 6   will earn a score of  because the spies in the first  rows are in a straight line as are the spies in the next  rows.       Input Format There is no input for this challenge. Constraints  is odd.  (Do not submit for any value of  larger than ) Scoring  A correct configuration will get a score of . Output Format Print the following  lines of output: The first line should be a single integer denoting the value of .  The second line should contain a space-separated list of integers. Each integer  (where ) should be the -indexed column number where the spy in row  is located.
__label__Dynamic-Programming __label__Depth-first-Search There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.   Example 1: Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:   Example 2: Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:     Note:  Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50].
__label__Strings Return the result of evaluating a given boolean expression, represented as a string. An expression can either be:  "t", evaluating to True; "f", evaluating to False; "!(expr)", evaluating to the logical NOT of the inner expression expr; "&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...; "|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...    Example 1: Input: expression = "!(f)" Output: true  Example 2: Input: expression = "|(f,t)" Output: true  Example 3: Input: expression = "&(t,f)" Output: false  Example 4: Input: expression = "|(&(t,f,t),!(t))" Output: false    Constraints:  1 <= expression.length <= 20000 expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}. expression is a valid expression representing a boolean, as given in the description.
__label__Tree Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.   Example: Given a binary tree            1          / \         2   3        / \            4   5        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].  Note: The length of path between two nodes is represented by the number of edges between them.
__label__Tree Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)   Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12]     Note:   1 <= preorder.length <= 100 The values of preorder are distinct.
__label__Dynamic-Programming You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths. Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7]. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.   Example 1: Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10 Output: 3 Explanation:  We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].  Example 2: Input: clips = [[0,1],[1,2]], T = 5 Output: -1 Explanation:  We can't cover [0,5] with only [0,1] and [0,2].  Example 3: Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9 Output: 3 Explanation:  We can take clips [0,4], [4,7], and [6,9].  Example 4: Input: clips = [[0,4],[2,8]], T = 5 Output: 2 Explanation:  Notice you can have extra video after the event ends.    Note:  1 <= clips.length <= 100 0 <= clips[i][0], clips[i][1] <= 100 0 <= T <= 100
__label__Depth-first-Search In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe?  Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.    Note:  graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].
__label__Data-Structures __label__Advanced-Data-Structures Our lazy white falcon finally decided to learn heavy-light decomposition. Her teacher gave an assignment for her to practice this new technique. Please help her by solving this problem.  You are given a tree with  nodes and each node's value is initially . The problem asks you to operate the following two types of queries: "1 u x" assign  to the value of the node . "2 u v" print the maximum value of the nodes on the unique path between  and . Input Format First line consists of two integers seperated by a space:  and . Following  lines consisting of two integers denotes the undirectional edges of the tree.  Following  lines consist of the queries you are asked to operate.  Constraints  It is guaranteed that input denotes a connected tree with  nodes. Nodes are enumerated with 0-based indexing. Output Format For each second type of query print single integer in a single line, denoting the asked maximum value. Sample Input 3 3 0 1 1 2 1 0 1 1 1 2 2 0 2  Sample Output 2  Explanation After the first two updates value of the th node is  and st node is . That is why maxiumum value on the path between  and  is .
__label__Strings Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.  Note: You may assume that both strings contain only lowercase letters.  canConstruct("a", "b") -> false canConstruct("aa", "ab") -> false canConstruct("aa", "aab") -> true
__label__Binary-Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.  Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4   Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1    Note:  You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].
__label__Dynamic-Programming __label__Tree King Arthur has a large kingdom that can be represented as a tree, where nodes correspond to cities and edges correspond to the roads between cities. The kingdom has a total of  cities numbered from  to .  The King wants to divide his kingdom between his two children, Reggie and Betty, by giving each of them  or more cities; however, they don't get along so he must divide the kingdom in such a way that they will not invade each other's cities. The first sibling will invade the second sibling's city if the second sibling has no other cities directly connected to it. For example, consider the kingdom configurations below:  Given a map of the kingdom's  cities, find and print the number of ways King Arthur can divide it between his two children such that they will not invade each other. As this answer can be quite large, it must be modulo . Input Format The first line contains a single integer denoting  (the number of cities in the kingdom).  Each of the  subsequent lines contains two space-separated integers,  and , describing a road connecting cities  and .  Constraints   It is guaranteed that all cities are connected. Subtasks  for  of the maximum score. Output Format Print the number of ways to divide the kingdom such that the siblings will not invade each other, modulo . Sample Input 5 1 2 1 3 3 4 3 5  Sample Output 4  Explanation In the diagrams below, red cities are ruled by Betty and blue cities are ruled by Reggie. The diagram below shows a division of the kingdom that results in war between the siblings:  Because cities  and  are not connected to any other red cities, blue city  will cut off their supplies and declare war on them. That said, there are four valid ways to divide the kingdom peacefully:  We then print the value of  as our answer.
__label__Data-Structures __label__Advanced-Data-Structures Coolguy gives you a simple problem. Given a -indexed array, , containing  elements, what will  be after this pseudocode is implemented and executed? Print . //f(a, b) is a function that returns the minimum element in interval [a, b]  ans = 0  for a -> [1, n]     for b -> [a, n]         for c -> [b + 1, n]             for d -> [c, n]                 ans = ans + min(f(a, b), f(c, d))  Input Format The first line contains  (the size of array ).  The second line contains  space-separated integers describing . Constraints  ≤  ≤   ≤  ≤  Note:  is -indexed (i.e.: ). Output Format Print the integer result of . Sample Input 3 3 2 1  Sample Output 6  Explanation       We then sum these numbers () and print , which is .
__label__Hash-Table __label__Two-Pointers __label__Strings You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c.   Example 1: Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].    Note:  The given list may contain duplicates, so ascending order means >= here. 1 <= k <= 3500 -105 <= value of elements <= 105.
__label__Two-Pointers A character is unique in string S if it occurs exactly once in it. For example, in string S = "LETTER", the only unique characters are "L" and "R". Let's define UNIQ(S) as the number of unique characters in string S. For example, UNIQ("LETTER") =  2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.   Example 1: Input: "ABC" Output: 10 Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC". Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: "ABA" Output: 8 Explanation: The same as example 1, except uni("ABA") = 1.    Note: 0 <= S.length <= 10000.
__label__Game-Theory Manasa loves the nim game, in which there are  buckets, each having  balls. Two players play alternately. Each turn consists of removing some non-zero number of balls from one of the bucket. A player with lack of moves looses. But, Manasa having played it so many times, she gets bored one day. So she wants to change the rules of the game. She loves prime numbers, so she makes a new rule: any player can only remove a prime number of balls from a bucket. But there are infinite number prime numbers. So to keep the game simple, a player can only remove  balls from a bucket if  belongs to the set   The whole game can now be described as follows:    There are  buckets, and the  bucket contains  balls. A player can choose a bucket and remove  balls from that bucket where  belongs to . A player loses if there are no more available moves. Manasa plays the first move against Sandy. Who will win if both of them play optimally? Input Format The first line contains an integer , the number of test cases.  Each test case consists of two lines. The first line contains a single integer . The second line contain  space-separated integers .   Constraints       Output Format Print a single line containing the name of the winner: Manasa or Sandy. Manasa Sandy Sample Input 0 Sample Output 0 Explanation 0 For the first testcase: Since both the buckets have same number of balls, Manasa can choose any one of them for her first move. If Manasa selects to remove  or  balls to remove from first bucket. Now, Sandy  can always counter her move by removing  balls from first bucket if it's left with  balls respectively. Now, there are no valid moves left for first bucket. The same thing repeats for second bucket and Sandy wins. For the second testcase: Manasa removes  balls from the third bucket. Now, if Sandy choose the remove  balls from second bucket Manasa will empty the first bucket and if Sandy choose the remove  balls from first bucket, Manasa will empty second one. Hence, Manasa wins.
__label__Mathematics Meereen is famous for its fighting pits where fighters fight each other to the death. Initially, there are  fighters and each fighter has a strength value. The  fighters are divided into  teams, and each fighter belongs exactly one team. For each fight, the Great Masters of Meereen choose two teams,  and , that must fight each other to the death. The teams attack each other in alternating turns, with team  always launching the first attack. The fight ends when all the fighters on one of the teams are dead. Assume each team always attacks optimally. Each attack is performed as follows: The attacking team chooses a fighter from their team with strength . The chosen fighter chooses at most  fighters from other team and kills all of them.  The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries: 1 p x Add a new fighter with strength  to team . It is guaranteed that this new fighter's strength value will not be less than any current member of team . 1 p x 2 x y Print the name of the team that would win a matchup between teams  and  in their current state (recall that team  always starts first). It is guaranteed that .  2 x y Given the initial configuration of the teams and  queries, perform each query so the Great Masters can plan the next fight. Note: You are determining the team that would be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups. Input Format The first line contains three space-separated integers describing the respective values of  (the number of fighters),  (the number of teams), and  (the number of queries).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of fighter 's strength, , and team number, .  Each of the  subsequent lines contains a space-separated query in one of the two formats defined in the Problem Statement above (i.e., 1 p x or 2 x y). 1 p x 2 x y Constraints     It is guaranteed that both teams in a query matchup will always have at least one fighter. Scoring  This challange has binary scoring. This means you will get a full score if your solution passes all test cases; otherwise, you will get  points. Output Format After each type  query, print the name of the winning team on a new line. For example, if  and  are matched up and  wins, you would print . Sample Input 7 2 6 1 1 2 1 1 1 1 2 1 2 1 2 2 2 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2 2 2 1  Sample Output 1 2 1 1  Explanation Team  has three fighters with the following strength levels: .  Team  has four fighters with the following strength levels: .       The first query matching up team  and  would play out as follows: Team  attacks  The fighter with strength  can kill one fighter with strength  and one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill one fighter with strength . Now, , and . Team  attacks  The fighter with strength  can kill the last fighter with strength . Now, , and . After this last attack, all of Team 's fighters would be dead. Thus, we print  as team  would win that fight.
__label__Data-Structures The median of a set of integers is the midpoint value of the data set for which an equal number of integers are less than and greater than the value. To find the median, you must first sort your set of integers in non-decreasing order, then: If your set contains an odd number of elements, the median is the middle element of the sorted sample. In the sorted set ,  is the median. If your set contains an even number of elements, the median is the average of the two middle elements of the sorted sample. In the sorted set ,  is the median. Given an input stream of  integers, you must perform the following task for each  integer: Add the  integer to a running list of integers. Find the median of the updated list (i.e., for the first element through the  element). Print the list's updated median on a new line. The printed value must be a double-precision number scaled to  decimal place (i.e.,  format). Input Format The first line contains a single integer, , denoting the number of integers in the data stream.  Each line  of the  subsequent lines contains an integer, , to be added to your list. Constraints    Output Format After each new integer is added to the list, print the list's updated median on a new line as a single double-precision number scaled to  decimal place (i.e.,  format). Sample Input 6 12 4 5 3 8 7  Sample Output 12.0 8.0 5.0 4.5 5.0 6.0  Explanation There are  integers, so we must print the new median on a new line as each integer is added to the list:
__label__Graph-Algorithms During the Steam Summer Sale, Jim's  friends have purchased  games, which are numbered from  to . The games are multiplayer. Jim has invited his friends to his basement where they will play by making a LAN-Party.  Each friend has already decided the game he would like to play for the rest of the day. So there will be a group of friends who will play the same game together. But then, they face a problem: Currently, none of the friends' PCs are connected. So they have to be connected using the available  wires. Jim decides to connect friends  and  with the th wire one by one. So he starts with wire 1, then with wire 2 and so on.  A group can start playing their game, only if all the members are connected (if not directly, then there must exist a path connecting them). They want to start playing as soon as possible.  For each game, find out the wire after adding which the group can start playing. It is also possible that a group will never get connected. In such a case, this group starts crying and you should display -1. -1 Input Format On the first line there will be ,  and  each separated by a single space. On the second line we will give you  integers separated by a single space: The -th integer denotes the game friend  wants to play (all between  and ). The next  lines will denote  wires: ith line denotes ith wire and is denoted by  and  pairs each separated by a single space.  Constraints  For each game , the number of players playing  will be positive.    Note Each game is chosen by at least one player. If a group consists of only one member, then print 0, since this lucky (?) lone player can start right away! 0 Output Format Print on the th line the answer for the th game.  Sample Input 5 2 4 1 2 2 2 1 1 2  2 3 1 5 4 5   Sample Output 3 4  Explanation The group with the game 1 can play after the 3rd wire is added. The group with game 2 can play only after the 4th wire has been added because after adding the 4th wire, a path between (2,3) (3,4) and (2,4) gets created.
__label__Depth-first-Search Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:  If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary.  Example 1: Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]  Example 2: Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] Output: ["JFK","ATL","JFK","SFO","ATL","SFO"] Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].              But it is larger in lexical order.
__label__Strings For two strings A and B, we define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings "abc" and "abd" is 2, while the similarity of strings "aaa" and "aaab" is 3. Calculate the sum of similarities of a string S with each of it's suffixes. Input Format The first line contains the number of test cases t.  Each of the next t lines contains a string to process, . Constraints      is composed of characters in the range ascii[a-z]   Output Format Output t lines, each containing the answer for the corresponding test case. Sample Input 2 ababaa   aa  Sample Output 11   3  Explanation For the first case, the suffixes of the string are "ababaa", "babaa", "abaa", "baa", "aa" and "a". The similarities of these strings with the string "ababaa" are 6,0,3,0,1, & 1 respectively. Thus, the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11. For the second case, the answer is 2 + 1 = 3.
__label__Dynamic-Programming There are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.   Example 1: Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation:  To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes.   Example 2: Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation:  To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).     Note:  1 <= G <= 100 0 <= P <= 100 1 <= group[i] <= 100 0 <= profit[i] <= 100 1 <= group.length = profit.length <= 100
__label__Dynamic-Programming You are given an array A = [1, 2, 3, ..., n]:      How many sequences (S1) can you get after exact k adjacent swaps on A?  How many sequences (S1) can you get after exact k adjacent swaps on A?  How many sequences (S2) can you get after at most k swaps on A?   How many sequences (S2) can you get after at most k swaps on A?   An adjacent swap can be made between two elements of the Array A, A[i] and A[i+1] or A[i] and A[i-1].  A swap otherwise can be between any two elements of the array A[i] and A[j] ∀ 1 ≤ i, j ≤ N, i ≠ j. Input Format First and only line contains n and k separated by space.     Constraints 1 ≤ n ≤ 2500  1 ≤ k ≤ 2500       Output Format Output S1 % MOD and S2 % MOD in one line, where MOD = 1000000007.     MOD = 1000000007 Sample Input 3 2  Sample Output 3 6  Explanation Original array: [1, 2, 3] 1. After 2 adjacent swaps: We can get [1, 2, 3], [2, 3, 1], [3, 1, 2] ==> S1 == 3  2. After at most 2 swaps: 1) After 0 swap: [1, 2, 3] 2) After 1 swap: [2, 1, 3], [3, 2, 1], [1, 3, 2]. 3) After 2 swaps: [1, 2, 3], [2, 3, 1], [3, 1, 2] ==> S2 == 6
__label__Tree Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).  For example: Given binary tree [3,9,20,null,null,15,7],     3    / \   9  20     /  \    15   7    return its zigzag level order traversal as: [   [3],   [20,9],   [15,7] ]
__label__Mathematics __label__Strings Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:  Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.  Example 1: Input: "42" Output: 42  Example 2: Input: "   -42" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.              Then take as many numerical digits as possible, which gets 42.  Example 3: Input: "4193 with words" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.  Example 4: Input: "words and 987" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical               digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: "-91283472332" Output: -2147483648 Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.              Thefore INT_MIN (−231) is returned.
__label__Graph-Algorithms The member states of the UN are planning to send  people to the moon. They want them to be from different countries.  You will be given a list of pairs of astronaut ID's.  Each pair is made of astronauts from the same country.  Determine how many pairs of astronauts from different countries they can choose from. For example, we have the following data on 2 pairs of astronauts, and 4 astronauts total, numbered  through . 1   2 2   3  Astronauts by country are  and .  There are  pairs to choose from:  and . Function Description  Complete the journeyToMoon function in the editor below.  It should return an integer that represents the number of valid pairs that can be formed.   journeyToMoon has the following parameter(s):   n: an integer that denotes the number of astronauts   astronaut: a 2D array where each element  is a  element integer array that represents the ID's of two astronauts from the same country   Input Format The first line contains two integers  and , the number of astronauts and the number of pairs.  Each of the next  lines contains  space-separated integers denoting astronaut ID's of two who share the same nationality.  Constraints     Output Format An integer that denotes the number of ways to choose a pair of astronauts from different coutries. Sample Input 0 Sample Output 0 Explanation 0 Persons numbered  belong to one country, and those numbered  belong to another. The UN has  ways of choosing a pair:    Sample Input 1 Sample Output 1 Explanation 1 Persons numbered   belong to the same country, but persons  and  don't share countries with anyone else.  The UN has  ways of choosing a pair:
__label__Dynamic-Programming Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4
__label__Array __label__Hash-Table __label__Dynamic-Programming Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [   ["1","0","1","0","0"],   ["1","0","1","1","1"],   ["1","1","1","1","1"],   ["1","0","0","1","0"] ] Output: 6
__label__Tree Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers.    Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7]    Note:  1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.
__label__Dynamic-Programming Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:  Every song is played at least once A song can only be played again only if K other songs have been played  Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.      Example 1: Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].   Example 2: Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]   Example 3: Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]      Note:  0 <= K < N <= L <= 100
__label__Data-Structures __label__Greedy-Algorithms You have three stacks of cylinders where each cylinder has the same diameter, but they may vary in height. You can change the height of a stack by removing and discarding its topmost cylinder any number of times.  Find the maximum possible height of the stacks such that all of the stacks are exactly the same height. This means you must remove zero or more cylinders from the top of zero or more of the three stacks until they're all the same height, then print the height. The removals must be performed in such a way as to maximize the height.  Note: An empty stack is still a stack. Input Format The first line contains three space-separated integers, , , and , describing the respective number of cylinders in stacks , , and . The subsequent lines describe the respective heights of each cylinder in a stack from top to bottom:       The second line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   The third line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.    The fourth line contains  space-separated integers describing the cylinder heights in stack . The first element is the top of the stack.   Constraints   Output Format Print a single integer denoting the maximum height at which all stacks will be of equal height. Sample Input 5 3 4 3 2 1 1 1 4 3 2 1 1 4 1  Sample Output 5  Explanation Initially, the stacks look like this:  Observe that the three stacks are not all the same height. To make all stacks of equal height, we remove the first cylinder from stacks  and , and then remove the top two cylinders from stack  (shown below).  As a result, the stacks undergo the following change in height:    All three stacks now have . Thus, we print  as our answer.
__label__Data-Structures __label__Advanced-Data-Structures Two positive integers  and  are given.   is decimal representation of integer .  Lets define . For example, if :   For each query you will be given two integers  and  that define a substring equal to .  Your task is to calculate divisibility of given substring.  Divisibility of given substring is equal to number of  pairs such that:   and   is divisible by , assuming that  is divisible by any other integer. Timelimits  Timelimits for this challenge is given here Input Format First line contains two integers  and  separated by a single space.  is the number of queries.  Second line contains a big integer .  Next  lines contains two integers  and  separated by a single space each - begin and end points of substring. Constraints   Output Format Output  lines, the -th line of the output should contain single integer  divisibility of the -th query substring. Sample Input 3 5 4831318 3 5 5 7 1 7 1 2 2 3  Sample Output 2 3 9 1 1  Explanation In the first query, b = 3 and e = 5. Two such pairs that are divisible by P = 3 are   f(3, 3) = 3 and f(5, 5). Hence the answer 2.   In the second query, b = 5 and e = 7. Three such pairs that are divisible by P are   F(5, 5) = 3, f(6, 7) = 18 and f(5, 7) = 318
__label__Strings We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').  For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = "abc", shifts = [3,5,9] Output: "rpl" Explanation:  We start with "abc". After shifting the first 1 letters of S by 3, we have "dbc". After shifting the first 2 letters of S by 5, we have "igc". After shifting the first 3 letters of S by 9, we have "rpl", the answer.  Note:  1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9
__label__Strings Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.   Example 1: Input: "cdadabcc" Output: "adbc"   Example 2: Input: "abcd" Output: "abcd"   Example 3: Input: "ecbacba" Output: "eacb"   Example 4: Input: "leetcode" Output: "letcod"    Note:  1 <= text.length <= 1000 text consists of lowercase English letters.
__label__Search The median of a list of numbers is essentially it's middle element after sorting.  The same number of elements occur after it as before.  Given a list of numbers with an odd number of elements, can you find the median? For example, the median of  is , the middle element in the sorted array. Function Description Complete the findMedian function in the editor below.  It must return an integer that represents the median of the array.  findMedian has the following parameter(s):   arr: an unsorted array of integers Input Format The first line contains the integer , the size of .  The second line contains  space-separated integers  Constraints    is odd   Output Format Output one integer, the median. Sample Input 0 Sample Output 0 Explanation 0 The sorted .  It's middle element is at .
__label__Array Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either:  Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...  Return the minimum number of moves to transform the given array nums into a zigzag array.   Example 1: Input: nums = [1,2,3] Output: 2 Explanation: We can decrease 2 to 0 or 3 to 1.  Example 2: Input: nums = [9,6,1,6,2] Output: 4    Constraints:  1 <= nums.length <= 1000 1 <= nums[i] <= 1000
__label__Mathematics An integer  is a divisor of an integer  if the remainder of .   Given an integer, for each digit that makes up the integer determine whether it is a divisor.  Count the number of divisors occurring within the integer.   Note: Each digit is considered to be unique, so each occurrence of the same digit should be counted (e.g. for ,  is a divisor of  each time it occurs so the answer is ). Function Description Complete the findDigits function in the editor below.  It should return an integer representing the number of digits of  that are divisors of .   findDigits has the following parameter(s): n: an integer to analyze Input Format The first line is an integer, , indicating the number of test cases.  The  subsequent lines each contain an integer, .   Constraints    Output Format For every test case, count the number of digits in  that are divisors of .  Print each answer on a new line. Sample Input 2 12 1012  Sample Output 2 3  Explanation The number  is broken into two digits,  and . When  is divided by either of those two digits, the remainder is  so they are both divisors. The number  is broken into four digits, , , , and .  is evenly divisible by its digits , , and , but it is not divisible by  as division by zero is undefined.
__label__Dynamic-Programming We define subsequence as any subset of an array.  We define a subarray as a contiguous subsequence in an array.   Given an array, find the maximum possible sum among: all nonempty subarrays.  all nonempty subsequences.  Print the two values as space-separated integers on one line.  Note that empty subarrays/subsequences should not be considered.  For example, given an array , the maximum subarray sum is comprised of element inidices  and the sum is .  The maximum subsequence sum is comprised of element indices  and the sum is .   Function Description  Complete the maxSubarray function in the editor below.  It should return an array of two integers: the maximum subarray sum and the maximum subsequence sum of .   maxSubarray has the following parameter(s):   arr: an array of integers   Input Format The first line of input contains a single integer , the number of test cases. The first line of each test case contains a single integer .  The second line contains  space-separated integers  where .    Constraints      The subarray and subsequences you consider should have at least one element. Output Format Print two space-separated integers denoting the maximum sums of nonempty subarrays and nonempty subsequences, respectively.  Sample Input 0 Sample Output 0 Explanation 0 In the first case: The maximum sum for both types of subsequences is just the sum of all the elements since they are all positive. In the second case: The subarray  is the subarray with the maximum sum, and  is the subsequence with the maximum sum. Sample Input 1 Sample Output 1 Explanation 1 Since all of the numbers are negative, both the maximum subarray and maximum subsequence sums are made up of one element, .
__label__Dynamic-Programming We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: n = 10, I pick 8.  First round:  You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round:  You guess 9, I tell you that it's lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.  Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.
__label__Bit Let a and b be binary numbers of length n (MSB to the left). The following commands may be performed: set_a idx x: Set  to , where  and   is  least significant bit of .   set_a idx x set_b idx x: Set  to , where  and   is  least significant bit of .   set_b idx x get_c idx: Print , where  and .   get_c idx Given , and a list of commands, create a string made of the results of each  call, the only command that produces output.  For example,  and  so the length of the numbers is .  Print an answer string that contains the results of all commands on one line.  A series of commands and their results follow:  Starting  ans = '' (empty string)  a   b  000 111  set_a 1 1  010 111  set_b 0 1  010 111  get_c 3  a + b = 1001  ans = '1'  010 111  get_c 4  a + b = 01001  ans = '10'    Starting  ans = '' (empty string)  a   b  000 111  set_a 1 1  010 111  set_b 0 1  010 111  get_c 3  a + b = 1001  ans = '1'  010 111  get_c 4  a + b = 01001  ans = '10'   Note: When the command is get_c 4,   had to be padded to the left with a  to be long enough to return a value.   get_c 4 Function Description  Complete the changeBits function in the editor below.  For each get_c command, it should print either a 0 or a 1 without a newline until all commands have been processed. At that point, add a newline.    get_c 0 1 changeBits has the following parameters:  - a, b: two integers represented as binary strings  - queries[queries[0]-queries[n-1]]: an array of query strings in the format described   Input Format The first line of input contains two space-separated integers,  and , the length of the binary representations of  and , and the number of commands, respectively.  The second and third lines each contain a string representation of  and .  The following  lines each contain a command string  as described above.   Constraints     Output Format For each query of the type , output a single digit 0 or 1. Output must be placed on a single line. Sample Input 0 Sample Output 0 Explanation 0 set_a 0 1 sets 00000 to 00001 C = A + B = 00001 + 11111 = 100000, so get_c[5] = 1 from the above computation get_c[1] = 0 set_b 2 0 sets 11111 to 11011 C = A + B = 00001 + 11011 = 011100, so get_c[5]  = 0 The output is hence concatenation of 1, 0 and 0  = 100
__label__Data-Structures Suppose there is a circle. There are  petrol pumps on that circle. Petrol pumps are numbered  to  (both inclusive). You have two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give, and (2) the distance from that petrol pump to the next petrol pump.  Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps. The truck will move one kilometer for each litre of the petrol. Input Format The first line will contain the value of . The next  lines will contain a pair of integers each, i.e. the amount of petrol that petrol pump will give and the distance between that petrol pump and the next petrol pump. Constraints:   Output Format An integer which will be the smallest index of the petrol pump from which we can start the tour. Sample Input 3 1 5 10 3 3 4  Sample Output 1  Explanation We can start the tour from the second petrol pump.
__label__Tree Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL. For example,  Given the tree:         4        / \       2   7      / \     1   3  And the value to search: 2  You should return this subtree:       2           / \        1   3  In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.
__label__Dynamic-Programming HackerRank-city is an acyclic connected graph (or tree). Its not an ordinary place, the construction of the whole tree takes place in  steps. The process is described below: It initially has  node. At each step, you must create  duplicates of the current tree, and create  new nodes to connect all  copies in the following H shape: H  At each  step, the tree becomes  times bigger plus  new nodes, as well as  new edges connecting everything together. The length of the new edges being added at step  is denoted by input . Calculate the sum of distances between each pair of nodes; as these answers may run large, print your answer modulo . Input Format The first line contains an integer,  (the number of steps). The second line contains  space-separated integers describing  , . Constraints   Subtask  For  score  Output Format Print the sum of distances between each pair of nodes modulo . Sample Input 0 1 1  Sample Output 0 29  Sample Input 1 2 2 1  Sample Output 1 2641  Explanation Sample 0 In this example, our tree looks like this:  Let  denote the distance between nodes  and .    .      We print the result of  as our answer. Sample 1 In this example, our tree looks like this:  We calculate and sum the distances between nodes in the same manner as Sample 0 above, and print the result of our , which is .
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1
__label__Bit Consider four numbers: , , , and . You must change at most  bits in  and  to form the numbers  and  satisfying the equation . Here, the | symbol denotes the bitwise OR operation. Given  sets of the numbers defined above, find and print the respective values of  and  on new lines; if no such value exists, print  instead. If there are multiple solutions, make  as small as possible; if there are still multiple solutions, make  as small as possible.  Notes:  , , and  are given in Hexadecimal (base 16), and  is given in decimal (base 10). If the number of bits changed in  is  and the number of bits changed in B is , then  must be . Input Format The first line contains an integer, , denoting the number of queries. The subsequent lines describe each respective query as follows: The first line contains a single integer denoting the value of . Each of the next  lines contains a Hexadecimal (base 16) number describing the respective values of , , and . Constraints    Output Format Print two lines of output for each query: The first line should contain a Hexadecimal (base 16) number denoting the value of . The second line must contain a Hexadecimal (base 16) number denoting the value of .  If no valid answer exists, you must instead print one line of output with the integer . Note: The letters in Hexadecimal numbers must be in uppercase. Sample Input 3 8 2B 9F 58 5 B9 40 5A 2 91 BE A8  Sample Output 8 58 18 42 -1  Explanation Query 0:  In this query, .  Change  to .  bits are changed.  Change B =  to .  bits are changed.   Query 1:  In this query, .  Change  to .  bits are changed.  Change  to . Only  bit is changed.  Query 2:  There is no valid answer, so we print .
__label__Two-Pointers __label__Greedy-Algorithms The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)    Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3)   Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note:  1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000
__label__Tree __label__Depth-first-Search Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin.    Example 1:  Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.   Example 2:  Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.   Example 3:  Input: [1,0,2] Output: 2   Example 4:  Input: [1,0,0,null,3] Output: 4    Note:  1<= N <= 100 0 <= node.val <= N
__label__Bit Alice and Bob are playing the game of Nim with  piles of stones with sizes . If Alice plays first, she loses if and only if the 'xor sum' (or 'Nim sum') of the piles is zero, i.e., . Since Bob already knows who will win (assuming optimal play), he decides to cheat by removing some stones in some piles before the game starts. However, to reduce the risk of suspicion, he must keep at least one pile unchanged. Your task is to count the number of ways Bob can remove the stones to force Alice into losing the game. Since the number can be very large, output the number of ways modulo . Assume that both players will try to optimize their strategy and try to win the game. Input Format The first line of the input contains an integer  denoting the number of piles. The next line contains  space-separated integers  indicating the sizes of the stone piles. Constraints     Output Format Print a single integer denoting the number of ways Bob can force Alice to lose the game, modulo .   Sample Input 0 Sample Output 0 Explanation 0 The answer is . The four possible resulting lists of piles is:         Note that  is not allowed since he must keep one pile unchanged. Sample Input 1 Sample Output 1
__label__Mathematics A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square. Here are the rules of Tic-Tac-Toe:  Players take turns placing characters into empty squares (" "). The first player always places "X" characters, while the second player always places "O" characters. "X" and "O" characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Example 1: Input: board = ["O  ", "   ", "   "] Output: false Explanation: The first player always plays "X".  Example 2: Input: board = ["XOX", " X ", "   "] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = ["XXX", "   ", "OOO"] Output: false  Example 4: Input: board = ["XOX", "O O", "XOX"] Output: true  Note:  board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {" ", "X", "O"}.
__label__Data-Structures Alexa has two stacks of non-negative integers, stack  and stack  where index  denotes the top of the stack. Alexa challenges Nick to play the following game: In each move, Nick can remove one integer from the top of either stack  or stack . Nick keeps a running sum of the integers he removes from the two stacks. Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer  given at the beginning of the game. Nick's final score is the total number of integers he has removed from the two stacks. Given , , and  for  games, find the maximum possible score Nick can achieve (i.e., the maximum number of integers he can remove without being disqualified) during each game and print it on a new line. Input Format The first line contains an integer,  (the number of games). The  subsequent lines describe each game in the following format: The first line contains three space-separated integers describing the respective values of  (the number of integers in stack ),  (the number of integers in stack ), and  (the number that the sum of the integers removed from the two stacks cannot exceed). The second line contains  space-separated integers describing the respective values of . The third line contains  space-separated integers describing the respective values of . Constraints     Subtasks  for  of the maximum score. Output Format For each of the  games, print an integer on a new line denoting the maximum possible score Nick can achieve without being disqualified. Sample Input 0 Sample Output 0 Explanation 0 The two stacks initially look like this:  The image below depicts the integers Nick should choose to remove from the stacks. We print  as our answer, because that is the maximum number of integers that can be removed from the two stacks without the sum exceeding .  (There can be multiple ways to remove the integers from the stack, the image shows just one of them.)
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool Given pointers to the head nodes of  linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL. In the diagram below, the two lists converge at Node x: x [List #1] a--->b--->c                      \                       x--->y--->z--->NULL                      /      [List #2] p--->q  Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge.  int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) Input Format Do not read any input from stdin/console. The findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) method has two parameters,  and , which are the non-null head Nodes of two separate linked lists that are guaranteed to converge.   findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode) Constraints The lists will merge.  .   .  Output Format Do not write any output to stdout/console.  Each Node has a data field containing an integer.  Return the integer data for the Node where the two lists merge.   Sample Input The diagrams below are graphical representations of the lists that input Nodes  and  are connected to. Recall that this is a method-only challenge; the method only has initial visibility to those  Nodes and must explore the rest of the Nodes using some algorithm of your own design. Test Case 0  1   \    2--->3--->NULL   /  1  Test Case 1 1--->2       \        3--->Null       /      1  Sample Output 2 3  Explanation Test Case 0: As demonstrated in the diagram above, the merge Node's data field contains the integer .  Test Case 1: As demonstrated in the diagram above, the merge Node's data field contains the integer .
__label__Hash-Table __label__Strings Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1:  Input: ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]   Example 2: Input: ["bat","tab","cat"] Output: [[0,1],[1,0]]  Explanation: The palindromes are ["battab","tabbat"]
__label__Greedy-Algorithms Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: Input: nums = [1,3], n = 6 Output: 1  Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: Input: nums = [1,5,10], n = 20 Output: 2 Explanation: The two patches can be [2, 4].  Example 3: Input: nums = [1,2,2], n = 5 Output: 0
__label__Strings Jane loves strings more than anything. She has a string  with her, and value of string  over function  can be calculated as given below:   Jane wants to know the maximum value of  among all the substrings  of string . Can you help her? Input Format  A single line containing string  . Output Format  Print the maximum value of  among all the substrings  of string . Constraints    The string consists of lowercase English alphabets.   Sample Input 0  aaaaaa  Sample Output 0  12  Explanation 0  f('a') = 6 f('aa') = 10 f('aaa') = 12 f('aaaa') = 12 f('aaaaa') = 10 f('aaaaaa') = 6  Sample Input 1  abcabcddd  Sample Output 1  9  Explanation 1 f values of few of the substrings are shown below: f("a") = 2 f("b") = 2 f("c") = 2 f("ab") = 4 f("bc") = 4 f("ddd") = 3 f("abc") = 6 f("abcabcddd") = 9  Among the function values 9 is the maximum one.
__label__Dynamic-Programming We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible. Example: Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation:  Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.  Note:  A, B are arrays with the same length, and that length will be in the range [1, 1000]. A[i], B[i] are integer values in the range [0, 2000].
__label__Data-Structures __label__Advanced-Data-Structures Consider a permutation, , of integers from  to . Let's determine the  of  to be the minimum absolute difference between any  consecutive integers in :    Generate a lexicographically sorted list of all permutations of length  having a maximal distance between all permutations of the same length. Print the lexicographically  permutation. Input Format The first line contains an integer,  (the number of test cases). The  subsequent lines each contain two space-separated integers,  (the permutation length) and  (the 1-based index in the list of permutations having a maximal distance), respectively. The  line corresponds to the  test case.  Note: It is guaranteed that the sum of all  does not exceed . Constraints    Output Format For each test case: if the list of permutations having maximal distance has at least  elements, print the  permutation as sequential (i.e.: from  to ) space-separated integers on a new line; otherwise, print . Sample Input 3 3 5 4 2 4 3  Sample Output 3 1 2 3 1 4 2 -1  Explanation For  and :              Each of the  permutations has distance . We choose the fifth one (because ), and print 3 1 2 on a new line. 3 1 2 For  and :  The maximal distance in the list of permutations of integers from  to  is , and the only permutations having that distance are  and . We choose the second one (because ), and print 3 1 4 2 on a new line. 3 1 4 2
__label__Game-Theory __label__Game-Theory Two players are playing a game on a  chessboard. The rules of the game are as follows: The game starts with  coins located at one or more  coordinates on the board (a single cell may contain more than one coin). The coordinate of the upper left cell is , and the coordinate of the lower right cell is . In each move, a player must move a single coin from some cell  to one of the following locations:       .  Note: The coin must remain inside the confines of the board. In each move, a player must move a single coin from some cell  to one of the following locations:       .  Note: The coin must remain inside the confines of the board. The players move in alternating turns. The first player who is unable to make a move loses the game. The players move in alternating turns. The first player who is unable to make a move loses the game. The figure below shows all four possible moves:  Note: While the figure shows a  board, this game is played on a  board. Given the value of  and the initial coordinate(s) of  coins, determine which player will win the game. Assume both players always move optimally. Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is defined as follows over the subsequent lines: The first line contains an integer, , denoting the number of coins on the board. Each line  (where ) of the  subsequent lines contains  space-separated integers describing the respective values of  and  of the coordinate where coin  is located. Note: Recall that a cell can have more than one coin (i.e., any cell can have  to  coins in it at any given time). Constraints   , where . Output Format On a new line for each test case, print  if the first player is the winner; otherwise, print . Sample Input 2 3 5 4 5 8 8 2 6 7 1 7 2 7 3 7 4 7 4 7 4  Sample Output First Second
__label__Data-Structures Victoria has a tree, , consisting of  nodes numbered from  to . Each edge from node  to  in tree  has an integer weight, . Let's define the cost, , of a path from some node  to some other node  as the maximum weight () for any edge in the unique path from node  to node . Victoria wants your help processing  queries on tree , where each query contains  integers,  and , such that . For each query, she wants to print the number of different paths in  that have a cost, , in the inclusive range . It should be noted that path from some node  to some other node  is considered same as path from node  to  i.e  is same as .  Input Format The first line contains  space-separated integers,  (the number of nodes) and  (the number of queries), respectively.  Each of the  subsequent lines contain  space-separated integers, , , and , respectively, describing a bidirectional road between nodes  and  which has weight .  The  subsequent lines each contain  space-separated integers denoting  and . Constraints         Scoring  for  of the test data.    for  of the test data. Output Format For each of the  queries, print the number of paths in  having cost  in the inclusive range  on a new line. Sample Input 5 5 1 2 3 1 4 2 2 5 6 3 4 1 1 1 1 2 2 3 2 5 1 6  Sample Output 1 3 5 5 10  Explanation :   :   :   :   ...etc.
__label__Array Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.    Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]]   Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]    Note:  1 <= A.length <= 1000 1 <= A[0].length <= 1000
__label__Binary-Search Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up:  This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity?
__label__Binary-Search __label__Dynamic-Programming Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:   There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.  Follow up: Could you improve it to O(n log n) time complexity?
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Time Limits C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5 Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions: Any pair of servers within the network should be directly connected by at most 1 link. Each link is controlled by some specific network administrator. No server has more than 2 links connected to it, that are controlled by the same administrator. For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers) Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software.  Operations performed by the directives are: Change the administrator assigned to some particular link. Place some number of security devices along a particular link. Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers. Input Format  Input begins with a line containing 4 integers  separated by a single whitespace, denoting the number of servers, links, network administrators and transformations, respectively.  lines follow each one with 3 integers  and , saying that there is a link between server  and server , and that link is controlled by administrator . Initially, network topology fulfills the restrictions described above and there is no security device along any link. Remaining  lines in the input follow one the next formats:     meaning that link between server  and server   is requested to be assigned to administrator      meaning that the number of security devices along the link between server  and server   will be fixed to  , removing any existing devices on this link before the operation. The involved link will always exist.       meaning that directives want to know the number of security devices placed along the path between server  and server , just considering links controlled by administrator . Output Format  For each network transformation in the form     you should output: "Wrong link" if there is no direct link between server  and server . "Already controlled link" if the requested link does exist, but it is already controlled by administrator . "Server overload" if administrator  already controls 2 links connected to one of the involved servers. "Network redundancy" if the requested assignment creates no new connection considering just the links controlled by . "Assignment done" if none of the above conditions holds. In this case, link directly connecting  with  is assigned to . For each network transformation in the form     you should output: "No connection" if there is no path between the requested servers considering just the links controlled by . " security devices placed" where D is the number of security devices placed so far on the existing connection between the requested servers considering just the links controlled by .  Constraints           Sample Input: 4 5 3 15 1 2 1 2 3 1 3 4 2 1 4 2 1 3 3 2 3 4 49 1 1 2 3 2 1 4 64 3 1 4 2 1 1 2 3 3 4 2 3 3 1 3 3 1 1 4 3 3 3 4 2 3 2 4 1 2 1 4 13 2 1 3 21 2 2 3 24 1 2 3 3 1 2 4 3  Sample Output: Assignment done 64 security devices placed Already controlled link No connection 0 security devices placed Server overload 49 security devices placed No connection Network redundancy Wrong link
__label__Hash-Table __label__Strings Given an array of strings, group anagrams together. Example: Input: ["eat", "tea", "tan", "ate", "nat", "bat"], Output: [   ["ate","eat","tea"],   ["nat","tan"],   ["bat"] ] Note:  All inputs will be in lowercase. The order of your output does not matter.
__label__Data-Structures Consider an -integer sequence, . We perform a query on  by using an integer, , to calculate the result of the following expression:   In other words, if we let , then you need to calculate .   Given  and  queries (each query consists of an integer, ), print the result of each query on a new line. Input Format The first line consists of two space-separated integers describing the respective values of  and .  The second line consists of  space-separated integers describing the respective values of .  Each of the  subsequent lines contains a single integer denoting the value of  for that query.  Constraints     Output Format For each query, print an integer denoting the query's answer on a new line. After completing all the queries, you should have printed  lines. Sample Input 0 Sample Output 0 Explanation 0 For , the answer is   Sample Input 1 Sample Output 1 Explanation 1 For each query, the "prefix" has the least maximum value among the consecutive subsequences of the same size.
__label__Depth-first-Search Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: "()())()" Output: ["()()()", "(())()"]  Example 2: Input: "(a)())()" Output: ["(a)()()", "(a())()"]  Example 3: Input: ")(" Output: [""]
__label__Tree Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.  Example 1: Input:      1    / \   0   2    L = 1   R = 2  Output:      1       \        2   Example 2: Input:      3    / \   0   4    \     2    /   1    L = 1   R = 3  Output:        3      /     2      /  1
__label__Dynamic-Programming A chess knight can move as indicated in the chess diagram below:  .              This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops.  Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7.      Example 1: Input: 1 Output: 10   Example 2: Input: 2 Output: 20   Example 3: Input: 3 Output: 46    Note:  1 <= N <= 5000
__label__Array You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps.   Example 1: Input: s = "dcab", pairs = [[0,3],[1,2]] Output: "bacd" Explaination:  Swap s[0] and s[3], s = "bcad" Swap s[1] and s[2], s = "bacd"  Example 2: Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]] Output: "abcd" Explaination:  Swap s[0] and s[3], s = "bcad" Swap s[0] and s[2], s = "acbd" Swap s[1] and s[2], s = "abcd" Example 3: Input: s = "cba", pairs = [[0,1],[1,2]] Output: "abc" Explaination:  Swap s[0] and s[1], s = "bca" Swap s[1] and s[2], s = "bac" Swap s[0] and s[1], s = "abc"     Constraints:  1 <= s.length <= 10^5 0 <= pairs.length <= 10^5 0 <= pairs[i][0], pairs[i][1] < s.length s only contains lower case English letters.
__label__Strings Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]
__label__Graph-Algorithms Detective Rust is investigating a homicide and he wants to chase down the murderer. The murderer knows he would definitely get caught if he takes the main roads for fleeing, so he uses the village roads (or side lanes) for running away from the crime scene. Rust knows that the murderer will take village roads and he wants to chase him down. He is observing the city map, but it doesn't show the village roads (or side lanes) on it and shows only the main roads.  The map of the city is a graph consisting  nodes (labeled  to ) where a specific given node  represents the current position of Rust and the rest of the nodes denote other places in the city, and an edge between two nodes is a main road between two places in the city. It can be suitably assumed that an edge that doesn't exist/isn't shown on the map is a village road (side lane). That means, there is a village road between two nodes  and  iff(if and only if) there is no city road between them.   In this problem, distance is calculated as number of village roads (side lanes) between any two places in the city. Rust wants to calculate the shortest distance from his position (Node ) to all the other places in the city if he travels only using the village roads (side lanes). Note: The graph/map of the city is ensured to be a sparse graph. Input Format The first line contains , denoting the number of test cases.  testcases follow.  First line of each test case has two integers , denoting the number of cities in the map and , denoting the number of roads in the map.  The next  lines each consist of two space-separated integers  and  denoting a main road between city  and city .  The last line has an integer , denoting the current position of Rust.  Constraints         Note  No nodes will have a road to itself.  There will not be multiple edges between any pair of nodes i.e. there is at most one undirected edge between them.  Graph is guaranteed to be sparse.  It is guranteed that there will be a path between any pair of nodes using the side lanes. Output Format For each of T test cases, print a single line consisting of N-1 space separated integers, denoting the shortest distances of the remaining N-1 places from Rust's position (that is all distances, except the source node to itself) using the village roads/side lanes in ascending order based on vertex number.   Sample Input 0 Sample Output 0 Explanation 0 The graph in the first testcase can be shown as:  Here the source node is 1 (marked S).  The distance from 1 to 2 is 3. Path: 1 -> 3 -> 4 -> 2  The distance from 1 to 3 is 1. Path: 1 -> 3  The distance from 1 to 4 is 2. Path: 1 -> 3 -> 4
__label__Dynamic-Programming Given an array of integers and a target sum, determine the sum nearest to but not exceeding the target that can be created.  To create the sum, use any element of your array zero or more times. For example, if  and your target sum is , you might select  or .  In this case, you can arrive at exactly the target.   Function Description  Complete the unboundedKnapsack function in the editor below.  It must return an integer that represents the sum nearest to without exceeding the target value.   unboundedKnapsack has the following parameter(s):   k: an integer   arr: an array of integers   Input Format The first line contains an integer , the number of test cases.     Each of the next  pairs of lines are as follows:  - The first line contains two integers  and , the length of  and the target sum.  -  The second line contains  space separated integers .  Constraints     Output Format Print the maximum sum for each test case which is as near as possible, but not exceeding, to the target sum on a separate line. Sample Input 2 3 12 1 6 9 5 9 3 4 4 4 8  Sample Output 12 9  Explanation In the first test case, one can pick {6, 6}. In the second, we can pick {3,3,3}.
__label__Tree In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v. Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \ 2 - 3   Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.    Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.
__label__Two-Pointers __label__Strings Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.   Example 1: Input: name = "alex", typed = "aaleex" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed.   Example 2: Input: name = "saeed", typed = "ssaaedd" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.   Example 3: Input: name = "leelee", typed = "lleeelee" Output: true   Example 4: Input: name = "laiden", typed = "laiden" Output: true Explanation: It's not necessary to long press any character.       Note:  name.length <= 1000 typed.length <= 1000 The characters of name and typed are lowercase letters.
__label__Tree __label__Data-Structures __label__Mathematics __label__Advanced-Data-Structures Shashank loves trees and math. He has a rooted tree, , consisting of  nodes uniquely labeled with integers in the inclusive range . The node labeled as  is the root node of tree , and each node in  is associated with some positive integer value (all values are initially ).  Let's define  as the  Fibonacci number. Shashank wants to perform  types of operations over his tree, :    Update the subtree rooted at node  such that the node at level  in subtree  (i.e., node ) will have  added to it, all the nodes at level  will have  added to them, and so on. More formally, all the nodes at a distance  from node  in the subtree of node  will have the  Fibonacci number added to them.    Find the sum of all values associated with the nodes on the unique path from  to . Print your sum modulo  on a new line. Given the configuration for tree  and a list of  operations, perform all the operations efficiently. Note: . Input Format The first line contains  space-separated integers,  (the number of nodes in tree ) and  (the number of operations to be processed), respectively.  Each line  of the  subsequent lines contains an integer, , denoting the parent of the  node.  Each of the  subsequent lines contains one of the two types of operations mentioned in the Problem Statement above. Constraints    Output Format For each operation of type  (i.e., ), print the required answer modulo  on a new line. Sample Input 5 10 1 1 2 2 Q 1 5 U 1 1 Q 1 1 Q 1 2 Q 1 3 Q 1 4 Q 1 5 U 2 2 Q 2 3 Q 4 5  Sample Output 0 1 2 2 4 4 4 10  Explanation Intially, the tree looks like this:  After update operation , it looks like this:  After update operation , it looks like this:
__label__Tree __label__Data-Structures One of the most important skills a programmer needs to learn early on is the ability to pose a problem in an abstract way. This skill is important not just for researchers but also in applied fields like software engineering and web development.   You are able to solve most of a problem, except for one last subproblem, which you have posed in an abstract way as follows: Given an array consisting of  integers , define   For example, for an input array [ 10, -5, 5, 20 ], a subsegment  would be computed as follows:    What is , i.e., the maximum value of  among all subsegments ?   Complete the function maximumValue which takes an integer array as input and returns the maximum value of  among all subsegments . maximumValue Note that:   Input Format The first line contains a single integer  The second line contains  space-separated integers  Constraints     Output Format Print a single integer denoting the answer Sample Input 0 Sample Output 0 Explanation 0 The maximum value occurs at  as shown below.   Sample Input 1 Sample Output 1 Explanation 1 The maximum value occurs at .
__label__Array We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. Example : Input:  A = [2, 1, 4, 3] L = 2 R = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].  Note:  L, R  and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000].
__label__Greedy-Algorithms An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.  Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.  Example 1: Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]] Output: 3 Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval. Also, there isn't a smaller size set that fulfills the above condition. Thus, we output the size of this set, which is 3.   Example 2: Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]] Output: 5 Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.   Note: intervals will have length in range [1, 3000]. intervals[i] will have length 2, representing some integer interval. intervals[i][j] will be an integer in [0, 10^8].
__label__Strings S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input:  S = "cba" T = "abcd" Output: "cbad" Explanation:  "a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a".  Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.    Note:  S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only.
__label__Array Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.   Note:  Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means <=.
__label__Array __label__Hash-Table Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2   Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].
__label__Tree Find the sum of all left leaves in a given binary tree. Example:     3    / \   9  20     /  \    15   7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
__label__Hash-Table Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input:  formula = "H2O" Output: "H2O" Explanation:  The count of elements are {'H': 2, 'O': 1}.   Example 2: Input:  formula = "Mg(OH)2" Output: "H2MgO2" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.   Example 3: Input:  formula = "K4(ON(SO3)2)2" Output: "K4N2O14S4" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.   Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.
__label__Dynamic-Programming You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.   Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.    Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.  Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]   Note:  The number of given pairs will be in the range [1, 1000].
__label__Hash-Table __label__Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.   Example 1:   Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation:  Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2).   Example 2:  Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation:  The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report "[1,5,6]", the node value of 5 comes first since 5 is smaller than 6.     Note:  The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000.
__label__Dynamic-Programming A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between  and  inclusive, are lucky? For example,  and .  Each number is tested below:           digit   digit   squares value   sum     squares sum  20      2       4,0     4 21      3       4,1     5 22      4       4,4     8 23      5       4,9     13 24      6       4,16    20 25      7       4,25    29  We see that two numbers, ,  and  are lucky. Note: These lucky numbers are not to be confused with Lucky Numbers Function Description  Complete the luckyNumbers function in the editor below.  It should return an integer that represents the number of lucky numbers in the given range.   luckyNumbers has the following parameter(s):   a: an integer, the lower range bound   b: an integer, the higher range bound   Input Format The first line contains the number of test cases .  Each of the next  lines contains two space-separated integers,  and . Constraints     Output Format Output T lines, one for each test case in the order given. Sample Input 2   1 20   120 130  Sample Output 4   1  Explanation For the first case, the lucky numbers are , and .  For the second case, the only lucky number is .
__label__Strings You are given a string containing characters  and  only.  Your task is to change it into a string such that there are no matching adjacent characters. To do this, you are allowed to delete zero or more characters in the string.   Your task is to find the minimum number of required deletions. For example, given the string , remove an  at positions  and  to make  in  deletions. Function Description Complete the alternatingCharacters function in the editor below.  It must return an integer representing the minimum number of deletions to make the alternating string.   alternatingCharacters has the following parameter(s): s: a string Input Format The first line contains an integer , the number of queries.  The next  lines each contain a string . Constraints    Each string  will consist only of characters  and  Output Format For each query, print the minimum number of deletions required on a new line.   Sample Input 5 AAAA BBBBB ABABABAB BABABA AAABBB  Sample Output 3 4 0 0 4  Explanation The characters marked red are the ones that can be deleted so that the string doesn't have matching consecutive characters.
__label__Dynamic-Programming Let's play Fairy Chess! You have an  chessboard. An -leaper is a chess piece which can move from some square  to some square  if ; however, its movements are restricted to up (), down (), left (), and right () within the confines of the chessboard, meaning that diagonal moves are not allowed. In addition, the leaper cannot leap to any square that is occupied by a pawn. Given the layout of the chessboard, can you determine the number of ways a leaper can move  times within the chessboard? Note:  refers to the absolute value of some integer, . Input Format The first line contains an integer, , denoting the number of queries. Each query is described as follows: The first line contains three space-separated integers denoting , , and , respectively. Each line  of the  subsequent lines contains  characters. The  character in the  line describes the contents of square  according to the following key: . indicates the location is empty. P indicates the location is occupied by a pawn. L indicates the location of the leaper. . indicates the location is empty. . P indicates the location is occupied by a pawn. P L indicates the location of the leaper. L Constraints   There will be exactly one L character on the chessboard. L The -leaper can move up (), down (), left (), and right () within the confines of the chessboard. It cannot move diagonally. Output Format For each query, print the number of ways the leaper can make  moves on a new line. Because this value can be quite large, your answer must be modulo . Sample Input 0 Sample Output 0 Explanation 0 You must perform two queries, outlined below. The green cells denote a cell that was leaped to by the leaper, and coordinates are defined as . The leaper can leap to the following locations:    Observe that the leaper cannot leap to the square directly underneath it because it's occupied by a pawn. Thus, there are  ways to make  move and we print  on a new line.  The leaper can leap to the following locations:    Thus, we print  on a new line. Note: Don't forget that your answer must be modulo .
__label__Dynamic-Programming __label__Tree Byteland has  cities (numbered from  to ) and  bidirectional roads. A path is comprised of  or more connected roads. It is guaranteed that there is a path from any city to any other city. Steven is a road maintenance worker in Byteland. He is required to maintain exactly  paths on any given workday. He cannot work on the same road twice in one day (so no  paths can contain the same  roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city. Given , help Steven determine how many different possible path sets will allow him to perform his maintenance duties. Then print the answer modulo . Input Format The first line contains  space-separated integers,  (the number of cities) and  (the number of roads to maintain).  Each line  of the  subsequent lines contains  space-separated integers, , describing a bidirectional road between cities  and . Constraints     Output Format Find the number of different path sets that will allow Steven to complete  orders, and print the answer .  Sample Input 4 2 1 2 2 3 2 4  Sample Output 6  Explanation For the following Byteland map:   Steven can maintain  roads using any of the following  routes:  and   and   and   and   and   and  Thus, we print the result of  on a new line, which is .
__label__Dynamic-Programming Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2]  Follow up:  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
__label__Hash-Table Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].  Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
__label__Dynamic-Programming __label__Depth-first-Search There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.    Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.  Example 1: Input: "aaabbb" Output: 2 Explanation: Print "aaa" first and then print "bbb".   Example 2: Input: "aba" Output: 2 Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.   Hint: Length of the given string will not exceed 100.
__label__Mathematics __label__Strings Validate if a given string can be interpreted as a decimal number. Some examples: "0" => true " 0.1 " => true "abc" => false "1 a" => false "2e10" => true " -90e3   " => true " 1e" => false "e3" => false " 6e-1" => true " 99e2.5 " => false "53.5e93" => true " --6 " => false "-+3" => false "95a54e53" => false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:  Numbers 0-9 Exponent - "e" Positive/negative sign - "+"/"-" Decimal point - "."  Of course, the context of these characters also matters in the input. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.
__label__Strings We are given two arrays A and B of words.  Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world". Now say a word a from A is universal if for every b in B, b is a subset of a.  Return a list of all universal words in A.  You can return the words in any order.      Example 1: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"] Output: ["facebook","google","leetcode"]   Example 2: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"] Output: ["apple","google","leetcode"]   Example 3: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"] Output: ["facebook","google"]   Example 4: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"] Output: ["google","leetcode"]   Example 5: Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"] Output: ["facebook","leetcode"]    Note:  1 <= A.length, B.length <= 10000 1 <= A[i].length, B[i].length <= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn't i != j with A[i] == A[j].
__label__Search We define the following: A subarray of array  of length  is a contiguous segment from  through  where . The sum of an array is the sum of its elements. Given an  element array of integers, , and an integer, , determine the maximum value of the sum of any of its subarrays modulo . For example,  Assume  and .  The following table lists all subarrays and their moduli: The maximum modulus is . Function Description Complete the maximumSum function in the editor below.  It should return a long integer that represents the maximum value of . maximumSum has the following parameter(s): a: an array of long integers, the array to analyze m: a long integer, the modulo divisor Input Format The first line contains an integer , the number of queries to perform. The next  pairs of lines are as follows: The first line contains two space-separated integers  and (long), the length of  and the modulo divisor.   The second line contains  space-separated long integers . Constraints        the sum of  over all test cases   Output Format For each query, return the maximum value of  as a long integer. Sample Input 1 5 7 3 3 9 9 5  Sample Output 6  Explanation The subarrays of array  and their respective sums modulo  are ranked in order of length and sum in the following list:  and    and                        The maximum value for  for any subarray is .
__label__Dynamic-Programming Roy is helping the police department of his city in crime fighting. Today, they informed him about a new planned operation. Think of the city as a  plane. The road along the -axis is very crime prone, because  criminals live there. No two criminals live at the same position. To catch these criminals, the police department has to recruit some police officers and give each of them USD  as wages. A police officer can start his operation from any point , drive his car to point  in a straight line, and catch all the criminals who live on this way. The cost of fuel used by the officer's car is equal to the square of the euclidean distance between points  and  (Euclidean distance between points  and  equals to  ). The police department asks Roy to plan this operation. So Roy has to tell them the number of officers to recruit and the routes these officers should take in order to catch all the criminals. Roy has to provide this information while minimizing the total expenses of this operation. Find out the minimum amount of money required to complete the operation. Input Format The first line contains two integers  , number of criminals, and  , the cost of recruiting a police officer. The next line contains  space separated integers. The  integer indicates the position of the  criminal on -axis (in other words, if the  integer is , then location of the  criminal is ). The value of the positions are between  and  and are given in increasing order in the input. Output Format Print the minimum amount of money required to complete the operation. Sample Input 5 10 1 4 5 6 9  Sample Output 34  Explanation For the sample test case, police department recruits  officers who get paid . The first officer starts at point  and catches the criminal there. So he does not use any fuel. The second officer catches criminals at points ,  and . He burns fuel worth USD . The third officer catches the criminal at point . He also does not burn any fuel. The total money spent by the department is, . Timelimits  Timelimits for this challenge are given here
__label__Data-Structures In this challenge, you must implement a simple text editor. Initially, your editor contains an empty string, . You must perform  operations of the following  types: append  - Append string  to the end of . delete   - Delete the last  characters of . print     - Print the  character of . undo     - Undo the last (not previously undone) operation of type  or , reverting  to the state it was in prior to that operation.  Input Format The first line contains an integer, , denoting the number of operations.  Each line  of the  subsequent lines (where ) defines an operation to be performed. Each operation starts with a single integer,  (where ), denoting a type of operation as defined in the Problem Statement above. If the operation requires an argument,  is followed by its space-separated argument. For example, if  and , line  will be 1 abcd.  1 abcd Constraints     The sum of the lengths of all  in the input .   The sum of  over all delete operations .   All input characters are lowercase English letters.   It is guaranteed that the sequence of operations given as input is possible to perform. Output Format Each operation of type  must print the  character on a new line. Sample Input 8 1 abc 3 3 2 3 1 xy 3 2 4  4  3 1  Sample Output c y a  Explanation Initially,  is empty. The following sequence of  operations are described below: . We append  to , so .  Print the  character on a new line. Currently, the  character is c. c Delete the last  characters in  (), so .  Append  to , so .  Print the  character on a new line. Currently, the  character is y. y Undo the last update to , making  empty again (i.e., ). Undo the next to last update to  (the deletion of the last  characters), making . Print the  character on a new line. Currently, the  character is a. a
__label__Data-Structures There are  values to represent nodes in a graph. They are divided into two sets  and . Each set has exactly  values. Set  is represent by .  can contain any value between  to (inclusive). Set  is represented by .  can contain any value between  to (inclusive). Same value can be chosen any number of times.   Here  represents the edges of the graph.   Your task is to print the number of vertices in the smallest and the largest connected components of the graph.   Note Single nodes should not be considered in the answer.  For more clarity look at the following figure.    For the above graph smallest connected component is 7 and largest connected component is 17.   Input Format First line contains an integer .  Each of the next  lines contain two space-separated integers,  line contains  and .   Constraints       Output Format Print two space separated integers, the number of vertices in the smallest and the largest components. Sample Input 5 1 6  2 7 3 8 4 9 2 6  Sample Output 2 4  Explanation The number of vertices in the smallest connected component in the graph is  i.e. either  or .  The number of vertices in the largest connected component in the graph is  i.e. .
__label__Hash-Table Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.       Example: Input: ["Hello", "Alaska", "Dad", "Peace"] Output: ["Alaska", "Dad"]    Note:  You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.
__label__Dynamic-Programming Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters:   'A' : Absent.  'L' : Late.  'P' : Present.     A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). Example 1: Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" Only "AA" won't be regarded as rewardable owing to more than one absent times.    Note: The value of n won't exceed 100,000.
__label__Tree __label__Depth-first-Search Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22,       5      / \     4   8    /   / \   11  13  4  /  \      \ 7    2      1  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
__label__Strings Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.   Example: Input:  paragraph = "Bob hit a ball, the hit BALL flew far after it was hit." banned = ["hit"] Output: "ball" Explanation:  "hit" occurs 3 times, but it is a banned word. "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.  Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as "ball,"),  and that "hit" isn't the answer even though it occurs more because it is banned.    Note:   1 <= paragraph.length <= 1000. 0 <= banned.length <= 100. 1 <= banned[i].length <= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols.
__label__Array Given an array A of integers, a ramp is a tuple (i, j) for which i < j and A[i] <= A[j].  The width of such a ramp is j - i. Find the maximum width of a ramp in A.  If one doesn't exist, return 0.   Example 1: Input: [6,0,8,2,1,5] Output: 4 Explanation:  The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.   Example 2: Input: [9,8,1,0,1,9,4,0,4,1] Output: 7 Explanation:  The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.       Note:  2 <= A.length <= 50000 0 <= A[i] <= 50000
__label__Bit Consider an array of  binary integers (i.e., 's and 's) defined as . Let  be the bitwise XOR of all elements in the inclusive range between index  and index  in array . In other words, . Next, we'll define another function, :   Given array  and  independent queries, perform each query on  and print the result on a new line. A query consists of three integers, , , and , and you must find the maximum possible  you can get by changing at most  elements in the array from  to  or from  to .  Note: Each query is independent and considered separately from all other queries, so changes made in one query have no effect on the other queries.  Input Format The first line contains two space-separated integers denoting the respective values of  (the number of elements in array ) and  (the number of queries).  The second line contains  space-separated integers where element  corresponds to array element  .  Each line  of the  subsequent lines contains  space-separated integers, ,  and  respectively, describing query  . Constraints     Subtask  and  for  of the maximum score ,  and  for  of the maximum score Output Format Print  lines where line  contains the answer to query  (i.e., the maximum value of  if no more than  bits are changed). Sample Input 3 2 0 0 1 0 2 1 0 1 0  Sample Output 4 0  Explanation Given , we perform the following  queries: If we change  to , then we get  and . In this query, .
__label__Strings Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.            Example 1: Input: "ab-cd" Output: "dc-ba"   Example 2: Input: "a-bC-dEf-ghIj" Output: "j-Ih-gfE-dCba"   Example 3: Input: "Test1ng-Leet=code-Q!" Output: "Qedo1ct-eeLg=ntse-T!"     Note:  S.length <= 100 33 <= S[i].ASCIIcode <= 122  S doesn't contain \ or "
__label__Data-Structures __label__Advanced-Data-Structures Given a tree of N nodes, where each node is uniquely numbered in between [1, N]. Each node also has a value which is initially 0. You need to perform following two operations in the tree.   Update Operation Report Operation Update Operation U r t a b  Adds ab + (a+1)b + (b+1)a to all nodes in the subtree rooted at t, considering that tree is rooted at r (see explanation for more details).   ab + (a+1)b + (b+1)a t r Report Operation R r t m  Output the sum of all nodes in the subtree rooted at t, considering that tree is rooted at r. Output the sum modulo m (see explanation for more details). t r m Input Format First line contains N, number of nodes in the tree.  Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, number of queries to follow.  Next Q lines follow, each line will be either a report operation or an update operation.   Output Format For each report query output the answer in a separate line. Constraints 1 ≤ N ≤ 100000  1 ≤ Q ≤ 100000  1 ≤ m ≤ 101  1 ≤ r, t, x, y ≤ N  x ≠ y  1 ≤ a, b ≤ 1018  Notes There will be at most one edge between a pair of nodes. There will be no loop. Tree will be completely connected.  Sample Input 4 1 2 2 3 3 4 4 U 3 2 2 2 U 2 3 2 2 R 1 2 8 R 4 3 9  Sample Output 2 3  Explanation Initially Values in each node : [0,0,0,0]  The first query is U 3 2 2 2. Here, tree is rooted at 3. It looks like  U 3 2 2 2     3(0)    / \   /   \  2(0)  4(0)  |  |  1(0)  For the sub tree rooted at 2 ( nodes 2 and 1 ), we add ab  + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After first update operation, nodes 1, 2, 3, and 4 will have values 22, 22, 0 and 0 respectively.       3(0)    / \   /   \  2(22) 4(0)  |  |  1(22)  The second query is U 2 3 2 2. Here, tree is rooted at 2. It looks like U 2 3 2 2     2(22)    / \   /   \  1(22) 3(0)        |        |        4(0)  For the sub tree rooted at 3 (nodes 3 and 4), we add ab + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After second update operation, nodes 1, 2, 3, and 4 each have values 22,22,22,22 respectively.       2(22)    / \   /   \  1(22) 3(22)        |        |        4(22)  The first report query is R 1 2 8 asks for the sum modulo 8 of the subtree rooted at 2, when the tree is rooted at 1. The tree looks like  R 1 2 8 1(22)  \   \    2*(22)    |    |    3*(22)    |    |    4*(22)  The sum of the values of nodes 2, 3 and 4 are  (22 + 22 + 22) % 8 = 2  The second report query is R 4 3 9 asks for the sum modulo 9 of the subtree rooted at 3 when the tree is rooted at 4. The tree looks like  R 4 3 9 4(22)  \   \    3*(22)    |    |    2*(22)    |    |    1*(22)  The sum of the values of nodes 3, 2 and 1 are  (22 + 22 + 22) % 9 = 3  Time Limits:  C, C++: 4s | Java and other JVM based languages: 10s | Python, Python3 = 45s | Other interpreted Language: 30s | C#, Haskell: 10s | Rest: 3 times of default.
__label__Tree __label__Depth-first-Search Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B. (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)   Example 1:  Input: [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation:  We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.    Note:  The number of nodes in the tree is between 2 and 5000. Each node will have value between 0 and 100000.
__label__Game-Theory Stephanie just learned about a game called Nim in which there are two players and  piles of stones. During each turn, a player must choose any non-empty pile and take as many stones as they want. The first player who cannot complete their turn (i.e., because all piles are empty) loses.   Stephanie knows that, for each start position in this game, it's possible to know which player will win (i.e., the first or second player) if both players play optimally. Now she wants to know the number of different games that exist that satisfy all of the following conditions: The game starts with  non-empty piles and each pile contains less than  stones. All the piles contain pairwise different numbers of stones. The first player wins if that player moves optimally. Help Stephanie by finding and printing the number of such games satisfying all the above criteria, modulo . Input Format The first line contains two space-separated integers describing the respective values of  and . Constraints   Output Format Print the number of such games, modulo . Sample Input 0 Sample Output 0 Explanation 0 We want to know the number of games with  piles where each pile contains  stones. There are six such possible games with the following distributions of stones: . Thus, we print the result of  as our answer.
__label__Hash-Table Given words first and second, consider occurrences in some text of the form "first second third", where second comes immediately after first, and third comes immediately after second. For each such occurrence, add "third" to the answer, and return the answer.   Example 1: Input: text = "alice is a good girl she is a good student", first = "a", second = "good" Output: ["girl","student"]   Example 2: Input: text = "we will we will rock you", first = "we", second = "will" Output: ["we","rock"]    Note:  1 <= text.length <= 1000 text consists of space separated words, where each word consists of lowercase English letters. 1 <= first.length, second.length <= 10 first and second consist of lowercase English letters.
__label__Depth-first-Search There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.  Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0).  You can walk back and forth between rooms freely. Return true if and only if you can enter every room.   Example 1: Input: [[1],[2],[3],[]] Output: true Explanation:   We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3.  Since we were able to go to every room, we return true.  Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2.  Note:  1 <= rooms.length <= 1000 0 <= rooms[i].length <= 1000 The number of keys in all rooms combined is at most 3000.
__label__Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]    Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.  Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.    Note:  All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree.
__label__Array Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1: Input: A = [[1,1,0],             [0,1,0],             [0,1,0]]        B = [[0,0,0],             [0,1,1],             [0,0,1]] Output: 3 Explanation: We slide A to right by 1 unit and down by 1 unit. Notes:   1 <= A.length = A[0].length = B.length = B[0].length <= 30 0 <= A[i][j], B[i][j] <= 1
__label__Search Watson gives Sherlock an array of integers.  His challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right.  For instance, given the array ,  is between two subarrays that sum to .  If your starting array is , that element satisfies the rule as left and right sum to . You will be given arrays of integers and must determine whether there is an element that meets the criterion. Function Description  Complete the balancedSums function in the editor below.  It should return a string, either YES if there is an element meeting the criterion or NO otherwise.   YES NO balancedSums has the following parameter(s):   arr: an array of integers   Input Format The first line contains , the number of test cases.   The next  pairs of lines each represent a test case.  - The first line contains , the number of elements in the array .  - The second line contains  space-separated integers  where .   Constraints        Output Format For each test case print YES if there exists an element in the array, such that the sum of the elements on its left is equal to the sum of the elements on its right; otherwise print NO.   YES NO Sample Input 0 Sample Output 0 Explanation 0 For the first test case, no such index exists.  For the second test case, , therefore index  satisfies the given conditions. Sample Input 1 Sample Output 1 Explanation 1 In the first test case,  is between two subarrays summing to .  In the second case,  is between two subarrays summing to .  In the third case,  is between two subarrays summing to .
__label__Graph-Algorithms Fedya is a seasoned traveller and is planning his trip to Treeland. Treeland is a country with an ancient road system which is in the form of a tree structure.  cities of Treeland are numbered by  positive integers: . Fedya has not yet decided the starting point (city) of his journey and the cities he will visit. But there are a few things you know about Fedya's trip: Fedya is fond of travelling to great distances. So if he is currently located in city , his destination will be a city which is most distant from city . Fedya is fond of travelling to great distances. So if he is currently located in city , his destination will be a city which is most distant from city . There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey. There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey. There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number. There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number. Fedya has prepared a list of  possible journeys. Each one is characterized by two integers - the starting city  and the total number of cities to be visited, . For each of them, he is keen to know the total distance travelled by him. Input Format The first line of input will contain two space separated integers  and  - the number of cities and the number of possible journeys. Then, there will be  lines, each of them will contain two space separated integers  , denoting the bi-directional road between the cities with numbers  and  with the unitary length. Then there will be  lines, each of them will have two space separated integers  and , denoting a journey. Constraints    Output Format For each journey, output the travelled distance on a separate line. Sample Input Sample Output   Explanation The tree in question is given in the picture below.   4 6 indicates that Fedya starts at 4. Now we see that the most distant city from 4 is 8. Fedya now travels to city 8.  From 8, the most distance cities are [4, 3]. As 4 is already visited, he chooses to visit city 3. From city 3, he revisits city 8 and so on. The cities in the order of visit is 4 - > 8 -> 3 -> 8 -> 4 -> 8 -> 3 which sums to 24. Hence, the answer.   4 6 6 3 indicates that Fedya starts at city 6. From 6, the most distant cities are [3,4,8]. In this leg of the journey, no city is visited and hence Fedya chooses to visit the city with the smallest number 3. From 3, he visits 8 and then he ends his trip at city 4 which sums to 3 + 4 + 4 = 11. Hence, the answer.   6 3
__label__Two-Pointers __label__Strings Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: "A man, a plan, a canal: Panama" Output: true  Example 2: Input: "race a car" Output: false
__label__Array Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them. The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots.   Example 1: Input: [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11    Note:  2 <= A.length <= 50000 1 <= A[i] <= 1000
__label__Data-Structures __label__Advanced-Data-Structures Jim has invented a new flying object called HZ42. HZ42 is like a broom and can only fly horizontally, independent of the environment. One day, Jim started his flight from Dubai's highest skyscraper, traveled some distance and landed on another skyscraper of same height! So much fun! But unfortunately, new skyscrapers have been built recently. Let us describe the problem in one dimensional space. We have in total  skyscrapers aligned from left to right. The th skyscraper has a height of . A flying route can be described as  with , which means, Jim starts his HZ42 at the top of the skyscraper  and lands on the skyscraper . Since HZ42 can only fly horizontally, Jim will remain at the height  only. Thus the path  can be valid, only if each of the skyscrapers  is not strictly greater than  and if the height of the skyscraper he starts from and arrives on have the same height. Formally,  is valid iff  and . Help Jim in counting the number of valid paths represented by ordered pairs .   Input Format The first line contains , the number of skyscrapers. The next line contains  space separated integers representing the heights of the skyscrapers.  Output Format Print an integer that denotes the number of valid routes. Constraints  and no skyscraper will have height greater than  and less than . Sample Input #00 6 3 2 1 2 3 3  Sample Output #00 8  Sample Input #01 3 1 1000 1  Sample Output #01 0  Explanation First testcase: (1, 5), (1, 6) (5, 6) and (2, 4) and the routes in the opposite directions are the only valid routes.  Second testcase: (1, 3) and (3, 1) could have been valid, if there wasn't a big skyscraper with height 1000 between them.
__label__Mathematics On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes.            Example 1: Input: [[2]] Output: 10   Example 2: Input: [[1,2],[3,4]] Output: 34   Example 3: Input: [[1,0],[0,2]] Output: 16   Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32   Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46    Note:  1 <= N <= 50 0 <= grid[i][j] <= 50
__label__Greedy-Algorithms Jim's Burgers has a line of hungry customers.  Orders vary in the time it takes to prepare them.  Determine the order the customers receive their orders.  Start by numbering each of the customers from  to , front of the line to the back.  You will then be given an order number and a preparation time for each customer.    The time of delivery is calculated as the sum of the order number and the preparation time.  If two orders are delivered at the same time, assume they are delivered in ascending customer number order. For example, there are  customers in line.  They each receive an order number  and a preparation time .: We see that the orders are delivered to customers in the following order: Function Description  Complete the jimOrders function in the editor below.  It should return an array of integers that represent the order that customers' orders are delivered.   jimOrders has the following parameter(s):   orders: a 2D integer array where each  is in the form .   Input Format The first line contains an integer , the number of customers.  Each of the next  lines contains two space-separated integers, an order number and prep time for .       Constraints      Output Format Print a single line of  space-separated customer numbers (recall that customers are numbered from  to ) that describes the sequence in which the customers receive their burgers. If two or more customers receive their burgers at the same time, print their numbers in ascending order. Sample Input 0 3 1 3 2 3 3 3  Sample Output 0 1 2 3  Explanation 0  Jim has the following orders: . This order is delivered at time . . This order is delivered at time . . This order is delivered at time . The orders were delivered in the same order as the customers stood in line. The index in  is the customer number and is what is printed.  In this case, the customer numbers match the order numbers. Sample Input 1 5 8 1 4 2 5 6 3 1 4 3  Sample Output 1 4 2 5 1 3  Explanation 1  Jim has the following orders: . This order is delivered at time . . This order is delivered at time . . This order is delivered at time . . This order is delivered at time . . This order is delivered at time . When we order these by ascending fulfillment time, we get: : customer . : customer . : customer . : customer . : customer . We print the ordered numbers in the bulleted listed above as 4 2 5 1 3.  4 2 5 1 3 Note: While not demonstrated in these sample cases, recall that any orders fulfilled at the same time must be listed by ascending order number.
__label__Array We have an array A of integers, and an array queries of queries. For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A. (Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.) Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.   Example 1: Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation:  At the beginning, the array is [1,2,3,4]. After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6. After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2. After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.    Note:  1 <= A.length <= 10000 -10000 <= A[i] <= 10000 1 <= queries.length <= 10000 -10000 <= queries[i][0] <= 10000 0 <= queries[i][1] < A.length
__label__Depth-first-Search Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.   Example: Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]    Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.
__label__Array __label__Mathematics An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other. What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1. Examples: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown below, from left to right:  0110     1010     1010 0110 --> 1010 --> 0101 1001     0101     1010 1001     0101     0101  The first move swaps the first and second column. The second move swaps the second and third row.   Input: board = [[0, 1], [1, 0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, 01 10  is also a valid chessboard.  Input: board = [[1, 0], [1, 0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.  Note:  board will have the same number of rows and columns, a number in the range [2, 30]. board[i][j] will be only 0s or 1s.
__label__Greedy-Algorithms You are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.) Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle's initial location. Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.    Example 1: Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false   Example 2: Input: trips = [[2,1,5],[3,3,7]], capacity = 5 Output: true   Example 3: Input: trips = [[2,1,5],[3,5,7]], capacity = 3 Output: true   Example 4: Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11 Output: true               Constraints:  trips.length <= 1000 trips[i].length == 3 1 <= trips[i][0] <= 100 0 <= trips[i][1] < trips[i][2] <= 1000 1 <= capacity <= 100000
__label__Mathematics Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1. We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order. For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right. Additionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer. Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.   Example 1: Input: 4 Output: 7 Explanation: 7 = 4 * 3 / 2 + 1  Example 2: Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1    Note:  1 <= N <= 10000 -2^31 <= answer <= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)
__label__Binary-Search Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]    Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?
__label__Array __label__Hash-Table __label__Two-Pointers Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]
__label__Depth-first-Search Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land) A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.   Example 1: Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation:  There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary. Example 2: Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation:  All 1s are either on the boundary or can reach the boundary.    Note:  1 <= A.length <= 500 1 <= A[i].length <= 500 0 <= A[i][j] <= 1 All rows have the same size.
__label__Hash-Table All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  Output: ["AAAAACCCCC", "CCCCCAAAAA"]
__label__Dynamic-Programming __label__Mathematics Consider an array, , of length . We can split  into contiguous segments called pieces and store them as another array, . For example, if , we have the following arrays of pieces:  contains three -element pieces.  contains two pieces, one having  elements and the other having  element.  contains two pieces, one having  element and the other having  elements.  contains one -element piece. We consider the value of a piece in some array  to be , and we consider the total value of some array  to be the sum of the values for all pieces in that . For example, the total value of  is . Given , find the total values for all possible 's, sum them together, and print this sum modulo  on a new line. Input Format The first line contains a single integer, , denoting the size of array .  The second line contains  space-separated integers describing the respective values in  (i.e., ). Constraints   Output Format Print a single integer denoting the sum of the total values for all piece arrays ('s) of , modulo . Sample Input 0 3 1 3 6  Sample Output 0 73  Explanation 0  Given , our piece arrays are: , and . , and . , and . , and . When we sum all the total values, we get . Thus, we print the result of  on a new line. Sample Input 1 5 4 2 9 10 1  Sample Output 1 971
__label__Mathematics __label__Strings Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: "One Hundred Twenty Three"  Example 2: Input: 12345 Output: "Twelve Thousand Three Hundred Forty Five" Example 3: Input: 1234567 Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Example 4: Input: 1234567891 Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
__label__Depth-first-Search Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000  Output: 1  Example 2: Input: 11000 11000 00100 00011  Output: 3
__label__Tree __label__Depth-first-Search Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5
__label__Two-Pointers Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)    Example 1:  Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.    Note:  0 <= A.length < 1000 0 <= B.length < 1000 0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9  NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Dynamic-Programming Li and Lu have  integers, , that they want to divide fairly between the two of them. They decide that if Li gets integers with indices  (which implies that Lu gets integers with indices ), then the measure of unfairness of this division is:    Find the minimum measure of unfairness that can be obtained with some division of the set of integers where Li gets exactly  integers.  Note  means Set complement Input Format The first line contains two space-separated integers denoting the respective values of  (the number of integers Li and Lu have) and  (the number of integers Li wants).  The second line contains  space-separated integers describing the respective values of . Constraints   For  of the test cases, . For  of the test cases, . Output Format Print a single integer denoting the minimum measure of unfairness of some division where Li gets  integers. Sample Input 0 4 2 4 3 1 2  Sample Output 0  6  Explanation 0  One possible solution for this input is .  Sample Input 1  4 1 3 3 3 1  Sample Output 1 2  Explanation 1  The following division of numbers is optimal for this input: .
__label__Strings Alice has a binary string. She thinks a binary string is beautiful if and only if it doesn't contain the substring .  In one step, Alice can change a  to a  or vice versa. Count and print the minimum number of steps needed to make Alice see the string as beautiful. For example, if Alice's string is  she can change any one element and have a beautiful string. Function Description  Complete the beautifulBinaryString function in the editor below.  It should return an integer representing the minimum moves required.   beautifulBinaryString has the following parameter(s):   b: a string of binary digits   Input Format The first line contains an integer , the length of binary string.  The second line contains a single binary string . Constraints  . Output Format Print the minimum number of steps needed to make the string beautiful. Sample Input 0 7 0101010  Sample Output 0 2    Explanation 0:  In this sample,  The figure below shows a way to get rid of each instance of :  Because we were able to make the string beautiful by changing  characters ( and ), we print . Sample Input 1 5 01100  Sample Output 1 0  Sample Case 1: In this sample   Explanation 1 The substring  does not occur in , so the string is already beautiful and we print . Sample Input 2 10 0100101010  Sample Output 2 3  Explanation 2  In this sample  One solution is to change the values of  to form a beautiful string.
__label__Dynamic-Programming Let's consider a permutation P = {p1, p2, ..., pN} of the set of N = {1, 2, 3, ..., N} elements .   P is called a magic set if it satisfies both of the following constraints:   Given a set of K integers, the elements in positions a1, a2, ..., aK are less than their adjacent elements, i.e., pai-1 > pai < pai+1 Given a set of L integers, elements in positions b1, b2, ..., bL are  greater than their adjacent elements, i.e., pbi-1 < pbi > pbi+1 How many such magic sets are there? Input Format  The first line of input contains three integers N, K, L separated by a single space.  The second line contains K integers, a1, a2, ... aK each separated by single space.  the third line contains L integers, b1, b2, ... bL each separated by single space.  Output Format  Output the answer modulo 1000000007 (109+7). Constraints  3 <= N <= 5000  1 <= K, L <= 5000  2 <= ai, bj <= N-1, where i ∈ [1, K] AND j ∈ [1, L]   Sample Input #00  4 1 1 2 3  Sample Output #00  5  Explanation #00 Here, N = 4 a1 = 2 and b1 = 3. The 5 permutations of {1,2,3,4} that satisfy the condition are  2 1 4 3 3 2 4 1 4 2 3 1 3 1 4 2 4 1 3 2 Sample Input #01 10 2 2 2 4 3 9  Sample Output #01 161280
__label__Hash-Table Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: "cbaebabacd" p: "abc"  Output: [0, 6]  Explanation: The substring with start index = 0 is "cba", which is an anagram of "abc". The substring with start index = 6 is "bac", which is an anagram of "abc".   Example 2: Input: s: "abab" p: "ab"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is "ab", which is an anagram of "ab". The substring with start index = 1 is "ba", which is an anagram of "ab". The substring with start index = 2 is "ab", which is an anagram of "ab".
__label__Tree __label__Depth-first-Search Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3]     1    / \   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1]     4    / \   9   0  / \ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026.
__label__Mathematics A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1: Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Note: The boundaries of each input argument are 1 <= left <= right <= 10000.
__label__Strings __label__Tree You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4]        1      /   \     2     3    /       4       Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".   Example 2: Input: Binary tree: [1,2,3,null,4]        1      /   \     2     3      \         4   Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
__label__Depth-first-Search Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.  Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.  Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.  Examples: Input: "WRRBBW", "RB" Output: -1 Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW  Input: "WWRRBBWW", "WRBRW" Output: 2 Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty  Input:"G", "GGGGG" Output: 2 Explanation: G -> G[G] -> GG[G] -> empty   Input: "RBYYBBRRB", "YRBGB" Output: 3 Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty    Note:  You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input. The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input. Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.
__label__Graph-Algorithms In order to entertain themselves during the long flight, Alex and Fedor invented the following very simple two players game. The game is:   First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph. First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph. Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.   Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.   We consider two trees different if the sets of the numbers of edges that are included in these trees are different. We consider two sets  and  different if there is at least one element that is present in  and not present in  or vice versa.   We should also mention that the graphs with enormous number of spanning trees upset Alex, as well as Fedor, so they will never have a graph that has more than  spanning trees.   At some point, Fedor became too lazy to look for minimal spanning trees and now he just picks some arbitrary spanning tree from the Alex's graph. Each spanning tree has equal probability to be picked by Fedor. What is the probability of Fedor's victory now?    Input Format The first line of input consists of two single space separated integers  and  - the number of nodes in Alex's graph and the number of edges in that graph, respectively.   Then there are  lines, where the  line has three numbers  with the meaning that the edge with the number  connects the nodes  and  and has the weight of .   Constraints The graph is always connected.       Output Format Output the probability of Fedor's victory, if he picks the spanning tree randomly, as an irreducible fraction. Sample Input 4 4 1 2 1 2 3 4 3 4 3 4 1 2  Sample Output 1/4
__label__Strings Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.    Follow up: Could you solve it using only O(1) extra space?    Example 1: Input: ["a","a","b","b","c","c","c"]  Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]  Explanation: "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".    Example 2: Input: ["a"]  Output: Return 1, and the first 1 characters of the input array should be: ["a"]  Explanation: Nothing is replaced.    Example 3: Input: ["a","b","b","b","b","b","b","b","b","b","b","b","b"]  Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].  Explanation: Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12". Notice each digit has it's own entry in the array.    Note:  All characters have an ASCII value in [35, 126]. 1 <= len(chars) <= 1000.
__label__Two-Pointers Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2.  After removing the second node from the end, the linked list becomes 1->2->3->5.  Note: Given n will always be valid. Follow up: Could you do this in one pass?
__label__Hash-Table In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times.      Example 1: Input: [1,2,3,3] Output: 3   Example 2: Input: [2,1,2,5,3,2] Output: 2   Example 3: Input: [5,1,5,2,5,3,5,4] Output: 5    Note:  4 <= A.length <= 10000 0 <= A[i] < 10000 A.length is even
__label__Tree __label__Data-Structures __label__Advanced-Data-Structures Burger Town is a city that consists of  special junctions and  pathways. There is exactly one shortest path between each pair of junctions. Junction  is located at  and the distance between two junctions  is defined by the Taxicab geometry.  Tim has recently afforded a taxicab to work as a taxicab driver. His vehicle was very cheap, but has a very big flaw. It can only drive  units horizontally and  units vertically before refueling.  If a customer wants to be brought from a junction  to another junction , then this car is only capable of driving the route, iff the sum of horizontal distances and the sum of vertical distances on this path are less than or equal to  and  respectively.  Also, there is a unique path between any two junctions.    Now he has thoughts about returning the vehicle back to the seller. But he first wants to know, if it's even worth it. That's why he wants to know the number of unordered pairs  such that it is not possible to drive a customer from junction  to junction .  Input Format On the first line you will be given ,  and  separated by a single space.  Each of the next  lines contains two space separated integers , denoting the location of junction . Each of the next  lines contains two space separated integers describing a path existing between , i.e., there is a path between  and .   Output Format Output the number of unordered pairs  such that it is not possible to drive from  to .  Constraints    Sample Input 3 2 1 0 0 1 1 2 0 1 2 2 3  Sample Output 1  Explanation The car is only capable of driving  units horizontally and  unit vertically. The horizontal distance between junction 1 and 3(via 2) is equal to 2(), which fits under the horizontal limit of the car. The vertical distance between 1 and 3 is also equal to 2(), but this is not possible for this car since .
__label__Strings Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period "." with "[.]".   Example 1: Input: address = "1.1.1.1" Output: "1[.]1[.]1[.]1" Example 2: Input: address = "255.100.50.0" Output: "255[.]100[.]50[.]0"    Constraints:  The given address is a valid IPv4 address.
__label__Strings Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note:  The length of both num1 and num2 is < 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.
__label__Hash-Table Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 Output: ["i", "love"] Explanation: "i" and "love" are the two most frequent words.     Note that "i" comes before "love" due to a lower alphabetical order.   Example 2: Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 Output: ["the", "is", "sunny", "day"] Explanation: "the", "is", "sunny" and "day" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:  You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters.   Follow up:  Try to solve it in O(n log k) time and O(n) extra space.
__label__Strings Given a balanced parentheses string S, compute the score of the string based on the following rule:  () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.     Example 1: Input: "()" Output: 1   Example 2: Input: "(())" Output: 2   Example 3: Input: "()()" Output: 2   Example 4: Input: "(()(()))" Output: 6    Note:  S is a balanced parentheses string, containing only ( and ). 2 <= S.length <= 50
__label__Strings __label__Dynamic-Programming Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: "abc" Output: 3 Explanation: Three palindromic strings: "a", "b", "c".    Example 2: Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".    Note:  The input string length won't exceed 1000.
__label__Array Write an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".   Example 1: Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation:  RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times:  .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].  .next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].  .next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].  .next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.   Note:  0 <= A.length <= 1000 A.length is an even integer. 0 <= A[i] <= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.
__label__Data-Structures __label__Advanced-Data-Structures A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves. Change the number of books in one of the shelves. Change the number of books in one of the shelves. Obtain the number of books on the shelf having the kth rank within  the range of shelves.  Obtain the number of books on the shelf having the kth rank within  the range of shelves.  A shelf is said to have the kth rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order. Can you write a program to simulate the above queries? Input Format  The first line contains a single integer T, denoting the number of test cases.  The first line of each test case contains an integer N denoting the number of shelves in the library.  The next line contains N space separated integers where the ith integer represents the number of books on the ith shelf where 1<=i<=N.  The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query.  Queries can be of two types: 1 x k - Update the number of books in the xth shelf to k (1 <= x <= N). 0 x y k - Find the number of books on the shelf between the shelves x and y  (both inclusive) with the kth rank (1 <= x <= y <= N, 1 <= k <= y-x+1). Output Format  For every test case, output the results of the queries in a new line. Constraints  1 <= T <= 5  1 <= N <= 104  1 <= Q <= 104  The number of books on each shelf is always guaranteed to be between 1 and 1000. Sample Input 2 2 1 2 2 0 1 2 1 0 1 2 2 4 4 3 2 1 4 0 1 1 1 1 1 1 0 1 1 1 0 1 4 3  Sample Output 1 2 4 1 2  Explanation  There are two test cases : The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :  i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.   ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.   The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2. The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :   i) The first query asks for the smallest number of books in the 1st shelf which is 4.   ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].   iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.   iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2.
__label__Data-Structures A queue is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed. A basic queue has the following operations: Enqueue: add a new element to the end of the queue. Dequeue: remove the element from the front of the queue and return it. In this challenge, you must first implement a queue using two stacks. Then process  queries, where each query is one of the following  types:  1 x: Enqueue element  into the end of the queue. 1 x 2: Dequeue the element at the front of the queue. 2 3: Print the element at the front of the queue. 3 Input Format The first line contains a single integer, , denoting the number of queries.  Each line  of the  subsequent lines contains a single query in the form described in the problem statement above. All three queries start with an integer denoting the query , but only query  is followed by an additional space-separated value, , denoting the value to be enqueued. Constraints       It is guaranteed that a valid answer always exists for each query of type . Output Format For each query of type , print the value of the element at the front of the queue on a new line.  Sample Input 10 1 42 2 1 14 3 1 28 3 1 60 1 78 2 2  Sample Output 14 14  Explanation We perform the following sequence of actions: Enqueue ; . Dequeue the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Print the value at the head of the queue, ; . Enqueue ; . Enqueue ; . Dequeue the value at the head of the queue, ; . Dequeue the value at the head of the queue, ; .
__label__Mathematics Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square. Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].   Example 1: Input: [1,17,8] Output: 2 Explanation:  [1,8,17] and [17,8,1] are the valid permutations.  Example 2: Input: [2,2,2] Output: 1    Note:  1 <= A.length <= 12 0 <= A[i] <= 1e9
__label__Dynamic-Programming Zurikela is creating a graph with a special graph maker. At the begining, it is empty and has no nodes or edges. He can perform  types of operations:      : Create a set of  new nodes and name it -.       : Create edges between nodes of - and -.        : Create a set composed of nodes from - and its directly and indirectly connected nodes, called -. Note that each node can only exist in one set, so other sets become empty.      The first 's name will be -. In first and third operation  is referring to the index of new set: K = [index of last created set] + 1  Create the graph by completing the  operations specified during input. Then calculate the maximum number of independent nodes (i.e.:how many nodes in the final graph which don't have direct edge between them). Input Format The first line contains .  The  subsequent lines each contain an operation to be performed. Constraints  . For the first operation, .  For the second operation,  and all s are distinct. For the second and third operation, it's guaranteed that - and - exist.      Output Format Print maximum number of independent nodes in the final graph (i.e.: nodes which have no direct connection to one another). Sample Input 8 A 1 A 2 B 1 2 C 1 A 2 A 3 B 3 4 B 4 5  Sample Output 5  Explanation There are  operations. After first operation:  After second operation:  After third operation:  After fourth operation:  After fifth and sixth operation  and :  After seventh operation:  After eigth operation:  There are  independent nodes in - and  independent nodes in -, so we print their sum () as our answer.
__label__Tree Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.     Example:  BSTIterator iterator = new BSTIterator(root); iterator.next();    // return 3 iterator.next();    // return 7 iterator.hasNext(); // return true iterator.next();    // return 9 iterator.hasNext(); // return true iterator.next();    // return 15 iterator.hasNext(); // return true iterator.next();    // return 20 iterator.hasNext(); // return false    Note:  next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
__label__Greedy-Algorithms Marc loves cupcakes, but he also likes to stay fit. Each cupcake has a calorie count, and Marc can walk a distance to expend those calories.  If Marc has eaten  cupcakes so far, after eating a cupcake with  calories he must walk at least   miles to maintain his weight. For example, if he eats  cupcakes with calorie counts in the following order: , the miles he will need to walk are .  This is not the minimum, though, so we need to test other orders of consumption.  In this case, our minimum miles is calculated as . Given the individual calorie counts for each of the cupcakes, determine the minimum number of miles Marc must walk to maintain his weight. Note that he can eat the cupcakes in any order.   Function Description  Complete the marcsCakewalk function in the editor below.  It should return a long integer that represents the minimum miles necessary.   marcsCakewalk has the following parameter(s):   calorie: an integer array that represents calorie count for each cupcake   Input Format The first line contains an integer , the number of cupcakes in .  The second line contains  space-separated integers . Constraints   Output Format Print a long integer denoting the minimum number of miles Marc must walk to maintain his weight.  Sample Input 0 Sample Output 0 Explanation 0 Let's say the number of miles Marc must walk to maintain his weight is . He can minimize  by eating the  cupcakes in the following order:  Eat the cupcake with  calories, so . Eat the cupcake with  calories, so . Eat the cupcake with  calories, so . We then print the final value of , which is , as our answer. Sample Input 1 Sample Output 1 Explanation 1
__label__Dynamic-Programming In a project, you have a list of required skills req_skills, and a list of people.  The i-th person people[i] contains a list of skills that person has. Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill.  We can represent these teams by the index of each person: for example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3]. Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.  It is guaranteed an answer exists.   Example 1: Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]] Output: [0,2] Example 2: Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]] Output: [1,2]    Constraints:  1 <= req_skills.length <= 16 1 <= people.length <= 60 1 <= people[i].length, req_skills[i].length, people[i][j].length <= 16 Elements of req_skills and people[i] are (respectively) distinct. req_skills[i][j], people[i][j][k] are lowercase English letters. Every skill in people[i] is a skill in req_skills. It is guaranteed a sufficient team exists.
__label__Binary-Search A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]  Note:  A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2.
__label__Data-Structures __label__Advanced-Data-Structures White Falcon has a tree with  nodes. Each node contains a linear function. Let's denote by  the linear function contained in the node .   Let's denote the path from node  to node  like this: , where  and , and  and  are connected.   White Falcon also has  queries. They are in the following format:       . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .     . Assign  as the function of all the nodes on the path from  to , i.e.,  is changed to  where  is the path from  to .    . Calculate  modulo     . Calculate  modulo  Input Format The first line contains , the number of nodes. The following  lines each contain two integers  and  that describe the function .   Following  lines contain edges of the tree.  The next line contains , the number of queries. Each subsequent line contains one of the queries described above. Output Format For every query of the second kind, print one line containing an integer, the answer for that query.   Constraints   (Number of nodes)   (Number of queries)   Sample Input 2 1 1 1 2 1 2 2 1 2 2 1 1 2 1 2 1  Sample Output 3  Explanation
__label__Strings Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.   A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.   The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.  Example 1: Input: "aba", "cdc" Output: 3 Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings.    Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.
__label__Depth-first-Search (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.      Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0   Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1   Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Graph-Algorithms A crab is an undirected graph which has two kinds of vertices: 1 head, and K feet , and exactly K edges which join the head to each of the feet.( 1 <= K <= T, where T is given) Given an undirected graph, you have to find in it some vertex-disjoint subgraphs where each one is a crab . The goal is to select those crabs in such a way that the total number of vertices covered by them is maximized. Note: two graphs are vertex-disjoint if they do not have any vertices in common.  Input Format The first line of input contains a single integer C. C test-cases follow. The first line of each test-case contains three integers N, T, and M (the number of nodes, max number of feet in the crab graph, and number of edges, respectively). Each of next M lines contains two space separated values v1i, v2i meaning that the there is an edge between vertices v1i and v2i. Note that the graph doesn't have parallel edges or loops. Constraints 1 <= C <= 10   2 <= T <= 100   2 <= N <= 100   0 <= M <= N * (N-1)/2   1 <= v1i <= N   1 <= v2i <= N Output Format For each test-case, output a single integer indicating the maximum number of vertices which can be covered by vertex-disjoint sub-graphs of crab- graphs. Sample Input 2   8 2 7   1 4   2 4   3 4   5 4   5 8   5 7   5 6   6 3 8   1 2   2 3   3 4   4 5   5 6   6 1   1 4   2 5  Sample Output 6   6  Explanation Test #1: The graph for this test-case below. Because T = 2, each crab can have a maximum of 2 feet => each crab can cover a maximum of 3 nodes. We can cover 6 nodes of this graph with these two crabs: One of the crabs has 4 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 7 and 8 as its feet. No additional crabs can be added. The above is not a unique solution: any combination of two crabs, with one head at 4 and one head at 5, will suffice. We could have also chosen Head[4]feet[1,2] and Head[5]feet[6,7] as our two crabs.  Test #2: The graph for this test-case below. We can cover all 6 nodes using two crabs. One of the crabs has 2 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 4 and 6 as its feet.
__label__Dynamic-Programming Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:  You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100  Example: Input: [3,1,5,8] Output: 167  Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
__label__Dynamic-Programming We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve? Note that our partition must use every number in A, and that scores are not necessarily integers. Example: Input:  A = [9,1,2,3,9] K = 3 Output: 20 Explanation:  The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned A into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.    Note:   1 <= A.length <= 100. 1 <= A[i] <= 10000. 1 <= K <= A.length. Answers within 10^-6 of the correct answer will be accepted as correct.
__label__Dynamic-Programming Given an  cube, let  (where ) denote the value stored in cell .  A  sub-cube (where ) of an  cube is considered to be special if the maximum value stored in any cell in the sub-cube is equal to . For each  in the inclusive range , calculate the number of special sub-cubes. Then print each  as a single line of space-separated integers (i.e., ). Input Format The first line contains an integer, , denoting the number of queries. The  subsequent lines describe each query over two lines: The first line contains an integer, , denoting the side length of the initial cube. The second line contains  space-separated integers describing an array of  integers in the form . The integer in some cell  is calculated using the formula . Constraints    where  Output Format For each query, print  space-separated integers where the  integer denotes the number of special sub-cubes for . Sample Input 2 2 2 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 2  Sample Output 7 1 6 1  Explanation We must perform the following  queries: We have a cube of size  and must calculate the number of special sub-cubes for the following values of : : There are  sub-cubes of size  and seven of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .     We then print the respective values for each  as a single line of space-separated integers (i.e., 7 1). We have a cube of size  and must calculate the number of special sub-cubes for the following values of : : There are  sub-cubes of size  and seven of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .     We then print the respective values for each  as a single line of space-separated integers (i.e., 7 1). 7 1 We have a cube of size  and must calculate the number of special sub-cubes for the following values of :    : There are  sub-cubes of size  and six of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .         We then print the respective values for each  as a single line of space-separated integers (i.e., 6 1). We have a cube of size  and must calculate the number of special sub-cubes for the following values of :    : There are  sub-cubes of size  and six of them have a maximum value of  written inside them. So, for , the answer is .  : There is only one sub-cube of size  and the maximum number written inside it is . So, for , the answer is .         We then print the respective values for each  as a single line of space-separated integers (i.e., 6 1). 6 1
__label__Game-Theory __label__Game-Theory Two players are playing a game on a  chessboard. The rules of the game are as follows: The game starts with a single coin located at some  coordinates. The coordinates of the upper left cell are , and of the lower right cell are . The game starts with a single coin located at some  coordinates. The coordinates of the upper left cell are , and of the lower right cell are . In each move, a player must move the coin from cell  to one of the following locations:        Note: The coin must remain inside the confines of the board. In each move, a player must move the coin from cell  to one of the following locations:        Note: The coin must remain inside the confines of the board. Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game. Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game. The figure below shows all four possible moves using an  board for illustration:  Given the initial coordinates of the players' coins, assuming optimal play, determine which player will win the game.  Function Description Complete the chessboardGame function in the editor below.  It should return a string, either First or Second. First Second chessboardGame has the following parameter(s):   x: an integer that represents the starting column position    y: an integer that represents the starting row position   Input Format The first line contains an integer , the number of test cases.  Each of the next  lines contains  space-separated integers  and . Constraints   Output Format On a new line for each test case, print  if the first player is the winner.  Otherwise, print . Sample Input 3 5 2 5 3 8 8  Sample Output Second First First  Explanation In the first case, player1 starts at the red square and can move to any of the blue squares.  Regardless of which one is chosen, the player 2 can move to one of the green squares to win the game.  In the second case, player 1 starts at the red square and can move to any of the blue squares or the purple one.  Moving to the purple one limits player 2 to the yellow square.  From the yellow square, player 1 moves to the green square and wins.
__label__Tree For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.   Example 1: Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.     Note:  Each tree will have at most 100 nodes. Each value in each tree will be a unique integer in the range [0, 99].
__label__Dynamic-Programming Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.   Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation:  The possible falling paths are:   [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]  The falling path with the smallest sum is [1,4,7], so the answer is 12.   Note:  1 <= A.length == A[0].length <= 100 -100 <= A[i][j] <= 100
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool You’re given the pointer to the head node of a doubly linked list. Reverse the order of the nodes in the list. The head node might be NULL to indicate that the list is empty.  Change the next and prev pointers of all the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.  Function Description Complete the reverse function in the editor below.  It should return a reference to the head of your reversed list. reverse has the following parameter(s): head: a reference to the head of a DoublyLinkedList Input Format The first line contains an integer , the number of test cases.   Each test case is of the following format: The first line contains an integer , the number of elements in the linked list.   The next  lines contain an integer each denoting an element of the linked list. Constraints       Output Format Return a reference to the head of your reversed list.  The provided code will print the reverse array as a one line of space-separated integers for each test case.   Sample Input 1 4 1 2 3 4  Sample Output 4 3 2 1   Explanation The initial doubly linked list is:   The reversed doubly linked list is:
__label__Two-Pointers Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL  Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL
__label__Tree __label__Depth-first-Search Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input:     1         1           / \       / \          2   3     2   3          [1,2,3],   [1,2,3]  Output: true  Example 2: Input:     1         1           /           \          2             2          [1,2],     [1,null,2]  Output: false  Example 3: Input:     1         1           / \       / \          2   1     1   2          [1,2,1],   [1,1,2]  Output: false
__label__Dynamic-Programming Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.   Example 1: Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9  Example 2: Input: grid = [[1,1,0,0]] Output: 1    Constraints:  1 <= grid.length <= 100 1 <= grid[0].length <= 100 grid[i][j] is 0 or 1
__label__Search __label__Tree __label__Data-Structures The median of  numbers is defined as the middle number after sorting them in order if  is odd. Or it is the average of the middle two numbers if  is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median. Example:  For a set of  numbers  the median is the third number in the sorted set , which is . Similarly, for a set of  numbers, , the median is the average of the second and the third element in the sorted set , which is .   Input:  The first line is an integer, , that indicates the number of operations. Each of the next  lines is either a x or r x. a x indicates that  is added to the set, and r x indicates that  is removed from the set. Output:  For each operation: If the operation is add, output the median after adding  in a single line. If the operation is remove and the number  is not in the list, output Wrong! in a single line. If the operation is remove and the number  is in the list, output the median after deleting  in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.) Note  If your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong! Constraints:    For each a x or r x,  will always be a signed integer (which will fit in 32 bits). Sample Input:  7   r 1   a 1   a 2   a 1   r 1   r 2   r 1    Sample Output:  Wrong!   1   1.5   1   1.5   1   Wrong!  Note: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!.
__label__Tree __label__Data-Structures An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree.  In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. We define balance factor for each node as : balanceFactor = height(left subtree) - height(right subtree)  The balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.  (https://en.wikipedia.org/wiki/AVL_tree)         You are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.  Input Format  You are given a function, node *insert(node * root,int new_val) {   }  'node' is defined as : struct node { int val;            //value struct node* left;  //left child struct node* right; //right child int ht;             //height of the node } node;  You only need to complete the function.      Note: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.  Output Format  Insert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced. Sample Input      3   /  \  2    4        \         5  The value to be inserted is 6. Sample Output     3   /  \  2    5      / \     4   6  Explanation After inserting 6 in the tree. the tree becomes:     3 (Balance Factor = -2)   /  \  2    4 (Balance Factor = -2)        \         5 (Balance Factor = -1)          \           6 (Balance Factor = 0)  Balance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree. After performing the rotation, the tree becomes :                                3 (Balance Factor = -1)                             /   \       (Balance Factor = 0) 2     5 (Balance Factor = 0)                                 / \            (Balance Factor = 0)4   6 (Balance Factor = 0)
__label__Binary-Search In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.   Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.    Example 1: Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation:  At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8.    Note:  1 <= persons.length = times.length <= 5000 0 <= persons[i] <= persons.length times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0].
__label__Greedy-Algorithms You have an initial power P, an initial score of 0 points, and a bag of tokens. Each token can be used at most once, has a value token[i], and has potentially two ways to use it.  If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point. If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.  Return the largest number of points we can have after playing any number of tokens.      Example 1: Input: tokens = [100], P = 50 Output: 0   Example 2: Input: tokens = [100,200], P = 150 Output: 1   Example 3: Input: tokens = [100,200,300,400], P = 200 Output: 2    Note:  tokens.length <= 1000 0 <= tokens[i] < 10000 0 <= P < 10000
__label__Binary-Search __label__Dynamic-Programming Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2  Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,              and 2 is the max number no larger than k (k = 2). Note:  The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns?
__label__Mathematics A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y). Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False. Examples: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: True Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)  Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: False  Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: True   Note:  sx, sy, tx, ty will all be integers in the range [1, 10^9].
__label__Data-Structures __label__Advanced-Data-Structures Given a rooted tree of  nodes, where each node is uniquely numbered in between [1..N]. The node 1 is the root of the tree. Each node has an integer value which is initially 0. You need to perform the following two kinds of queries on the tree: add t value: Add value to all nodes in subtree rooted at t max a b: Report maximum value on the path from a to b Input Format First line contains N, number of nodes in the tree. Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y.  Next line contains Q, the number of queries to process.  Next Q lines follow with either add or max query per line. Constraints           Output Format For each max query output the answer in a separate line. Sample Input 5 1 2 2 3 2 4 5 1 6 add 4 30 add 5 20 max 4 5 add 2 -20 max 4 5 max 3 4  Sample Output 30 20 10  Explanation In the test case we have the following tree:  Initially all node values are zero.  Queries are performed in the following way: add 4 30 // add 30 to node 4  add 5 20 // add 20 to node 5  max 4 5 // maximum of nodes 4,2,1,5 is 30  add 2 -20 // subtract 20 from nodes 2,3,4  max 4 5 // maximum of nodes 4,2,1,5 is 20  max 3 4 // maximum of nodes 3,2,4 is 10
__label__Greedy-Algorithms Goodland is a country with a number of evenly spaced cities along a line.  The distance between adjacent cities is  unit.  There is an energy infrastructure project planning meeting, and the government needs to know the fewest number of power plants needed to provide electricity to the entire list of cities.  Determine that number.  If it cannot be done, return . You are given a list of city data.  Cities that may contain a power plant have been labeled .  Others not suitable for building a plant are labeled .  Given a distribution range of , find the lowest number of plants that must be built such that all cities are served.  The distribution range limits supply to cities where distance is less than k. For example, you are given  and your city data is .  Each city is  unit distance from its neighbors, and we'll use  based indexing.  We see there are  cities suitable for power plants, cities  and .  If we build a power plant at , it can serve  through  because those endpoints are at a distance of  and .  To serve , we would need to be able to build a plant in city  or .  Since none of those is suitable, we must return .  It cannot be done using the current distribution constraint. Function Description  Complete the pylons function in the editor below.  It should return an integer that represents the minimum number of plants required or -1 if it is not possible.   pylons has the following parameter(s):   k: an integer that represents distribution range   arr: an array of integers that represent suitability as a building site   Input Format The first line contains two space-separated integers  and , the number of cities in Goodland and the plants' range constant.  The second line contains  space-separated binary integers where each integer indicates suitability for building a plant.   Constraints  Each . Subtask  for  of the maximum score. Output Format Print a single integer denoting the minimum number of plants that must be built so that all of Goodland's cities have electricity.  If this is not possible for the given value of , print . Sample Input 6 2 0 1 1 1 1 0  Sample Output 2  Explanation Cities , , , and  are suitable for power plants.  Each plant will have a range of . If we build in cities  cities,  and , then all cities will have electricity.
__label__Graph-Algorithms Jenna is playing a computer game involving a large map with  cities numbered sequentially from  to  that are connected by  bidirectional roads. The game's objective is to travel to as many cities as possible without visiting any city more than once. The more cities the player visits, the more points they earn. As Jenna's fellow student at Hackerland University, she asks you for help choosing an optimal path. Given the map, can you help her find a path that maximizes her score? Note: She can start and end her path at any two distinct cities. Input Format The first line contains two space-separated integers describing the respective values of  (the number of cities) and  (the number of roads).  Each line  of the  subsequent lines contains two space-separated integers,  and , describing a bidirectional road between cities  and . Map Generation Algorithm  The graph representing the map was generated randomly in the following way: Initially, the graph was empty. Permutations  were chosen uniformly at random among all  permutations. For each , edge  was added to the graph. An additional  edges were chosen uniformly at random among all possible sets of  edges which don't intersect with edges added during step . Constraints    For  of test  and . For  of test  and . For  of test  and . It's guaranteed that a valid path of length  always exists.  Scoring A valid path of length  earns  of a test case's available points. The total score will be rounded to next . Output Format Print the following two lines of output: The first line must contain a single integer, , denoting the length of the path. The second line must contain  distinct space-separated integers describing Jenna's path in the same order in which she visited each city. Sample Input 0 Sample Output 0 Explanation 0 The diagrams below depict the city's initial map, an optimal path that would earn a full score, and an alternative path that would earn a partial score:  In the optimal path (center image), Jenna walks the path . This answer earns  of the maximum score because the path length, , is equal to  (i.e., she was able to visit every city exactly once).  In the alternative path (right image), Jenna walks the path  for  of the maximum score.
__label__Dynamic-Programming You have a pile of  stones that you want to split into multiple piles, as well as a set, , of  distinct integers. We define a move as follows: First, choose a pile of stones. Let's say that the chosen pile contains  stones.  Next, look for some  such that  and  is divisible by  (i.e.,  is a factor of ); if such an  exists, you can split the pile into  equal smaller piles. You are given  queries where each query consists of  and . For each query, calculate the maximum possible number of moves you can perform and print it on a new line. Input Format The first line contains an integer, , denoting the number of queries. The  subsequent lines describe each query in the following format: The first line contains two space-separated integers describing the respective values of  (the size of the initial pile in the query) and  (the size of the set in the query). The second line contains  distinct space-separated integers describing the values in set . Constraints      Subtask  for  of the maximum score. Output Format For each query, calculate the maximum possible number of moves you can perform and print it on a new line. Sample Input 0 Sample Output 0 Explanation 0 Initially there is a pile with  stones:   You can make a maximal  moves, described below: Select  from  and split it into  equal piles of size  to get:    Select  from  and split a pile of size  into  equal piles of size  to get:   Select  from  and split a pile of size  into  equal piles of size  to get:   Repeat the previous move again on another pile of size  to get:   Repeat the previous move again on another pile of size  to get:   Repeat the move again on the last pile of size  to get:   As there are no more available moves, we print  (the number of moves) on a new line.
__label__Game-Theory Two players (numbered  and ) are playing a game of Tower Breakers! The rules of the game are as follows: Player  always moves first. Initially there are  towers of various heights. The players move in alternating turns. In each turn, a player must choose a tower of height  and break it down into  towers, each of height . The numbers  and  must satisfy  and .   If the current player is unable to make any move, they lose the game. Given the value of  and the respective height values for all towers, can you determine who will win, assuming both players always move optimally? If the first player wins, print ; otherwise, print . Input Format The first line contains an integer, , denoting the number of test cases.  The  subsequent lines define the test cases. Each test case is described by two lines: An integer, , denoting the number of towers.  space-separated integers, , where each  describes the height of tower . Constraints    Output Format For each test case, print a single integer denoting the winner (i.e., either  or ) on a new line. Sample Input 2 2  1 2 3  1 2 3  Sample Output 1 2  Explanation In the first test case, the first player simply breaks down the second tower of height  into two towers of height  and wins. In the second test case, there are only two possible moves: Break the second tower into  towers of height . Break the third tower into  towers of height .  Whichever move player  makes, player  can make the other move and win the game.
__label__Binary-Search Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.  Note that it is the kth smallest element in the sorted order, not the kth distinct element.  Example: matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.   Note:  You may assume k is always valid, 1 ≤ k ≤ n2.
__label__Mathematics __label__Binary-Search __label__Dynamic-Programming You are given K eggs, and you have access to a building with N floors from 1 to N.  Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).  Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?      Example 1: Input: K = 1, N = 2 Output: 2 Explanation:  Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1. If it didn't break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty.   Example 2: Input: K = 2, N = 6 Output: 3   Example 3: Input: K = 3, N = 14 Output: 4    Note:  1 <= K <= 100 1 <= N <= 10000
__label__Dynamic-Programming Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".  Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".              Note that you are allowed to reuse a dictionary word.  Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false
__label__Dynamic-Programming Nina received an odd New Year's present from a student: a set of  unbreakable sticks. Each stick has a length, , and the length of the  stick is . Deciding to turn the gift into a lesson, Nina asks her students the following: How many ways can you build a square using exactly  of these unbreakable sticks?  Note: Two ways are distinct if they use at least one different stick. As there are  choices of sticks, we must determine which combinations of sticks can build a square. Input Format The first line contains an integer, , denoting the number of sticks. The second line contains  space-separated integers  describing the length of each stick in the set. Constraints   Output Format On a single line, print an integer representing the number of ways that  unbreakable sticks can be used to make a square. Sample Input 0 8 4 5 1 5 1 9 4 5   Sample Output 0 3  Sample Input 1 6 1 2 3 4 5 6   Sample Output 1 0      Explanation Sample 0  Given  sticks (), the only possible side length for our square is . We can build square  in  different ways:         In order to build a square with side length  using exactly  sticks,  and  must always build two of the sides. For the remaining two sides, you must choose  of the remaining  sticks of length  ( and ). Sample 1  We have to use all  sticks, making the largest stick length () the minimum side length for our square. No combination of the remaining sticks can build  more sides of length  (total length of all other sticks is  and we need at least length ), so we print .
__label__Dynamic-Programming Given two strings,  and , find and print the total number of ways to insert a character at any position in string  such that the length of the Longest Common Subsequence of characters in the two strings increases by one. Input Format The first line contains a single string denoting .  The second line contains a single string denoting . Constraints Scoring   Strings  and  are alphanumeric (i.e., consisting of arabic digits and/or upper and lower case English letters). The new character being inserted must also be alphanumeric (i.e., a digit or upper/lower case English letter). Subtask   for  of the maximum score.   Output Format Print a single integer denoting the total number of ways to insert a character into string  in such a way that the length of the longest common subsequence of  and  increases by one. Sample Input aa baaa  Sample Output 4  Explanation The longest common subsequence shared by  and  is aa, which has a length of . There are two ways that the length of the longest common subsequence can be increased to  by adding a single character to : aa There are  different positions in string  where we could insert an additional a to create longest common subsequence aaa (i.e., at the beginning, middle, and end of the string).  a aaa We can insert a b at the beginning of the string for a new longest common subsequence of baa. b baa As we have  ways to insert an alphanumeric character into  and increase the length of the longest common subsequence by one, we print  on a new line.
__label__Dynamic-Programming Christy is interning at HackerRank. One day she has to distribute some chocolates to her colleagues. She is biased towards her friends and plans to give them more than the others. One of the program managers hears of this and tells her to make sure everyone gets the same number. To make things difficult, she must equalize the number of chocolates in a series of operations. For each operation, she can give  chocolates to all but one colleague.  Everyone who gets chocolate in a round receives the same number of pieces.   For example, assume the starting distribution is .  She can give  bars to the first two and the distribution will be .  On the next round, she gives the same two  bars each, and everyone has the same number:  . Given a starting distribution, calculate the minimum number of operations needed so that every colleague has the same number of chocolates.  Function Description  Complete the equal function in the editor below.  It should return an integer that reperesents the minimum number of operations required.   equal has the following parameter(s):   arr: an array of integers to equalize   Input Format The first line contains an integer , the number of test cases.    Each test case has  lines.  - The first line contains an integer , the number of colleagues.  - The second line contains  space-separated integers denoting the number of chocolates each colleague has. Constraints     Number of initial chocolates each colleague has <   Output Format Print the minimum number of operations needed for each test case, one to a line. Sample Input 1 4 2 2 3 7  Sample Output 2  Explanation Start with   Add  to all but the 3rd element   Add  to all but the 4th element   Two operations were required. Sample Input 1 1 3 10 7 12  Sample Output 1 3  Explanation 1 Start with   Add  to the first two elements   Add  to the last two elements   Add  to the last two elements   Three operations were required.
__label__Strings Two strings A and B, consisting of small English alphabet letters are called pseudo-isomorphic if   Their lengths are equal For every pair (i,j), where 1 <= i < j <= |A|, B[i] = B[j], iff A[i] = A[j] For every pair (i,j), where 1 <= i < j <= |A|, B[i] != B[j] iff A[i] != A[j] Naturally, we use 1-indexation in these definitions and |A| denotes the length of the string A.   You are given a string S, consisting of no more than 105 lowercase alphabetical characters. For every prefix of S denoted by S', you are expected to find the size of the largest possible set of strings , such that all elements of the set are substrings of S' and no two strings inside the set are pseudo-isomorphic to each other.   if S = abcde  then, 1st prefix of S is 'a'  then, 2nd prefix of S is 'ab'  then, 3rd prefix of S is 'abc'  then, 4th prefix of S is 'abcd' and so on..   Input Format The first and only line of input will consist of a single string S. The length of S will not exceed 10^5.   Constraints   S contains only lower-case english alphabets ('a' - 'z').   Output Format Output N lines. On the ith line, output the size of the largest possible set for the first i alphabetical characters of S such that no two strings in the set are pseudo-isomorphic to each other. Sample Input abbabab    Sample Output 1    2    4    6    9    12    15     Explanation The first character is 'a', the set is {a} hence 1.  The first 2 characters are 'ab', the set is {a, b, ab} but 'a' is pseudo-isomorphic to 'b'. So, we can remove either 'a' or 'b' from the set. We get {a,ab} or {b,ab}, hence 2.  Similarly, the first 3 characters are 'abb', the set is {a, ab, abb, b, bb} and as 'a' is pseudo-isomorphic to 'b', we have to remove either 'a' or 'b' from the set. We get {a,ab, abb, bb}, hence 4. and so on...
__label__Array __label__Strings Given a string s, we make queries on substrings of s. For each query queries[i] = [left, right, k], we may rearrange the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter.  If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false. Return an array answer[], where answer[i] is the result of the i-th query queries[i]. Note that: Each letter is counted individually for replacement so if for example s[left..right] = "aaa", and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)   Example : Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] Output: [true,false,false,true,true] Explanation: queries[0] : substring = "d", is palidrome. queries[1] : substring = "bc", is not palidrome. queries[2] : substring = "abcd", is not palidrome after replacing only 1 character. queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab". queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.    Constraints:  1 <= s.length, queries.length <= 10^5 0 <= queries[i][0] <= queries[i][1] < s.length 0 <= queries[i][2] <= s.length s only contains lowercase English letters.
__label__Mathematics __label__Dynamic-Programming Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9.
__label__Depth-first-Search In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness. For convenience, we'll call the person with label x, simply "person x". We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations. Also, we'll say quiet[x] = q if person x has quietness q. Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.    Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation:  answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it isn't clear if they have more money than person 0.  answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.  The other answers can be filled out with similar reasoning.   Note:  1 <= quiet.length = N <= 500 0 <= quiet[i] < N, all quiet[i] are different. 0 <= richer.length <= N * (N-1) / 2 0 <= richer[i][j] < N richer[i][0] != richer[i][1] richer[i]'s are all different. The observations in richer are all logically consistent.
__label__Graph-Algorithms __label__Data-Structures __label__Advanced-Data-Structures Enter-View  is a linear, street-like country. By linear, we mean all the cities of the country are placed on a single straight line - the -axis. Thus every city's position can be defined by a single coordinate, , the distance from the left borderline of the country. You can treat all cities as single points. Unfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if  people are living in city , there must be at least  cables from city  to every other city of EV - this way he can guarantee no congestion will ever occur! Mr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population.  Note that The connections between the cities can be shared. Look at the example for the detailed explanation. Input Format  A number  is given in the first line and then comes  blocks, each representing a scenario. Each scenario consists of three lines. The first line indicates the number of cities (N). The second line indicates the coordinates of the N cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input. Output Format  For each scenario of the input, write the length of cable needed in a single line modulo . Constraints        Border to border length of the country  Sample Input  2   3   1 3 6   10 20 30   5   5 55 555 55555 555555   3333 333 333 33 35  Sample Output  280   463055586  Explanation For the first test case, having  cities requires  sets of cable connections. Between city  and , which has a population of  and , respectively, Mr. Treat believes at least  cables should come out of city 1 for this connection, and at least 20 cables should come out of city  for this connection. Thus, the connection between city  and city  will require  cables, each crossing a distance of  km. Applying this absurd logic to connection 2,3 and 1,3, we have  =>  connections   km of cable  =>  connections   km of cable  =>  connections   km of cable For a total of  , Output is  km of cable
__label__Strings Jack and Daniel are friends. Both of them like letters, especially upper-case ones.  They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack.  One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack.  Morgan wants to use all of the letters in their collections.   As an example, assume Jack has collected  and Daniel has .  The example shows the top at index  for each stack of letters. Assembling the string would go as follows:   Note the choice when there was a tie at CA and CF. CA CF Function Description  Complete the morganAndString function in the editor below.  It should return the completed string.   morganAndString has the following parameter(s):   a: a string representing Jack's letters, top at index   b: a string representing Daniel's letters, top at index   Input Format The first line contains the an integer , the number of test cases.   The next  pairs of lines are as follows:  - The first line contains string   - The second line contains string .   Constraints      and  contain upper-case letters only, ascii[A-Z]. Output Format Output the lexicographically minimal string  for each test case in new line. Sample Input 2 JACK DANIEL ABACABA ABACABA  Sample Output DAJACKNIEL AABABACABACABA  Explanation The first letters to choose from were J and D since they were at the top of the stack. D was chosen, the options then were J and A. A chosen. Then the two stacks have J and N, so J is chosen. (Current string is DAJ) Continuing this way till the end gives us the resulting string.
__label__Hash-Table __label__Two-Pointers __label__Strings You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input:   s = "barfoothefoobarman",   words = ["foo","bar"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.  Example 2: Input:   s = "wordgoodgoodgoodbestword",   words = ["word","good","best","word"] Output: []
__label__Dynamic-Programming Given an array of integers A, find the number of triples of indices (i, j, k) such that:  0 <= i < A.length 0 <= j < A.length 0 <= k < A.length A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.    Example 1: Input: [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 & 2 & 1 (i=0, j=1, k=0) : 2 & 1 & 2 (i=0, j=1, k=1) : 2 & 1 & 1 (i=0, j=1, k=2) : 2 & 1 & 3 (i=0, j=2, k=1) : 2 & 3 & 1 (i=1, j=0, k=0) : 1 & 2 & 2 (i=1, j=0, k=1) : 1 & 2 & 1 (i=1, j=0, k=2) : 1 & 2 & 3 (i=1, j=1, k=0) : 1 & 1 & 2 (i=1, j=2, k=0) : 1 & 3 & 2 (i=2, j=0, k=1) : 3 & 2 & 1 (i=2, j=1, k=0) : 3 & 1 & 2    Note:  1 <= A.length <= 1000 0 <= A[i] < 2^16
__label__Array __label__Dynamic-Programming A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:  For i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even; OR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.  That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. Return the length of a maximum size turbulent subarray of A.    Example 1: Input: [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: (A[1] > A[2] < A[3] > A[4] < A[5])   Example 2: Input: [4,8,12,16] Output: 2   Example 3: Input: [100] Output: 1       Note:  1 <= A.length <= 40000 0 <= A[i] <= 10^9
__label__Dynamic-Programming Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible. Note that the subarray needs to be non-empty after deleting one element.   Example 1: Input: arr = [1,-2,0,3] Output: 4 Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value. Example 2: Input: arr = [1,-2,-2,3] Output: 3 Explanation: We just choose [3] and it's the maximum sum.  Example 3: Input: arr = [-1,-1,-1,-1] Output: -1 Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.    Constraints:  1 <= arr.length <= 10^5 -10^4 <= arr[i] <= 10^4
__label__Mathematics Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3: Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.  Note:  1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231,  231 − 1].
__label__Hash-Table You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.  Please note that both secret number and friend's guess may contain duplicate digits. Example 1: Input: secret = "1807", guess = "7810"  Output: "1A3B"  Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7. Example 2: Input: secret = "1123", guess = "0111"  Output: "1A1B"  Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow. Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.
__label__Dynamic-Programming Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).   The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.  Example: Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12   Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.
__label__Data-Structures Given an array  of  distinct elements. Let  and  be the smallest and the next smallest element in the interval  where .   .   where , are the bitwise operators ,  and  respectively.  Your task is to find the maximum possible value of . Input Format First line contains integer .  Second line contains  integers, representing elements of the array .   Constraints      Output Format Print the value of maximum possible value of .    Sample Input 5 9 6 3 5 2  Sample Output 15  Explanation Consider the interval  the result will be maximum.
__label__Game-Theory __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Andy and Lily love playing games with numbers and trees. Today they have a  tree consisting of  nodes and  edges. Each edge  has an integer weight, . Before the game starts, Andy chooses an unordered pair of distinct nodes, , and uses all the edge weights present on the unique path from node  to node  to construct a list of numbers. For example, in the diagram below, Andy constructs a list from the edge weights along the path :  Andy then uses this list to play the following game with Lily: Two players move in alternating turns, and both players play optimally (meaning they will not make a move that causes them to lose the game if some better, winning move exists). Andy always starts the game by removing a single integer from the list. During each subsequent move, the current player removes an integer less than or equal to the integer removed in the last move. The first player to be unable to move loses the game. For example, if the list of integers is  and Andy starts the game by removing , the list becomes . Then, in Lily's move, she must remove a remaining integer less than or equal to  (i.e., , , , or ). The two friends decide to play  games, where each game is in the form of a tree. For each game, calculate the number of unordered pairs of nodes that Andy can choose to ensure he always wins the game. Input Format The first line contains a single integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of nodes in the tree. Each line  of the  subsequent lines contains three space-separated integers describing the respective values of , , and  for the  edge connecting nodes  and  with weight . Constraints         Sum of  over all games does not exceed  Scoring  For  of score, the sum of  over all games does not exceed . For  of score, the sum of  over all games does not exceed . Output Format For each game, print an integer on a new line describing the number of unordered pairs Andy can choose to construct a list that allows him to win the game. Sample Input 0 Sample Output 0 Explanation 0 Andy and Lily play the following  games: The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The first game's tree looks like this:   There are  ways to choose , and only one such pair causes Andy to lose the game. If he chooses the pair , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other  pairs, we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The second game's tree looks like this:    There are  ways to choose , and two pairs that cause Andy to lose the game: If Andy chooses , the list is . Andy removes  in his first move, and Lily removes the remaining  in the next move; at this point, Andy has no remaining moves and Lily wins. If Andy chooses , the list is . Andy can remove either a  or a  in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other  pairs, so we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line. The third game's tree looks like this:    There are  ways to choose , and Andy will win the game regardless of which pair he chooses. Thus, we print  on a new line.
__label__Strings __label__Dynamic-Programming Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word:  Insert a character Delete a character Replace a character  Example 1: Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')  Example 2: Input: word1 = "intention", word2 = "execution" Output: 5 Explanation:  intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')
__label__Array Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]
__label__Dynamic-Programming Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".  On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input: s1="acb", n1=4 s2="ab", n2=2  Return: 2
__label__Array __label__Dynamic-Programming Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
__label__Strings Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.   Example 1: Input: "abab" Output: True Explanation: It's the substring "ab" twice.  Example 2: Input: "aba" Output: False  Example 3: Input: "abcabcabcabc" Output: True Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
__label__Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
__label__Mathematics __label__Dynamic-Programming Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:  Choosing any x with 0 < x < N and N % x == 0. Replacing the number N on the chalkboard with N - x.  Also, if a player cannot make a move, they lose the game. Return True if and only if Alice wins the game, assuming both players play optimally.      Example 1: Input: 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves.   Example 2: Input: 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.    Note:  1 <= N <= 1000
__label__Dynamic-Programming A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.  Longest common subsequence (LCS) of 2 sequences is a subsequence, with maximal length, which is common to both the sequences.   Given two sequences of integers,  and , find the longest common subsequence and print it as a line of space-separated integers. If there are multiple common subsequences with the same maximum length, print any one of them. In case multiple solutions exist, print any of them. It is guaranteed that at least one non-empty common subsequence will exist.     Recommended References  This Youtube video tutorial explains the problem and its solution quite well.     Function Description  Complete the longestCommonSubsequence function in the editor below.  It should return an integer array of a longest common subsequence.   longestCommonSubsequence has the following parameter(s):   a: an array of integers   b: an array of integers Input Format The first line contains two space separated integers  and , the sizes of sequences  and .  The next line contains  space-separated integers .  The next line contains  space-separated integers . Constraints          Constraints     Output Format Print the longest common subsequence as a series of space-separated integers on one line. In case of multiple valid answers, print any one of them. Sample Input 5 6 1 2 3 4 1 3 4 1 2 1 3  Sample Output 1 2 3  Explanation There is no common subsequence with length larger than 3. And "1 2 3",  "1 2 1", "3 4 1" are all correct answers.   Tested by Khongor
__label__Data-Structures __label__Advanced-Data-Structures Alexey is playing with an array, , of  integers. His friend, Ivan, asks him to calculate the sum of the maximum values for all subsegments of . More formally, he wants Alexey to find . Alexey solved Ivan's challenge faster than expected, so Ivan decides to add another layer of difficulty by having Alexey answer  queries. The  query contains subsegment , and he must calculate the sum of maximum values on all subsegments inside subsegment .  More formally, for each query , Alexey must calculate the following function: . Can you help Alexey solve this problem? Input Format The first line contains  space-separated positive integers,  (the length of array ) and  (number of queries), respectively.  The second line contains  space-separated integers,  describing each element  (where ) in array .  Each of the  subsequent lines contains  space-separated positive integers describing the respective values for  and  in query  (where ). Constraints    Output Format For each query  (where ), print its answer on a new line. Sample Input 3 6 1 3 2 1 1 1 2 1 3 2 2 2 3 3 3  Sample Output 1 7 15 3 8 2  Explanation The answer for the second query is shown below:   The answer for the third query is shown below:
__label__Array __label__Dynamic-Programming Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.
__label__Strings __label__Greedy-Algorithms Given a string, , we define some operations on the string as follows: a.  denotes the string obtained by reversing string . Example:    b.  denotes any string that's a permutation of string . Example:    c.  denotes any string that's obtained by interspersing the two strings  & , maintaining the order of characters in both. For example,  & , one possible result of  could be , another could be , another could be  and so on.   Given a string  such that  for some string , find the lexicographically smallest . For example, .  We can split it into two strings of .  The reverse is  and we need to find a string to shuffle in to get .  The middle two characters match our reverse string, leaving the  and  at the ends.  Our shuffle string needs to be .  Lexicographically , so our answer is .   Function Description Complete the reverseShuffleMerge function in the editor below.  It must return the lexicographically smallest string fitting the criteria.   reverseShuffleMerge has the following parameter(s): s: a string Input Format A single line containing the string . Constraints  contains only lower-case English letters, ascii[a-z]    Output Format Find and return the string which is the lexicographically smallest valid . Sample Input 0 Sample Output 0 Explanation 0 Split "eggegg" into strings of like character counts: "egg", "egg"  reverse("egg") = "gge"  shuffle("egg") can be "egg"  "eggegg" belongs to the merge of ("gge", "egg") The merge is: gge. 'egg' < 'gge' Sample Input 1 Sample Output 1 Explanation 1 Split the string into two strings with like characters:  and .  Reverse  =   Shuffle  can be   Merge to bcdefga  Sample Input 2 Sample Output 2 Explanation 2 Split the string into groups of like characters:   Reverse  =   These merge to uoiea
__label__Mathematics Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome. Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].   Example 1: Input: L = "4", R = "1000" Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.   Note:  1 <= len(L) <= 18 1 <= len(R) <= 18 L and R are strings representing integers in the range [1, 10^18). int(L) <= int(R)
__label__Data-Structures This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. You’re given the pointer to the head node of a linked list. Change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty. next Input Format You have to complete the SinglyLinkedListNode reverse(SinglyLinkedListNode head) method which takes one argument - the head of the linked list. You should NOT read any input from stdin/console. SinglyLinkedListNode reverse(SinglyLinkedListNode head) The input is handled by the code in the editor and the format is as follows:   The first line contains an integer , denoting the number of test cases.  Each test case is of the following format:   The first line contains an integer , denoting the number of elements in the linked list.  The next  lines contain an integer each, denoting the elements of the linked list.   Constraints     , where  is the  element in the list. Output Format Change the next pointers of the nodes that their order is reversed and return the head of the reversed linked list. Do NOT print anything to stdout/console. next return The output is handled by the code in the editor. The output format is as follows: For each test case, print in a new line the elements of the linked list after reversing it, separated by spaces. Sample Input 1 5 1 2 3 4 5  Sample Output 5 4 3 2 1   Explanation The initial linked list is: 1 -> 2 -> 3 -> 4 -> 5 -> NULL The reversed linked list is: 5 -> 4 -> 3 -> 2 -> 1 -> NULL
__label__Mathematics __label__Binary-Search Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000  Example 2: Input: 2.10000, 3 Output: 9.26100  Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Note:  -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]
__label__Tree __label__Depth-first-Search Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric:     1    / \   2   2  / \ / \ 3  4 4  3    But the following [1,2,2,null,3,null,3] is not:     1    / \   2   2    \   \    3    3    Note: Bonus points if you could solve it both recursively and iteratively.
__label__Array Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
__label__Strings Given two strings, determine if they share a common substring.  A substring may be as small as one character.   For example, the words "a", "and", "art" share the common substring .  The words "be" and "cat" do not share a substring.   Function Description Complete the function twoStrings in the editor below.  It should return a string, either YES or NO based on whether the strings share a common substring.   YES NO twoStrings has the following parameter(s):   s1, s2: two strings to analyze .  Input Format The first line contains a single integer , the number of test cases.      The following  pairs of lines are as follows: The first line contains string . The second line contains string . Constraints  and  consist of characters in the range ascii[a-z].   Output Format For each pair of strings, return YES or NO. YES NO Sample Input 2 hello world hi world  Sample Output YES NO  Explanation We have  pairs to check: , . The substrings  and  are common to both strings.   , .  and  share no common substrings.
__label__Array This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.  Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.  Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.  Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].
__label__Game-Theory __label__Game-Theory Two people are playing game of Misère Nim. The basic rules for this game are as follows: The game starts with  piles of stones indexed from  to . Each pile  (where ) has  stones. The players move in alternating turns. During each move, the current player must  remove one or more stones from a single pile.  The player who removes the last stone loses the game. Given the value of  and the number of stones in each pile, determine whether the person who wins the game is the first or second person to move. If the first player to move wins, print First on a new line; otherwise, print Second. Assume both players move optimally.  First Second Input Format The first line contains an integer, , denoting the number of test cases.  Each of the  subsequent lines defines a test case. Each test case is described over the following two lines: An integer, , denoting the number of piles.  space-separated integers, , where each  describes the number of stones at pile . Constraints    Output Format For each test case, print the name of the winner on a new line (i.e., either First or Second). First Second Sample Input 2 2 1 1 3 2 1 3   Sample Output First Second  Explanation In the first testcase, the first player removes 1 stone from the first pile and then the second player has no moves other than removing the only stone in the second pile. So first wins.   In the second testcase, the series of moves can be depicted as:  In every possible move of first player we see that the last stone is picked by him, so second player wins.
__label__Greedy-Algorithms You will be given a list of integers, , and a single integer .  You must create an array of length  from elements of  such that its unfairness is minimized. Call that array .  Unfairness of an array is calculated as   Where:  - max denotes the largest integer in   - min denotes the smallest integer in   As an example, consider the array  with a  of .  Pick any two elements, test .    Testing for all pairs, the solution  provides the minimum unfairness. Note: Integers in  may not be unique.  Function Description Complete the maxMin function in the editor below.  It must return an integer that denotes the minimum possible value of unfairness.   maxMin has the following parameter(s): k:  an integer, the number of elements in the array to create arr:  an array of integers .  Input Format The first line contains an integer , the number of elements in array .  The second line contains an integer .  Each of the next  lines contains an integer  where .    Constraints       Output Format An integer that denotes the minimum possible value of unfairness. Sample Input 0 Sample Output 0 Explanation 0 Here ; selecting the  integers , unfairness equals   max(10,20,30) - min(10,20,30) = 30 - 10 = 20  Sample Input 1 Sample Output 1 Explanation 1 Here ; selecting the  integers , unfairness equals   max(1,2,3,4) - min(1,2,3,4) = 4 - 1 = 3  Sample Input 2 Sample Output 2 Explanation 2 Here .   or  give the minimum unfairness of .
__label__Array Given an array of integers nums, write a method that returns the "pivot" index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.    Example 2: Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.    Note:  The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000].
__label__Dynamic-Programming In the middle of a nightmare, Maxine suddenly finds herself in a mysterious room with the following items:  A piece of paper with the word score and the integer  written on it. A map of the castle where the room is located. There are  rooms uniquely labeled from  to .   There are  bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction. Every room is reachable from every other room.   Maxine is located in the room labeled .   The exit is located in the room labeled . Once this room is reached, score is reduced modulo  and Maxine can (but is not required to) exit that level!  There are  rooms uniquely labeled from  to .   There are  bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction. Every room is reachable from every other room.   Maxine is located in the room labeled .   The exit is located in the room labeled . Once this room is reached, score is reduced modulo  and Maxine can (but is not required to) exit that level!  Assume some corridor  (where ) is associated with an integer, , and connects rooms  and . Then: Traveling corridor  from room  to room  increases score by . Traveling corridor  from room  to room  decreases score by .  There are  levels to Maxine's nightmare castle, and each one has a different set of values for , , and . Given the above information, help Maxine by finding and printing her maximum possible score for each level. Only you can help her wake up from this nightmare! Note: Recall that the result of a modulo operation is always non-negative.  For example, .   Input Format The first line contains a single integer, , denoting the number of rooms.  Each of the  subsequent lines describes a corridor in the form of three space-separated integers denoting the respective values for , , and .  The next line contains a single integer, , denoting the number of queries.  Each of the  subsequent lines describes a level in the form of three space-separated integers denoting its respective , , and  values.  Constraints   ,       For each level: The room layout is the same     Subtask  for  of max score. Output Format For each of the  levels, print the maximum possible score for that level on a new line. Sample Input 3 1 3 5 2 3 8 2 1 31 1 1 2 13  Sample Output 12  Explanation The Sample Input represents the following setup:    We want to travel from room  to room  while maximizing the value of score. There are at least two ways to achieve the maximum score value of :   Travel through corridors  times:   .   Travel through corridors  times:   .   Travel through corridors  times:   , because  is the smallest non-negative integer  such that  divides .   Travel through corridors  times:   , because  is the smallest non-negative integer  such that  divides .
__label__Tree __label__Data-Structures Complete the postOrder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.   Input Format Our hidden tester code passes the root node of a binary tree to your postOrder function. Constraints 1 Nodes in the tree   500 Output Format Print the tree's postorder traversal as a single line of space-separated values. Sample Input      1       \        2         \          5         /  \        3    6         \          4  Sample Output 4 3 6 5 2 1
__label__Strings Consider a string of  characters, , of where each character is indexed from  to . You are given  queries in the form of two integer indices:  and . For each query, count and print the number of different substrings of  in the inclusive range between  and .  Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string  aab, substrings  a and  a are the same but substrings  aa and  ab are different. aab a a aa ab Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains a single string denoting .  Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  for a query. Constraints   String  consists of lowercase English alphabetic letters (i.e., a to z) only. a z Subtasks  For  of the test cases,   For  of the test cases,   For  of the test cases,   Output Format For each query, print the number of different substrings in the inclusive range between index  and index  on a new line.  Sample Input 0 Sample Output 0 Explanation 0 Given  aabaa, we perform the following  queries: aabaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 1 1: The only substring of a is itself, so we print  on a new line. 1 1 a 1 4: The substrings of abaa are a, b, ab, ba, aa, aba, baa, and abaa, so we print  on a new line. 1 4 abaa a b ab ba aa aba baa abaa 0 2: The substrings of aab are a, b, aa, ab, and aab, so we print  on a new line. 0 2 aab a b aa ab aab
__label__Greedy-Algorithms Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: "bcabc" Output: "abc"  Example 2: Input: "cbacdcbc" Output: "acdb"
__label__Array According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input:  [   [0,1,0],   [0,0,1],   [1,1,1],   [0,0,0] ] Output:  [   [0,0,0],   [1,0,1],   [0,1,1],   [0,1,0] ]  Follow up:  Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?
__label__Mathematics Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true  Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion?
__label__Hash-Table A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly. Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com". We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain. Example 1: Input:  ["9001 discuss.leetcode.com"] Output:  ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"] Explanation:  We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.   Example 2: Input:  ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"] Output:  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"] Explanation:  We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.   Notes:   The length of cpdomains will not exceed 100.  The length of each domain name will not exceed 100. Each address will have either 1 or 2 "." characters. The input count in any count-paired domain will not exceed 10000. The answer output can be returned in any order.
__label__Strings Two words are anagrams of one another if their letters can be rearranged to form the other word.   In this challenge, you will be given a string.  You must split it into two contiguous substrings, then determine the minimum number of characters to change to make the two substrings into anagrams of one another. For example, given the string 'abccde', you would break it into two parts: 'abc' and 'cde'.  Note that all letters have been used, the substrings are contiguous and their lengths are equal.  Now you can change 'a' and 'b' in the first substring to 'd' and 'e' to have 'dec' and 'cde' which are anagrams.  Two changes were necessary. Function Description Complete the anagram function in the editor below.  It should return the minimum number of characters to change to make the words anagrams, or  if it's not possible.   anagram has the following parameter(s):   s: a string   Input Format The first line will contain an integer, , the number of test cases.  Each test case will contain a string  which will be concatenation of both the strings described above in the problem.  The given string will contain only characters in the range ascii[a-z]. Constraints      consists only of characters in the range ascii[a-z].   Output Format For each test case, print an integer representing the minimum number of changes required to make an anagram. Print  if it is not possible. Sample Input 6 aaabbb ab abc mnop xyyx xaxbbbxx  Sample Output 3 1 -1 2 0 1  Explanation Test Case #01: We split  into two strings ='aaa' and ='bbb'.  We have to replace all three characters from the first string with 'b' to make the strings anagrams.   Test Case #02: You have to replace 'a' with 'b', which will  generate "bb".   Test Case #03: It is not possible for two strings of unequal length to be anagrams of one another.   Test Case #04: We have to replace both the characters of first string ("mn") to make it an anagram of the other one.   Test Case #05:  and  are already anagrams of one another.   Test Case #06: Here S1 = "xaxb" and S2 = "bbxx". You must replace 'a' from S1 with 'b' so that S1 = "xbxb".
__label__Array __label__Mathematics Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.  Example 1: Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.   Example 2: Input: 9973 Output: 9973 Explanation: No swap.   Note:  The given number is in the range [0, 108]
__label__Mathematics We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.   Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.  Example: Input: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14   Note: The input number n will not exceed 100,000,000. (1e8)
__label__Greedy-Algorithms There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1]. Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.   Example 1: Input: [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation:  The first person goes to city A for a cost of 10. The second person goes to city A for a cost of 30. The third person goes to city B for a cost of 50. The fourth person goes to city B for a cost of 20.  The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.    Note:  1 <= costs.length <= 100 It is guaranteed that costs.length is even. 1 <= costs[i][0], costs[i][1] <= 1000
__label__Graph-Algorithms Let  be a connected, directed graph with vertices numbered from  to  such that any vertex is reachable from vertex . In addition, any two distinct vertices,  and , are connected by at most one edge . Consider the standard DFS (Depth-First Search) algorithm starting from vertex . As every vertex is reachable, each edge  of  is classified by the algorithm into one of four groups: tree edge: If  was discovered for the first time when we traversed . back edge: If  was already on the stack when we tried to traverse . forward edge: If  was already discovered while  was on the stack. cross edge: Any edge that is not a tree, back, or forward edge. To better understand this, consider the following C++ pseudocode: Given four integers, , , , and , construct any graph  having exactly  tree edges, exactly  back edges, exactly  forward edges, and exactly  cross edges. Then print  according to the Output Format specified below. Input Format A single line of four space-separated integers describing the respective values of , , , and . Constraints  Output Format If there is no such graph , print -1; otherwise print the following: -1 The first line must contain an integer, , denoting the number of vertices in . Each line  of the  subsequent lines must contain the following space-separated integers: The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. The first integer is the outdegree, , of vertex . This is followed by  distinct numbers, , denoting edges from  to  for . The order of each  should be the order in which a DFS considers edges. Sample Input 0 Sample Output 0 Explanation 0 The DFS traversal order is: . Thus, ,  and  are tree edges;  is a back edge;  is a forward edge; and  is a cross edge. This is demonstrated by the diagram below, in which tree edges are black, forward edges are blue, back edges are red, and cross edges are green.  Sample Input 1 Sample Output 1 Explanation 1 No such graph exists satisfying the given values.
__label__Array __label__Dynamic-Programming Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
__label__Tree __label__Depth-first-Search Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]         5       / \     3    6    / \    \   2   4    8  /        / \  1        7   9  Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]   1   \    2     \      3       \        4         \          5           \            6             \              7               \                8                 \                  9   Note:  The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.
__label__Strings Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2. One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index i to index j (i<=j) and asked them to find their strength. i j The strength of the group of students from i to j is defined as: strength(i , j) {     if a[i] = 0         return 0; //If first child has value 0 in the group, strength of group is zero     value = 0;     for k from i to j         value = value*10 + a[k]     return value; }   Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof. Input Format First line contains number of test cases T  Next T line contains the numbers of number plates the students were having when standing in the row in the form of a string A. Constraints 1 ≤ T ≤ 100  1 ≤ len(A) ≤ 105  0 ≤ A[i] ≤ 9 Output Format Output the total number of strengths of the form 2x such that 0 ≤ x ≤ 800.  Sample Input 0 Sample Output 0 Explanation 0 In following explanations group i-j is group of student from index i to index j (1-based indexing) In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7   In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5. In third case 65536 is only number in required form. It is strength of group 1-5 In third case 65536 is only number in required form. It is strength of group 1-5 In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.   In fifth case, None of the group has strength of required form.   In fifth case, None of the group has strength of required form.
__label__Two-Pointers We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.  Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].  Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100  Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes:  1 <= difficulty.length = profit.length <= 10000 1 <= worker.length <= 10000 difficulty[i], profit[i], worker[i]  are in range [1, 10^5]
__label__Dynamic-Programming A tree, , has  vertices numbered from  to  and is rooted at vertex . Each vertex  has an integer weight, , associated with it, and 's total weight is the sum of the weights of its nodes. A single remove operation removes the subtree rooted at some arbitrary vertex  from tree .  Given , perform up to  remove operations so that the total weight of the remaining vertices in  is maximal. Then print 's maximal total weight on a new line. Note: If 's total weight is already maximal, you may opt to remove  nodes. Input Format The first line contains two space-separated integers,  and , respectively.  The second line contains  space-separated integers describing the respective weights for each node in the tree, where the  integer is the weight of the  vertex.  Each of the  subsequent lines contains a pair of space-separated integers,  and , describing an edge connecting vertex  to vertex .   Constraints       Output Format Print a single integer denoting the largest total weight of 's remaining vertices. Sample Input 5 2 1 1 -1 -1 -1 1 2 2 3 4 1 4 5  Sample Output 2  Explanation We perform  remove operations:  Remove the subtree rooted at node . Losing this subtree's  weight increases the tree's total weight by .  Remove the subtree rooted at node . Losing this subtree's  weight increases the tree's total weight by .  The sum of our remaining positively-weighted nodes is , so we print  on a new line.
__label__Tree Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Example: Input:           1        /   \       2     3 Output: 1 Explanation:  Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1   Note:  The sum of node values in any subtree won't exceed the range of 32-bit integer.  All the tilt values won't exceed the range of 32-bit integer.
__label__Search __label__Tree __label__Data-Structures __label__Advanced-Data-Structures Let  denote an arithmetic progression (AP) with first term  and common difference , i.e.  denotes an infinite . You are given  APs => . Let  denote the sequence obtained by multiplying these APs. Multiplication of two sequences is defined as follows. Let the terms of the first sequence be , and terms of the second sequence be . The sequence obtained by multiplying these two sequences is    If  are the terms of a sequence, then the terms of the first difference of this sequence are given by  calculated as  respectively. Similarly, the second difference is given by , and so on. We say that the  difference of a sequence is a constant if all the terms of the  difference are equal.   Let  be a sequence defined as =>   Similarly,  is defined as => product of .  Task:  Can you find the smallest  for which the  difference of the sequence  is a constant? You are also required to find this constant value.   You will be given many operations. Each operation is of one of the two forms:   1) 0 i j => 0 indicates a query . You are required to find the smallest  for which the  difference of  is a constant. You should also output this constant value.   0 i j 2) 1 i j v => 1 indicates an update . For all , we update .   1 i j v Input Format  The first line of input contains a single integer , denoting the number of APs.  Each of the next  lines consists of three integers  .  The next line consists of a single integer , denoting the number of operations. Each of the next  lines consist of one of the two operations mentioned above.    Output Format  For each query, output a single line containing two space-separated integers  and .  is the smallest value for which the  difference of the required sequence is a constant.  is the value of this constant. Since  might be large, output the value of  modulo 1000003.   Note:  will always be such that it fits into a signed 64-bit integer. All indices for query and update are 1-based. Do not take modulo 1000003 for . Constraints        For updates of the form 1 i j v,     1 i j v Sample Input  2   1 2 1   5 3 1   3   0 1 2   1 1 1 1   0 1 1    Sample Output  2 12   2 8    Explanation The first sequence given in the input is =>   The second sequence given in the input is =>   For the first query operation, we have to consider the product of these two sequences:  =>   =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 12.   2 12 After the update operation 1 1 1 1, the first sequence becomes =>   i.e =>   For the second query, we consider only the first sequence =>   First difference is =>   Second difference is =>  This is a constant and hence the output is 2 8 1 1 1 1 2 8
__label__Dynamic-Programming __label__Mathematics Alex has two arrays defined as  and . He created an  matrix, , where  for each  in . Recall that  is the greatest common divisor of  and .  For example, if  and , he builds  like so: Alex's friend Kiara loves matrices, so he gives her  questions about matrix  where each question is in the form of some submatrix of  with its upper-left corner at  and its bottom-right corner at . For each question, find and print the number of distinct integers in the given submatrix on a new line. Input Format The first line contains three space-separated integers describing the respective values of  (the size of array ),  (the size of array ), and  (Alex's number of questions).  The second line contains  space-separated integers describing .  The third line contains  space-separated integers describing .  Each line  of the  subsequent lines contains four space-separated integers describing the respective values of , , , and  for the  question (i.e., defining a submatrix with upper-left corner  and bottom-right corner ). Constraints           Scoring   for  of score.    for  of score.   Output Format For each of Alex's questions, print the number of distinct integers in the given submatrix on a new line. Sample Input 0 Sample Output 0 Explanation 0 Given  and , we build the following : The diagram below depicts the submatrices for each of the  questions in green:  For the submatrix between  and , the set of integers is . The number of distinct integers is . For the submatrix between  and , the set of integers is . The number of distinct integers is . For the submatrix between  and , the set of integers is . The number of distinct integers is .
__label__Tree Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7] key = 3      5    / \   3   6  / \   \ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \   4   6  /     \ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \   2   6    \   \     4   7
__label__Graph-Algorithms __label__Graph-Algorithms It's almost summertime, so Big Cat and Little Cat are getting in shape. They decide the core of their fitness plan is to start jogging every day. Their city consists of  intersections connected by  bidirectional roads. The cats decide that their jogging route should be cyclic (i.e., starting and ending at the same intersection) and consist of  different roads. The cats also love exploring new places, so each day they want to choose a new route to jog on that is not equal to any of their previous routes. Two routes are considered to be equal if their sets of component roads are equal. Given a map of the city, can you help our heroic cats determine the maximum number of days they can go jogging so that every route traveled is different?  Input Format The first line contains a pair of space-separated integers,  (the number of intersections) and  (the number of roads), respectively. Each line  of the  subsequent lines contains a pair of space-separated integers,  and , defining a bidirectional road connecting intersections  and . Constraints    Each bidirectional road connects  distinct intersections (i.e., no road connects an intersection to itself). Each pair of intersections is directly connected by no more than  road. Output Format Print the maximum number of days for which the cats can go jogging without repeating a route. Sample Input 4 6 1 2 2 3 3 4 4 1 1 3 2 4  Sample Output 3  Explanation There are  different routes:    Recall that each route is a set of intersections forming a cycle, so each unique route is the same regardless of which city on the route the cats start out at. Thus, we print  (the number of routes) as our answer.
__label__Data-Structures An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  (you may also see it written as ). Given an array, , of  integers, print each element in reverse order as a single line of space-separated integers. Note: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this. Input Format The first line contains an integer,  (the number of integers in ).  The second line contains  space-separated integers describing . Constraints   Output Format Print all  integers in  in reverse order as a single line of space-separated integers.
__label__Dynamic-Programming __label__Strings String  is called a Super String if and only if:  contains only letters ; For any  and ,  has lower ascii code than , where  Given a set of Super Strings , a Hyper String is a string that can be constructed by concatenation of some Super Strings of the set . We can use each Super String as many times as we want. Given set , you have to compute the number of Hyper Strings with length no greater than .   Input Format The first line of input contains two integers,  (the number of Super Strings in ) and . The next  lines describe the Super Strings in set .   Constraints  and  are not greater than . Output Format Output an integer which is the number of possible Hyper Strings that can be derived. Since it may not fit in  bit integer, print the output module . (i.e. answer = answer % ) Sample Input 2 3   a   ab  Sample Output 7  Explanation In the example all the Hyper Strings are : "" (empty string), "", "", "", "", "", and "".
__label__Data-Structures A linked list is said to contain a cycle if any node is visited more than once while traversing the list.  Complete the function provided for you in your editor. It has one parameter: a pointer to a Node object named  that points to the head of a linked list. Your function must return a boolean denoting whether or not there is a cycle in the list. If there is a cycle, return true; otherwise, return false. Note: If the list is empty,  will be null. Input Format Our hidden code checker passes the appropriate argument to your function. You are not responsible for reading any input from stdin. Constraints  Output Format If the list contains a cycle, your function must return true. If the list does not contain a cycle, it must return false. The binary integer corresponding to the boolean value returned by your function is printed to stdout by our hidden code checker. Sample Input The following linked lists are passed as arguments to your function:       Sample Output 0 1  Explanation The first list has no cycle, so we return false and the hidden code checker prints  to stdout. The second list has a cycle, so we return true and the hidden code checker prints  to stdout.
__label__Dynamic-Programming Watson gave Sherlock a collection of arrays . Here each  is an array of variable length. It is guaranteed that if you merge the arrays into one single array, you'll get an array, , of  distinct integers in the range .  Watson asks Sherlock to merge  into a sorted array. Sherlock is new to coding, but he accepts the challenge and writes the following algorithm:  (an empty array).  (an empty array).  number of arrays in the collection .  number of arrays in the collection . While there is at least one non-empty array in :  (an empty array) and . While : If  is not empty: Remove the first element of  and push it to . . While  is not empty: Remove the minimum element of  and push it to . While there is at least one non-empty array in :  (an empty array) and . While : If  is not empty: Remove the first element of  and push it to . . While : If  is not empty: Remove the first element of  and push it to . Remove the first element of  and push it to . . While  is not empty: Remove the minimum element of  and push it to . While  is not empty: Remove the minimum element of  and push it to . Return  as the output. Return  as the output. Let's see an example. Let V be .  The image below demonstrates how Sherlock will do the merging according to the algorithm:  Sherlock isn't sure if his algorithm is correct or not. He ran Watson's input, , through his pseudocode algorithm to produce an output, , that contains an array of  integers. However, Watson forgot the contents of  and only has Sherlock's  with him! Can you help Watson reverse-engineer  to get the original contents of ? Given , find the number of different ways to create collection  such that it produces  when given to Sherlock's algorithm as input. As this number can be quite large, print it modulo . Notes: Two collections of arrays are different if one of the following is true: Their sizes are different. Their sizes are the same but at least one array is present in one collection but not in the other. Two collections of arrays are different if one of the following is true: Their sizes are different. Their sizes are the same but at least one array is present in one collection but not in the other. Two arrays,  and , are different if one of the following is true: Their sizes are different. Their sizes are the same, but there exists an index  such that . Two arrays,  and , are different if one of the following is true: Their sizes are different. Their sizes are the same, but there exists an index  such that . Input Format The first line contains an integer, , denoting the size of array .  The second line contains  space-separated integers describing the respective values of . Constraints     Output Format Print the number of different ways to create collection , modulo . Sample Input 0 Sample Output 0 Explanation 0 There are four distinct possible collections:     . Thus, we print the result of  as our answer. Sample Input 1 Sample Output 1 Explanation 1 The only distinct possible collection is , so we print the result of  as our answer.
__label__Mathematics We distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies.   Example 1: Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].  Example 2: Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation:  On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3].    Constraints:  1 <= candies <= 10^9 1 <= num_people <= 1000
__label__Array Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]
__label__Strings Jimmy loves playing with strings. He thinks string  is similar to string  if the following conditions are satisfied: Both strings have the same length (i.e.,  and ).  For each valid pair of indices, , in the strings,  and  or  and .   For example, string  and  are similar as for ,  and  and for all other  pairs  as well as .   He has a string, , of size  and gives you  queries to answer where each query is in the form of a pair of integers . For each substring , find the number of substrings  where substring  is similar to substring  and print this number on a new line. Note: Substring  is the contiguous sequence of characters from index  to index . For example, if  abcdefgh, then  cdef.  abcdefgh cdef Input Format The first line contains two space-separated integers describing the respective values of  and .  The second line contains string .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for query . Constraints    Output Format For each query, print the number of similar substrings on a new line. Sample Input 8 4 giggabaj 1 1 1 2 1 3 2 4  Sample Output 8 6 2 1  Explanation We perform the following sequence of queries: Strings with length  are all similar, so our answer is . gi, ig, ga, ab, ba, and aj are similar, so our answer is . gi ig ga ab ba aj gig and aba are similar, so our answer is . gig aba igg has no similar string, so our answer is . igg
__label__Mathematics Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c. Example 1: Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5    Example 2: Input: 3 Output: False
__label__Array __label__Hash-Table __label__Binary-Search __label__Dynamic-Programming Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].    Note:  1 <= len(A), len(B) <= 1000 0 <= A[i], B[i] < 100
__label__Greedy-Algorithms A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:  -2: turn left 90 degrees -1: turn right 90 degrees 1 <= x <= 9: move forward x units  Some of the grid squares are obstacles.  The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin.   Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4)   Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)     Note:  0 <= commands.length <= 10000 0 <= obstacles.length <= 10000 -30000 <= obstacle[i][0] <= 30000 -30000 <= obstacle[i][1] <= 30000 The answer is guaranteed to be less than 2 ^ 31.
__label__Mathematics Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle. Note:  input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle. randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.   Example 1: Input:  ["Solution","randPoint","randPoint","randPoint"] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]   Example 2: Input:  ["Solution","randPoint","randPoint","randPoint"] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Array __label__Binary-Search Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why?
__label__Mathematics __label__Data-Structures __label__Advanced-Data-Structures In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have N space-fighters.  Initially the ith fighter is located at (xi, yi). All of the space-fighters move with constant velocity V units/sec in the positive X direction.  i.e., fighter at (xi, yi) moves to (xi+V, yi) in 1 second.  The ith space-fighter broadcasts enemy information at a frequency fi. The republic is not scared of the artificially intelligent droid force as they have Yoda. Yoda has a special power, at any time T he can choose a region of the droid army and block one specific frequency F. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across X axis (refer image below for clarity). If a frequency (F) is blocked all the space-fighters in the region having the frequency F can’t communicate.  Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form: YU YD T where YU, YD are the bounds on y-axis inside which YODA can block a frequency at time T.  In the region described by the query, after a time T seconds from the start, if Yoda can chose one frequency (F) he wishes to, what is the maximum number of communications he can block? Input Format  Each test case is described as follows; the first line contains 3 space separated integers N - the number of space-fighters, Q - the number of queries you have to answer, and V - the velocity of the space-fighters separated by a single space.  N lines follow, each containing 3 space separated integers xi, yi, and fi, denoting the x co-ordinate, y co-ordinate and the frequency at which the ith ship broadcasts respectively. Each of the next Q lines contain 3 space separated integers representing YU, YD, T respectively. Refer the figure for more clarity Note: Points on the boundaries should be counted as well. Output Format  For each query you are to output a single integer denoting the result. Constraints  1 <= N <= 50000 1 <= Q <= 30000 1 <= V <= 10000 -109 <= xi <= 109 -109 <= yi <= 109 1 <= fi <= 109 -109 <= YU <= 109 -109 <= YD <= 109 1 <= T <= 10000 YU >= YD Sample Input 5 5 82 -4 1 4 -3 -2 2 -3 5 1 0 -5 2 1 -1 2 1 -1 57 -2 -5 11 5 -5 40 -1 -5 16 5 -1 93  Sample Output 1 2 3 3 1  Explanation Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.
__label__Search King Richard is leading a troop of  knights into battle! Being very organized, he labels his knights  and arranges them in an  square formation, demonstrated below:  Before the battle begins, he wants to test how well his knights follow instructions. He issues  drill commands, where each command follows the format ai bi di and is executed like so: ai bi di All knights in the square having the top-left corner at location  and the bottom-right corner at location  rotate  in the clockwise direction. Recall that some location  denotes the cell located at the intersection of row  and column . For example:  You must follow the commands sequentially. The square for each command is completely contained within the square for the previous command. Assume all knights follow the commands perfectly. After performing all  drill commands, it's time for battle! King Richard chooses knights  for his first wave of attack; however, because the knights were reordered by the drill commands, he's not sure where his chosen knights are! As his second-in-command, you must find the locations of the knights. For each knight , , print the knight's row and column locations as two space-separated values on a new line.   Input Format This is broken down into three parts: The first line contains a single integer, .        The second line contains a single integer, .  Each line  of the  subsequent lines describes a command in the form of three space-separated integers corresponding to , , and , respectively.   Each line  of the  subsequent lines describes a command in the form of three space-separated integers corresponding to , , and , respectively.   The next line contains a single integer, .  Each line  of the  subsequent lines describes a knight the King wants to find in the form of a single integer corresponding to .   Each line  of the  subsequent lines describes a knight the King wants to find in the form of a single integer corresponding to .   Constraints         and    and       Subtask   for  of the maximum score.   Output Format Print  lines of output, where each line  contains two space-separated integers describing the respective row and column values where knight  is located.   Sample Input 7 4 1 2 4 2 3 3 3 4 1 3 4 0 7 0 6 9 11 24 25 48  Sample Output 1 1 1 7 4 6 3 4 2 5 2 4 7 7  Explanation The following diagram demonstrates the sequence of commands:  Click here to download a larger image. In the final configuration: Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location  Knight  is at location
__label__Data-Structures Meera teaches a class of  students, and every day in her classroom is an adventure. Today is drawing day! The students are sitting around a round table, and they are numbered from  to  in the clockwise direction. This means that the students are numbered , and students  and  are sitting next to each other. After letting the students draw for a certain period of time, Meera starts collecting their work to ensure she has time to review all the drawings before the end of the day. However, some of her students aren't finished drawing! Each student  needs  extra minutes to complete their drawing.  Meera collects the drawings sequentially in the clockwise direction, starting with student ID , and it takes her exactly  minute to review each drawing. This means that student  gets  extra minutes to complete their drawing, student  gets  extra minute, student  gets  extra minutes, and so on. Note that Meera will still spend  minute for each student even if the drawing isn't ready.  Given the values of , help Meera choose the best possible  to start collecting drawings from, such that the number of students able to complete their drawings is maximal. Then print  on a new line. If there are multiple such IDs, select the smallest one. Input Format The first line contains a single positive integer, , denoting the number of students in the class.  The second line contains  space-separated integers describing the respective amounts of time that each student needs to finish their drawings (i.e., ). Constraints   Subtasks  for  of the maximum score. Output Format Print an integer denoting the ID number, , where Meera should start collecting the drawings such that a maximal number of students can complete their drawings. If there are multiple such IDs, select the smallest one.
__label__Array __label__Tree __label__Depth-first-Search Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:     3    / \   9  20     /  \    15   7
__label__Array __label__Greedy-Algorithms Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.  Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Hash-Table __label__Mathematics Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i >= 0 and j >= 0. Return a list of all powerful integers that have value less than or equal to bound. You may return the answer in any order.  In your answer, each value should occur at most once.    Example 1: Input: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation:  2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2   Example 2: Input: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14]      Note:  1 <= x <= 100 1 <= y <= 100 0 <= bound <= 10^6
__label__Strings Under a grammar given below, strings can represent a set of lowercase words.  Let's use R(expr) to denote the set of words the expression represents. Grammar can best be understood through simple examples:  Single letters represent a singleton set containing that word. 	 R("a") = {"a"} R("w") = {"w"}   When we take a comma delimited list of 2 or more expressions, we take the union of possibilities. 	 R("{a,b,c}") = {"a","b","c"} R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains each word at most once)   When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. 	 R("{a,b}{c,d}") = {"ac","ad","bc","bd"} R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}    Formally, the 3 rules for our grammar:  For every lowercase letter x, we have R(x) = {x} For expressions e_1, e_2, ... , e_k with k >= 2, we have R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ... For expressions e_1 and e_2, we have R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}, where + denotes concatenation, and × denotes the cartesian product.  Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.    Example 1: Input: "{a,b}{c,{d,e}}" Output: ["ac","ad","ae","bc","bd","be"]   Example 2: Input: "{{a,z},a{b,c},{ab,z}}" Output: ["a","ab","ac","z"] Explanation: Each distinct word is written only once in the final answer.    Constraints:  1 <= expression.length <= 50 expression[i] consists of '{', '}', ','or lowercase English letters. The given expression represents a set of words based on the grammar given in the description.
__label__Bit Consider an array, , of  integers ().  We take all consecutive subsequences of integers from the array that satisfy the following:   For example, if  our subsequences will be:          For each subsequence, we apply the bitwise XOR () operation on all the integers and record the resultant value. Since there are  subsequences, this will result in  numbers.    Given array , find the XOR sum of every subsequence of  and determine the frequency at which each number occurs. Then print the number and its respective frequency as two space-separated values on a single line.   Input Format The first line contains an integer, , denoting the size of the array.  Each line  of the  subsequent lines contains a single integer describing element . Constraints   Output Format Print  space-separated integers on a single line. The first integer should be the number having the highest frequency, and the second integer should be the number's frequency (i.e., the number of times it appeared). If there are multiple numbers having maximal frequency, choose the smallest one. Sample Input 0 Sample Output 0 Explanation 0 Let's find the XOR sum for all consecutive subsequences. We'll refer to the frequency of some number  as , and keep a running sum for each frequency:   , frequencies:  , frequencies:  and  , frequencies:  and  , frequencies: , , and  , frequencies: , , and  , frequencies: , , , and  , frequencies: , , , and  , frequencies: , , , and   , frequencies: , , , and   , frequencies: , , , and   Our maximal frequency is , and the integers , , and  all have this frequency. Because more than one integer has this frequency, we choose the smallest one, which is . We then print the respective smallest number having the maximal frequency and the maximal frequency as a single line of space-separated values.
__label__Graph-Algorithms Recall that a tree is an undirected, connected acyclic graph. We have a weighted tree, , with  vertices; let  be the total sum of edge weights on the path between nodes  and . Let's consider all the matrices, , such that:    for each  and  We consider the total value of matrix  to be:   Calculate and print the maximum total value of  for a given tree, . Input Format The first line contains a single positive integer, , denoting the number of vertices in tree .  Each line  of the  subsequent lines contains three space-separated positive integers denoting the respective , , and  values defining an edge connecting nodes  and  (where ) with edge weight . Constraints   Test cases with  have  of total score Test cases with  have  of total score  Output Format Print a single integer denoting the maximum total value of matrix  satisfying the properties specified in the Problem Statement above. Sample Input 3 1 2 2 1 3 1  Sample Output 3  Explanation In the sample case, matrix  is:   The sum of the elements of the first row is equal to .
__label__Dynamic-Programming __label__Mathematics __label__Game-Theory __label__Game-Theory It's New Year's Day, and Balsa and Koca are stuck inside watching the rain. They decide to invent a game, the rules for which are described below. Given array  containing  integers, they take turns making a single move. Balsa always moves first, and both players are moving optimally (playing to win and making no mistakes). During each move, the current player chooses one element from , adds it to their own score, and deletes the element from ; because the size of  decreases by  after each move, 's size will be  after  moves and the game ends (as all elements were deleted from ). We refer to Balsa's score as  and Koca's score as . Koca wins the game if |-| is divisible by ; otherwise Balsa wins.  Given , determine the winner. Note: . Input Format The first line contains an integer, , denoting the number of test cases.  Each test case is comprised of two lines; the first line has an integer , and the second line has  space-separated integers  describing array . Constraints    Subtasks For  score:  For  score:  Output Format For each test case, print the winner's name on a single line; if Balsa wins print Balsa, otherwise print Koca. Sample Input 2  3 7 6 18 1 3  Sample Output Balsa Koca  Explanation Test Case 1 Array . The possible play scenarios are: , , , and . , , , and . , , , and . , , , and . , , -, and . , , -, and . In this case, it doesn't matter what Balsa chooses because the difference between their scores isn't divisible by . Thus, Balsa wins. Test Case 2 Array . Balsa must choose that element, the first move ends the game.  , , , and . Thus, Koca wins.
__label__Strings Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \n. In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = "string s = "/* Not a comment. */";" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.  After removing the comments from the source code, return the source code in the same format. Example 1: Input:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.   Example 2: Input:  source = ["a/*comment", "line", "more_comment*/b"] Output: ["ab"] Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].   Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code.
__label__Dynamic-Programming Shashank loves strings, but he loves palindromic strings the most. He has a list of  strings, , where each string, , consists of lowercase English alphabetic letters. Shashank wants to count the number of ways of choosing non-empty subsequences  such that the following conditions are satisfied:  is a subsequence of string ,  is a subsequence of string ,  is a subsequence of string , , and  is a subsequence of string .  is a palindromic string, where + denotes the string concatenation operator. + You are given  queries where each query consists of some list, . For each query, find and print the number of ways Shashank can choose  non-empty subsequences satisfying the criteria above, modulo , on a new line. Note: Two subsequences consisting of the same characters are considered to be different if their characters came from different indices in the original string. Input Format The first line contains a single integer, , denoting the number of queries. The subsequent lines describe each query in the following format: The first line contains an integer, , denoting the size of the list.  Each line  of the  subsequent lines contains a non-empty string describing . Constraints      over a test case. For  of the maximum score:    over a test case. Output Format For each query, print the number of ways of choosing non-empty subsequences, modulo , on a new line. Sample Input 0 Sample Output 0 Explanation 0 The first two queries are explained below: We can choose the following five subsequences: , , , where  is the first character of  and  is the first character of . , , , where  is the second character of  and  is the second character of .  , , , where  is the first character of  and  is the second character of . , , , where  is the second character of  and  is the first character of .    , ,   Thus, we print the result of  on a new line. We can choose the following five subsequences: , , , where  is the first character of  and  is the first character of . , , , where  is the second character of  and  is the second character of .  , , , where  is the first character of  and  is the second character of . , , , where  is the second character of  and  is the first character of .    , ,   Thus, we print the result of  on a new line. There is no way to choose non-empty subsequences such that their concatenation results in a palindrome, as each string contains unique characters. Thus, we print  on a new line.
__label__Array __label__Two-Pointers Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.    Example 1: Input: [-4,-1,0,3,10] Output: [0,1,9,16,100]   Example 2: Input: [-7,-3,2,3,11] Output: [4,9,9,49,121]    Note:  1 <= A.length <= 10000 -10000 <= A[i] <= 10000 A is sorted in non-decreasing order.
__label__Array __label__Two-Pointers Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3,  Your function should return length = 2, with the first two elements of nums being 2.  It doesn't matter what you leave beyond the returned length.  Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2,  Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.  Note that the order of those five elements can be arbitrary.  It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {     print(nums[i]); }
__label__Array __label__Depth-first-Search Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,1,1,0,1,0,0,0,0,0,0,0,0],  [0,1,0,0,1,1,0,0,1,0,1,0,0],  [0,1,0,0,1,1,0,0,1,1,1,0,0],  [0,0,0,0,0,0,0,0,0,0,1,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,0,0,0,0,0,0,1,1,0,0,0,0]]  Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.  Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0.  Note: The length of each dimension in the given grid does not exceed 50.
__label__Tree __label__Graph-Algorithms Given a tree with vertices numbered from  to . You need to process  queries. Each query represents a vertex number encoded in the following way: Queries are encoded in the following way: Let,  be the  query and  be the answer for the  query where  and  is always . Then vertex . We are assure that  is between  and , and hasn't been removed before.  Note:  is the bitwise XOR operator. For each query, first decode the vertex  and then perform the following: Print the size of the connected component containing .   Remove vertex  and all edges connected to .   Input Format The first line contains a single integer, , denoting the number of vertices in the tree.  Each line  of the  subsequent lines (where ) contains  space-separated integers describing the respective nodes,  and , connected by edge .  The next line contains a single integer, , denoting the number of queries.  Each line  of the  subsequent lines contains a single integer, vertex number .   Constraints   Output Format For each query, print the size of the corresponding connected component on a new line. Sample Input 0 3 1 2 1 3 3 1 1 2  Sample Output 0 3 1 1  Sample Input 1 4 1 2 1 3 1 4 4 3 6 2 6  Sample Output 1 4 3 2 1  Explanation Sample Case 0:  We have,  = 0 and connected component :    has vertex =  =  = . The size of connected component containing  is .  So,  = . Removing vertex  and all of it's edges, we get two disconnected components :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, we are left with only one component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removed vertex . Sample Case 1:  We have,  =  and connected component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, we get component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, now, we get two disconnected components :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removing vertex  and all of it's edges, now we are left with only one component :    has vertex =  =  = . The size of connected component containing  is .  So,  = .  Removed vertex .
__label__Dynamic-Programming __label__Tree Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3
__label__Array Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.  Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.
__label__Mathematics Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True    Note:  All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order.
__label__Dynamic-Programming Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:  Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.    Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.    Note:  The n will be in the range [1, 1000].
__label__Strings Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". Example 1: Input: ["flower","flow","flight"] Output: "fl"  Example 2: Input: ["dog","racecar","car"] Output: "" Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z.
__label__Hash-Table __label__Binary-Search Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note:  1 <= N <= 1000000000 0 <= B.length < min(100000, N) [0, N) does NOT include N. See interval notation.  Example 1: Input:  ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] Output: [null,0,0,0]  Example 2: Input:  ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] Output: [null,1,1,1]  Example 3: Input:  ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] Output: [null,0,0,2]  Example 4: Input:  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] Output: [null,1,3,1]  Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.
__label__Graph-Algorithms The travelling salesman has a map containing m*n squares. He starts from the top left corner and visits every cell exactly once and returns to his initial position (top left). The time taken for the salesman to move from a square to its neighbor might not be the same. Two squares are considered adjacent if they share a common edge and the time taken to reach square b from square a and vice-versa are the same. Can you figure out the shortest time in which the salesman can visit every cell and get back to his initial position?  Input Format The first line of the input is 2 integers m and n separated by a single space. m and n are the number of rows and columns of the map.  Then m lines follow, each of which contains (n – 1) space separated integers. The jth integer of the ith line is the travel time from position (i,j) to (i,j+1) (index starts from 1.)  Then (m-1) lines follow, each of  which contains n space integers. The jth integer of the ith line is the travel time from position (i,j) to (i + 1, j).  Constraints 1 ≤ m, n ≤ 10  Times are non-negative integers no larger than 10000.   Output Format Just an integer contains the minimal time to complete his task. Print 0 if its not possible to visit each cell exactly once.  Sample Input 2 2 5 8 6 7  Sample Output 26  Explanation As its a 2*2 square, all cells are visited. 5 + 7 + 8 + 6 = 26
__label__Array __label__Strings A transaction is possibly invalid if:  the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city.  Each transaction string transactions[i] consists of comma separated values representing the name, time (in minutes), amount, and city of the transaction. Given a list of transactions, return a list of transactions that are possibly invalid.  You may return the answer in any order.   Example 1: Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"] Output: ["alice,20,800,mtv","alice,50,100,beijing"] Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. Example 2: Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"] Output: ["alice,50,1200,mtv"]  Example 3: Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"] Output: ["bob,50,1200,mtv"]    Constraints:  transactions.length <= 1000 Each transactions[i] takes the form "{name},{time},{amount},{city}" Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10. Each {time} consist of digits, and represent an integer between 0 and 1000. Each {amount} consist of digits, and represent an integer between 0 and 2000.
__label__Array A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).   Example 1: Input: [[4,3,8,4],         [9,5,1,9],         [2,7,6,2]] Output: 1 Explanation:  The following subgrid is a 3 x 3 magic square: 438 951 276  while this one is not: 384 519 762  In total, there is only one magic square inside the given grid.  Note:  1 <= grid.length <= 10 1 <= grid[0].length <= 10 0 <= grid[i][j] <= 15
__label__Bit Consider the following pseudocode, run on an array  of length : Given the values of  and array , compute and print the final value of  after the pseudocode above terminates; if the loop will never terminate, print -1 instead. -1 Input Format The first line contains a single integer, , denoting the length of array .  The second line contains  space-separated integers describing the respective values of . Constraints    Output Format Print the final value of  after the pseudocode terminates; if the loop will never terminate, print -1 instead. -1 Sample Input 0 Sample Output 0 Explanation 0 After the first loop,  becomes . After the second loop, the array only contains 's and 's. After the third loop, the array only contains 's. After the fourth loop, the array is empty. Because the value of  is incremented after each loop,  at the time the loop terminates. Thus, we print 4 as our answer. 4
__label__Depth-first-Search Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4]. Examples: s = "3[a]2[bc]", return "aaabcbc". s = "3[a2[c]]", return "accaccacc". s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
__label__Graph-Algorithms You are a real estate broker in ancient Knossos. You have  unsold houses, and each house  has an area, , and a minimum price, . You also have  clients, and each client  wants a house with an area greater than  and a price less than or equal to . Each client can buy at most one house, and each house can have at most one owner. What is the maximum number of houses you can sell? Input Format The first line contains two space-separated integers describing the respective values of  (the number of clients) and  (the number of houses).  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for client .  Each line  of the  subsequent lines contains two space-separated integers describing the respective values of  and  for house . Constraints  , where . , where . Output Format Print a single integer denoting the maximum number of houses you can sell. Sample Input 0 Sample Output 0 Explanation 0 Recall that each client  is only interested in some house  where  and . The diagram below depicts which clients will be interested in which houses:  Client  will be interested in house  because it has more than  units of space and costs less than . Both of the other houses are outside of this client's price range. Client  will be interested in houses  and , as both these houses have more than  units of space and cost less than . They will not be interested in the remaining house because it's too small. Client  will be interested in house  because it has more than  units of space and costs less than . They will not be interested in the other two houses because they are too small. All three clients are interested in the same two houses, so you can sell at most two houses in the following scenarios:    Client  buys house  and client  buys house . Client  buys house  and client  buys house . Client  buys house  and client  buys house . Thus, we print the maximum number of houses you can sell, , on a new line.
__label__Array __label__Dynamic-Programming On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.   Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].   Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].
__label__Array Given an array A, partition it into two (contiguous) subarrays left and right so that:  Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size.  Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.   Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6]   Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12]     Note:  2 <= A.length <= 30000 0 <= A[i] <= 10^6 It is guaranteed there is at least one way to partition A as described.
__label__Array Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75    Note:  1 <= k <= n <= 30,000. Elements of the given array will be in the range [-10,000, 10,000].
__label__Dynamic-Programming Chloe is fascinated by prime numbers. She came across the number  on a sign and, though the number is not prime, found some primes hiding in it by using the following rules:   Every three consecutive digits sum to a prime:  Every four consecutive digits sum to a prime:  Every five consecutive digits sum to a prime:  You must answer  queries, where each query consists of an integer, . For each , find and print the number of positive -digit numbers, modulo , that satisfy all three of Chloe's rules (i.e., every three, four, and five consecutive digits sum to a prime). Input Format The first line contains an integer, , denoting the number of queries.  Each of the  subsequent lines contains an integer denoting the value of  for a query.   Constraints     Output Format For each query, print the number of -digit numbers satisfying Chloe's rules, modulo , on a new line.    Sample Input 0 Sample Output 0 Explanation 0 There are  six-digit numbers satisfying the property above, where the respective first and last ones are  and .
__label__Binary-Search Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?   Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.  Example 1: Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6 3	6	9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).   Example 2: Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1	2	3 2	4	6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).   Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]
__label__Hash-Table __label__Strings Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word. For a given query word, the spell checker handles two categories of spelling mistakes:  Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.  	 Example: wordlist = ["yellow"], query = "YellOw": correct = "yellow" Example: wordlist = ["Yellow"], query = "yellow": correct = "Yellow" Example: wordlist = ["yellow"], query = "yellow": correct = "yellow"   Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist. 	 Example: wordlist = ["YellOw"], query = "yollow": correct = "YellOw" Example: wordlist = ["YellOw"], query = "yeellow": correct = "" (no match) Example: wordlist = ["YellOw"], query = "yllw": correct = "" (no match)    In addition, the spell checker operates under the following precedence rules:  When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. When the query matches a word up to capitlization, you should return the first such match in the wordlist. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. If the query has no matches in the wordlist, you should return the empty string.  Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].   Example 1: Input: wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"] Output: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]   Note:  1 <= wordlist.length <= 5000 1 <= queries.length <= 5000 1 <= wordlist[i].length <= 7 1 <= queries[i].length <= 7 All strings in wordlist and queries consist only of english letters.
__label__Depth-first-Search There are N network nodes, labelled 1 to N. Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target. Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.   Example 1:  Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2 Output: 2    Note:  N will be in the range [1, 100]. K will be in the range [1, N]. The length of times will be in the range [1, 6000]. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.
__label__Game-Theory Bob and Ben are playing a game with forests! The game's rules are as follows: The game starts with a forest of  trees. Bob always moves first and they take alternating turns. The first player with no available move loses the game. During each move, the player removes one node. If the node is not a leaf, then the whole tree vanishes; otherwise, the rest of the tree remains in the forest. We define a leaf to be a node with exactly  connected edge. Both players play optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists. We define each tree  in the -tree forest as follows: Tree  is defined by two integers,  (the number of nodes in the tree) and  (a constant).  Its nodes are numbered sequentially from  to . Its edges are numbered sequentially from  to , and each edge  connects node  to node . Given the values of  and  for each tree in the forest, can you determine who will win the game? Input Format The first line contains an integer, , denoting the number of games. The subsequent lines describe each game in the following format: The first line contains an integer, , denoting the number of trees in the forest.      Each of the  subsequent lines contains two space-separated integers describing the respective values of  and  for tree .  Constraints     The sum of  over all games is at most . Subtasks For  of the maximum score: The sum of  over all games is at most .  For  of the maximum score:  Output Format For each game, print the name of the winner on a new line (i.e., BOB or BEN). BOB BEN Sample Input 2 2 1 2 1 3 1 3 2  Sample Output BEN BOB  Explanation Bob and Ben play the following two games: The forest consists of  trees containing one node each, and each tree has no edges as  and  are both  (so both trees have  edges). The sequence of moves is as follows:    We then print the name of the winner, BEN, on a new line. BEN The forest consists of  tree containing three nodes. We find the  edges like so:  Edge  connects node  to node . Edge  connects node  to node .        The game then plays out as follows:    We then print the name of the winner, BOB, on a new line. The forest consists of  tree containing three nodes. We find the  edges like so:  Edge  connects node  to node . Edge  connects node  to node .        The game then plays out as follows:    We then print the name of the winner, BOB, on a new line. BOB
__label__Array __label__Dynamic-Programming Given a matrix, and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.   Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0.   Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.     Note:  1 <= matrix.length <= 300 1 <= matrix[0].length <= 300 -1000 <= matrix[i] <= 1000 -10^8 <= target <= 10^8
__label__Strings The count-and-say sequence is the sequence of integers with the first five terms as following: 1.     1 2.     11 3.     21 4.     1211 5.     111221  1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21 is read off as "one 2, then one 1" or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string.   Example 1: Input: 1 Output: "1"  Example 2: Input: 4 Output: "1211"
__label__Dynamic-Programming __label__Depth-first-Search Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.  Example 1: Input:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output: 23  Explanation:  [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)   Note: The number of boxes n would not exceed 100.
__label__Dynamic-Programming __label__Depth-first-Search Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example: Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]  Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]  Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";  "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".   Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.
__label__Dynamic-Programming Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may return any of them. (A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)   Example 1: Input: str1 = "abac", str2 = "cab" Output: "cabac" Explanation:  str1 = "abac" is a subsequence of "cabac" because we can delete the first "c". str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac". The answer provided is the shortest such string that satisfies these properties.    Note:  1 <= str1.length, str2.length <= 1000 str1 and str2 consist of lowercase English letters.
__label__Array __label__Hash-Table Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true
__label__Dynamic-Programming You are given two positive integers  and  in binary representation. You should find the following sum modulo :   where operation  means exclusive OR operation, operation  means binary shift to the left. Please note, that we consider ideal model of binary integers. That is there is infinite number of bits in each number, and there are no disappearings (or cyclic shifts) of bits. Input Format The first line contains number   in binary representation. The second line contains number   in the same format. All the numbers do not contain leading zeros. Output Format Output a single integer  the required sum modulo . Sample Input 10 1010  Sample Output 489429555
__label__Array __label__Dynamic-Programming Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are              engaging multiple transactions at the same time. You must sell before buying again.  Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.
__label__Graph-Algorithms There are N cities in Hacker Country. Each pair of cities are directly connected by a unique directed road, and each road has its own toll that must be paid every time it is used. You're planning a road trip in Hacker Country, and its itinerary must satisfy the following conditions:   You can start in any city. You must use  or more different roads (meaning you will visit  or more cities). At the end of your trip, you should be back in your city of origin. The average cost (sum of tolls paid per road traveled) should be minimum. Can you calculate the minimum average cost of a trip in Hacker Country? Time Limits  Time limits for this challenge are provided here. Input Format The first line is an integer,  (number of cities).  The  subsequent lines of   space-separated integers each describe the respective tolls or traveling from city  to city ; in other words, the  integer of the  line denotes the toll for traveling from city  to city .   Note: As there are no roads connecting a city to itself, the  integer of line  will always be . Constraints       Output Format Print the minimum cost as a rational number  (tolls paid over roads traveled). The greatest common divisor of  and  should be .  Sample Input 2 0 1 2 0  Sample Output 3/2  Explanation The toll from city  to city  is . The toll from  to  is . Your travel cost . Your number of roads traveled is . Thus, we print 3/2 as our answer. 3/2
__label__Strings Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.    Example 1: Input: "Hello" Output: "hello"   Example 2: Input: "here" Output: "here"   Example 3: Input: "LOVELY" Output: "lovely"
__label__Mathematics __label__Binary-Search __label__Greedy-Algorithms Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 < j, such that:  A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value.  If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.   Example 1: Input: [1,0,1,0,1] Output: [0,3]   Example 2: Input: [1,1,0,1,1] Output: [-1,-1]    Note:  3 <= A.length <= 30000 A[i] == 0 or A[i] == 1
__label__Graph-Algorithms __label__Tree There are  points on a plane.  Each point  is described by , where . There are three types of queries needed:  X i j Reflect all points in the inclusive range between points  and  along the -axis.   X i j Y i j Reflect all points in the inclusive range between points  and  along the -axis.  Y i j C i j Count the number of points in the inclusive range between points  and  in each of the  quadrants. Then print a single line of four space-separated integers describing the respective numbers of points in the first, second, third, and fourth quadrants in that order.  C i j As a reminder, the four quadrants of a graph are labeled as follows:   Given a set of  points and  queries, perform each query in order. For example, given points  and .  Initially the points are in quadrants  and .  The first query says to reflect points with indices from  to  along the -axis.  After the query,  and quadrants are  and .  The next query prints the number of points in each quadrant: 0 1 0 1.  The third query says to reflect the point with index  to  along the -axis, so now .  The points now lie in quadrants  and , so the fourth query output is 0 1 1 0. 0 1 0 1 0 1 1 0 Note: Points may sometimes share the same coordinates.   Function Description  Complete the quadrants function in the editor below.  It should print the results of each C type query on a new line.   C quadrants has the following parameters:  - p[p[1]...p[n]]: a 2-dimensional array of integers where each element  contains two integers   and   - queries[queries[1]...queries[n]: an array of strings   Input Format The first line contains a single integer, , that denotes the number of points.  Each line  of the  subsequent lines contains two space-separated integers that describe the respective  and  values for point  .  The next line contains a single integer, , that denotes the number of queries.  Each of the  subsequent lines contains three space-separated values that describe a query in one of the three forms defined above.   Constraints    No point lies on the  or  axes.  In all queries, . Output Format For each query of type C i j, print four space-separated integers that describe the number of points having indices in the inclusive range between  and  in the first, second, third, and fourth graph quadrants in that order. C i j Sample Input 4 1 1 -1 1 -1 -1 1 -1 5 C 1 4 X 2 4 C 3 4 Y 1 2 C 1 3  Sample Output 1 1 1 1 1 1 0 0 0 2 0 1  Explanation Initially,  so there is one point in each of the four quadrants.  The first query results in printing 1 1 1 1. 1 1 1 1 The second query, X 2 4, reflects the points in the inclusive range between indices  and  along the -axis. Now . X 2 4 The query C 3 4 requires that the number of points considering  through  be printed: 1 1 0 0 C 3 4 1 1 0 0 The third query, Y 1 2 requires reflection of  along the -axis.  Now .   Y 1 2 The last query, C 1 3 requires that the number of points considering  through  be printed: 0 2 0 1 C 1 3 0 2 0 1
__label__Hash-Table There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.    Example: Input: [[1,2,2,1],         [3,1,2],         [1,3,2],         [2,4],         [3,1,2],         [1,3,1,1]]  Output: 2  Explanation:      Note:  The width sum of bricks in different rows are the same and won't exceed INT_MAX. The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.
__label__Greedy-Algorithms Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.    Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
__label__Dynamic-Programming Mr. Road Runner bought a piece of land in the middle of a desert for a nominal amount. It turns out that the piece of land is now worth millions of dollars as it has an oil reserve under it. Mr. Road Runner contacts the ACME corp to set up the oil wells on his land. Setting up oil wells is a costly affair and the charges of setting up oil wells are as follows.  The rectangular plot bought by Mr. Road Runner is divided into r * c blocks. Only some blocks are suitable for setting up the oil well and these blocks have been marked. ACME charges nothing for building the first oil well. For every subsequent oil well built, the cost would be the maximum ACME distance between the new oil well and the existing oil wells.  If (x,y) is the position of the block where a new oil well is setup and (x1, y1) is the position of the block of an existing oil well, the ACME distance is given by  max(|x-x1|, |y-y1|)  the maximum ACME distance is the maximum among all the ACME distance between existing oil wells and new wells.  If the distance of any two adjacent blocks (horizontal or vertical) is considered 1 unit, what is the minimum cost (E) in units it takes to set up oil wells across all the marked blocks? Input Format The first line of the input contains two space separated integers r *c*.  r lines follow each containing c space separated integers.  1 indicates that the block is suitable for setting up an oil well, whereas 0 isn't.  r c   M11 M12 ... M1c   M21 M22 ... M2c   ...   Mr1 Mr2 ... Mrc    Constraints 1 <= r, c <= 50  Output Format Print the minimum value E as the answer.  Sample Input 3 4 1 0 0 0 1 0 0 0 0 0 1 0  Sample Output 3    Explanation (1, 1) (2, 1) (3, 3) are the places where are to be setup.  There are 3! = 6 ways to do it.  (1, 1) (2, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3  (1, 1) (3, 3) (2, 1) ==> cost = 0 + 2 + 2 = 4  (2, 1) (1, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3  (2, 1) (3, 3) (1, 1) ==> cost = 0 + 2 + 2 = 4  (3, 3) (1, 1) (2, 1) ==> cost = 0 + 2 + 2 = 4  (3, 3) (2, 1) (1, 1) ==> cost = 0 + 2 + 2 = 4   So E = 3
__label__Dynamic-Programming On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.      Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.   Example: Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.    Note:  N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board.
__label__Depth-first-Search Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice. Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Output: true Explanation:  The graph looks like this: 0----1 |    | |    | 3----2 We can divide the vertices into two groups: {0, 2} and {1, 3}.  Example 2: Input: [[1,2,3], [0,2], [0,1,3], [0,2]] Output: false Explanation:  The graph looks like this: 0----1 | \  | |  \ | 3----2 We cannot find a way to divide the set of nodes into two independent subsets.    Note:  graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j].
__label__Array Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: Input:  [1,2,3,4] Output: [24,12,8,6]  Note: Please solve it without division and in O(n). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
__label__Strings You are given string  and number .  Consider a substring  of string . For each position of string  mark it if there is an occurence of the substring that covers the position. More formally, position  will be marked if there exists such index  that:  and . We will tell  produce  islands if all the marked positions form  groups of contiguous positions.  For example, if we have a string ababaewabaq the substring aba marks the positions 1, 2, 3, 4, 5, 8, 9, 10; that is XXXXXewXXXq (X denotes marked position). We can see 2 groups of contiguous positions, that is 2 islands. Finally, substring aba produces 2 islands in the string ababaewabaq. ababaewabaq aba XXXXXewXXXq X aba ababaewabaq Calculate and print the number of different substrings of string  that produce exactly  islands. Input Format The first line contains string  . The string consists of lowercase letters only. The second line contains an integer  . Output Format Output a single integer  the answer to the problem. Sample Input abaab 2  Sample Output 3  Explanation All the suitable substrings are: a, ab, b. a ab b
__label__Dynamic-Programming There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones. A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles. Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.    Example 1: Input: stones = [3,2,4,1], K = 2 Output: 20 Explanation:  We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible.   Example 2: Input: stones = [3,2,4,1], K = 3 Output: -1 Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.   Example 3: Input: stones = [3,5,1,2,6], K = 3 Output: 25 Explanation:  We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible.    Note:  1 <= stones.length <= 30 2 <= K <= 30 1 <= stones[i] <= 100
__label__Array Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.  Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows  a, b are from arr a < b b - a equals to the minimum absolute difference of any two elements in arr    Example 1: Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2: Input: arr = [1,3,6,10,15] Output: [[1,3]]  Example 3: Input: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]]    Constraints:  2 <= arr.length <= 10^5 -10^6 <= arr[i] <= 10^6
__label__Array Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.   Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000
__label__Strings Palindromes are strings that read the same from the left or right, for example madam or 0110.   You will be given a string representation of a number and a maximum number of changes you can make.  Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes.  The length of the string may not be altered, so you must consider 's left of all higher digits in your tests.  For example  is valid,  is not.   Given a string representing the starting number and a maximum number of changes allowed, create the largest palindromic string of digits possible or the string -1 if it's impossible to create a palindrome under the contstraints.   Function Description  Complete the highestValuePalindrome function in the editor below.  It should return a string representing the largest value palindrome achievable, or -1.   -1 highestValuePalindrome has the following parameter(s):   s: a string representation of an integer     n: an integer that represents the length of the integer string   k: an integer that represents the maximum number of changes allowed   Input Format The first line contains two space-separated integers,  and , the number of digits in the number and the maximum number of changes allowed.  The second line contains an -digit string of numbers.   Constraints   Each character  in the number is an integer where . Output Format Print a single line with the largest number that can be made by changing no more than  digits. If this is not possible, print -1. -1 Sample Input 0 4 1 3943  Sample Output 0 3993  Sample Input 1 6 3 092282  Sample Output 1 992299  Sample Input 2 4 1 0011  Sample Output 2 -1  Explanation Sample 0 There are two ways to make  a palindrome by changing no more than  digits:   , so we print .
__label__Tree __label__Data-Structures Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit.  If they are on the left side of the tree, they will be a 0 (zero).  If on the right, they'll be a 1 (one).  Only the leaves will contain a letter and its frequency count.  All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters. For instance, consider the string ABRACADABRA.  There are a total of  characters in the string.  This number should match the count in the ultimately determined root of the tree.  Our frequencies are  and .  The two smallest frequencies are for  and , both equal to , so we'll create a tree with them.  The root node will contain the sum of the counts of its descendants, in this case .  The left node will be the first character encountered, , and the right will contain .  Next we have  items with a character count of :  the tree we just created, the character  and the character .  The tree came first, so it will go on the left of our new root node.   will go on the right.  Repeat until the tree is complete, then fill in the 's and 's for the edges.  The finished graph looks like:    Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL).  We can determine that our values for characters are:   A - 0 B - 111 C - 1100 D - 1101 R - 10  Our Huffman encoded string is: A B    R  A C     A D     A B    R  A 0 111 10 0 1100 0 1101 0 111 10 0 or 01111001100011010111100  To avoid ambiguity, Huffman encoding is a prefix free encoding technique.  No codeword appears as a prefix of any other codeword.   To decode the encoded string, follow the zeros and ones to a leaf and return the character there.   You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string. Function Description Complete the function decode_huff in the editor below.  It must return the decoded string. decode_huff has the following parameters:   root: a reference to the root node of the Huffman tree s: a Huffman encoded string Input Format There is one line of input containing the plain string, .  Background code creates the Huffman tree then passes the head node and the encoded string to the function. Constraints  Output Format Output the decoded string on a single line. Sample Input   s="1001011"  Sample Output ABACA  Explanation S="1001011" Processing the string from left to right. S[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[1]='0' : we move to the left child.  S[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string. We move back to the root.  S[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  S[4]='0' : we move to the left child.  S[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string. We move back to the root.   S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string. We move back to the root.  Decoded String = "ABACA"
__label__Data-Structures __label__Advanced-Data-Structures Alice purchased an array of  wooden boxes that she indexed from  to . On each box , she writes an integer that we'll refer to as . Alice wants you to perform  operations on the array of boxes. Each operation is in one of the following forms: (Note: For each type of operations, ) 1 l r c: Add  to each . Note that  can be negative. 1 l r c 2 l r d: Replace each  with .  2 l r d 3 l r: Print the minimum value of any . 3 l r 4 l r: Print the sum of all . 4 l r Recall that  is the maximum integer  such that  (e.g.,  and ). Given , the value of each , and  operations, can you perform all the operations efficiently?  Input Format The first line contains two space-separated integers denoting the respective values of  (the number of boxes) and  (the number of operations).  The second line contains  space-separated integers describing the respective values of  (i.e., the integers written on each box).  Each of the  subsequent lines describes an operation in one of the four formats defined above. Constraints      Output Format For each operation of type  or type , print the answer on a new line. Sample Input 0 Sample Output 0 Explanation 0 Initially, the array of boxes looks like this:  We perform the following sequence of operations on the array of boxes: The first operation is 1 0 4 1, so we add  to each  where :   The first operation is 1 0 4 1, so we add  to each  where :   1 0 4 1 The second operation is 1 5 9 1, so we add  to each  where :   The second operation is 1 5 9 1, so we add  to each  where :   1 5 9 1 The third operation is 2 0 9 3, so we divide each  where  by  and take the floor:   2 0 9 3 The fourth operation is 3 0 9, so we print the minimum value of  for , which is the result of . 3 0 9 The fifth operation is 4 0 9, so we print the sum of  for , which is the result of . 4 0 9 ... and so on.
__label__Binary-Search __label__Tree Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:  You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \      3   6     / \    2   4   /  1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
__label__Tree __label__Data-Structures Kitty has a tree, , consisting of  nodes where each node is uniquely labeled from  to . Her friend Alex gave her  sets, where each set contains  distinct nodes. Kitty needs to calculate the following expression on each set:   where:  denotes an unordered pair of nodes belonging to the set.  denotes the number of edges on the unique path between nodes  and . Given  and  sets of  distinct nodes, can you help her calculate the expression for each set? For each set of nodes, print the value of the expression modulo  on a new line. Input Format The first line contains two space-separated integers describing the respective values of  (the number of nodes in tree ) and  (the number of sets).  Each of the  subsequent lines contains two space-separated integers,  and , describing an undirected edge between nodes  and .  The  subsequent lines define each set over two lines in the following format: The first line contains an integer, , denoting the size of the set.  The second line contains  space-separated integers describing the set's elements. Constraints        The sum of  over all  does not exceed .  All elements in each set are distinct.  Subtasks  for  of the maximum score.   for  of the maximum score.  for  of the maximum score. Output Format Print  lines of output where each line  contains the expression for the  query, modulo . Sample Input 0 Sample Output 0 Explanation 0 Tree  looks like this:  We perform the following calculations for  sets: Set : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:   Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print  on a new line. Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line: Set : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:
__label__Depth-first-Search Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \    -3   9    /   /  -10  5
__label__Array Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).  Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.    Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.    Note: Length of the array will not exceed 10,000.
__label__Mathematics __label__Greedy-Algorithms On a broken calculator that has a number showing on its display, we can perform two operations:  Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display.  Initially, the calculator is displaying the number X. Return the minimum number of operations needed to display the number Y.   Example 1: Input: X = 2, Y = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.  Example 2: Input: X = 5, Y = 8 Output: 2 Explanation: Use decrement and then double {5 -> 4 -> 8}.  Example 3: Input: X = 3, Y = 10 Output: 3 Explanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.  Example 4: Input: X = 1024, Y = 1 Output: 1023 Explanation: Use decrement operations 1023 times.    Note:  1 <= X <= 10^9 1 <= Y <= 10^9
__label__Array __label__Greedy-Algorithms Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index.
__label__Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]  Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  Note:  Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space?
__label__Binary-Search __label__Dynamic-Programming Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.  Note: If n is the length of array, assume the following constraints are satisfied:  1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)   Examples:  Input: nums = [7,2,5,10,8] m = 2  Output: 18  Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
__label__Hash-Table Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each." Example: Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.               Since the researcher has 3 papers with at least 3 citations each and the remaining               two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index.
__label__Tree __label__Data-Structures A binary tree is a tree which is characterized by one of the following properties: It can be empty (null). It contains a root node only. It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees. In-order traversal is performed as Traverse the left subtree. Visit root. Traverse the right subtree. For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true: it is the first node visited, the first time visited  it is a leaf, should only be visited once   all of its subtrees have been explored, should only be visited once while this is true   it is the root of the tree, the first time visited   Swapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L. L R R L For example, in the following tree, we swap children of node 1. 1                                 Depth     1               1            [1]    / \             / \   2   3     ->    3   2          [2]    \   \           \   \     4   5           5   4        [3]  In-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4. 2 4 1 3 5 3 5 1 2 4 Swap operation:  We define depth of a node as follows: The root node is at depth 1. If the depth of the parent node is d, then the depth of current node will be d+1. d d+1 Given a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h ∈ [k, 2k, 3k,...].  In other words, if h is a multiple of k, swap the left and right subtrees of that level. k h h ∈ [k, 2k, 3k,...] h k You are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree. n [1..n] 1 t Function Description Complete the swapNodes function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation. swapNodes has the following parameter(s):  - indexes: an array of integers representing index values of each , beginning with , the first element, as the root.  - queries: an array of integers, each representing a  value. Input Format  The first line contains n, number of nodes in the tree.    n Each of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.    n a b a b Note: -1 is used to represent a null node.    -1 The next line contains an integer, t, the size of .  Each of the next t lines contains an integer , each being a value .   t t Output Format  For each k, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.   k Constraints        Either  or   Either  or   The index of a non-null child will always be greater than that of its parent.   Sample Input 0  3 2 3 -1 -1 -1 -1 2 1 1  Sample Output 0  3 1 2 2 1 3  Explanation 0 As nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.     1   [s]       1    [s]       1       / \      ->   / \        ->  / \     2   3 [s]     3   2  [s]     2   3  Note: [s] indicates that a swap operation is done at this depth. [s] Sample Input 1  5 2 3 -1 4 -1 5 -1 -1 -1 -1 1 2  Sample Output 1  4 2 1 5 3  Explanation 1 Swapping child nodes of node 2 and 3 we get     1                  1      / \                / \    2   3   [s]  ->    2   3    \   \            /   /      4   5          4   5    Sample Input 2  11 2 3 4 -1 5 -1 6 -1 7 8 -1 9 -1 -1 10 11 -1 -1 -1 -1 -1 -1 2 2 4  Sample Output 2  2 9 6 4 1 3 7 5 11 8 10 2 6 9 4 1 3 7 5 10 8 11  Explanation 2  Here we perform swap operations at the nodes whose depth is either 2 or 4 for  and then at nodes whose depth is 4 for .          1                     1                          1                      / \                   / \                        / \                    /   \                 /   \                      /   \                  2     3    [s]        2     3                    2     3                /      /                \     \                    \     \              /      /                  \     \                    \     \            4      5          ->        4     5          ->        4     5          /      / \                  /     / \                  /     / \        /      /   \                /     /   \                /     /   \      6      7     8   [s]        6     7     8   [s]        6     7     8  \          / \            /           / \              \         / \      \        /   \          /           /   \              \       /   \      9      10   11        9           11   10              9     10   11
__label__Two-Pointers __label__Strings Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = "hello", needle = "ll" Output: 2  Example 2: Input: haystack = "aaaaa", needle = "bba" Output: -1  Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
__label__Binary-Search You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.
__label__Greedy-Algorithms Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each of the array element between two given indices, inclusive.  Once all operations have been performed, return the maximum value in your array.   For example, the length of your array of zeros .  Your list of queries is as follows:   Add the values of  between the indices  and  inclusive: The largest value is  after all operations are performed.   Function Description  Complete the function arrayManipulation in the editor below.  It must return an integer, the maximum value in the resulting array.   arrayManipulation has the following parameters: n - the number of elements in your array   queries - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.   Input Format The first line contains two space-separated integers  and , the size of the array and the number of operations.  Each of the next  lines contains three space-separated integers ,  and , the left index, right index and summand.   Constraints         Output Format Return the integer maximum value in the finished array. Sample Input 5 3 1 2 100 2 5 100 3 4 100  Sample Output 200  Explanation After the first update list will be  100 100 0 0 0.  After the second update list will be  100 200 100 100 100.  After the third update list will be  100 200 200 200 100.  The required answer will be .   100 100 0 0 0 100 200 100 100 100 100 200 200 200 100
__label__Depth-first-Search In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.     Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0  Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0  Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1    Note:  1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] == graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <= initial[i] < graph.length
__label__Dynamic-Programming Your goal is to find the number of ways to construct an array such that consecutive positions contain different values. Specifically, we want to construct an array with  elements such that each element between  and , inclusive. We also want the first and last elements of the array to be  and .   Given ,  and , find the number of ways to construct such an array. Since the answer may be large, only find it modulo .  For example, for , , , there are  ways, as shown here:  Complete the function countArray which takes input ,  and . Return the number of ways to construct the array such that consecutive elements are distinct.  countArray Constraints       Subtasks For  of the maximum score,  and   Sample Input , ,   Sample Output  Explanation Refer to the diagram in the challenge statement.
__label__Dynamic-Programming Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. We define an inverse pair as following: For ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not. Since the answer may be very large, the answer should be modulo 109 + 7. Example 1: Input: n = 3, k = 0 Output: 1 Explanation:  Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.    Example 2: Input: n = 3, k = 1 Output: 2 Explanation:  The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.    Note:  The integer n is in the range [1, 1000] and k is in the range [0, 1000].
__label__Dynamic-Programming __label__Mathematics Given an integer, , find the smallest integer  such that  is divisible by  (i.e.,  is a factor of ) and satisfies the following properties:  must not contain zeroes in its decimal representation.  The sum of 's digits must be greater than or equal to the product of 's digits.  Given , find  and print the number of digits in 's decimal representation.  Input Format A single integer denoting . Constraints   is not divisible by . Time Limits The time limits for this challenge are available here. Output Format Print the number of digits in the decimal representation of the smallest possible . Sample Input 0 Sample Output 0 Explanation 0  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in  (which also happens to be ) as our answer. Sample Input 1 Sample Output 1 Explanation 1  is evenly divided by , doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in , which is , as our answer.
__label__Binary-Search Given a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order. If there is a tie,  the smaller elements are always preferred.  Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]   Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]   Note:  The value k is positive and will always be smaller than the length of the sorted array.  Length of the given array is positive and will not exceed 104  Absolute value of elements in the array and x will not exceed 104     UPDATE (2017/9/19): The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.
__label__Graph-Algorithms There are  people at the railway station, and each one wants to buy a ticket to go to one of  different destinations. The  people are in a queue.   There are  ticket windows from which tickets can be purchased. The  people will be distributed in the windows such that the order is maintained. In other words, suppose we number the people  to  from front to back. If person  and person  go to the same window and , then person  should still be ahead of person  in the window.   Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.   For example, suppose there are  people in the queue for a single ticket window, all with the same destination which costs  bucks. Then the first person in the queue pays  bucks, and the 2nd and 3rd persons get a discount of 20% on  bucks, so they end up paying  bucks each instead of  bucks.   Try to distribute the  people across the  windows such that the total cost  paid by all  people is minimized.   Input Format The first line contains  integers:  is the number of people    is the number of ticket windows    is the number of destinations separated by a single space (in the same order)  Then  lines follow. The  line contains an alphanumeric string  and an integer :  is the  destination    is the ticket price for   Then  lines follow. The  line contains an alphanumeric string  which is the destination of the  person.   Constraints       The  available destinations have nonempty and distinct names.   Each person's destination appears in the list of  available destinations.     Output Format Output  lines. The first line contains , the total cost that is to be minimized. In the  following line, print the ticket window which the  person goes to. The windows are indexed  to . There may be multiple ways to distribute the people among the windows such that the total cost is minimized; any one will be accepted.   The answer  will be accepted if it is within an error of  of the true answer.   Sample Input 5 2 3 CALIFORNIA 10 HAWAII 8 NEWYORK 12 NEWYORK NEWYORK CALIFORNIA NEWYORK HAWAII  Sample Output 49.2 1 1 2 1 1  Explanation At the beginning, all the people are in the same queue, and will go to the ticket windows one by one in the initial order.    will buy ticket in the first window.   will buy ticket in the second window.   In the first ticket window, #1 will pay  bucks to go to NEWYORK, and #2 and #4 have the same destination with the person in front of them, so they will get 20% off, and will pay  bucks each. #5 has a different destination, so it will cost him  bucks to go to HAWAII.   NEWYORK HAWAII In the second ticket window, #3 will pay  bucks to go to CALIFORNIA.   CALIFORNIA
__label__Dynamic-Programming __label__Strings Steve loves playing with palindromes. He has a string, , consisting of  lowercase English alphabetic characters (i.e., a through z). He wants to calculate the number of ways to insert exactly  lowercase character into string  such that the length of the longest palindromic subsequence of  increases by at least . Two ways are considered to be different if either of the following conditions are satisfied: a z The positions of insertion are different. The inserted characters are different.  This means there are at most  different ways to insert exactly  character into a string of length . Given  queries consisting of , , and , print the number of different ways of inserting exactly  new lowercase letter into string  such that the length of the longest palindromic subsequence of  increases by at least . Input Format The first line contains a single integer, , denoting the number of queries. The  subsequent lines describe each query over two lines: The first line of a query contains two space-separated integers denoting the respective values of  and .    The second line contains a single string denoting . Constraints    It is guaranteed that  consists of lowercase English alphabetic letters (i.e., a to z) only. a z Subtasks  for  of the maximum score.  for  of the maximum score. Output Format On a new line for each query, print the number of ways to insert exactly  new lowercase letter into string  such that the length of the longest palindromic subsequence of  increases by at least . Sample Input 3 1 1 a 3 2 aab 3 0 aba  Sample Output 2 1 104  Explanation We perform the following  queries: The length of the longest palindromic subsequence of  a is . There are two ways to increase this string's length by at least : Insert an a at the start of string , making it aa. Insert an a at the end of string , making it aa.       Both methods result in aa, which has a longest palindromic subsequence of length  (which is longer than the original longest palindromic subsequence's length by ). Because there are two such ways, we print  on a new line. The length of the longest palindromic subsequence of  a is . There are two ways to increase this string's length by at least : a Insert an a at the start of string , making it aa. a aa Insert an a at the end of string , making it aa.       a aa Both methods result in aa, which has a longest palindromic subsequence of length  (which is longer than the original longest palindromic subsequence's length by ). Because there are two such ways, we print  on a new line. aa The length of the longest palindromic subsequence of  aab is . There is one way to increase the length by at least : Insert a b at the start of string , making it baab.    We only have one possible string, baab, and the length of its longest palindromic subsequence is  (which is longer than the original longest palindromic subsequence's length by ). Because there is one such way, we print  on a new line. The length of the longest palindromic subsequence of  aab is . There is one way to increase the length by at least : aab Insert a b at the start of string , making it baab.    b baab We only have one possible string, baab, and the length of its longest palindromic subsequence is  (which is longer than the original longest palindromic subsequence's length by ). Because there is one such way, we print  on a new line. baab
__label__Array __label__Binary-Search Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.  Example 1: Input: nums = [1,3,1] k = 1 Output: 0  Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.   Note:  2 <= len(nums) <= 10000. 0 <= nums[i] < 1000000. 1 <= k <= len(nums) * (len(nums) - 1) / 2.
__label__Dynamic-Programming You are given a sequence of integers a1,a2,a3.....an. You are free to replace any integer with any other positive integer. How many integers must be replaced to make the resulting sequence strictly increasing?  Input Format  The first line of the test case contains an integer  - the number of entries in the sequence.  The next line contains  space separated integers where the  integer is . Output Format  Output the minimal number of integers that should be replaced to make the sequence strictly increasing. Constraints      Sample Input #00 3 4 10 20  Sample Output #00 0  Sample Input #01 6 1 7 10 2 20 22  Sample Output #01 1  Sample Input #02 5 1 2 2 3 4   Sample Output #02 3  Explanation  In the first sample input, we need not replace anything, hence the output is 0.  In the second sample input, we can replace 2 with any integer between 11 and 19 to make the sequence strictly increasing, hence the output is 1.  In the third sample input, we can obtain 1, 2, 3, 4, 5 by changing the last three elements of the sequence.
__label__Search Xander Cage has a list of cities he can visit on his new top-secret mission. He represents each city as a tuple of . The values of , , and  are distinct across all cities. We define a mission as a sequence of cities, , that he visits. We define the total  of such a mission to be the sum of the  of all the cities in his mission list. Being eccentric, he abides by the following rules on any mission: He can choose the number of cities he will visit (if any). He can start the mission from any city. He visits cities in order of strictly increasing . The absolute difference in  between adjacent visited cities in his mission must be at most . The absolute difference in  between adjacent visited cities in his mission must be at most . Given , , and the definitions for  cities, find and print the maximum possible total  that Xander can earn on a mission. Input Format The first line contains three space-separated integers describing the respective values of , , and .  Each line  of the  subsequent lines contains four space-separated integers denoting the respective , , , and  for a city. Constraints        Output Format Print a single integer denoting the maximum possible  that Xander can earn on a mission. Sample Input 0 Sample Output 0 Explanation 0 Xander can start at city , then go to city , and then go to city  for a maximum value of total    Note that he cannot go directly from city  to city  as that would violate his rules that the absolute difference in  between adjacent visited cities be  and the absolute difference in  between adjacent visited cities be . Because  and , he cannot directly travel between those cities.
__label__Mathematics Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes. If there isn't any rectangle, return 0.   Example 1:  Input: [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.   Example 2:  Input: [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.   Example 3:  Input: [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points.   Example 4:  Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.       Note:  1 <= points.length <= 50 0 <= points[i][0] <= 40000 0 <= points[i][1] <= 40000 All points are distinct. Answers within 10^-5 of the actual value will be accepted as correct.
__label__Array Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.   We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).  Example 1: Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array.   Example 2: Input: [4,2,1] Output: False Explanation: You can't get a non-decreasing array by modify at most one element.   Note: The n belongs to [1, 10,000].
__label__Hash-Table Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.   Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.  The sister has three different kinds of candies.    Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].  The sister has two different kinds of candies, the brother has only one kind of candies.    Note:  The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000].
__label__Dynamic-Programming You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3  Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.
__label__Graph-Algorithms Sophia is playing a game on the computer. There are two random arrays A & B, each having the same number of elements. The game begins with Sophia removing a pair (Ai, Bj) from the array if they are not co-prime. She keeps a count on the number of times this operation is done.  Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value? Input Format The first line contains an integer n. 2 lines follow, each line containing n numbers separated by a single space. The format is shown below.  n A[0] A[1] ... A[n - 1] B[0] B[1] ... B[n - 1]  Constraints 0 < n <= 105  2 <= A[i], B[i] <= 109  Each element in both arrays are generated randomly between 2 and 109 Output Format Output S which is the maximum number of times the above operation can be made. Sample Input 4 2 5 6 7 4 9 10 12  Sample Output 3  Explanation You can remove: (2, 4) (5, 10) (6, 9)  hence 3.
__label__Graph-Algorithms __label__Tree Byteland has  cities (numbered from  to ) and  bidirectional roads. It is guaranteed that there is a route from any city to any other city.  Jeanie is a postal worker who must deliver  letters to various cities in Byteland. She can start and end her delivery route in any city. Given the destination cities for  letters and the definition of each road in Byteland, find and print the minimum distance Jeanie must travel to deliver all  letters. Note: The letters can be delivered in any order. Input Format The first line contains two space-separated integers,  (the number of cities) and  (the number of letters), respectively.  The second line contains  space-separated integers describing the delivery city for each letter.  Each line  of the  subsequent lines contains  space-separated integers describing a road as , where  is the distance (length) of the bidirectional road between cities  and . Constraints    Output Format Print the minimum distance Jeanie must travel to deliver all  letters. Sample Input 0 Sample Output 0 Explanation 0 Jeanie has  letters she must deliver to cities , , and  in the following map of Byteland:  One of Jeanie's optimal routes is , for a total distanced traveled of . Thus, we print  on a new line.
__label__Mathematics A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.   Example 1: Input: [[1,1],[2,3],[3,2]] Output: true   Example 2: Input: [[1,1],[2,2],[3,3]] Output: false    Note:  points.length == 3 points[i].length == 2 0 <= points[i][j] <= 100
__label__Array Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]
__label__Mathematics Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  . Example 1: Input: "1 + 1" Output: 2  Example 2: Input: " 2-1 + 2 " Output: 3 Example 3: Input: "(1+(4+5+2)-3)+(6+8)" Output: 23 Note:  You may assume that the given expression is always valid. Do not use the eval built-in library function.
__label__Dynamic-Programming You have a warehouse with  containers filled with an infinite number of candies. The containers are arranged in a single row, equally spaced to be  meter apart. You also have  robots that can pick up  piece of candy and transport it between any two containers. The robots take instructions in the form of queries consisting of two integers,  and , respectively. To execute a query, a robot travels to container , picks up  candy, transports it to container , and then stops at  until it receives another query.    Calculate the minimum total distance the robots must travel to execute  queries in order.  Note: You choose which robot executes each query. Input Format The first line contains a single integer,  (the number of test cases); each of the  test cases is described over  lines.      The first line of a test case has two space-separated integers,  (the number of containers) and  (the number of queries).  The  subsequent lines each contain two space-separated integers,  and , respectively; each line  describes the  query. Constraints            Output Format On a new line for each test case, print an integer denoting the minimum total distance that the robots must travel to execute the queries in order. Sample Input 3 5 4 1 5 3 2 4 1 2 4 4 2 1 2 4 3 10 3 2 4 5 4 9 8  Sample Output 11 2 5  Explanation In this explanation, we refer to the two robots as  and , each container  as , and the total distance traveled for each query  as .  Note: For the first query a robot executes, there is no travel distance. For each subsequent query that robot executes, it must travel from the location where it completed its last query. Test Case 0:  The minimum distance traveled is :       Robot:      meters. Robot:      meter.     Robot:      meters.        Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 1:  Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line. Test Case 2:  Robot:      meters. Robot:      meters. Robot:      meters. Sum the distances traveled () and print the result on a new line.
__label__Dynamic-Programming Given a tree T with n nodes, how many subtrees (T') of T have at most K edges connected to (T - T')?  Input Format The first line contains two integers n and K followed by n-1 lines each containing two integers a & b denoting that there's an edge between a & b. Constraints 1 <= K <= n <= 50  Every node is indicated by a distinct number from 1 to n. Output Format A single integer which denotes the number of possible subtrees. Sample Input 3 1 2 1 2 3  Sample Output 6  Explanation There are 2^3 possible sub-trees:    {} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3} But:  the sub-trees {2} and {1,3} are not valid.  {2} isn't valid because it has 2 edges connecting to it's complement {1,3} whereas K = 1 in the sample test-case {1,3} isn't valid because, well, it's not a sub-tree. The nodes aren't connected.
__label__Graph-Algorithms A clique in a graph is set of nodes such that there is an edge between any two distinct nodes in the set. Finding the largest clique in a graph is a computationally difficult problem. Currently no polynomial time algorithm  is known for solving this. However, you wonder what is the minimum size of the largest clique in any graph with  nodes and  edges.   For example, consider a graph with  nodes and  edges.  The graph below shows  nodes with  edges and no cliques.  It is evident that the addition of any  edge must create two cliques with  members each.    Input Format The first line contains an integer , the number of test cases.   Each of the next  lines contains two space-separated integers  and .   Constraints      Output Format For each test case, print the minimum size of the largest clique that must be formed given  and .    Sample Input 3   3 2   4 6   5 7  Sample Output 2   4   3  Explanation For the first case, we have two cliques with two nodes each:     For the second test case, the only valid graph having  nodes and  edges is one where each pair of nodes is connected. So the size of the largest clique cannot be smaller than .     For the third test case, it is easy to verify that any graph with  nodes and .  The  solid lines in the graph below indicate the maximum edges that can be added without forming a clique larger than .  The dashed lines could connect any two nodes not connected by solid lines producing a clique of size .     Hints  Turan's theorem gives us an upper bound on the number of edges a graph can have if we wish that it should not have a clique of size . Though the bound is not exact, it is easy to extend the statement of the theorem to get an exact bound in terms of  and . Once this is done, we can binary search for the largest  such that . See: Turan's Theorem
__label__Mathematics A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true  Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false  Notes:  Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9.
__label__Mathematics Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note:  Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted. Input length is less than 50,000.   Example 1: Input: "owoztneoer"  Output: "012"   Example 2: Input: "fviefuro"  Output: "45"
__label__Strings __label__Bit The SuperBowl Lottery is about to commence, and there are several lottery tickets being sold, and each ticket is identified with a ticket ID. In one of the many winning scenarios in the Superbowl lottery, a winning pair of tickets is: Concatenation of the two ticket IDs in the pair, in any order, contains each digit from  to  at least once. For example, if there are  distinct tickets with ticket ID  and ,  is a winning pair.  NOTE: The ticket IDs can be concantenated in any order. Digits in the ticket ID can occur in any order.  Your task is to find the number of winning pairs of distinct tickets, such that concatenation of their ticket IDs (in any order) makes for a winning scenario. Complete the function winningLotteryTicket which takes a string array of ticket IDs as input, and return the number of winning pairs.  winningLotteryTicket Input Format The first line contains  denoting the total number of lottery tickets in the super bowl.  Each of the next  lines contains a string, where string on a  line denotes the ticket id of the  ticket. Constraints   length of   sum of lengths of all  Each ticket id consists of digits from  Output Format Print the number of pairs in a new line. Sample Input 0 Sample Output 0 Explanation 0 Pairs of distinct tickets that make for a winning scenario are :  Notice that each winning pair has digits from  to  atleast once, and the digits in the ticket ID can be of any order. Thus, the number of winning pairs is .
__label__Tree __label__Depth-first-Search Given the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, "ab" is lexicographically smaller than "aba".  A leaf of a node is a node that has no children.)          Example 1:  Input: [0,1,2,3,4,3,4] Output: "dba"   Example 2:  Input: [25,1,3,1,3,0,2] Output: "adz"   Example 3:  Input: [2,2,1,null,1,0,null,0] Output: "abc"    Note:  The number of nodes in the given tree will be between 1 and 8500. Each node in the tree will have a value between 0 and 25.
__label__Strings Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: "Hello World" Output: 5
__label__Hash-Table In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.    Example 1: Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.   Example 2: Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.   Example 3: Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz" Output: false Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).    Note:  1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in words[i] and order are english lowercase letters.
__label__Mathematics __label__Greedy-Algorithms Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once). After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.      Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1]   Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8]   Example 3: Input: A = [1,3,6], K = 3 Output: 3 Explanation: B = [4,6,3]    Note:  1 <= A.length <= 10000 0 <= A[i] <= 10000 0 <= K <= 10000
__label__Binary-Search Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: Input: [1,3,2,3,1] Output: 2  Example2: Input: [2,4,3,5,1] Output: 3  Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.
__label__Array __label__Binary-Search Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2  Example 2: Input: [1,3,5,6], 2 Output: 1  Example 3: Input: [1,3,5,6], 7 Output: 4  Example 4: Input: [1,3,5,6], 0 Output: 0
__label__Data-Structures Given a  2D Array, :  1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  We define an hourglass in  to be a subset of values with indices falling in this pattern in 's graphical representation: a b c   d e f g  There are  hourglasses in , and an hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. For example, given the 2D array: -9 -9 -9  1 1 1   0 -9  0  4 3 2 -9 -9 -9  1 2 3  0  0  8  6 6 0  0  0  0 -2 0 0  0  0  1  2 4 0  We calculate the following  hourglass values: -63, -34, -9, 12,  -10, 0, 28, 23,  -27, -11, -2, 10,  9, 17, 25, 18  Our highest hourglass value is  from the hourglass: 0 4 3   1 8 6 6  Note: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge. Function Description Complete the function hourglassSum in the editor below.  It should return an integer, the maximum hourglass sum in the array.   hourglassSum has the following parameter(s): arr: an array of integers  Input Format Each of the  lines of inputs  contains  space-separated integers . Constraints    Output Format Print the largest (maximum) hourglass sum found in . Sample Input 1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 2 4 4 0 0 0 0 2 0 0 0 0 1 2 4 0  Sample Output 19  Explanation  contains the following hourglasses:   The hourglass with the maximum sum () is: 2 4 4   2 1 2 4
__label__Game-Theory __label__Greedy-Algorithms __label__Game-Theory Kyle and Mike are bored on a rainy day and decide to pass the time by creating a new game having the following rules: The game starts with two -sized integer arrays,  and , and is played by two players,  and .  The players move in alternating turns, with  always moving first. During each move, the current player must choose an integer, , such that . If the current player is , then  receives  points; if the current player is , then  receives  points. Each value of  can be chosen only once. That is, if a value of  is already chosen by some player, none of the player can re-use it. So, game always ends after  moves. The player with the maximum number of points wins. The arrays A and B are accessible to both the players P1 and P2. So the players make a optimal move at every turn.  Given the values of , , and , can you determine the outcome of the game? Print  if  will win,  if  will win, or  if they will tie. Assume both players always move optimally. Input Format The first line of input contains a single integer, , denoting the number of test cases. Each of the  subsequent lines describes a test case. A single test case is defined over the following three lines: An integer, , denoting the number of elements in arrays  and .  space-separated integers, , where each  describes the element at index  of array .  space-separated integers, , where each  describes the element at index  of array . Constraints       Output Format For each test case, print one of the following predicted outcomes of the game on a new line: Print  if  will win. Print  if  will win. Print  if the two players will tie. Sample Input 3 3 1 3 4 5 3 1 2 1 1 1 1 2 2 2 3 3  Sample Output First Tie Second  Explanation Test Case 0: ,  The players make the following  moves:  chooses  and receives  points.  chooses  and receives  points. Note that  will not choose , because this would cause  to win.  chooses  (which is the only remaining move) and receives  points. As all  moves have been made, the game ends. 's score is  points and 's score is  points, so  is the winner and we print  on a new line. Test Case 1: ,  Because both players will only make  move and all possible point values are , the players will end the game with equal scores. Thus, we print  on a new line. Test Case 1: ,   Because both players will only make  move and all the possible point values for  are greater than all the possible point values for ,  will win the game. Thus, we print  on a new line.
__label__Strings __label__Greedy-Algorithms Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:  0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length >= 3; and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.  Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from S, or return [] if it cannot be done. Example 1: Input: "123456579" Output: [123,456,579]  Example 2: Input: "11235813" Output: [1,1,2,3,5,8,13]  Example 3: Input: "112358130" Output: [] Explanation: The task is impossible.  Example 4: Input: "0123" Output: [] Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.  Example 5: Input: "1101111" Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.  Note:   1 <= S.length <= 200 S contains only digits.
__label__Graph-Algorithms Chinese   Fedor is a research scientist, who has recently found a road map of Ancient Berland. Ancient Berland consisted of N cities that were connected by M bidirectional roads. The road builders weren't knowledgable. Hence, the start city and the end city for each road were always chosen randomly and independently. As a result, there were more than one road between some pairs of cities. Nevertheless, by luck, the country remained connected (i.e. you were able to get from one city to another via these M roads). And for any road, the start and the end city were not the same. Moreover, each road had it's own value of importance. This value was assigned by the Road Minister of Ancient Berland. The Road Minister also was not knowledgable, so these numbers were assigned to the roads randomly and independently from the other roads. When there was a war with the neighboring countries (usually it was with Ancient Herland), it was important to estimate separation number for some pairs of cities. The separation number for a pair of cities - let's call these cities A and B - is explained below:  Consider a set of roads that were built. The subset of this set is good, if after removing all roads from this set, there's no longer a way from A to B. The minimal possible sum of roads' value of importance of any good subset is a separation number for the pair of cities (A, B). For a research, Fedor would like to know the product of separation values over all unordered pairs of cities. Please, find this number. It can be huge, so we ask you to output its product modulo 109+7. Input Format The first line of input consist of two integers N and M, separated by a single space.  Then, M lines follow. Each of these lines consist of three integers Xi, Yi, Zi separated by a single space.  It means that there was a road between the city Xi and the city Yi with a value of importance equal to Zi. Constraints 3 ≤ N ≤ 500  3 ≤ M ≤ 104  1 ≤ value of importance ≤ 105  The cities are indexed from 1 to N. Scoring In the 25% of the test data N = 50 and M = 300. In another 25% of the test data N = 200 and M = 10000 In the rest of the test data N = 500 and M = 10000   Output Format An integer that represents the value, Fedor needs, modulo 109+7.
__label__Strings A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found here.   You are given n strings w[1], w[2], ......, w[n]. Let S[i] denote the set of all unique substrings of the string w[i]. Let , that is, S is a set of strings that is the union of all substrings in all sets S[1], S[2], ..... S[n]. There will be many queries.  For each query you will be given an integer 'k'. Your task is to find the kth element of the -indexed lexicographically ordered set of substrings in the set S.  If there is no element , return INVALID.   For example, your strings are .  All of the substrings are  and .  Combine the two sets and sort them to get .  So, for instance if , we return 'a'.  If , we return 'bc'.  If  though, there is not an  so we return INVALID. Function Description  Complete the findStrings function in the editor below.  It should return array of strings.   findStrings has the following parameter(s):   w: an array of strings   queries: an array of integers   Input Format The first line contains an integer n, the number of strings in the array .  Each of the next n lines consists of a string .  The next line contains an integer q, the number of queries.  Each of the next q lines consists of a single integer k. Constraints         Each character of   Output Format Return an array of q strings where the ith string is the answer to the ith query. If a  is invalid, return "INVALID" for that case. Sample Input 2  aab  aac  3  3  8  23   Sample Output aab  c  INVALID   Explanation For the sample test case, we have 2 strings "aab" and "aac".  S1 = {"a", "aa", "aab", "ab", "b"} . These are the 5 unique substrings of "aab".  S2 = {"a", "aa", "aac",  "ac", "c" } . These are the 5 unique substrings of "aac".  Now, S = {S1 U S2} = {"a", "aa", "aab", "aac", "ab", "ac", "b", "c"}. Totally, 8 unique strings are present in the set S.  The lexicographically 3rd smallest string in S is "aab" and the lexicographically 8th smallest string in S is "c". Since there are only 8 distinct substrings, the answer to the last query is "INVALID".
__label__Tree __label__Depth-first-Search Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.    Example 1:     2    / \   1   3  Input: [2,1,3] Output: true  Example 2:     5    / \   1   4      / \     3   6  Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.
__label__Array Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: Input:  [0,1,2,4,5,7] Output: ["0->2","4->5","7"] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2: Input:  [0,2,3,4,6,8,9] Output: ["0","2->4","6","8->9"] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.
__label__Data-Structures You are given a square grid with some cells open (.) and some blocked (X).  Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell.  Given a grid, a start and an end position, determine the number of moves it will take to get to the end position.   For example, you are given a grid with sides  described as follows: ... .X. ...  Your starting position  so you start in the top left corner.  The ending position is .  The path is .  It takes  moves to get to the goal. Function Description  Complete the minimumMoves function in the editor.  It must print an integer denoting the minimum moves required to get from the starting position to the goal. minimumMoves has the following parameter(s): grid: an array of strings representing the rows of the grid   startX: an integer   startY: an integer   goalX: an integer   goalY: an integer   Input Format The first line contains an integer , the size of the array grid.  Each of the next  lines contains a string of length .  The last line contains four space-separated integers,   Constraints   Output Format Print an integer denoting the minimum number of steps required to move the castle to the goal position. Sample Input 3 .X. .X. ... 0 0 0 2  Sample Output 3  Explanation Here is a path that one could follow in order to reach the destination in  steps: .
__label__Dynamic-Programming __label__Tree Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [   [1,null,3,2],   [3,2,null,1],   [3,1,null,null,2],   [2,1,3],   [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below:     1         3     3      2      1     \       /     /      / \      \      3     2     1      1   3      2     /     /       \                 \    2     1         2                 3
__label__Hash-Table We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1: Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3].    Note: The length of the input array will not exceed 20,000.
__label__Strings We are given that the string "abc" is valid. From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V.  (X or Y may be empty.)  Then, X + "abc" + Y is also valid. If for example S = "abc", then examples of valid strings are: "abc", "aabcbc", "abcabc", "abcabcababcc".  Examples of invalid strings are: "abccba", "ab", "cababc", "bac". Return true if and only if the given string S is valid.   Example 1: Input: "aabcbc" Output: true Explanation:  We start with the valid string "abc". Then we can insert another "abc" between "a" and "bc", resulting in "a" + "abc" + "bc" which is "aabcbc".   Example 2: Input: "abcabcababcc" Output: true Explanation:  "abcabcabc" is valid after consecutive insertings of "abc". Then we can insert "abc" before the last letter, resulting in "abcabcab" + "abc" + "c" which is "abcabcababcc".   Example 3: Input: "abccba" Output: false   Example 4: Input: "cababc" Output: false      Note:  1 <= S.length <= 20000 S[i] is 'a', 'b', or 'c'
__label__Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.   Example 2: Input: [1,2,2,3,1,4,2] Output: 6   Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999.
__label__Mathematics __label__Greedy-Algorithms Sherlock Holmes suspects his archenemy Professor Moriarty is once again plotting something diabolical. Sherlock's companion, Dr. Watson, suggests Moriarty may be responsible for MI6's recent issues with their supercomputer, The Beast.  Shortly after resolving to investigate, Sherlock receives a note from Moriarty boasting about infecting The Beast with a virus.  He also gives him a clue:  an integer. Sherlock determines the key to removing the virus is to find the largest Decent Number having that number of digits. A Decent Number has the following properties: Its digits can only be 3's and/or 5's. The number of 3's it contains is divisible by 5. The number of 5's it contains is divisible by 3. It is the largest such number for its length.  Moriarty's virus shows a clock counting down to The Beast's destruction, and time is running out fast. Your task is to help Sherlock find the key before The Beast is destroyed! For example, the numbers  and  are both decent numbers because there are  's and  's in the first, and  's in the second.  They are the largest values for those length numbers that have proper divisibility of digit occurrences.   Function Description Complete the decentNumber function in the editor below.  It should print the decent number for the given length, or  if a decent number of that length cannot be formed.   decentNumber has the following parameter(s):   n: the integer length of the decent number to create Input Format The first line is an integer, , denoting the number of test cases.  The next  lines each contain an integer , the number of digits in the number. Constraints     Output Format Print the Decent Number having  digits; if no such number exists, tell Sherlock by printing -1. -1 Sample Input 4 1 3 5 11  Sample Output -1 555 33333 55555533333  Explanation For , there is no Decent Number having  digit (so we print ).  For ,  is the only possible number. (Decent Number Property 3).  For ,  is the only possible number. (Decent Number Property 2).  For ,  is the Decent Number.  All other permutations of these digits are not decent (Decent Number Property 4).
__label__Mathematics On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid.  Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)  Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.   Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]]      Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]        Note:  1 <= R <= 100 1 <= C <= 100 0 <= r0 < R 0 <= c0 < C
__label__Array For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1]. Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.      Example 1: Input: A = [1,2,0,0], K = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234   Example 2: Input: A = [2,7,4], K = 181 Output: [4,5,5] Explanation: 274 + 181 = 455   Example 3: Input: A = [2,1,5], K = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021   Example 4: Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1 Output: [1,0,0,0,0,0,0,0,0,0,0] Explanation: 9999999999 + 1 = 10000000000    Note：  1 <= A.length <= 10000 0 <= A[i] <= 9 0 <= K <= 10000 If A.length > 1, then A[0] != 0
__label__Data-Structures __label__Advanced-Data-Structures Natural numbers from 1 to N have been placed in an increasing order over some helix ( a circular structure ). When the helix starts rotating, it is easy to find out  The position of a given number The number located at a given position.  The helix has numbers arranged in the following fashion:   [1, 2, 3, ..., N]  Due to some malfunction, the helix has started rotating in a weird manner. Right now, every possible contiguous interval can be rotated, and hence, locating a particular number or identifying the number at a given position is almost impossible. For example, if at some particular instant, the integer list is like this: [1, 2, 3, 4, 5, ..., N]  rotating the interval [5...N] will leave the list like this: [1, 2, 3, 4, N, N - 1, N - 2, ..., 5]  We need a software to handle this. Can you help us? Input Format  The first line of the input consists of two space separated integers, N, Q. N signifies that initially our list contains numbers from 1 to N, placed in an increasing order. Q lines follow and contain input in one of the following formats:   1 A B  indicating that the helix rotated circularly in the interval [A..B] ( both inclusive); 2 A  indicating that we are interested in knowing the current position of the number A   3 A  indicating that we are interested in knowing the number at position A.   Output Format  For each line in the input of the form 2 A  2 A output a line saying  element A is at position x  where A is the number we are interested in and x is its current position. For each line of the form 3 A 3 A output a line saying  element at position A is x  where A is the position we are interested in and x is the integer located at this position.  Constraints  1 ≤ N, Q ≤ 105  positions are 1-indexed.    Sample Input 5 10 1 1 3 2 3 3 3 1 3 5 1 2 4 3 1 3 5 2 4 1 5 5 2 2  Sample Output element 3 is at position 1 element at position 3 is 1 element at position 1 is 3 element at position 5 is 1 element 4 is at position 2 element 2 is at position 4  Explanation Initially elements are placed like this: [1, 2, 3, 4, 5]  after the first rotation, they are placed like this: [3, 2, 1, 4, 5]  and that's how we get the first 2 results (first 2 lines in the output). After second rotation, they are placed like this: [3, 2, 5, 4, 1]  and third one does this: [3, 4, 5, 2, 1]  In the last rotation (1 5 5), it's easy to see that output matches the initial positions of the elements. Last rotation doesn't change the positions of the elements.
__label__Tree __label__Depth-first-Search We run a preorder depth first search on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  (If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.) If a node has only one child, that child is guaranteed to be the left child. Given the output S of this traversal, recover the tree and return its root.   Example 1:  Input: "1-2--3--4-5--6--7" Output: [1,2,5,3,4,6,7]   Example 2:  Input: "1-2--3---4-5--6---7" Output: [1,2,5,3,null,6,null,4,null,7]      Example 3:  Input: "1-401--349---90--88" Output: [1,401,null,349,88,90]     Note:  The number of nodes in the original tree is between 1 and 1000. Each node will have a value between 1 and 10^9.
